<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on Noboru Saito's page</title><link>https://noborus.github.io/blog/</link><description>Recent content in Blog on Noboru Saito's page</description><generator>Hugo -- gohugo.io</generator><language>ja</language><atom:link href="https://noborus.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>ov v0.11.0</title><link>https://noborus.github.io/blog/ov_011_0/</link><pubDate>Sat, 21 May 2022 08:39:02 +0900</pubDate><guid>https://noborus.github.io/blog/ov_011_0/</guid><description>ov v0.11.0をリリースしました Terminal PAGER releases ov v0.11.0
セクションの概念を追加 対象の文書を--section-delimiterで区切り文字を指定することにより、セクションとして扱えるようになりました。
--section-delimiterの区切り文字は正規表現で指定できます。改行は含まれませんので、^$は空行を指定したことになります。 その場合空行毎に違うセクションになります。
ページャーは通常、内容に関係なく画面サイズにより次のページの表示を決めていますが、セクションを利用することにより意味のある単位で移動できます。
デフォルトでは、次のセクションに移動するのは[スペース]キー、前のセクションに移動するのは[^]キーです。最後のセクションに移動は[9]キーです。
空行を指定した場合は、セクション移動時に最初の行が空行になってしまいます。これを調整するために--section-startも追加しました。--section-start 1を指定することにより、--section-delimiterの次の行から表示できます。
起動オプションだけでなく、起動後も--section-delimiterは[alt+d]、--section-startは[alt+s]で指定できます。
follow-sectionを追加 --follow-sectionオプションを追加しました。section-delimiterで指定した区切り文字単位で、内容が更新されたときに最後のセクションを表示します。 follow-sectionを利用することにより、PostgreSQL version 15で追加される psqlのwatchのページャー（PSQL_WATCH_PAGER）として使用できるようになります。
PSQL_WATCH_PAGER 'ov --follow-section --section-delimiter &amp;quot;^$&amp;quot;' Watchは追記するように変更 --watchは指定した時間毎にファイルを再読込していましたが、前の内容を消さずに再読込をした内容を追記するように変更しました。 このときEOFに到達するとEOFを&amp;rsquo;\f&amp;rsquo;に置き換えて追記します。
さらにWatchモードは自動で&amp;rsquo;\f&amp;rsquo;をsection-delimiterとして、最終セクションを表示するようになりました。
つまり、--watchで最後に実行された内容が表示され続けるのは変わりませんが、Watchモードを止めて上にスクロールすると履歴が見られます。
Watchモードはファイルの定期再読込に加えてsection-delimiterとfollow-sectionを自動で設定したモードです。
過去のバージョン v0.11.0 sectionの概念を追加 v0.10.0 reload,watchを追加 v0.9.6 リダイレクト出力、列モードの修正 v0.9.5 サスペンド／レジュームのサポート v0.9.4 マーク機能の強化、インクリメンタルサーチを追加して検索強化。 v0.9.3 スキップ行オプションの追加 v0.9.2 主要モジュール更新版 v0.9.1 半画面下移動のバグ修正。goのバージョンを1.16以降へ変更。 v0.9.0 follow,follow-all,execの各モードを追加、改善。検索とカラム選択のスタイルカスタマイズを可能にしました。 v0.8.9 (pre)follow-mode,follow-all-modeの追加 v0.8.1 文字の単位をCode point から Grapheme clusterに変更しました。 v0.8.0 tcell v2にアップグレードしました。 v0.7.1 交互に行スタイル効果適用の行がズレていたので修正 v0.7.0 スタイルカスタマイズの改善 v0.6.2 検索の高速化とキャンセル処理の追加 v0.</description></item><item><title>手っ取り遅くSQLを学ぶ</title><link>https://noborus.github.io/blog/sql/</link><pubDate>Thu, 05 May 2022 10:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/sql/</guid><description>手っ取り遅くSQLを学ぶ 「手っ取り遅くSQLを学ぶ」とは？すぐにSQLを使えるよう学ぶのではなく、まわりくどくSQLを理解して学んでいく方法で解説します。
「手っ取り早くSQLを学ぶ」と言ったら、よく使うSQLをなるべくシンプルな形にして、実際に試しながら、徐々に応用していく方法だと考えています。 「手っ取り遅くSQLを学ぶ」はその逆で、SQLの記法は後回しにして考え方を解説していきます。
まずはテーブル SQLは主にリレーショナル・データベース（RDBMS）で使用されるデータ操作のための言語です。
リレーショナル・データベースは「テーブル」をデータの集合として使用しているので、SQLを学ぶには、まずテーブルを理解する必要があります。
テーブルとは、訳すと「表」なので、コンピューターと関係なくても日常でも溢れている表現方法です。 名簿であったり、一覧表など一般に、よく目にします。
SQLで扱うテーブルは、表全般の中でもう少しルールが定まったものを対象とします。
他のプログラミング言語と同じく「型を持った値」があります。数値の123や文字列の&amp;rsquo;abc&amp;rsquo;等。 この「型を持った値」を複数持つことができます。これをレコードと言ったり、「行」と言ったりします。
このレコードが含んでいる値の数と型が一致している集合がテーブルです。 通常は、単純な数合わせではなく、型が一致しているだけでもなく、同じ意味を表しています。これをカラムと言ったり、「列」と言ったりします。 このカラムには名前を付けられることが多いです。「格納」する場合は、あとで取り出す必要があるので名前が必須になります。
この集合をレコードの配列と考えても良いかもしれませんが、この時点では順序は不動なことに注意が必要です。 他のプログラミングからは、2次元配列で表される場合もありますが、プログラミング言語を理解している人は、構造体の配列と考えた方が良いでしょう。実際にSQLで操作したデータをプログラミング言語で受け取るときには、構造体の配列に変換することがよくあります。
そして、テーブルの行も列も理論上は0以上無限まで可能です。 実際には上限はデータベースの仕様やコンピューターの限界値に左右されますが、下限は0から可能です。
行が0というのは、たとえば名簿リストを作成したとして該当者が存在しないことはあるのでよくある話だと思いますが、列が0というのは理論上存在しても現実にはないので、定義はできないようにしているデータベースもあります。
この「テーブル」単位にしておけば、自分の欲しいデータを取得できると考えて作られたのがリレーショナル・データベース（RDBMS）で、そのための記法がSQLです。
SQLとは？ リレーショナル・データベースは、SQLを実行できるだけでなくテーブルを効率よく管理するためにいろいろな機能が備わっていますが、主要なSQLはテーブルを操作するため、少し切り離して考えることができます。
SQLはテーブル（複数でも可）から「1つの」テーブルを作ることを目的としています。
SQLをすでに知っている人からすると、テーブルを作ると言ったら「CREATE TABLE」と思うかもしれません。 データベースにテーブルを作るという狭い意味ではそうなのですが、その結果がテーブルになるという意味で広い意味では、テーブルを作るという目的であると言えます。
INSERT/UPDATE/DELETEなどの更新系SQL文は、実行した結果がデータベースに反映されます。
取得するSQL文と説明されることが多いSELECT文は、実際には取得ではなく、「SELECT」の意味の通り、「選択する」と解釈する方が正しいです。 「SELECT」文により選択された結果が指定されていない場合は、暗黙の了解として結果を取得します。
3つ以上のテーブルから1つのテーブルを「作る」場合、まず2つのテーブルから1つのテーブルを作成し、作成されたテーブルと残ったテーブルから、1つのテーブルを作成するといった風に考えることで3つ以上のテーブルから1つのテーブルを作成できます。
数学（というよりも算数）の「3+2+4」を「3+2」してその結果から「5+4」を計算するのと似ています。
つまりSQLはテーブルとテーブルの計算式と言えます。
JOIN テーブルの計算式として、一番基本は算数の足し算に相当するテーブルのJOINです。 ただし、テーブルとテーブルのJOINは、むしろ算数の掛け算に似ています。
まずは列だけ考えてみます。テーブルAとテーブルXをJOINします。
テーブルA
A B テーブルX
X Y テーブルとテーブルのJOINは、双方の「列」はそのまま全部使用します。
A B X Y 続いて、行のJOINを考えます。
Aテーブルの1行に対してXテーブルのすべての行に合成します。これをAテーブルのすべての行でおこないます。
A B 1 3 2 4 X Y 1 8 2 9 Aの1行目とXテーブルを合成</description></item><item><title>Another way to aggregate json(jq + SQL)</title><link>https://noborus.github.io/blog/jqsql/</link><pubDate>Tue, 03 May 2022 12:58:24 +0900</pubDate><guid>https://noborus.github.io/blog/jqsql/</guid><description>Aggregate json with trdsql I agree that the aggregation of jq described in the Introducing zq is not easy.
I&amp;rsquo;ve seen A Practical Example of zq, zq was not easy for me.
SQL is not easy for everyone, but it is a language that many people can use. I am one of them.
Of course, it is difficult to process all JSON with SQL. But what about using them in combination?</description></item><item><title>trdsql v0.10.0</title><link>https://noborus.github.io/blog/trdsql_0100/</link><pubDate>Tue, 03 May 2022 09:29:54 +0900</pubDate><guid>https://noborus.github.io/blog/trdsql_0100/</guid><description>trdsql v0.10.0をリリースしました。 リリースのページから各バイナリがダウンロードできます。
NULLの扱い変更 今回はNULLの扱いを変更しました。
JSONにはnullがありましたが、CSV等のテキストフォーマットには無いため、 すべて空文字として扱っていましたが、JSONのnullをSQLのNULLとして扱うようにしました。
JSONの文字列とみなせる箇所がnullの場合は、それほど問題ではありませんでしたが、 配列（&amp;quot;[]&amp;quot;）のようなJSONが入る箇所がnullの場合に空文字（&amp;quot;&amp;quot;）にしてしまうと、 SQLのJSON関数に渡しづらい問題があったためSQLのNULLにするようにしました。
これによりJSONの集計問題が解きやすくなっていると思います。
Introducing zqで示されている問題にSQLで解くときにスッキリ書けるようになっています。
上記の&amp;quot;A Practical Example&amp;quot;は、以下のSQLで解けます。
SELECT json(author_name)-&amp;gt;&amp;gt;0 AS author_name, count(*) AS count FROM openlibrary.json::.docs WHERE author_name IS NOT NULL AND publish_year IS NOT NULL GROUP BY json(author_name)-&amp;gt;&amp;gt;0 ORDER BY count DESC LIMIT 3; {&amp;quot;author_name&amp;quot;:&amp;quot;S. Stepniak&amp;quot;,&amp;quot;count&amp;quot;:38} {&amp;quot;author_name&amp;quot;:&amp;quot;Władysław Stępniak&amp;quot;,&amp;quot;count&amp;quot;:7} {&amp;quot;author_name&amp;quot;:&amp;quot;Władysław Stępniak&amp;quot;,&amp;quot;count&amp;quot;:4} Unicodeの正規化はPostgreSQLエンジンを使用する場合はnormalize()関数があるため、間に入れれば可能です。SQLite3エンジンを使用する場合は、 別のコマンドで正規化してからパイプで使用する必要があります。
jq .docs openlibrary.json| uconv norm | trdsql -driver sqlite3 -ijson -ojsonl &amp;quot;SELECT json(author_name)-&amp;gt;&amp;gt;0 AS author_name, count(*) AS count FROM - WHERE author_name IS NOT NULL AND publish_year IS NOT NULL GROUP BY json(author_name)-&amp;gt;&amp;gt;0 ORDER BY count DESC LIMIT 3&amp;quot; NULLオプション追加 また、-inullと-onullオプションを追加しました。-inullはSQLのNULLに変換する文字列を指定し、 -onullはSQLのNULLを指定された文字列に変換します。</description></item><item><title>第32回 PostgreSQLアンカンファレンス@オンラインで発表しました</title><link>https://noborus.github.io/blog/pgunconf/</link><pubDate>Fri, 01 Apr 2022 09:54:52 +0900</pubDate><guid>https://noborus.github.io/blog/pgunconf/</guid><description>「作ったツール紹介」というタイトルで発表しました https://pgunconf.connpass.com/event/240528/
自分で作った以下のツールを紹介してます。
trdsql ov pgsp jpug-doc-tool また、ovの関連でページャーとして、lessとpspgも紹介してます。
とくに、lessはまだ正式リリース版ではないですが、ヘッダーオプションが追加されるということで、PostgreSQLに限らず全DBのCLIを使っている人にとって、朗報だと思います。
また、ヘッダー固定が可能なことを前提にすると他のアプリケーションの作り方も変わっていくものだと思っています。
jpug-doc-toolでみんなの自動翻訳＠TexTraを使用できるようにしていることを紹介しました。
みんなの自動翻訳の説明はだいぶ省略しましたが、対訳語の登録や対訳集を学習させる等によりカスタマイズエンジンをみんなで育てることができれば、PostgreSQL向けの翻訳精度が上がっていくと思うので、利用者を増やしたいところです。</description></item><item><title>ov v0.10.0</title><link>https://noborus.github.io/blog/ov_010_0/</link><pubDate>Thu, 17 Feb 2022 10:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/ov_010_0/</guid><description>ov v0.10.0をリリースしました Terminal PAGER releases ov v0.10.0
reload/watchの追加 ファイルを再読込みするreloadを追加しました。ファイルを再オープンして読み込み直します。(起動後のF5 or ctrl+alt+l)
標準入力等のパイプ経由の場合は、それまで読み込んだ入力をリセットして、そこから読み込みを開始します。
watchは指定したｎ秒毎にreloadを繰り返します。watchの指定はオプション--watch nまたは起動後のF4 or ctrl+alt+wで指定して開始します。
例えば/proc/meminfo等の特殊ファイルに対しても使用できます。
終了時の出力を改善 ov終了時に表示している画面を再現するように出力できます（画面をクリアせずに終了の要望がきますが、その代替としての機能です）が、lessの場合はその時点の画面ではなく、それまで表示した画面を残して終了できます。
lessとまったく同じ機能はできませんが、さかのぼって出力させておきたい場合があるときのために出力範囲をできるようにしました。
オプションの--exit-write-beforeと--exit-write-afterで指定できます。--exit-write-beforeを多めに指定しておけば、画面をスクロールした後そこまでの行まで先頭から出力できるようになります。
また逆に--exit-write-afterを3行等少なく指定すれば、現在表示している画面の上から3行目までのように少なく出力できます。
これは起動した後終了するときにctrl+qで終了しようとするとその前に範囲指定できます。
WriteAndQuit Before:After: 1000:0 のようにすると1000行遡って（1000行に満たなければ先頭）出力します(Afterの0は画面下限を意味します)。
WriteAndQuit Before:After: :3 とした場合は、現在の画面を3行のみ出力します。
描画速度の改善 環境によって表示が遅い場合があるようなので、描画速度を改善しました。
ovはunisegを使用して1文字を判定しているので、Unicodeの結合文字に対応していない他のソフトに比べて遅い場合があります。それでも大抵の環境では気づくことはない速度で描画できていると思います。
過去のバージョン v0.10.0 reload,watchを追加 v0.9.6 リダイレクト出力、列モードの修正 v0.9.5 サスペンド／レジュームのサポート v0.9.4 マーク機能の強化、インクリメンタルサーチを追加して検索強化。 v0.9.3 スキップ行オプションの追加 v0.9.2 主要モジュール更新版 v0.9.1 半画面下移動のバグ修正。goのバージョンを1.16以降へ変更。 v0.9.0 follow,follow-all,execの各モードを追加、改善。検索とカラム選択のスタイルカスタマイズを可能にしました。 v0.8.9 (pre)follow-mode,follow-all-modeの追加 v0.8.1 文字の単位をCode point から Grapheme clusterに変更しました。 v0.8.0 tcell v2にアップグレードしました。 v0.7.1 交互に行スタイル効果適用の行がズレていたので修正 v0.7.0 スタイルカスタマイズの改善 v0.6.2 検索の高速化とキャンセル処理の追加 v0.6.1 細かな修正バージョン v0.</description></item><item><title>trdsql v0.9.1</title><link>https://noborus.github.io/blog/trdsql_091/</link><pubDate>Fri, 07 Jan 2022 00:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/trdsql_091/</guid><description>trdsql v0.9.1をリリースしました。 リリースのページから各バイナリがダウンロードできます。
読み込み行数を指定できるオプションを追加しました -ilr num で行数を指定します。SQLでは結果を制限するLIMITがありますが、これは入力の行数を制限します。 大きなファイルでは、読み込むのに時間がかかるためSQLを試行するときや、全部の結果が必要ないとき等に使用できます。
JSON出力時にオブジェクトの順番を固定しました JSON出力ではSQLでSELECT a,b FROM csvとしてもaとbの順番が不定で出力されていました。
SELECT a,b FROM ab.csv [ { &amp;quot;b&amp;quot;: &amp;quot;2&amp;quot;, &amp;quot;a&amp;quot;: &amp;quot;1&amp;quot; }, { &amp;quot;b&amp;quot;: &amp;quot;4&amp;quot;, &amp;quot;a&amp;quot;: &amp;quot;3&amp;quot; }, { &amp;quot;b&amp;quot;: &amp;quot;6&amp;quot;, &amp;quot;a&amp;quot;: &amp;quot;5&amp;quot; } ] SQLの出力結果をgoのmapにしてからJSONを出力するので、オブジェクト順は不定になっていました。 これをorderedmapを使用して、結果を指定順になるようにしました。
GOの対象バージョンを変更 goの対象バージョンを1.16以上にしました。リリースのバイナリは1.17でビルドするようになっています。</description></item><item><title>ov v0.9.6</title><link>https://noborus.github.io/blog/ov_096/</link><pubDate>Thu, 06 Jan 2022 10:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/ov_096/</guid><description>ov v0.9.6をリリースしました リダイレクト出力がうまくいかない場合があったので修正しました。
値がない列があると列モードのハイライト選択がそれ以降選択できない問題があったので修正しました。
過去のバージョン v0.9.6 リダイレクト出力、列モードの修正 v0.9.5 サスペンド／レジュームのサポート v0.9.4 マーク機能の強化、インクリメンタルサーチを追加して検索強化。 v0.9.3 スキップ行オプションの追加 v0.9.2 主要モジュール更新版 v0.9.1 半画面下移動のバグ修正。goのバージョンを1.16以降へ変更。 v0.9.0 follow,follow-all,execの各モードを追加、改善。検索とカラム選択のスタイルカスタマイズを可能にしました。 v0.8.9 (pre)follow-mode,follow-all-modeの追加 v0.8.1 文字の単位をCode point から Grapheme clusterに変更しました。 v0.8.0 tcell v2にアップグレードしました。 v0.7.1 交互に行スタイル効果適用の行がズレていたので修正 v0.7.0 スタイルカスタマイズの改善 v0.6.2 検索の高速化とキャンセル処理の追加 v0.6.1 細かな修正バージョン v0.6.0 マウスサポート v0.5.0 複数のドキュメントを開く方法を変更 v0.4.0 ヘルプ画面を追加 v0.3.1 位置をマークする機能を追加 v0.3.0 入力の改善 v0.2.1 色をカスタマイズ可能にする v0.2.0 検索の改善 v0.1.3 行番号モードを追加 v0.1.2 Homebrewパッケージの追加 v0.1.1 パッケージ自動更新の調整 v0.1.0 ovにレポジトリ名と構成を変更。deb/rpmパッケージの追加 v0.0.5 現在の基本機能を備えた最初のバージョン 参考 ovの紹介</description></item><item><title>ov v0.9.5</title><link>https://noborus.github.io/blog/ov_095/</link><pubDate>Tue, 28 Dec 2021 10:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/ov_095/</guid><description>ov v0.9.5をリリースしました Terminal PAGER releases ov v0.9.5
サスペンド／レジュームのサポートを追加 そのままでは、あまり使わなくなってきたと思っていますが、サスペンド／レジュームを出来るようにしました。 ov表示中に一旦Shellを起動してコマンドが実行できます。Shellを終了するとovに戻ります。シグナルのサスペンドも（サポートしている環境では）サスペンドします。
リダイレクト出力をサポート これまで echo &amp;quot;hoge&amp;quot; | ov &amp;gt; out.txt としてもovの表示はしても出力はしませんでしたが、リダイレクトするようにしました。 また、標準出力をパイプで受け取った場合に、標準エラー出力によって画面が崩れることがあったのをなるべく抑止するように改善しました。
その他内部的にリファクタリングにより多くの修正をしています。
過去のバージョン v0.9.5 サスペンド／レジュームのサポート v0.9.4 マーク機能の強化、インクリメンタルサーチを追加して検索強化。 v0.9.3 スキップ行オプションの追加 v0.9.2 主要モジュール更新版 v0.9.1 半画面下移動のバグ修正。goのバージョンを1.16以降へ変更。 v0.9.0 follow,follow-all,execの各モードを追加、改善。検索とカラム選択のスタイルカスタマイズを可能にしました。 v0.8.9 (pre)follow-mode,follow-all-modeの追加 v0.8.1 文字の単位をCode point から Grapheme clusterに変更しました。 v0.8.0 tcell v2にアップグレードしました。 v0.7.1 交互に行スタイル効果適用の行がズレていたので修正 v0.7.0 スタイルカスタマイズの改善 v0.6.2 検索の高速化とキャンセル処理の追加 v0.6.1 細かな修正バージョン v0.6.0 マウスサポート v0.5.0 複数のドキュメントを開く方法を変更 v0.4.0 ヘルプ画面を追加 v0.3.1 位置をマークする機能を追加 v0.3.0 入力の改善 v0.2.1 色をカスタマイズ可能にする v0.2.0 検索の改善 v0.1.3 行番号モードを追加 v0.</description></item><item><title>trdsql+PostgreSQL 14でJSONを処理する</title><link>https://noborus.github.io/blog/trdsql_jq/</link><pubDate>Sat, 18 Dec 2021 15:40:00 +0900</pubDate><guid>https://noborus.github.io/blog/trdsql_jq/</guid><description>trdsql はCSVやLTSVと共にJSONに対してもSQLを実行できるツールですが、SQLを使用するため得意な対象はフラットなJSONです。 ただし、v0.9.0からjqの構文が使え、SQL内でもSQLの関数が使えるため、内容によっては簡単に書くことができる場合があります。
デフォルトのsqlite3にもJSON関数がありますが、ここではよりJSON関数が充実しているPostgreSQL 14を使用します。
基本的な使用法 SQLを実行する対象として複数の列のリストの形になっているものが対象です。 以下のように{``}で囲まれた複数の名前: 値が,で並べられたJSONが基本的な形です。 改行で区切られた（実際には）複数のJSONが並べられたLDJSONやJSONLと呼ばれるものは一番SQLで実行しやすい形です。
{ &amp;quot;name&amp;quot;: &amp;quot;Tanaka&amp;quot;, &amp;quot;age&amp;quot;: 26 } { &amp;quot;name&amp;quot;: &amp;quot;Suzuki&amp;quot;, &amp;quot;age&amp;quot;: 32 } 一つのJSONの場合は上記を配列化します。
[ { &amp;quot;age&amp;quot;: &amp;quot;26&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Tanaka&amp;quot; }, { &amp;quot;age&amp;quot;: &amp;quot;32&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Suzuki&amp;quot; } ] どちらもそのままSELECT name, age FROM example0.jsonのようにtrdsqlのSQLとして実行できます。
JSONはオブジェクトや配列で入れ子に出来るため、ルートが対象とならない場合があります。以下の場合は、そのまま実行すると menu 列が一つに中身がすべて入っていることになります。
{ &amp;quot;menu&amp;quot;: { &amp;quot;id&amp;quot;: &amp;quot;file&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;File&amp;quot;, &amp;quot;popup&amp;quot;: { &amp;quot;menuitem&amp;quot;: [ { &amp;quot;value&amp;quot;: &amp;quot;New&amp;quot;, &amp;quot;onclick&amp;quot;: &amp;quot;CreateDoc()&amp;quot; }, { &amp;quot;value&amp;quot;: &amp;quot;Open&amp;quot;, &amp;quot;onclick&amp;quot;: &amp;quot;OpenDoc()&amp;quot; }, { &amp;quot;value&amp;quot;: &amp;quot;Save&amp;quot;, &amp;quot;onclick&amp;quot;: &amp;quot;SaveDoc()&amp;quot; } ] } } } SQLのJSON関数を使用することで内部のオブジェクトにアクセスできますが、ほとんどがJSON関数の記述になってしまうのでSQLで実行するメリットが感じられません。</description></item><item><title>ov v0.9.4</title><link>https://noborus.github.io/blog/ov_094/</link><pubDate>Tue, 02 Nov 2021 12:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/ov_094/</guid><description>ov v0.9.4をリリースしました Terminal PAGER releases ov v0.9.4
検索の改善 検索にインクリメンタルサーチを追加しました。issue#83に上がっていたインクリメンタルサーチを実装しました。 一文字入力するごとに検索をして最短でみつかった語の位置に移動します。 検索は毎回goroutineを使用しているため、入力を妨げないようになっています（小さなファイルだと気がつかないですが、大きなファイルで固まる実装が多いので、その差を実感していただけると思います）。
検索は元々、正規表現の入力も可能だったのですが、入力時に特殊文字を\でエスケープする等のわかりづらさがあったので、今回正規表現検索を使用するかを分けました。 インクリメンタルサーチでも正規表現は使用できます。
元々、大文字、小文字を区別するスイッチはあったので、検索時は、これらの組み合わせによって動作が変わるため複雑になっています。
機能 表示 (Default)切り替えキー コマンドオプション インクリメンタルサーチ (I) alt+i &amp;ndash;incremental 正規表現 (R) alt+r &amp;ndash;regexp-search 大文字小文字の区別 (Aa) alt+c -i, &amp;ndash;case-sensitive オプションの他、設定によってデフォルトを変更できます。ov.yamlのコメントを外して設定してください。
マークの改善 こちらもissue#86に上がっていたマークの削除とマークの可視化を実装しました。
これまで、現在の見ている行にマークを付けて移動して戻れるようにしていたのですが、削除機能は付けていませんでした。個別削除と全削除をできるようにしています。
マークすると先頭の背景色を変更して可視化しています。この部分はスタイルカスタマイズでStyleMarkLineにより、背景色、前景色、太字、アンダーライン等カスタマイズ可能です。また、MarkStyleWidthにより先頭から何文字スタイルを適用するか設定可能です。一行全部を変更したい場合は -1を指定してください。
スキップ行の指定 v0.9.3のオプションとして、先頭から指定した行を不可視にするオプションを追加しました。これは--headerと組み合わせて使用することを想定しています。 --headerを指定すると先頭から指定した行を固定表示できますが、余分な行があると表示領域が狭くなります。
例えばASCIIのボックス表示では、最上位行が区切り線の行になります。1行だけならまだ良いですが、横に長いデータの場合、折返し表示モードでは区切り線が何行にも渡って表示される場合があります。
1 +----+--------+ 2 | id | name | 3 +----+--------+ 4 | 1 | Orange | 5 | 2 | Melon | 6 | 3 | Apple | 7 +----+--------+ この場合 1行スキップして、ヘッダーを1行に指定すると2行目のみヘッダーとして扱われ、4行目以降がボディとしてスクロール対象になります。 おまけ インクリメンタルサーチと正規表現の組み合わせで以下のようなことができるようになりました:-) 過去のバージョン v0.</description></item><item><title>mdtsql v0.0.3</title><link>https://noborus.github.io/blog/mdtsql_003/</link><pubDate>Thu, 14 Oct 2021 15:45:50 +0900</pubDate><guid>https://noborus.github.io/blog/mdtsql_003/</guid><description>mdtsql v0.0.3をリリースしました mdtsql v0.0.3をリリースしました。 Markdown テーブルに対してSQLを実行できるツールです。
README.mdやGitHubのWikiなどで、Markdownのテーブルを書くことがありますが、ドキュメント翻訳担当リスト14.0のようにテーブルが大きくなる場合に手で編集するのも大変ですが、探し出したり、集計したり、更新したり、といった作業が面倒になることがあります。
そこでtrdsqlのモジュールを使って、Markdown Tableに対してもSQLを実行できるようにしました。
trdsqlは既に様々なフォーマットに対して実行できるようになっているため、Markdownを追加しても良いわけですが、一緒にするにはMarkdown用のオプションが必要になるのもどうかと思って、別にしてあります。
mdtsqlはMarkdownファイルに対して実行すると解析してテーブルがあればテーブル情報を表示します。markdownにテーブルは複数含むことができるため、Markdown内のテーブルを指定するテーブル名をここで得ます。
「ドキュメント翻訳担当リスト13.1.md」というファイルに実行してみます。
$ mdtsql ドキュメント翻訳担当リスト13.1.md Table Name: [ドキュメント翻訳担当リスト13.1] +-------------+------+ | column name | type | +-------------+------+ | ファイル名 | text | | 担当者 | text | | 進捗 | text | | 備考 | text | +-------------+------+ Table Name: [ドキュメント翻訳担当リスト13.1_2] +------------------------+------+ | column name | type | +------------------------+------+ | お名前 | text | | マニュアルへの表記 | text | | マニュアルへの記載可否 | text | | 主な貢献内容 | text | +------------------------+------+ テーブル名がわかったら、-q SQL文でSQLを実行できます。</description></item><item><title>pgsp</title><link>https://noborus.github.io/blog/pgsp/</link><pubDate>Wed, 14 Jul 2021 15:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/pgsp/</guid><description>pgsp は PostgreSQLの pg_stat_progress viewを監視して表示するCLIツールです。
pg_stat_progress PostgreSQLでは、いくつか時間がかかる処理に対して進捗状況が見られるViewがあります。 Viewの名前は pg_stat_progressではじまり、analyze, cluster, create_index, vacuum, basebackup (version 14からは copyが追加される予定)などが取得できます。
詳しくは progress-reportingを参照してください。
これらのViewは処理が始まったときにレコードが追加されて、変化する処理状況（フェーズや処理した数）を更新していき、終了するとレコードが消えます。SQLで簡単に確認できるので便利ですが、常に更新されていくため、状況を逐一見たいときにはpsqlでは\watch等を利用してSELECTを繰り返して見る必要があります。
SELECT * FROM pg_stat_progress_analyze; pgsp pgspはこれらのViewを監視して表示する専用のCLIツールです。Go製です。 やっていることはシンプルでpg_stat_progress_* のViewを定期的にSELECTで取得し、レコードが追加、更新されたら進捗に相当する数値でプログレスバーを更新します。
PostgreSQLに普通に接続にいくので接続情報（ホスト、ポート、ユーザー、パスワード等）が必要です。 --dsnで設定してください。
pgsp --dsn 'host=ホスト名 port=ポート番号 user=ユーザー名 password=パスワード' UNIXドメインソケットを使用する場合はhostにpathを書きます。
pgsp --dsn 'host=/var/run/postgresql' 設定ファイルとして $HOME/.pgsp.yaml に書くこともできます。
dsn: host='/var/run/postgresql/' user='postgres' 起動すると定期的にViewにSELECTを実行します。レコードがなければスピンが回るだけです。
何らかの処理が走ってViewにレコードが追加されるとViewの内容とプログレスバーが表示されます。Viewの内容はTerminalの表示域によって変わるようになっています。
また、Viewは処理が終わるとレコードが削除されますが、pgspでは少しの間（デフォルトで10秒）表示し続けるようになっています。この時間は -a --AfterCompletionにより調整できます。
10分経過まで表示しておきたい場合は以下のようにします。
pgsp -a 600 更新間隔は-i --Intervalによって指定できます（デフォルトは 0.5秒)。処理によってはすぐに終わってしまうので、0.5秒間隔だと、実際には処理が行われていたにも関わらず捕捉出来ない場合があります。その場合は更新間隔を0.1秒等にしてみてください。
逆に負荷が気になる場合は1以上に設定すると良いでしょう。
Bubble Tea CLIツールの表示はBubble Tea を使用しておこなっています。
Bubble TeaではTerminal上で、その場で表示するアプリケーションが簡単に作成出来るようになっています。その例でもあるプログレスバーをシンプルに利用しています。</description></item><item><title>trdsql v0.9.0</title><link>https://noborus.github.io/blog/trdsql_090/</link><pubDate>Mon, 24 May 2021 16:47:00 +0900</pubDate><guid>https://noborus.github.io/blog/trdsql_090/</guid><description>trdsql v0.9.0をリリースしました。 リリースのページから各バイナリがダウンロードできます。
JSONに対してjq式でフィルタを掛けられるようになりました。 JSONに対してtrdsqlでは最初のオブジェクトや配列をテーブルとみなして処理します。 JSONは階層構造に出来るため、その中のオブジェクトをテーブルとしたい場合にはSQLのJSON関数を使うか、jqを使用してフィルタリングしてパイプで受け取る等の処置が必要でした。
これが面倒だったため、JSONファイルに対してjq式を書けるようにしました。
この実装にはgojqを利用しています。
例えば以下のようなJSONファイルがあった場合に、通常のtrdsqlでは menuカラムしかありませんでした。
{ &amp;quot;menu&amp;quot;: { &amp;quot;id&amp;quot;: &amp;quot;file&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;File&amp;quot;, &amp;quot;popup&amp;quot;: { &amp;quot;menuitem&amp;quot;: [ { &amp;quot;value&amp;quot;: &amp;quot;New&amp;quot;, &amp;quot;onclick&amp;quot;: &amp;quot;CreateDoc()&amp;quot; }, { &amp;quot;value&amp;quot;: &amp;quot;Open&amp;quot;, &amp;quot;onclick&amp;quot;: &amp;quot;OpenDoc()&amp;quot; }, { &amp;quot;value&amp;quot;: &amp;quot;Save&amp;quot;, &amp;quot;onclick&amp;quot;: &amp;quot;SaveDoc()&amp;quot; } ] } } } ファイル名に追加してjq式を書くことで以下のようにmenuitemに対してSQLを書けるようになります。
trdsql -oat &amp;quot;SELECT * FROM menu.json::.menu.popup.menuitem&amp;quot; +-------+-------------+ | value | onclick | +-------+-------------+ | New | CreateDoc() | | Open | OpenDoc() | | Save | SaveDoc() | +-------+-------------+ これによりjqコマンドは必要なくなり、複数のファイル又は一つのJSONファイルの中の複数のテーブルを使用できるようになります。</description></item><item><title>ov v0.9.0</title><link>https://noborus.github.io/blog/ov_090/</link><pubDate>Fri, 09 Apr 2021 16:14:51 +0900</pubDate><guid>https://noborus.github.io/blog/ov_090/</guid><description>ov v0.9.0をリリースしました。 Terminal PAGER releases ov v0.9.0
v0.8.9をプレリリースバージョンとしてリリースしていましたが、正式にfollowモードを追加したバージョンとして v0.9.0をリリースしました。
followモード、follow-allモード followモードはtail -fのようにファイルが追記されたら自動で読み取って表示します。lessではless +Fで実現されています。 ログの監視に使われることが多いです。
ov --follow-mode /var/log/syslog followモードで複数のファイルを指定することも出来ますが、ovでは複数のファイルを別々のドキュメントとして管理して、 &amp;lsquo;]&amp;lsquo;と&amp;rsquo;[&amp;lsquo;で切り替えるようになっています。表示しているファイル以外が更新されていても裏側で読み取られているので気づくことが出来ません。
そこで、動作はfollowモードに似ていますが、最後に更新があったファイルに切り替えるfollow-allモードも追加しました。
ov --follow-all /var/log/syslog /var/log/auth.log のようにすると最後に更新されたファイルに自動で切り替わります。
followモードとfollow-allモードは起動後でもctrl+fやctrl+aによりモード切り替えが可能です。
execモード execモードはovの--exec に渡されたコマンドを実行して、stdout/stderrを表示します。 コマンドを実行した結果をパイプによりページャーで表示させるのが一般的ですが、stdin(標準入力)は一つしか無いので、stdout/stderrどちらかを表示か両方を一つにリダイレクトして（混ぜて）表示する必要があります。
例えばmakeコマンドでは、そこから更に複数のコマンドが呼ばれるためstdoutとstderr両方に多く出力されるため見づらい場合があります。
そのような場合にexecモードで実行すると簡単にエラーと通常出力を分けて見ることができます。その際にfollow-allモードも一緒に指定するとエラー時に気づきやすくなります。
ov --follow-all --exec -- make -j2 execオプションの後に(--)を付けるとそれ以降はovのオプションとは解釈されません（この例ではmakeのオプションと解釈されます）。
スタイルカスタマイズの追加 検索のハイライトとカラムモードのハイライトをカスタマイズ出来るようにしました。 ~/.ov.yamlに以下のように指定できます。
StyleSearchHighlight: Foreground: &amp;quot;gold&amp;quot; Reverse: true いくつかのモードを束ねて切り替えるview-modeの選択の追加 ページャーとして汎用的に使えるようになってきたのでファイル形式によっていくつものモードを変更したい場合が出てきます。あらかじめ ~/.ov.yamlに以下のようなModeを登録しておくと起動後にpを押してpsqlやMySQLと打つことでこれらのモードを束ねて切り替えることを出来るようにしました。
Mode: psql: Header: 2 AlternateRows: true ColumnMode: true LineNumMode: false WrapMode: true ColumnDelimiter: &amp;quot;|&amp;quot; MySQL: Header: 3 AlternateRows: true ColumnMode: true LineNumMode: false WrapMode: true ColumnDelimiter: &amp;quot;|&amp;quot; 過去のバージョン v0.</description></item><item><title>ov v0.8.1</title><link>https://noborus.github.io/blog/ov_081/</link><pubDate>Fri, 12 Feb 2021 18:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/ov_081/</guid><description>ov v0.8.1をリリースしました。 Terminal PAGER releases ov v0.8.1
文字の単位をCode point から Grapheme clusterに変更しました。
GoではruneがCode point単位で文字として数えます。Unicodeでは結合文字等があり、1Code pointが１文字ではない場合があります。1文字ではなくても元の文字の後に置けば良いので、文字数が変わる以外は通常それほど意識しなくても良い場合がほとんどです。
ただし端末に表示する場合のような文字幅が固定長の世界では、次の文字が0,1,2幅先なのかを決める必要があります。これまでCode pointに合わせて表示していたため🇯🇵のような文字は、端末では「JP」（フォントによりますが点線でそれぞれ囲まれた文字）のように表示されていました。そのため２文字で表示されることがありましたが、これからは1文字幅として扱うようにしました。
現在だとechoのように端末に任せて表示すると２文字幅で、ovで表示すると「J」のように表示され、文字が欠けてしまっているように見えます。これは端末側が対応して🇯🇵が表示出来るようになっても文字幅がズレずにそのまま表示されるようになるための対応です。端末側が対応するまではechoとの結果がズレてしまいますが、どちらが正しい仕様かを考えた結果先行して実装することにしてしまいました。 ただ、いまだに絵文字の結合に対応して表示できる端末が見つからないのが問題点です&amp;hellip;
過去のバージョン v0.8.1 文字の単位をCode point から Grapheme clusterに変更しました。 v0.8.0 tcell v2にアップグレードしました。 v0.7.1 交互に行スタイル効果適用の行がズレていたので修正 v0.7.0 スタイルカスタマイズの改善 v0.6.2 検索の高速化とキャンセル処理の追加 v0.6.1 細かな修正バージョン v0.6.0 マウスサポート v0.5.0 複数のドキュメントを開く方法を変更 v0.4.0 ヘルプ画面を追加 v0.3.1 位置をマークする機能を追加 v0.3.0 入力の改善 v0.2.1 色をカスタマイズ可能にする v0.2.0 検索の改善 v0.1.3 行番号モードを追加 v0.1.2 Homebrewパッケージの追加 v0.1.1 パッケージ自動更新の調整 v0.1.0 ovにレポジトリ名と構成を変更。deb/rpmパッケージの追加 v0.0.5 現在の基本機能を備えた最初のバージョン 参考 ovの紹介</description></item><item><title>trdsql v0.8.0</title><link>https://noborus.github.io/blog/trdsql_080/</link><pubDate>Wed, 27 Jan 2021 11:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/trdsql_080/</guid><description>trdsql v0.8.0をリリースしました。 リリースのページから各バイナリがダウンロードできます。
Contextを追加しました。 コマンドでは、killシグナルによって終了するので、変更はないですが、内部的にContextによるキャンセルを出来るようにしました。パッケージ使用する場合にプロセスの終了をせずにキャンセルする処理が書きやすく成ります。
JSON出力でJSONオブジェクトだった場合にjson.RawMessageで返すようになりました。 JSONは入れ子で配列、オブジェクトを入れられますが、これまでのtrdsqlではフラットな文字列として扱うため、JSONの入れ子構造を作ることが出来ませんでした。 json.RawMessageとして返すことで、SQLのJSON関数でJSON化した列をJSONとして扱えるようになりました。
JSON出力時にオブジェクトの順序が保持されるようになりました。 JSONのオブジェクト{&amp;quot;a&amp;quot;: &amp;quot;x&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;y&amp;quot;}が並んだときには順序は無いことになっています。そのため、{&amp;quot;a&amp;quot;: &amp;quot;x&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;y&amp;quot;}と{&amp;quot;b&amp;quot;, &amp;quot;y&amp;quot;,&amp;quot;a&amp;quot;: &amp;quot;x&amp;quot;,}は同じものです。 そのため、trdsqlでJSONやJSONL出力するときに &amp;quot;SELECT a,b FROM test.json&amp;quot;のようなSQLでもJSONに変換された時点でaとbの順序は不定でした。 しかしながら、不便な場合があるのでこの順序を守るようにしました。
~(tilde) を $HOMEに展開するようにしました。 ~/test.csv　などの ~(tilde) の指定は通常shellがおこなうため、&amp;quot;SELECT * FROM ~/test.csv&amp;quot;のようにした場合は~(tilde)が展開されませんでした。trdsqlではファイル名だった場合に自前で置き換えするようにしたので展開されることになります。</description></item><item><title>ov v0.8.0</title><link>https://noborus.github.io/blog/ov_080/</link><pubDate>Thu, 07 Jan 2021 14:57:42 +0900</pubDate><guid>https://noborus.github.io/blog/ov_080/</guid><description>ov v0.8.0をリリースしました。 Terminal PAGER releases ov v0.8.0
このバージョンからtcellをv2にアップグレードしました。 スタイルらへんの非互換があるためv2になっていますが、そこまで大きくは変わっていません。
Windowsターミナルでキーバインドに大文字を指定しているキーが効かない問題を修正しました。 他の端末では「Shift+a」は「A」になるのですが、Windowsターミナルでは「Shift+A」でイベントが発生するので、大文字のときには「Shift」が押されていてもイベントを取得するようにしました。
ドキュメントを追加・閉じるイベントを追加しました。追加は通常使用できませんが、閉じるは「Ctrl+k」で閉じるようになりました。
configとオプションを指定していた場合にオプションが優先されない問題があったのを修正しました。
oviewer パッケージ を使用できるように内部的にも修正をしています。
過去のバージョン v0.8.0 tcell v2にアップグレードしました。 v0.7.1 交互に行スタイル効果適用の行がズレていたので修正 v0.7.0 スタイルカスタマイズの改善 v0.6.2 検索の高速化とキャンセル処理の追加 v0.6.1 細かな修正バージョン v0.6.0 マウスサポート v0.5.0 複数のドキュメントを開く方法を変更 v0.4.0 ヘルプ画面を追加 v0.3.1 位置をマークする機能を追加 v0.3.0 入力の改善 v0.2.1 色をカスタマイズ可能にする v0.2.0 検索の改善 v0.1.3 行番号モードを追加 v0.1.2 Homebrewパッケージの追加 v0.1.1 パッケージ自動更新の調整 v0.1.0 ovにレポジトリ名と構成を変更。deb/rpmパッケージの追加 v0.0.5 現在の基本機能を備えた最初のバージョン 参考 ovの紹介</description></item><item><title>goのTUIについて2020年最終版</title><link>https://noborus.github.io/blog/go_tui2020/</link><pubDate>Thu, 31 Dec 2020 14:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/go_tui2020/</guid><description>概要 goのTUIについての2020年の最終更新版です。
goでTUI(text user interface)を作成する場合にライブラリを使用するのが一般的です。
goのTUIライブラリはだいたい以下に分類されます。
termbox-go系 tcell系 bubbletea系 その他 goのTUIライブラリはtermbox-go系、tcell系の利用が多かったですが、彗星のごとくbubbleteaが登場しました。
bubbleteaはThe Elm Architectureに基づいて作られているというフレームワークで、追加のコンポーネントとしてbubblesもあり、もう一つの系統として選択肢になると思います。
TUIライブラリを謳っている場合は、だいたい上記3つを元に実装されている場合が多いです。
TUIはエスケープシーケンスを使用すれば、ライブラリを使用しなくても実現できますが、端末によりエスケープシーケンスが変わっていたりするので、マルチプラットフォームで動作するのは難しくなります。 そのため、独自に一から作成するよりは、これらのライブラリの上に便利な機能を足す形になります。
termbox-go系 termbox-goは、老舗で現在も多く使われていますが、開発は停滞傾向で、termbox-goにもそれほど保守しない方向だと書かれています。
termbox-goを使用して、より高度なウィジットを実装したライブラリにgocuiがあります。
termbox-go gocui termui termbox-goのimported by tcell系 tcellは、termbox-goよりも新しくtermbox-goを意識して開発され、今も開発も続いています。 tcellは基本的な機能しか提供しませんが、tcell/viewsには、少し高度なウィジットがあります。
また、より高度なウィジットを実装したライブラリとしてtviewがあり、よく使用されています。また、そこからForkしたcviewも候補に入れておくと良いかも知れません。
さらに元々termbox-goを使用していたgocuiをtcellに変更したawesome-gocui/gocuiも開発されています。
tcell tcell/views tview cview cbind gowid goban awesome-gocui/gocui tcellのimported by bubbletea系 端末全部を使用するモードしかないtermbox-goとtcellと違い彗星のごとく現われたbubbleteaは現在のプロンプトから対話するような、ちょっとしたプログラムから端末全部を使用するTUIまでサポートしています。
既に例が豊富に用意されていて、十分に実用に耐えるように思います。
bubbletea bubbles bubbleteaのimported by その他 termbox-goやtcellは、端末画面をまるまる使用することを前提に作られています。起動すると現在の端末画面は消えて（終了時に戻すことは可能）、新しい画面が表示されます。
現在のshellプロンプトで動作するような対話型プログラムの場合は、termbox-goやtcellでは作ることはできないので、bubbletea系か別のライブラリや自前で実装することになります。
別のプログラムとしては、対話型のライブラリとして go-promptやlinerがあります。
また、コンソール上の表示を助けるツールとして色を付けたり、その行のまま表示を変えるプログレスバー的な表示をするライブラリがあります。
どれを選択すべきか？ 2020年12月現在、端末全体を使用する以外の使用の可能性がある場合は、bubbleteaを使用するのが良いと思います。端末全体を使用するアプリケーションを開発するなら、tview とbubbleteaで、例を見ながらどちらを使用するか決めるのが良いでしょう。</description></item><item><title>ov v0.7.0</title><link>https://noborus.github.io/blog/ov_070/</link><pubDate>Wed, 09 Dec 2020 10:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/ov_070/</guid><description>ov v0.7.0をリリースしました。 Terminal PAGER releases ov v0.7.0
PAGER=ov としても問題なく使えるバージョンになっていると思います。
スタイルカスタマイズを変更しました。 元々は、ヘッダーの色、行の交互表示の背景色、重ね打ちの色、重ね内下線の色を設定ファイルにより指定出来るようにしていましたが、これらの項目全体のスタイルを指定できるようにしました。
それぞれ、StyleHeader、StyleAlternate、StyleOverStrike、 StyleOverLineという項目名について、以下のスタイルを指定できます。
Foreground、Background には色名。 Bold, Blink, Dim, Italic, Underline には true / false(Boolean)。 以下のように指定できます。
StyleHeader: Background: &amp;quot;gray&amp;quot; Foreground: &amp;quot;red&amp;quot; Bold: true Italic: true Underline: true ov.yaml をコピーして変更していくと良いと思います。
また、lessのキーバインドに近づけた ov-less.yaml をアップしておきました。 lessに慣れている方はこちらを使用すると移行がしやすいと思います。
ページアップ、ページダウンの移動改善 1行を折り返さない表示の場合は、表示領域の高さ＝行数なので、+-するだけで問題なかったですが、 折り返す場合は、表示領域の幅により表示できる行数が変わり、スクロール時にはさらに行の途中から表示する必要があったりするので、 これまでページアップ、ページダウンは正確に1ページではありませんでした。
今回はその計算の実装をやり直しました。そのため、1行が非常に長く画面いっぱいになる場合でも、ページ単位の移動で、その途中の表示からちゃんと表示されるようになりました。 また1行が非常に長い場合にパフォーマンスが落ちるのを少し改善しました。元々の実装の仕方により、1行が長すぎる行の効率はあまり良くありません。
過去のバージョン v0.7.0 スタイルカスタマイズの改善 v0.6.2 検索の高速化とキャンセル処理の追加 v0.6.1 細かな修正バージョン v0.6.0 マウスサポート v0.5.0 複数のドキュメントを開く方法を変更 v0.4.0 ヘルプ画面を追加 v0.3.1 位置をマークする機能を追加 v0.3.0 入力の改善 v0.2.1 色をカスタマイズ可能にする v0.</description></item><item><title>SQLのORDER BY 列番号と式</title><link>https://noborus.github.io/blog/sqlorder/</link><pubDate>Sat, 31 Oct 2020 12:53:00 +0900</pubDate><guid>https://noborus.github.io/blog/sqlorder/</guid><description>きっかけ tom__boさんが書かれた8.0.22でのprepared statementの挙動変化 で、ORDER BY に列番号を指定する問題に注目が集まりました。
その中で紹介されていた、
For a prepared statement of the form SELECT expr1, expr2, &amp;hellip; FROM table ORDER BY ?, passing an integer value N for the parameter no longer causes ordering of the results by the Nth expression in the select list; the results are no longer ordered, as is expected with ORDER BY constant. 「the results are no longer ordered, as is expected with ORDER BY constant.</description></item><item><title>tcell/tviewでTUIを作るならキー割り当てにcbindを利用しよう</title><link>https://noborus.github.io/blog/cbind/</link><pubDate>Tue, 27 Oct 2020 10:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/cbind/</guid><description>cbindとは？ cbindはtcellのキーイベントとイベントハンドラを結びつけるライブラリです。
現在cbindの最新はtcellのversion 2が対象になっています。version 1を対象にする場合は cbind v0.1.1を使用して下さい。 go get gitlab.com/tslocum/cbind@v0.1.1 ここでも v0.1.1を対象にしています。
tcellのキーイベント tcell ではキー入力がイベントの１つとして取得できます。tviewでもtcellのイベントを使用しているので、同じ様にイベントとして取得します。
tcellのキーイベントを取得するのは以下のようにswitch caseでキーを判別して、イベントハンドラを呼び出すのが一般的です。
ev := screen.PollEvent() switch ev := ev.(type) { case *tcell.EventKey: switch ev.Key() { case tcell.KeyEscape: close(quit) return } case tcell.KeyEnter: action() return } ここのtcell.KeyEscapeは constの数値として定義されています（キーボードに存在する英数字などの文字はruneで入ってきます）。 キー割り当てが少ないうちは、このまま追加していけば機能を増やせるので分かりやすいですが、キー割り当てが多くなってくると以下のような問題が出てきます。
修飾キー(CTRL、ALT&amp;hellip;)が押された場合に動作が変わる場合はさらに分岐する キー割り当てをドキュメント化するのが大変になる キー割り当てのヘルプが必要になる キー割り当てを人によって変更したくなる ドキュメント化やヘルプはコードで実装した後、手間を掛けて書いていけばなんとか解決できますが、キー割り当ての変更に対応するには、元のままのコードでは不可能です。
cbindを使用 そこで使用したいのがcbindです。
cbind は *tcell.EventKeyを文字列にするEncodeとキー文字列（ctrl+a等）をtcellのイベントキーに変換するDecodeがあり、それらを利用して「文字列」にイベントハンドラを結びつけて登録できます。実際にキーイベントが起きたら、cbindに任せれば登録されていたイベントハンドラが実行されることになります。
実際の使用例です。 キーの登録は、まずcbind.NewConfiguration()をしてConfigurationを作成します。 そのConfigurationにキー文字列をDecodeでイベントキーに変換して、SetRuneまたはSetKeyで登録します。
実際に登録するときには、キー文字列（ctrl+a等）とイベントハンドラ（func）を直接結びつけるのではなく、アクション名（文字列）を介しておくと、ヘルプや設定ファイル化するときに便利です。
アクション名とキー文字列のマップ(keyBind)とアクション名とイベントハンドラのマップ(actionHandlers)をあらかじめ定義しておいてsetKeyBindで登録しています。
const ( // アクション名 actionQuit = &amp;quot;quit&amp;quot; ) var keyBind = map[string][]string{ // アクション名に対してキー文字列をマッピング（キー文字列は複数可能） actionQuit: {&amp;quot;q&amp;quot;, &amp;quot;ctrl+q&amp;quot;}, } var actionHandlers = map[string]func(){ // アクション名に対してイベントハンドラをマッピング actionQuit: handleQuit, } // 終了のイベントハンドラ var quit = make(chan struct{}) var handleQuit = func() { close(quit) } func setKeyBind() (*cbind.</description></item><item><title>ov v0.6.2</title><link>https://noborus.github.io/blog/ov_062/</link><pubDate>Mon, 19 Oct 2020 21:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/ov_062/</guid><description>ov v0.6.2をリリースしました。 releases ov v0.6.2
v0.6.0でマウスサポートを追加しました。 元のマウスの動きは、ov側では制御せずにターミナル側のマウス処理にまかせていました。しかしそれでは、選択してコピーする時に改行コードが含まれないでコピーされるため、複数行のコピーに問題がありました。
マウス制御を実装することで、複数行のコピーがちゃんと複数行としてコピーされるようになります。ただ、goでクリップボードを制御するのは、難しくLinuxでは外部コマンドを使用するライブラリを使用しています。
v0.6.1はv0.6.0の細かなバグの修正バージョンです。 v0.6.2で検索のキャンセルができるようになりました。 大きなファイルで検索をかけると時間がかかる場合があります。そのときにキャンセル（デフォルトでCtrl+c)を押すと、検索がキャンセルされすぐに制御が戻ります。
また、検索速度自体を速くしました。検索文字列が正規表現のメタ文字を使用していない場合は、正規表現検索ではない検索をします。正規表現よりも高速に検索できるため、通常の文字列を入れて検索するときは、かなり高速になっています。
過去のバージョン v0.6.2 検索の高速化とキャンセル処理の追加 v0.6.1 細かな修正バージョン v0.6.0 マウスサポート v0.5.0 複数のドキュメントを開く方法を変更 v0.4.0 ヘルプ画面を追加 v0.3.1 位置をマークする機能を追加 v0.3.0 入力の改善 v0.2.1 色をカスタマイズ可能にする v0.2.0 検索の改善 v0.1.3 行番号モードを追加 v0.1.2 Homebrewパッケージの追加 v0.1.1 パッケージ自動更新の調整 v0.1.0 ovにレポジトリ名と構成を変更。deb/rpmパッケージの追加 v0.0.5 現在の基本機能を備えた最初のバージョン 参考 ovの紹介</description></item><item><title>ov v0.5.0</title><link>https://noborus.github.io/blog/ov_050/</link><pubDate>Mon, 31 Aug 2020 15:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/ov_050/</guid><description>ov v0.5.0をリリースしました。 releases ov v0.5.0
こちらには書いていませんでしたが、0.2.0リリース以降に以下のリリースをしていました。
v0.3.0 v0.3.1 v0.4.0 v0.5.0 これまでの変更で内部的な修正を多くおこない v0.5.0では複数のファイルを別々のドキュメントとして開くように変更しました。
これまで ov *.txt は cat *.txtと同じようにファイルを繋げて表示していましたが、それぞれ独立して開いてドキュメントの切り替えで移動するようになっています。
1つのviewに対して複数のドキュメントを切り替えて使えるように内部的な修正をしたため、helpの表示、debug logの表示が可能になり、v0.5.0では、複数ファイルの開き方を変更するまでになりました。
また、安定バージョンとは言えませんが、ライブラリとしても使用可能になっています。
ライブラリの使用の仕方としては、サンプル がありますが、以下のようにOpenしてRun()で使用します。ページャーのライブラリなので、Run()の後は終了キーを押すまで返ってきません。goroutineで動かして、動いているページャーに対して動作を変更することが可能ですが、まだ仕様が落ち着いてないので、無茶をすると動かなくなる場合があります。
package main import ( &amp;quot;github.com/noborus/ov/oviewer&amp;quot; ) func main() { ov, err := oviewer.Open(&amp;quot;main.go&amp;quot;) if err != nil { panic(err) } if err := ov.Run(); err != nil { panic(err) } } 過去のバージョン v0.5.0 複数のドキュメントを開く方法を変更 v0.4.0 ヘルプ画面を追加 v0.3.1 位置をマークする機能を追加 v0.3.0 入力の改善 v0.2.1 色をカスタマイズ可能にする v0.2.0 検索の改善 v0.</description></item><item><title>ov v0.2.0</title><link>https://noborus.github.io/blog/ov_020/</link><pubDate>Mon, 25 May 2020 10:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/ov_020/</guid><description>ov v0.2.0をリリースしました。 releases ov v0.2.0
検索を正規表現対応にしました 検索を正規表現対応にしました。
検索入力を改善しました。カーソルを移動でき、削除、挿入できるようにしました。
バックスペースと重ね打ちに対応しました ^Hによるバックスペースに対応しました。
a^Ha のように文字にバックスペースしてからもう一度同じ文字を打つ重ね打ち、とアンダーラインにバックスペースしてから文字を打つ重ね打ちに対応しました。
これによりMANPAGERとして使用できるようになりました。
まとめ これまでpsqlやmysqlで使用される機能を多く追加してきましたが、 通常のPAGERとして使用される必要な機能を実装しました。
自分で使用する分にはlessの代わりにovを使用しても問題なく使用できています。 ただlessは高機能でオプションが多くあるので、人によっては全然足りないと感じることでしょう。
過去のバージョン v0.2.0　検索の改善 v0.1.3　行番号モードを追加 v0.1.2　Homebrewパッケージの追加 v0.1.1　パッケージ自動更新の調整 v0.1.0　ovにレポジトリ名と構成を変更。deb/rpmパッケージの追加 v0.0.5　現在の基本機能を備えた最初のバージョン 参考 ovの紹介</description></item><item><title>tcellについて2</title><link>https://noborus.github.io/blog/tcell_02/</link><pubDate>Sun, 17 May 2020 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/tcell_02/</guid><description>これまで goのTUIについて tcellについて イベント tcellのイベントは、NewScreen()で作成したスクリーンのPollEvent()で取得できます。
その名の通り、イベントが起こるまでポーリング（polling）して待つので、起こらない限り止まったままになります。
PollEvent()でイベントが起こったらイベントに応じて処理し、SetContent()でセットし、次のイベントが起こる前にDraw()で描画する。 というのが、実際のメインルーチンになります。
このメインルーチンをgoroutineで動かし、終了のイベントがきたらchannelに通知して通知を受信したらFini()を実行して終了するのが一般的な流れです。
キーイベント イベントの中でも重要でよく使用するのがキーイベントです。 以下のプログラムは左上に打ったキーが表示されます。ESCキー又はEnterキーで終了します。
package main import ( &amp;quot;log&amp;quot; &amp;quot;time&amp;quot; &amp;quot;github.com/gdamore/tcell&amp;quot; ) func main() { screen, err := tcell.NewScreen() if err != nil { log.Fatal(err) } if err = screen.Init(); err != nil { log.Fatal(err) } defer screen.Fini() screen.SetContent(0, 0, '_', nil, tcell.StyleDefault) quit := make(chan struct{}) go func() { for { screen.Show() ev := screen.PollEvent() switch ev := ev.(type) { case *tcell.</description></item><item><title>tcellについて</title><link>https://noborus.github.io/blog/tcell_01/</link><pubDate>Wed, 13 May 2020 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/tcell_01/</guid><description>SetContent() goのTUIについてで書いたようにtcellのSetContent()は1文字設置していくのでASCIIの範囲内だと簡単ですが、Unicodeの世界では注意すべき点があります。
まず日本語などの全角幅の文字と半角幅の文字が混在すると全角幅のときには、次の文字は1つとばして設置するといったことが必要になります。
単純に実装する場合はrunewidth.RuneWidth()を使用すれば、runeの文字幅を0,1,2で返してくれるので、その分xをずらせば表示されます。以下が実装例です。文字列を渡せるsetContents()で処理しています。
package main import ( &amp;quot;log&amp;quot; &amp;quot;github.com/gdamore/tcell&amp;quot; &amp;quot;github.com/mattn/go-runewidth&amp;quot; ) func setContents(screen tcell.Screen, x int, y int, str string, style tcell.Style) { for _, r := range str { screen.SetContent(x, y, r, nil, style) x += runewidth.RuneWidth(r) } } func main() { screen, err := tcell.NewScreen() if err != nil { log.Fatal(err) } if err = screen.Init(); err != nil { log.Fatal(err) } defer screen.Fini() setContents(screen, 0, 10, &amp;quot;あいうえお&amp;quot;, tcell.</description></item><item><title>goのTUIについて</title><link>https://noborus.github.io/blog/go_tui/</link><pubDate>Tue, 12 May 2020 23:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/go_tui/</guid><description>概要 ライブラリの状況を鑑みてgoのTUIについて2020年最終版に更新しました。
goでTUI(text user interface)を作成する場合にライブラリを使用するのが一般的です。
goのTUIライブラリはだいたい以下に分類されます。
termbox-go系 tcell系 その他 TUIライブラリを謳っている場合は、だいたい上記2つを元に実装されている場合が多いです。
TUIはエスケープシーケンスを使用すれば、ライブラリを使用しなくても実現できますが、端末によりエスケープシーケンスが変わっていたりするので、マルチプラットフォームで動作するのは難しくなります。 そのため、独自に一から作成するよりは、これらのライブラリの上に便利な機能を足す形になります。
termbox-go系 termbox-goは、老舗で現在も多く使われていますが、開発は停滞傾向で、termbox-goにもそれほど保守しない方向だと書かれています。
termbox-goを使用して、より高度なウィジットを実装したライブラリにgocuiがあります。
termbox-go gocui termui termbox-goのimported by tcell系 tcellは、termbox-goよりも新しくtermbox-goを意識して開発され、今も開発も続いています。 tcellは基本的な機能しか提供しませんが、tcell/viewsには、少し高度なウィジットがあります。
また、より高度なウィジットを実装したライブラリとしてtviewがあり、よく使用されています。
tcell tcell/views tview gowid goban tcellのimported by その他 termbox-goとtcellはいずれも端末画面をまるまる使用することを前提に作られています。起動すると現在の端末画面は消えて（終了時に戻すことは可能）、新しい画面が表示されます。
現在のshellプロンプトで動作するような対話型プログラムの場合は、上記2つで作ることはできないので、別のライブラリや自前で実装することになります。
別のプログラムとしては、対話型のライブラリとして go-promptやlinerがあります。
また、コンソール上の表示を助けるツールとして色を付けたり、その行のまま表示を変えるプログレスバー的な表示をするライブラリがあります。
どれを選択すべきか？ 2020年5月現在で端末全体を使用するアプリケーションを開発するなら、tview が第一候補だと思います。tviewが作ろうとしているアプリに当てはまるかを考えて、足りない機能は、tcellを使用して自分で実装できないか考えます。
それでも難しいようであればtermbox-goを検討するのが良いでしょう。
tviewは豊富なデモの実装例があり、また多く使われているので、それらを見れば使い方は分かっていくと思います。
tcellによる低レベルな実装 ということで、tviewの使い方は他に任せて、tcellの解説をします。tviewを使う場合もその下層について理解するのは有用だと思います。
個人的にtcellの一番大事な機能だと思うのはSetContentです。 SetContent()は指定された座標に文字を描画します。
SetContent( x int, y int, mainc rune, combc []rune, style Style) 端末上の左上（0）からx,y座標を指定して、maincにrune（文字）を描画します。 低レベルなので、文字列ではなく1文字1文字を設置します。
指定するのはgoのruneなので、マルチバイトであっても1文字として指定できます。
ただgoのruneは符号化単位なので、Unicodeの結合文字は別文字扱いになります。その結合文字をcombcのrune配列に追加して表現できます。
そして、styleには、文字色、背景色、反転等のスタイルをtcellの値で渡します。
SetContent()を使って端末画面分埋めれば自由に描画ができるわけです。</description></item><item><title>ov v0.1.3</title><link>https://noborus.github.io/blog/ov_013/</link><pubDate>Mon, 11 May 2020 10:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/ov_013/</guid><description>ov v0.1.3をリリースしました。 releases ov v0.1.3
行番号モードを追加しました -nオプションをつけての起動又はGキー（トグル）により行番号モードになります。
交互の背景色の仕様を少し変更しました 交互の背景色を付けるモードでは、画面の端から端まで色を付けるように変更しました。 これにより空行でも背景色が表示されます。
ステータスの行数を自動更新するようにしました ステータス右側の (0/177) の（177）が行数ですが、行数が多いと起動時に全行を読み取れていないので、「&amp;hellip;」と読み取り中の表示がついていました。何らかの操作をした時に、その時点の読み取られた行数を更新していましたが、タイマーでも更新するように変更しました。
過去のバージョン v0.1.2　Homebrewパッケージの追加 v0.1.1　パッケージ自動更新の調整 v0.1.0　ovにレポジトリ名と構成を変更。deb/rpmパッケージの追加 v0.0.5　現在の基本機能を備えた最初のバージョン 参考 ov - Oviewerの紹介</description></item><item><title>ov</title><link>https://noborus.github.io/blog/oviewer/</link><pubDate>Tue, 21 Apr 2020 14:50:00 +0900</pubDate><guid>https://noborus.github.io/blog/oviewer/</guid><description>私が作成中のovの紹介です。
最初Oviewerというレポジトリ名でしたが、コマンド名に合わせるようにovに変更しました。
インストール ov のリリースからバイナリもダウンロードできますが、今はまだgo getで最新をダウンロードして使うことをオススメします。
※ 2020/5/11追記。現在は各種パッケージも用意していますので、インストールしやすい方法利用してください。
go get -u github.com/noborus/ov cd ov make install 特徴 lessやmoreのようなTerminal pagerです。
圧縮（gzip, bzip2, zstd, lz4, xz）されているファイルをそのまま表示可能 より良いUnicodeのサポート。ターミナルで表示できる（フォントがあれば）結合文字も表示可能 より良いワイド幅（全角文字）の対応 ヘッダーの行数を指定して固定可能 行の折り返し／折り返さないを表示後に切替可能 1行毎に背景色を付けることが可能 psqlやmysqlからの表示を考慮 終了時に現在の画面の内容を書き出すことが可能 環境変数PAGERに設定して使用しても問題なく使えることを目指しています。
現在はUTF-8のテキストを対象にしています。
また、manのpagerとしては、問題があるので、MANPAGERは別途指定する必要があります。
※ 2020/5/25 追記 v0.2.0からMANPAGERとしても使用できるようになりました。
実装の特徴 tcellを使用していて、比較的多くの端末に対応しています。 メモリに溜め込む実装なので、メモリは多く使用します。更新されるログファイルの監視的な用途には向きません。
使用方法 コマンド名は ov です。
基本的にはファイル名を指定して起動します。
ov filename 又はパイプを使用して標準入力からの入力を受け付けます。
cat filename|ov オプションは以下です。オプションの多くは、起動後にキーより切り替え可能です。
$ ov --help ov is a feature rich pager(such as more/less). It supports various compressed files(gzip, bzip2, zstd, lz4, and xz).</description></item><item><title>GoのTUIで表示が崩れる場合</title><link>https://noborus.github.io/blog/runewidth/</link><pubDate>Mon, 06 Apr 2020 16:10:00 +0900</pubDate><guid>https://noborus.github.io/blog/runewidth/</guid><description>結論 gnome-terminalを使用している場合は、設定の「曖昧幅の文字(W)」と環境変数RUNEWIDTH_EASTASIANを一致させよう。
Ambiguous width(曖昧幅) ターミナル上のアプリケーション(TUI)では、GUIと違って文字単位で描画されます。 そして1文字の幅は固定されていて、アルファベットは1文字分とすると日本語などは2文字分使用する、いわゆる半角全角の世界です。 ただし、既にUnicode(UTF-8)が標準となっているので、バイト数と文字幅は関係しないようになっています。
Unicodeでは幅が決まっている文字がほとんどですが、一部に「Ambiguous; 曖昧」とされている文字があります。
以前は英語圏のアプリケーションではASCIIの範囲内のみを使用していて「Ambiguous」な範囲の文字を使用するのは、それ以外の地域の人だったため、全角幅で問題になることは無かったのですが、Unicodeの使用が拡大するにつれて英語圏の方が作るアプリケーションでも「Ambiguous」な幅の文字が使用されることが増えてきました。
特にTUIアプリケーションでは、罫線「┌ ├ ─ ┘等」を使用して枠線を表現することがあります。これが「Ambiguous」な幅として、英語圏では1文字幅で表示できる様になっているため、2文字幅と解釈して表示しようとすると表示が崩れてしまいます。
ターミナル上で罫線を使用したプログラムがズレる場合はこれが原因です。
そのための対応として、gnome-terminalではPreferencesから「曖昧幅の文字(W)」を半角／全角で変更出来るようになっています。
これを半角にすれば、罫線が1文字幅で表示されるため、表示が直ります。
例えば、psqlの \pset linestyle unicodeをgnome-terminalで使用するには、ここを半角にしておかないと縦の線が揃わなくなります。
ただし、これはアプリケーションが幅を半角幅と仮定しているのに合わせているだけなので、別のアプリケーションでは合わなくなるといったことが起こります。
go-runewidth のAmbiguous width go言語では、１文字がターミナルで半角なのか全角なのかを判断するには、go-runewidthで判断するのがデファクトスタンダードになっていると思います。
go-runewidthでは、ロケールに従ってAmbiguousな幅を決定していて日本語を使用している場合(ja_JP.UTF-8等)は、全角（2文字幅）になります。
この場合、上記のgnome-terminalで「曖昧幅の文字(W)」を半角にしていた場合は、余分な隙間が空いて表示が崩れたようになります。 LANG=Cでアプリケーションを起動し直してみて表示が正常になる場合は、この「曖昧幅の文字(W)」とgo-runewidthが解釈するロケールに齟齬が起こっていることになります。
go-runewideth ではロケールの他に環境変数RUNEWIDTH_EASTASIANによりAmbiguousな幅を変更できますので、gnome-terminalではPreferencesの「曖昧幅の文字(W)」が半角の場合は、環境変数RUNEWIDTH_EASTASIANを0に全角の場合は1に設定しておくとgo言語のTUIアプリケーションの表示の乱れが無くなるのでは無いかと思います。</description></item><item><title>trdsql 0.7.5</title><link>https://noborus.github.io/blog/trdsql_075/</link><pubDate>Sat, 07 Mar 2020 10:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/trdsql_075/</guid><description>trdsql 0.7.5をリリースしました。 リリースのページから各バイナリがダウンロードできます。
圧縮ファイルへの対応を強化 trdsql 圧縮ファイルに書いたように圧縮ファイルのサポートを増やしました。
また、圧縮しての出力をできるようにしました。
ファイルへの出力 trdsql outputに書いたように出力ファイルを指定して出力できるようになりました。
出力ファイル名から出力フォーマットと圧縮フォーマットを推測するのがデフォルトの動作になっています。
オプションが増加したため、-helpメッセージの出力を見直しました。 以下のようになります。
trdsql - Execute SQL queries on CSV, LTSV, JSON and TBLN. Usage: trdsql [OPTIONS] [SQL(SELECT...)] Options: -A string analyze the file but only suggest SQL. -a string analyze the file and suggest SQL. -config string configuration file location. -db string specify db name of the setting. -dblist display db information. -debug debug print. -driver string database driver. [ mysql | postgres | sqlite3 ] -dsn string database driver specific data source name.</description></item><item><title>trdsql output</title><link>https://noborus.github.io/blog/34_output/</link><pubDate>Mon, 02 Mar 2020 18:45:00 +0900</pubDate><guid>https://noborus.github.io/blog/34_output/</guid><description>今までは標準出力にのみ出力していましたが、-out ファイル名により、出力ファイルを指定できるようにしました。
-out ファイル名では出力ファイル名からファイル形式、圧縮形式を推測するモードをデフォルトで有効にしてあります。
出力ファイル名の拡張子が[.csv,.ltsv,json,jsonl,tbln,md,at,vf,raw]等の出力ファイル形式の拡張子だった場合は自動でその出力形式で出力します。
以下はLTSV形式で出力します。
trdsql -out test.ltsv &amp;#34;SELECT * FROM testdata/test.csv&amp;#34; 出力フォーマットを指定した場合は、出力フォーマットが優先されます。以下はjsonl形式で出力されます。
trdsql -ojsonl -out test.txt &amp;#34;SELECT * FROM testdata/test.csv&amp;#34; 圧縮形式も推測するので、test.csv.gzのようにした場合はCSV形式のgzip圧縮で出力されます。基本的ファイルの拡張子はファイル形式.圧縮形式の順です。
以下はLTSV形式でzstd圧縮で出力されます。
trdsql -out test.ltsv.zst &amp;#34;SELECT * FROM testdata/test.csv&amp;#34; 圧縮フォーマットも-oz 圧縮形式で指定した場合はそちらが優先されます。
例えば、.zstの拡張子を付けたいが圧縮してほしくない（理由はわかりませんが&amp;hellip;)の場合は、-out-without-guessを付けて実行して下さい。</description></item><item><title>trdsql 圧縮ファイル</title><link>https://noborus.github.io/blog/33_compression/</link><pubDate>Mon, 02 Mar 2020 17:52:00 +0900</pubDate><guid>https://noborus.github.io/blog/33_compression/</guid><description>圧縮ファイルに実行 0.7.4までは gzip(.gz)の圧縮形式のみの対応でしたが、最新のmaster(0.7.5以降の予定)では、gzip(gz)、bzip2(bz2)、zstd(zst)、lz4、xzの圧縮形式に対応しました。
従来は.gzの拡張子をみて判断していましたが、今回から圧縮形式のファイルの先頭のマジックナンバー（signatureの値）を見て判断するようになりました。そのため、拡張子が何であっても上記の圧縮形式はそのまま読み取ることが出来ます。
圧縮率にもよりますが、デフォルトレベルのzstdでの圧縮されたファイルをtrdsqlで処理すると、手元のマシンでの処理時間はほぼ変わらないか、少しzstdで圧縮されているファイルのほうが早いくらいです。
例えば以下のような145MBのファイルに対してzstdで圧縮すると44MBになりました。
145M worldcitiespop.csv 44M worldcitiespop.csv.zst timeを付けての結果は以下のようになりました。
/usr/bin/time -p trdsql -ih &amp;quot;SELECT count(*) FROM worldcitiespop.csv&amp;quot; real 11.47 user 11.76 sys 0.70 zstd圧縮
/usr/bin/time -p trdsql -ih &amp;quot;SELECT count(*) FROM worldcitiespop.csv.zst&amp;quot; real 9.76 user 11.00 sys 0.37 LTSVファイルでは、同じ内容のCSVファイルよりもファイルサイズが大きくなりますが、圧縮効率は良いので圧縮したときのファイルサイズの差は小さくなります。
330M worldcitiespop.ltsv 54M worldcitiespop.ltsv.zst 145MBをLTSVにすると330MBのファイルになっていたのが、圧縮するとCSV:44MB、LTSV:54MBになります。
処理時間は以下のようになりました。
/usr/bin/time -p trdsql &amp;quot;SELECT count(*) FROM worldcitiespop.ltsv real 16.72 user 17.41 sys 1.05 /usr/bin/time -p trdsql &amp;quot;SELECT count(*) FROM worldcitiespop.</description></item><item><title>MySQL の LOAD DATA INFILE (go)</title><link>https://noborus.github.io/blog/mysql-load/</link><pubDate>Mon, 10 Feb 2020 15:09:00 +0900</pubDate><guid>https://noborus.github.io/blog/mysql-load/</guid><description>前提 LOAD DATA INFILEはMySQLサーバーがファイルを読み取ってデータベースのテーブルにインポートする構文ですが、LOAD DATA LOCAL INFILEはクライアント側のファイル（の内容）をサーバー側に送信してインポートします。
このLOCAL指定ですが、セキュリティ上の問題を抱えているため、最近のバージョンだとデフォルトで使用できない設定に変更されたりしています。
そもそも LOAD DATA LOCAL INFILE の仕組みは、MySQLのLOAD DATA構文を（クライアント側ではパースして解釈しないので）サーバー側に送ってLOCAL INFILEの場合ファイル名をクライアントに伝えて、クライアントがそのファイル（の中身）をサーバー側に送信するようになっています。
サーバー側からLOAD DATA LOCAL INFILEに書いてあったファイル名とは違うファイル名を伝えられてもそのファイルを送信してしまう可能性があるため、セキュリティのリスクがあります。
LOAD DATA LOCAL INFILE(go) goのmysqlドライバでは、LOAD DATA LOCAL INFILE supportにあるように mysql.RegisterLocalFile(filepath)やmysql.RegisterReaderHandler(name, handler)という関数が追加されていてセキュリティ上の問題を解決するような拡張がされています。
mysql.RegisterLocalFile(filepath)は、LOAD DATA LOCAL INFILEを実行する前にあらかじめ送信するファイル名を登録しておいて、登録してあるファイルのみを送信することでリスクを軽減しています。
mysql.RegisterLocalFile(&amp;quot;/tmp/test.csv&amp;quot;) db.Exec(&amp;quot;LOAD DATA LOCAL INFILE '/tmp/test.csv' INTO TABLE test&amp;quot;) また、mysql.RegisterReaderHandler(name, handler)では、あらかじめクライアントプログラム側がファイルを開く等してできたio.Readerインターフェイスを&amp;lt;name&amp;gt;と共に登録しておき、LOAD DATA LOCAL INFILE 'Reader::\&amp;lt;name\&amp;gt;' INTO TABLE テーブル名 によりio.ReaderからReadしてサーバー側に送信します。
mysql.RegisterReaderHandler(&amp;quot;test&amp;quot;, func() io.Reader { file, err = os.Open(&amp;quot;/tmp/test.csv&amp;quot;) if err != nil { return nil } return file }) db.</description></item><item><title>trdsql 0.7.4</title><link>https://noborus.github.io/blog/trdsql_074/</link><pubDate>Wed, 05 Feb 2020 10:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/trdsql_074/</guid><description>trdsql 0.7.4をリリースしました。 リリースのページから各バイナリがダウンロードできます。
全ての項目を二重引用符（”）で囲うオプション(-oaq)を追加 今回は、CSV出力に全ての項目を二重引用符（”）で囲うオプション(-oaq)を追加しました。
goのencoding/csvはRFC 4180に沿って実装されていますが、必要な項目を二重引用符（”）で囲うようになっていますが、全ての項目を囲う方法は用意されていません。要望はありましたが、却下されています。
trdsqlにも要望が以前より来ていましたが、encoding/csvが対応していないので、対応出来ないとして、カスタマイズする方法を提示していました。 今回別の方からも要望が来たので、実装しました。
encoding/csvでは対応出来ないので、別の方法で実装する必要がありますが、定番と言えるモジュールは無く実装自体は難しくないので、自前で実装することにしました。と言ってもencoding/csvのコードから少し変更しているだけです。
その際に、関連する箇所を見直して、全体の出力が速くなるように改善しました。多くの出力をする場合でないと違いは出ませんが、手元では317万行(145MB)あるファイルを &amp;quot;SELECT * FROM 〜&amp;quot;で出力してみたら、全体で10%ほど高速化していました。
またその他に、二重引用符（”）以外の引用符が使用できる(-oq)と改行文字をCRLFに変更する(-ocrlf)を追加しました。 CRLFはRFC 4180にあり、encoding/csvでも対応していたのですが、入れそびれていたので今回入れました。 引用符は変更してしまうとtrdsqlで読めないCSVになってしまうので注意が必要です。普通は使わないと思うのでかなり特殊用途だと思います。
GitHub Actions でのバイナリ作成に変更 これまで travis-ciでリリース時にビルドしてアップロードしていましたが、GitHub Actionsに変更しました。 途中まではtravis-ciと同様に各環境でビルドしてアップロードしていましたが、crazy-max/xgo(https://github.com/karalabe/xgoのfork版ですが、こちらでないとまだ問題がありました)で、クロスビルドが出来たので、こちらでビルドしてアップロードしています。
crazy-max/ghaction-xgoを使用した場合は、ビルドからアップロードまで簡単に出来るようになっていますが、zipでアーカイブしてアップロードしたかったため、Makefileでビルドまでおこないアップロードをおこなっています。
対応環境数が大幅に増えたため、ワイルドカードでファイルが指定できるAButler/upload-release-assetsを使用してアップロードしています。
armやmipsは環境が無いので自分では動かして試して見ることが出来ません。問題がありましたらお知らせ下さい。</description></item><item><title>trdsql CASE式</title><link>https://noborus.github.io/blog/32_case/</link><pubDate>Tue, 07 Jan 2020 10:18:00 +0900</pubDate><guid>https://noborus.github.io/blog/32_case/</guid><description>CASE式は、プログラム言語のif文やswitch文のような条件に分岐した処理をおこないます。単純な1を&amp;rsquo;A&amp;rsquo;に変換するような場合は、一時的なテーブルとJOINさせたり文字列の書き換えで可能ですが、 範囲を指定してグループ化したい場合はCASE式を使うと便利です。
CASE式には以下の2つのパターンどちらも使用できます。
CASEは CASE 式（列) WHEN 値 THEN 結果とCASEの後に式を書いて、WHENが値だけのパターンと CASE WHEN 式 THEN 結果 とCASEの式を省略してWHENに式を書くパターン 必要であれば、ELSE 結果で当てはまらない場合を書き、ENDで式の終わりを示します。
case.csv のようなCSVを使用して、scoreが80以上の場合は&amp;rsquo;A&amp;rsquo;、30以上の場合は、&amp;lsquo;B&amp;rsquo;、30より下の場合は、&amp;lsquo;F&amp;rsquo;と表示させてみます。
id,name,score 1,bob,89 2,alice,75 3,dave,23 trdsql -ih -oat \ &amp;quot;SELECT id,name,score, &amp;quot; \ &amp;quot; CASE WHEN CAST(score AS int) &amp;gt;= 80 THEN 'A' &amp;quot; \ &amp;quot; WHEN CAST(score AS int) &amp;gt;= 30 THEN 'B' &amp;quot; \ &amp;quot; ELSE 'F' &amp;quot; \ &amp;quot; END AS evaluation &amp;quot; \ &amp;quot; FROM case.</description></item><item><title>trdsql 合計を行に追加する</title><link>https://noborus.github.io/blog/31_rollup/</link><pubDate>Sat, 04 Jan 2020 13:38:00 +0900</pubDate><guid>https://noborus.github.io/blog/31_rollup/</guid><description>Window関数により元のファイルの内容に列を追加して、集計結果を出せました。 ただ、人が確認する場合は、集計の結果行が最後に出るほうが確認しやすくなります。
通常のSQLでも元の内容と集計結果を別々に出してUNIONを使うことで、一つの結果として出すことが出来ますが、一回で済むならばそれに越したことはありません。
SQLite3ではサポートされていませんが、PostgreSQLとMySQLならばサポートされている文があります。
ROLLUP Window関数でも使用した以下のCSVファイルを使用します。
id,class,name,score 1,A,bob,174 2,A,alice,248 3,A,carol,163 4,B,dave,289 5,B,eve,157 6,B,flank,272 通常のGROUP BYで全体の合計又は、class毎の合計が出せました。 ただし、class毎の合計と全体の合計を出すにはWindow関数を使用して別の列に出していました。
GROUP BYに ROLLUPを指定することで、両方を出力できます。
PostgreSQL PostgreSQLでは、GROUP BY 列名の代わりにGROUP BY ROLLUP(列名)を使用することで、通常のGROUP BYに加えて、全体の集計結果を出力します。
trdsql -driver &amp;quot;postgres&amp;quot; -dsn &amp;quot;dbname=trdsql_test&amp;quot; -oat -ih \ &amp;quot;SELECT class, SUM(score::int) AS score FROM score.csv GROUP BY ROLLUP(class) ORDER BY class&amp;quot; +-------+------+ | class | sum | +-------+------+ | A | 585 | | B | 718 | | | 1303 | +-------+------+ MySQL MySQLでは、GROUP BY 列名の後に WITH ROLLUPを付けると、通常のGROUP BYに加えて、全体の集計結果を出力します。</description></item><item><title>trdsql convert log</title><link>https://noborus.github.io/blog/30_convert_log/</link><pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/30_convert_log/</guid><description>既存のログをLTSVに変換する 既存のログをLTSVに変換にしてみます。
mingrammer/flog を使用するとフェイクのログが簡単に出力できるので、 これで出力されるログをLTSV形式に変換する方法を紹介します。
Apache common log 以下のコマンドにより apache_common形式のログをaccess.common.logとして保存します。
flog -f apache_common -t log -o access.common.log 内容は、以下のようになります。
92.129.44.198 - metz3917 [30/Dec/2019:17:02:27 +0900] &amp;quot;DELETE /infomediaries/e-markets HTTP/2.0&amp;quot; 500 24843 246.54.243.199 - - [30/Dec/2019:17:02:27 +0900] &amp;quot;POST /24%2f7 HTTP/1.1&amp;quot; 302 8879 9.172.27.159 - - [30/Dec/2019:17:02:27 +0900] &amp;quot;DELETE /convergence/best-of-breed HTTP/1.1&amp;quot; 203 3252 49.129.77.219 - kozey2248 [30/Dec/2019:17:02:27 +0900] &amp;quot;PUT /embrace HTTP/1.1&amp;quot; 301 2812 216.42.120.216 - - [30/Dec/2019:17:02:27 +0900] &amp;quot;HEAD /infomediaries HTTP/2.0&amp;quot; 204 12516 これを trdsqlの -id &amp;quot; &amp;quot; によりスペース区切りで解析すると c4とc5でタイムが分かれてしまいますが、それ以外は問題無さそうです。</description></item><item><title>trdsql generate_series</title><link>https://noborus.github.io/blog/29_generate_series/</link><pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/29_generate_series/</guid><description>generate_series PostgreSQLにはgenerate_series()という便利な関数があります。 これはUnixのseqコマンドと同じような働きをする関数です。またgenerate_series()は、タイムスタンプ型にも使用できる拡張があります。
使い方は簡単で「開始値」、「終了値」、「刻み値（省略可能）」を指定して実行します。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; &amp;quot;SELECT * FROM generate_series(1,10)&amp;quot; 1 2 3 4 5 6 7 8 9 10 generate_series()はテーブルを返す関数で、テーブルの代わりに使用できます。 （SELECT generate_series(1,10)と書くこともできます）。
もちろん、trdsqlでは、外部からの入力を簡単に取り入れられるので、seqコマンドで代用することもできます。
seq 1 10|trdsql &amp;quot;SELECT * FROM -&amp;quot; 1 2 3 4 5 6 7 8 9 10 seqコマンドは、引数の順序が「開始値」、「刻み値（省略可能）」「終了値」になります。 2つの値を渡すときには同じですが、刻み値を指定する場合は、順序が異なるので注意が必要です。
タイムスタンプ generate_series()では、タイムスタンプを扱えるので、2020年のカレンダーを日本語で出すと少々トリッキーですが、以下のようになります。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; \ &amp;quot;SET LC_TIME='ja_JP.UTF-8'; &amp;quot; \ &amp;quot;SELECT to_char(day,'YYYY年TMMonthDD日 (TMDay)') &amp;quot; \ &amp;quot; FROM generate_series('2020-01-1'::timestamp,'2020-12-31','1 day') as day&amp;quot; 2020年1月01日 (水曜日) 2020年1月02日 (木曜日) 2020年1月03日 (金曜日) 2020年1月04日 (土曜日) .</description></item><item><title>trdsql CROSS JOIN</title><link>https://noborus.github.io/blog/28_cross_join/</link><pubDate>Sat, 28 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/28_cross_join/</guid><description>CROSS JOINは、総当りを簡単に作り出せる方法です。
a.csv
aa ab ac b.csv
ba bb bc の２つのCSVをCROSS JOINすると 3×3で全ての組み合わせを出力できます。
trdsql &amp;quot;SELECT * FROM a.csv CROSS JOIN b.csv&amp;quot; aa,ba aa,bb aa,bc ab,ba ab,bb ab,bc ac,ba ac,bb ac,bc また一つのファイルに対して自己結合をすることもできます。 例えば、ホーム＆アウェーの総当り表を作成してみます。
cleague.csv
team 巨人 DeNA 阪神 広島 中日 ヤクルト 単純にCROSS JOINするには以下のようになります（JOIN条件は無いので書けません）。
trdsql -ih \ &amp;quot;SELECT h.team,a.team &amp;quot;\ &amp;quot; FROM cleague.csv AS h &amp;quot;\ &amp;quot; CROSS JOIN cleague.csv AS a&amp;quot; 自分のチームとは対戦出来ないので、同じチームのときをWHERE h.team != a.teamにより除外します。
trdsql -ih -omd \ &amp;quot;SELECT h.</description></item><item><title>trdsql config</title><link>https://noborus.github.io/blog/27_config/</link><pubDate>Fri, 27 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/27_config/</guid><description>trdsqlは設定ファイルが無くても動作しますが、設定ファイルによりデフォルトのデータベースのエンジンを変更できます。
configファイルの場所 -configオプションで、直接ファイルの場所を指定できます。
-configオプションを使用しないデフォルトの場所は以下です。
Linux等のWindows以外 ${HOME}/.config/trdsql/config.json Windows %APPDATA%trdsql\config.json です。多くは以下の位置になります。
C:\Users\{&amp;quot;User&amp;quot;}\AppData\Roaming\trdsql\config.json configファイルの内容 以下がサンプルです。
{ &amp;quot;db&amp;quot;: &amp;quot;pdb&amp;quot;, &amp;quot;database&amp;quot;: { &amp;quot;sdb&amp;quot;: { &amp;quot;driver&amp;quot;: &amp;quot;sqlite3&amp;quot;, &amp;quot;dsn&amp;quot;: &amp;quot;&amp;quot; }, &amp;quot;pdb&amp;quot;: { &amp;quot;driver&amp;quot;: &amp;quot;postgres&amp;quot;, &amp;quot;dsn&amp;quot;: &amp;quot;user=test dbname=test&amp;quot; }, &amp;quot;mdb&amp;quot;: { &amp;quot;driver&amp;quot;: &amp;quot;mysql&amp;quot;, &amp;quot;dsn&amp;quot;: &amp;quot;user:password@/dbname&amp;quot; } } } &amp;ldquo;database&amp;rdquo; に &amp;ldquo;名前&amp;rdquo;: {&amp;ldquo;driver&amp;rdquo;: ドライバ名(sqlite3 or postgres or mysql), &amp;ldquo;dsn&amp;rdquo;: &amp;ldquo;ドライバに沿ったDSN&amp;rdquo;} でデータベースを定義しておき、最初の &amp;ldquo;db&amp;quot;に定義した&amp;quot;名前&amp;quot;を書くとデフォルトのエンジンが変更されます。
上記では、&amp;ldquo;pdb&amp;quot;がデフォルトになり、&amp;ldquo;postgres&amp;quot;エンジンが使用されます。
デフォルトの変更だけでなく、ここで定義しておくと trdsqlのオプション -db mdb を指定することにより、簡単にmysqlドライバのエンジンに切り替えられます。
確認方法 configファイルが無くても動作するため、実際にエンジンが変更されているかわかりにくいことがあります。
trdsqlを-debugオプション付きで起動すると詳細が表示されますので、そこで確認して下さい。
設定ファイルが見つからなかった場合 trdsql -debug -db pdb &amp;quot;SELECT * FROM testdata/test.</description></item><item><title>trdsql SQLファイル指定</title><link>https://noborus.github.io/blog/26_file_sql/</link><pubDate>Thu, 26 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/26_file_sql/</guid><description>SQLファイル名指定オプション「-q」 trdsql &amp;ldquo;SQLコマンド&amp;quot;の形式だと、長いSQLを書くのが難しいですし、シェルに対してエスケープしなければならない文字があって見た目もわかりにくい場合があります。
trdsqlではファイルにSQLを書いておき、そのファイルのSQLを実行させるオプションがあります。
以下のように記述したSQLをtest.sqlで保存しておきます。
test.sql
SELECT id, `name` FROM testsql.csv （コマンドの引数で渡していたときは「\`」のように「`」をエスケープする必要がありましたが、ファイルのSQLを実行する場合は必要ありません）。
testsql.csv は対象となるCSVファイルです。
id,name 1,tarou 2,jirou &amp;ldquo;SQLコマンド&amp;rdquo; の代わりに 「-q ファイル名.sql」で実行します。それ以外のオプションは代わりません。
trdsql -ih -oat -q test.sql +----+-------+ | id | name | +----+-------+ | 1 | tarou | | 2 | jirou | +----+-------+</description></item><item><title>trdsql ライブラリ使用</title><link>https://noborus.github.io/blog/25_library/</link><pubDate>Wed, 25 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/25_library/</guid><description>trdsqlは初期の頃は、main packageで構成されていましたが、現在はtrdsql packageをmainから呼び出す構成になっていて、trdsql packageをライブラリとして使用できます。
trdsqlのパッケージは、以下の構成になっていて、それぞれ呼び出し可能です。
簡単なサンプルを示します。
package main import ( &amp;quot;log&amp;quot; &amp;quot;github.com/noborus/trdsql&amp;quot; ) func main() { trd := trdsql.NewTRDSQL( trdsql.NewImporter(trdsql.InDelimiter(&amp;quot;:&amp;quot;)), trdsql.NewExporter(trdsql.NewWriter()), ) err := trd.Exec(&amp;quot;SELECT c1 FROM /etc/passwd&amp;quot;) if err != nil { log.Fatal(err) } } 上記のプログラムは/etc/passwdに対してSQL文を実行しています。 Importer(データベースにインポートするインターフェイス）とExporter(データベースから結果を出力するインターフェイス）を与えてTRDSQLをNewし、Execで実行するのが、おおまかな流れです。
func NewTRDSQL(im Importer, ex Exporter) *TRDSQL このImporter,Exporterはインターフェイスに沿っていれば、置き換えられます（例えば、SQL内のファイルをインポートするのではなく、独自にインポートするにはImporterのインターフェイスに沿った関数を作成します）。
Importer デフォルトのImporterは、trdsql.NewImporter()を呼び出せば作成できます。 デフォルトのImporterはtrdsql.Import()でReadOptsのオプションを取ります。ここでフォーマットやその他オプションを渡します。
SQL文にある「/etc/passwd」をデータベースにインポートして使用するのは、デフォルトの動作のため、区切り文字のみ「:」に変更しています。
trdsql.Import()はSQL文を受け取り、必要なファイルをデータベースにインポートします。そのときにファイルの形式に合わせたtrdsql.Readerインターフェイス（各CSV,LTSV,JSON,TBLNのReader)からテーブルへインポートされます。
また、インポートするデータベースによってバルクインサートかCOPYによるインポートを選択してインポートしています。
Exporter デフォルトのExporterは、trdsql.NewExporter()を呼び出せば作成できます。 SQLでは出力は1つなので、出力する関数（trdsql.NewWriter()）を渡しています。 trdsql.NewWriter()はWriteOptsによりフォーマットと動作のオプションを設定して、実際のWriter関数（CSV、LTSV、JSON、TBLN、AT、VF&amp;hellip;)によりSQLを実行した結果を書き出します。
Exec ImporterとExporterの準備が済んでいれば、ExecでSQLを実際に実行します。
データベース接続 トランザクションの開始 Importerでインポートの実行 Exporterで指定したSQLの実行をして出力 トランザクションの終了 データベース切断 参考資料 trdsqlには、参考してファイルからのインポートだけでなく、スライスからインポートする関数が入っています。 それを利用したサンプルが _example/slice/ にあります。</description></item><item><title>trdsql グラフ</title><link>https://noborus.github.io/blog/24_graph/</link><pubDate>Tue, 24 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/24_graph/</guid><description>trdsqlは、グラフ作成機能は持っていないためグラフを作成したいときには別のツールを使用して作成することになります。
ExcelやLibreOfficeで描画するのが定番でしょうが、ここではmarianogappa/chartでグラフを描画する方法を紹介します。
marianogappa/chartは、Goで作られていて、や多くのプラットフォームで動作して、標準入力から受け取ったデータをブラウザに描画します。
複雑なグラフには向いていませんが、簡単なグラフを少ないオプションを指定するだけで描画できます。
chartに与えるデータは表示したいグラフによりますが、1列又は2列のデータです。
例えばchartのデフォルトのpieでは、以下のような文字列が並んでいるようなデータを集計して円グラフにしてくれます。
aaa bbb ccc aaa aaa aaa cat aaa.csv|chart （ブラウザが開いて表示されます）
これを使用して例えば、ログ集計で使用したログのリクエストをグラフにすると以下のようになります。
trdsql &amp;quot;SELECT req FROM log.ltsv&amp;quot;|chart また、他のグラフでは、1列目がx項目名で、2列目が値として与えます。デフォルトはタブ区切りのデータを受け取るので、タブ区切りで出力します。
ログ集計のリクエストが多い順をTOP 20に変えて出力すると以下のようになります。
trdsql -od &amp;quot;\t&amp;quot; \ &amp;quot;SELECT req, count(req) as count &amp;quot; \ &amp;quot;FROM log.ltsv &amp;quot; \ &amp;quot;GROUP BY req &amp;quot; \ &amp;quot;ORDER BY count DESC LIMIT 20&amp;quot; |chart bar marianogappa/chartは、Chart.jsを使用してグラフを描画しています。Chart.js自体が簡単なJavaScriptを用意すれば描画してくれるので、もう少し複雑なグラフを描きたい場合は直接利用するのが良いでしょう。</description></item><item><title>trdsql 差分、比較</title><link>https://noborus.github.io/blog/23_except/</link><pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/23_except/</guid><description>CSV同士やCSVとテーブルなどで、値の比較をしたい場合があります。
同じ形式で一部が違うCSVファイルであれば、diffを取る方法もありますが、trdsqlのSQLを使用して比較すると形式が違う場合の比較にも使用できます。
差分の出力 SQLで比較して、差分を出すには、EXCEPTを使用します。EXCEPTは Aのテーブルから Bのテーブルを引いた残りのAの内容を出力します。
Bの方に多くの行があっても関係なく、AにあってBにない行を出力します。
以下のCSVファイルで比較してみます。new.csvで、3の更新と4の追加があるCSVファイルです。
old.csv
1,AAA 2,BBB 3,CCC new.csv
1,AAA 2,BBB 3,CCB 4,DDD 単純に全列を比較すると1と2の行が同じであるため、消されて残った3と4が出力されます。 この場合old.csv側にnew.csvにない行があっても出力されません。diffの比較とは違いますね。
trdsql &amp;quot;SELECT * FROM new.csv EXCEPT SELECT * FROM old.csv &amp;quot; 3,CCB 4,DDD テーブルとファイルの差分出力 既存のデータベースに接続すれば、テーブルとの比較もできます。
例えば、trdsql DBインポートでインポートしたテーブルと更新されたCSVとの比較をしたいときには、以下のようにすると良いでしょう。
CSVファイル側をキャストして型を合わせています。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; -ih -oh \ &amp;quot;SELECT id::int,name FROM fruits.csv &amp;quot; \ &amp;quot;EXCEPT &amp;quot; \ &amp;quot;SELECT id,name FROM fruits &amp;quot; id,name 4,Grape データベース側のテーブルが更新されて新しい場合は、逆にテーブル EXCEPT CSVファイルとすれば、良いでしょう。
共通の行の出力 また、EXCEPTとは逆に共通の行を出力させたいときには、INTERSECT を使用します。</description></item><item><title>trdsql JSON出力</title><link>https://noborus.github.io/blog/22_json_output/</link><pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/22_json_output/</guid><description>CSVやLTSVなどのフラットな形式のデータは、JSONにしたいときには（-ojsonによる）JSON出力をすれば良いですが、JSONは本来より深い階層も表現できるフォーマットです。
そのようなJSONは、データベースのJSON関数を使用することにより作成できます。
以下のCSVからJSON関数でJSON出力をしてみます。
id,name 1,Orange 2,Melon 3,Apple JSON関数で出力する場合は、「”」等がエスケープされない-orawを使用して出力すると、有効なJSONとして出力できます。
SQLite3、MySQL SQLite3、MySQLでは、json_array()やjson_object()を使用することによりJSONを生成できます。 ここでは「名前:値」の形式で出力するためjson_objectを使用します。2つペアの引数で、指定していきます。
trdsql -ih -oraw &amp;#34;SELECT json_object(&amp;#39;id&amp;#39;,id,&amp;#39;name&amp;#39;,name) FROM header.csv&amp;#34; {&amp;quot;id&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;Orange&amp;quot;} {&amp;quot;id&amp;quot;:&amp;quot;2&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;Melon&amp;quot;} {&amp;quot;id&amp;quot;:&amp;quot;3&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;Apple&amp;quot;} 階層を深くするには、json_object()を内部でさらに使います。 SQLite3にはjson_pretty()関数が無いので、jqで見やすくしています。
trdsql -ih -oraw &amp;#34;SELECT json_object(&amp;#39;fruits&amp;#39;, json_object(&amp;#39;id&amp;#39;,id,&amp;#39;name&amp;#39;,name)) FROM header.csv&amp;#34;|jq . { &amp;quot;fruits&amp;quot;: { &amp;quot;id&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Orange&amp;quot; } } { &amp;quot;fruits&amp;quot;: { &amp;quot;id&amp;quot;: &amp;quot;2&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Melon&amp;quot; } } { &amp;quot;fruits&amp;quot;: { &amp;quot;id&amp;quot;: &amp;quot;3&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Apple&amp;quot; } } 上記の結果は1行1JSONで出力されています。これをさらに配列にして、一つのJSONにするには、SQLite3では json_group_array()、MySQLではjson_arrayagg()でグループ化して出力できます。
SQLite3 trdsql -ih -oraw &amp;#34;SELECT json_group_array(json_object(&amp;#39;fruits&amp;#39;, json_object(&amp;#39;id&amp;#39;,id,&amp;#39;name&amp;#39;,name))) FROM header.</description></item><item><title>trdsql JSON解析</title><link>https://noborus.github.io/blog/21_json_parse/</link><pubDate>Sat, 21 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/21_json_parse/</guid><description>これまでtrdsqlでは、JSONの入力が可能と書きましたが、例として書いたのは基本的にフラットな構造のJSONでした。 ただ、２階層以上の階層構造が含まれるJSONはエラーになる訳ではなく、そのまま文字列として扱われます。
以下のようなJSONがあるとします。
sample.json
[ { &amp;quot;color&amp;quot;: &amp;quot;white&amp;quot;, &amp;quot;category&amp;quot;: &amp;quot;value&amp;quot;, &amp;quot;code&amp;quot;: { &amp;quot;rgba&amp;quot;: [0, 0, 0, 1], &amp;quot;hex&amp;quot;: &amp;quot;#FFF&amp;quot; } }, { &amp;quot;color&amp;quot;: &amp;quot;red&amp;quot;, &amp;quot;category&amp;quot;: &amp;quot;hue&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;primary&amp;quot;, &amp;quot;code&amp;quot;: { &amp;quot;rgba&amp;quot;: [255, 0, 0, 1], &amp;quot;hex&amp;quot;: &amp;quot;#FF0&amp;quot; } }, { &amp;quot;color&amp;quot;: &amp;quot;blue&amp;quot;, &amp;quot;category&amp;quot;: &amp;quot;hue&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;primary&amp;quot;, &amp;quot;code&amp;quot;: { &amp;quot;rgba&amp;quot;: [0, 0, 255, 1], &amp;quot;hex&amp;quot;: &amp;quot;#00F&amp;quot; } } ] これをそのままtrdsqlを実行すると以下のようになります(見やすいように-oatを付けています。CSV出力にすると「&amp;quot;」が含まれる文字列のためエスケープされて出力されます。)
trdsql -oat &amp;#34;SELECT color,category,code FROM sample.json&amp;#34; +-------+----------+-----------------------------------+ | color | category | code | +-------+----------+-----------------------------------+ | white | value | {&amp;quot;hex&amp;quot;:&amp;quot;#FFF&amp;quot;,&amp;quot;rgba&amp;quot;:[0,0,0,1]} | | red | hue | {&amp;quot;hex&amp;quot;:&amp;quot;#FF0&amp;quot;,&amp;quot;rgba&amp;quot;:[255,0,0,1]} | | blue | hue | {&amp;quot;hex&amp;quot;:&amp;quot;#00F&amp;quot;,&amp;quot;rgba&amp;quot;:[0,0,255,1]} | +-------+----------+-----------------------------------+ このcodeは文字列の扱いですが、各データベースは既にJSONを扱える関数を備えているため、データベース側の関数を使って変更できます。</description></item><item><title>trdsql 日付・時刻処理</title><link>https://noborus.github.io/blog/20_date/</link><pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/20_date/</guid><description>ファイル内に入っている日付、時刻をそのまま扱う場合は良いですが、変換等の処理をしたい場合があります。
その場合は、一旦日付や時刻と解釈させてから扱う方が扱いやすくなります。
SQLite3の日付、時刻処理 デフォルトのSQLite3の日付、時刻処理では、以下のフォーマットであれば、日付、時刻として解釈することができます。 もしSQLite3のエンジンで処理したい場合は、このフォーマットにしておくと良いでしょう。
YYYY-MM-DD YYYY-MM-DD HH:MM YYYY-MM-DD HH:MM:SS YYYY-MM-DD HH:MM:SS.SSS YYYY-MM-DDTHH:MM YYYY-MM-DDTHH:MM:SS YYYY-MM-DDTHH:MM:SS.SSS HH:MM HH:MM:SS HH:MM:SS.SSS now DDDDDDDDDD 以下のようなログファイルのtimeを処理したい場合、
time:2015-09-06T05:58:05+09:00 method:POST ... time:2015-09-06T05:58:41+09:00 method:POST ... time:2015-09-06T06:00:42+09:00 method:GET ... datetime(time)で日時として、認識させれば、strftime()で再フォーマットがしやすくなります。
trdsql -iltsv &amp;#34;SELECT strftime(&amp;#39;%Y年%m月%d日%H時%M分%S秒&amp;#39;,datetime(time)) FROM log.ltsv&amp;#34; 2015年09月05日20時58分05秒 2015年09月05日20時58分41秒 2015年09月05日21時00分42秒 上記以外のフォーマットの場合は、SQLite3では文字列をまず書き換える必要があります。
PostgreSQLの日付、時刻処理 PostgreSQLの日付、時刻処理は、より豊富なフォーマットを処理できます。
多くの場合は、dateやtimestampにCASTするだけで、多くの有名なフォーマットは解釈されます。
trdsql -driver postgres -dsn &amp;#34;dbname=trdsql_test&amp;#34; &amp;#34;SELECT to_char(CAST(time AS timestamp),&amp;#39;YYYY年MM月dd日HH24時MI分ss秒&amp;#39;) FROM log.ltsv&amp;#34; 2015年09月06日05時58分05秒 2015年09月06日05時58分41秒 2015年09月06日06時00分42秒 日付、時刻型に変換されるので、そこから表示するフォーマットに変換するにはto_char()を使用します。指定の仕方はマニュアルを参照して下さい。
さらに独特なフォーマットの場合は、 to_dateやto_timestampにより自分で定義したフォーマットで解釈させることが出来ます。
例えば上記で出力したフォーマットの場合、to_charと同じフォーマット指定でto_timestampを実行すれば逆にタイムスタンプとして扱われます。
trdsql -ih -oh -driver postgres -dsn &amp;#34;dbname=trdsql_test&amp;#34; &amp;#34;SELECT to_timestamp(\&amp;#34;日時\&amp;#34;,&amp;#39;YYYY年MM月dd日HH24時MI分ss秒&amp;#39;) FROM d.</description></item><item><title>trdsql Window関数</title><link>https://noborus.github.io/blog/19_window/</link><pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/19_window/</guid><description>これまでグループ集計による集計を紹介していますが、グループ集計は元の行とはまったく別にグループ毎の行を出力していました。 つまり、元のファイルとは別に集計の結果を出力していた訳です。
そうではなくて、元のファイルの情報にプラスして集計結果を出して欲しい場合があります。 例えば、点数の列では、点数の平均との差を出力したり、柔軟な計算が出来るようになります。これまでの方法では、一旦集計してからJOINするしかありませんでしたが、SQLのWindow関数を使うとそういった集計も出すことが出来ます。
古いバージョンではSQLite3では、Window関数を使用できませんでしたが、現在のtrdsqlに含まれているSQLite3では、Window関数を使用できます。
PostgreSQLやMySQLでもWindow関数が使用できますが、MySQLは8.0からなので、注意が必要です。
合計の表示 合計の計算は集計計算で出しましたが、最後の結果のみを出力していました。 Window関数では、行毎に結果を表示できます。
例えば、以下のような点数のCSVについて結果を表示してみます。
id,class,name,score 1,A,bob,174 2,A,alice,248 3,A,carol,163 4,B,dave,289 5,B,eve,157 6,B,flank,272 Window関数は集約関数の関数にOVER ()句を付けることにより範囲や、順序を指定することにより計算をおこないます。 OVER ()句があることで、他の列とは独立して対象の行以外を計算できます。
OVER()句を空で指定すると全行が対象となります。
trdsql -ih -omd \ &amp;quot;SELECT id,name,score, SUM(CAST(score AS int)) OVER () FROM score.csv&amp;quot; | id | name | score | sum | |----|-------|-------|------| | 1 | bob | 174 | 1303 | | 2 | alice | 248 | 1303 | | 3 | carol | 163 | 1303 | | 4 | dave | 289 | 1303 | | 5 | eve | 157 | 1303 | | 6 | flank | 272 | 1303 | SUM()で合計が求められるので、AVG()で平均も求められます。</description></item><item><title>trdsql 列の編集</title><link>https://noborus.github.io/blog/18_edit_columns/</link><pubDate>Wed, 18 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/18_edit_columns/</guid><description>これまで列の並べ替えはしてきましたが、列の内容はそのままでした。 SQLでは、文字列の書き換えが得意分野とは言えませんが、SQLの関数を使うことにより、それなりできる機能は揃っています。
列の連結 「||」を使って、列名をつなげば、２つ以上の列を連結して一つの列になります。
trdsql -ih -oh \ &amp;quot;SELECT id,name||id AS name_id FROM header.csv&amp;quot; id,name_id 1,Orange1 2,Melon2 3,Apple3 列と列だけでなく、文字列をそのまま連結も可能です。SQLの文字列は「&amp;rsquo;」シングルクオートで括ります。
trdsql -ih -oh \ &amp;quot;SELECT id,name||'_'||id AS name_id FROM header.csv&amp;quot; id,name_id 1,Orange_1 2,Melon_2 3,Apple_3 PostgreSQL、MySQL またPostgreSQLとMySQLでは、複数の列をつなげたいときには concat(列名or文字列,列名or文字列,&amp;hellip;) が使用できます。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; -ih -oh \ &amp;quot;SELECT concat(id,name,'個') FROM header.csv&amp;quot; concat 1Orange個 2Melon個 3Apple個 接続文字を付けてつなげたい場合は、concat_ws(接続文字,列名or文字列,列名or文字列,&amp;hellip;)が使用できます。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; -ih -oh \ &amp;quot;SELECT concat_ws(' ',id,name,'個') FROM header.csv&amp;quot; concat_ws 1 Orange 個 2 Melon 個 3 Apple 個 SQLite3 SQLite3では、concat,concat_wsはありませんが、printfが使用できますので、より柔軟に文字列を生成できます。</description></item><item><title>trdsql ファイルとテーブルのJOIN</title><link>https://noborus.github.io/blog/17_file_table/</link><pubDate>Tue, 17 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/17_file_table/</guid><description>既にテーブルが存在するデータベースに接続することにより、ファイルとテーブルをJOINすることもできます。
例えば、データベース内にfruitsというテーブルがあった場合に、前回のabc.csvとJOINできます。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; \ &amp;quot;SELECT a.c1, a.c2, f.name FROM abc.csv AS a &amp;quot;\ &amp;quot;LEFT JOIN fruits AS f ON (CAST(a.c1 AS int) = f.id)&amp;quot; 1,AAA,Orange 2,BBB,Melon 3,CCC,Apple 例えば、データベース上にusersテーブルがあり、抽出したいリストがCSVファイルであった場合に、リストをWHERE user IN (...)で並べる等を検討するところですが、trdsqlではダイレクトにJOINして抽出できます。
list.csv
tarou jirou noborus usersテーブル
id,name 1,taizou 2,momo 3,tarou trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; \ &amp;quot;SELECT u.id, u.name FROM users AS u &amp;quot;\ &amp;quot;INNER JOIN list.csv AS l ON (u.name = l.c1)&amp;quot; 3,tarou 逆にCSVファイルにデータベースのテーブルから情報を足すといったことも考えられます。</description></item><item><title>trdsql JOIN</title><link>https://noborus.github.io/blog/16_join/</link><pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/16_join/</guid><description>これまで一つのファイルにSQLを実行してきましたが、複数のファイルをJOINするSQLも実行できます。
以下の2つのCSVファイルがあったとして、
abc.csv
1,AAA 2,BBB 3,CCC price.csv
1,100 2,500 3,50 以下のように連結するのが、JOINです。
1,AAA,100 2,BBB,500 3,CCC,50 trdsqlではテーブルの代わりにファイル名を使用すれば、そのままSQLのJOINが書けます。
trdsql &amp;quot;SELECT a.c1, a.c2, p.c2&amp;quot; \ &amp;quot;FROM abc.csv AS a&amp;quot; \ &amp;quot;LEFT JOIN price.csv AS p&amp;quot; \ &amp;quot;USING (c1)&amp;quot; 同じ件数で対応する同じ列がある1対1のJOINのため、INNER JOINと同じ結果になります。 LEFT JOINの場合は、先に指定したabc.csvの行はすべて表示され、price.csvは対応する行がある場合のみ表示されます。 今回はヘッダーがないCSVなので、列名はc1,c2&amp;hellip;の共通になるため、一番左側(c1)が共通の列としてUSINGを使用してます。これは ON a.c1 = p.c1 と同じ意味になります。
複数のCSVをJOINするときには、ヘッダーの有無を統一しておく必要があります。
しかしながら、自動判別可能な拡張子になっていれば、CSVとLTSV等の混在は可能です。
unit.ltsv
id:1 unit:個 id:2 unit:箱 先程のCSVのJOINの結果に更にLTSVをJOINします。
trdsql -oat \ &amp;quot;SELECT a.c1, a.c2, p.c2, unit&amp;quot; \ &amp;quot; FROM abc.csv AS a&amp;quot; \ &amp;quot;LEFT JOIN price.</description></item><item><title>trdsql DBインポート</title><link>https://noborus.github.io/blog/15_import/</link><pubDate>Sun, 15 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/15_import/</guid><description>trdsqlにはデータベースにインポートするオプションはありません。 しかしながら、SELECT以外のSQLの実行も可能なので、SQLによるインポートが可能です。
以下は、メモリデータベースにインポートしても終了すると消えてしまうので、メモリデータベース以外のデータベースに接続して実行します。
CREATE TABLE AS テーブルを作成してインポートするには CREATE TABLE ASを使用します。
PostgreSQL で CREATE TABLE AS まず、PostgreSQLへデータをインポートしてみます。 これまで、SELECTで実行してきた内容に CREATE TABLE テーブル名 AS を前につければ、テーブルが作成されデータがインポートされます。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; -ih \ &amp;quot;CREATE TABLE test AS SELECT * FROM header.csv&amp;quot; 成功した場合、何も表示されずに終了します。失敗した場合、エラーが表示されます。
SELECTの結果がインポートされるため、SELECT側で列名の変更、列の型指定、インポートするデータの条件指定をすれば良いことになります。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; -ih \ &amp;quot;CREATE TABLE fruits AS SELECT id::int AS num, name::VARCHAR(20) FROM header.csv&amp;quot; trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; -ih -oh\ &amp;quot;SELECT * FROM fruits&amp;quot; num,name 1,Orange 2,Melon 3,Apple もし、テーブルの作成のみを先にして、INSERTを後でおこないたい場合はWITH NO DATAを付けます。</description></item><item><title>trdsql SQLite3エンジンの使用</title><link>https://noborus.github.io/blog/14_sqlite3/</link><pubDate>Sat, 14 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/14_sqlite3/</guid><description>SQLite3への接続方法を説明します。
SQLite3に接続 そもそもtrdsqlのデフォルトはSQLite3のメモリデータベースに接続していますが、メモリデータベース以外にも接続できます。
オプションの -driver に sqlite3 を指定し、-dsn にサーバーへの接続情報を指定します。
dsnはsqlite3のデータファイル名を指定すれば、そのファイルをデータベースとして使用します。 （ファイル名の指定の仕方はfile: や file:// 等も可能です）。
あらかじめファイルが無い場合もエラーにはなりません。
trdsql -driver sqlite3 -dsn &amp;#34;test.sqlite&amp;#34; -oat &amp;#34;SELECT * FROM test&amp;#34; +----+--------+-------+ | id | name | price | +----+--------+-------+ | 1 | Orange | 50 | | 2 | Melon | 500 | | 3 | Apple | 100 | +----+--------+-------+ さらに「?」で続けて、オプションを渡すこともできます。 メモリデータベースでオプションを渡すときには 「:memory:?」の後にオプションを続けて下さい。
例えば、LIKEで大文字小文字を区別するように変更するには以下のようにします。
デフォルトではLIKEは大文字小文字が区別されない。
trdsql -driver sqlite3 -dsn &amp;#34;:memory:&amp;#34; -ih &amp;#34;SELECT * FROM header.</description></item><item><title>trdsql MySQLエンジンの使用</title><link>https://noborus.github.io/blog/13_mysql/</link><pubDate>Fri, 13 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/13_mysql/</guid><description>前回はPostgreSQL接続の話でしたが、今度はMySQLに接続して使用する方法を説明します。
MySQLに接続 MySQLに接続するには動作しているMySQLサーバーが必要です。接続できテーブルが作成できる権限があるデータベースを作成しておきます。
オプションの -driver に mysql を指定し、-dsn にサーバーへの接続情報を指定します。
MySQLのdsnは以下のような形式です。
ユーザー名:パスワード@プロトコル(ホスト名:ポート番号)/データベース名?param=value param=valueのパラメーターは多くの種類がありますので、go-sql-driverを参照して下さい。
UNIXドメインソケット ローカルホストのデフォルトのUNIXドメインソケットを使用する場合は、ユーザー名、パスワード、データベース名を指定すれば接続できます。
trdsql -driver mysql -dsn &amp;#34;noborus:noborus@/trdsql_test&amp;#34; &amp;#34;SELECT 1&amp;#34; UNIXドメインソケットのパスを指定するには、プロトコルにunixを指定して、unix(パス)で指定します。
trdsql -driver mysql -dsn &amp;#34;noborus:noborus@unix(/var/run/mysqld/mysqld.sock)/trdsql_test&amp;#34; &amp;#34;SELECT 1&amp;#34; TCP接続 TCPはプロトコルにtcpを指定して、tcp(ホスト名:ポート番号)を指定します。
trdsql -driver mysql -dsn &amp;#34;noborus:noborus@tcp(localhost:3306)/trdsql_test&amp;#34; &amp;#34;SELECT 1&amp;#34; 実テーブルの出力 接続できれば、これまでと同じようにSQLが実行できますが、実際に実行されるのはMySQL上なので、MySQLが実行できるSQLを書く必要があります。
前回のPostgreSQLと同様にMySQLのテーブルに対してSQLを実行し、オプションで指定したフォーマットで出力することが出来ます。
trdsql -driver mysql -dsn &amp;#34;noborus:noborus@/trdsql_test&amp;#34; -oat -ih &amp;#34;SELECT * FROM actor LIMIT 10&amp;#34; +----------+------------+--------------+---------------------+ | actor_id | first_name | last_name | last_update | +----------+------------+--------------+---------------------+ | 1 | PENELOPE | GUINESS | 2006-02-15 04:34:33 | | 2 | NICK | WAHLBERG | 2006-02-15 04:34:33 | | 3 | ED | CHASE | 2006-02-15 04:34:33 | | 4 | JENNIFER | DAVIS | 2006-02-15 04:34:33 | | 5 | JOHNNY | LOLLOBRIGIDA | 2006-02-15 04:34:33 | | 6 | BETTE | NICHOLSON | 2006-02-15 04:34:33 | | 7 | GRACE | MOSTEL | 2006-02-15 04:34:33 | | 8 | MATTHEW | JOHANSSON | 2006-02-15 04:34:33 | | 9 | JOE | SWANK | 2006-02-15 04:34:33 | | 10 | CHRISTIAN | GABLE | 2006-02-15 04:34:33 | +----------+------------+--------------+---------------------+</description></item><item><title>trdsql PostgreSQLエンジンの使用</title><link>https://noborus.github.io/blog/12_postgres/</link><pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/12_postgres/</guid><description>trdsqlは組込みのSQLite3を利用してSQLを実行していますが、データベースの処理を別のデータベースに変更出来ます。
ここではPostgreSQLを使用する方法を説明します。
PostgreSQLに接続 SQLite3と違いPostgreSQLは動作しているPostgreSQLサーバーが必要です。接続できテーブルが作成できる権限があるデータベースを作成しておきます。
オプションの -driver に postgres を指定し、-dsn にサーバーへの接続情報を指定します。
dsnの項目には以下が指定できます。デフォルトの場合は省略可能です。
項目名 説明 dbname データベース名（デフォルト:ログインユーザー名） user ユーザー名（デフォルト:ログインユーザー名） password パスワード（デフォルト:なし） host ホスト名又はIPアドレス（デフォルト:localhost） port ポート番号(デフォルト: 5432) sslmode SSLモード（デフォルト: require） fallback_application_name （提供されない場合の）アプリケーション名（デフォルト:なし） connect_timeout 接続の最大待機時間 sslcert 証明書ファイルの場所 sslkey 秘密鍵ファイルの場所 sslrootcert ルート証明書ファイルの場所 項目=値をスペース区切りで指定します。
DSN指定 例えば、ローカルホストのportが5433でデータベース名がtrdsql_testに接続するには以下のようにします。</description></item><item><title>trdsql 処理の概要</title><link>https://noborus.github.io/blog/11_summary/</link><pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/11_summary/</guid><description>ここでtrdsqlの内部処理の概要を簡単に説明します。
trdsqlの内部処理は、以下のようになっています。
オプションやSQLコマンドの解釈 SQLコマンド内のファイル名をデータベースにインポート SQLの実行 指定された出力フォーマットで実行結果を出力 SQLの実行は実際のRDBMSを使用して実行されます（デフォルトではSQLite3のメモリデータベース)。
trdsqlはインポートとエクスポートの形式を整えているだけで、データベースに丸投げしているツールと言えます。
そのため、他の1行づつ処理するようなストリーミングができるツールとは違い、一旦全部のデータをインポートしてから実行されるため、非常に大きなデータではSQLの実行開始までに時間がかかります。
しかしながら、SQLライクではなく本当のSQLが使用できます。
これらの特徴を踏まえて使用すると良いでしょう。</description></item><item><title>trdsql 標準入力</title><link>https://noborus.github.io/blog/10_stdin/</link><pubDate>Tue, 10 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/10_stdin/</guid><description>標準入力 trdsqlは他のUNIXツールのように標準入力からデータを受け取ることができます。ただSQLの文法上テーブル名を指定する必要があります。標準入力を使用するときは、「-」か「stdin」を使用します。
cat test.csv|trdsql -icsv &amp;#34;SELECT * FROM -&amp;#34; apple,100 orange,50 potato,30 trdsqlは標準入力から受け取りますが、標準入力をすべて受け取り終わってからSQLの実行が開始されます。 そのため終わらないコマンドからの出力を受け取ることはできません。 CSV、LTSV、JSONを出力するコマンドでは、ファイル名の代わりに標準入力を使えばそのまま利用できます。 例えば、文字コードがUTF-8でないファイルをUTF-8に変更してそのまま使用したり、
nkf -w sjis.csv|trdsql -icsv &amp;#34;SELECT * FROM -&amp;#34; 大きなファイルを処理する前に先頭の数行のみを処理して試してみたりできます。
head -100 big.csv|trdsql -icsv &amp;#34;SELECT * FROM -&amp;#34; それ以外にも、例えばUNIX系のコマンドでは、スペースを区切りとして解釈すればテーブルデータとして扱える出力をするコマンドが数多くあります。
例えば psコマンドでは、
ps PID TTY TIME CMD 1157 pts/3 00:00:00 ps 22590 pts/3 00:00:03 zsh のようにヘッダーがあり、それぞれの列を出力しています（trdsqlでは連続したスペースの区切り文字は一つとして解釈するように動作します）。
そのため、以下のように実行すると Ascii Table形式で出力できます。
ps|trdsql -ih -id &amp;#34; &amp;#34; -oat &amp;#34;SELECT \`PID\`, \`TTY\`, \`TIME\`, \`CMD\` FROM -&amp;#34; +-------+-------+----------+--------+ | PID | TTY | TIME | CMD | +-------+-------+----------+--------+ | 1363 | pts/3 | 00:00:00 | ps | | 1364 | pts/3 | 00:00:00 | trdsql | | 22590 | pts/3 | 00:00:03 | zsh | +-------+-------+----------+--------+ 標準入力の解析 また、trdsqlの-a解析オプションは標準入力も使用することが出来ます。</description></item><item><title>trdsql ワイルドカード、圧縮ファイル</title><link>https://noborus.github.io/blog/09_wildcard/</link><pubDate>Mon, 09 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/09_wildcard/</guid><description>Wildcard ここまでは一つのファイルを対象としてきましたが、ログファイル等はローテートされて複数のファイルになっている場合があります。
同じ列で構成されている対象ファイルであれば、ワイルドカードを使用して、複数のファイルを一つのテーブルとして扱うことができます。
ls test*.csv test1.csv test2.csv test3.csv trdsql -icsv &amp;#34;SELECT COUNT(*) FROM test*.csv&amp;#34; 15 圧縮ファイル また古いログファイルは圧縮されている場合があります。[gzip, bzip2, zstd, lz4, xz]圧縮であれば自動で伸長して実行します。
trdsql -iltsv &amp;#34;SELECT * FROM access.log.2.gz&amp;#34; 圧縮ファイルとワイルドカードを組み合わせて実行することもできます。
ls access.log access.log.1 access.log.2.gz trdsql -iltsv &amp;#34;SELECT * FROM access.log.*&amp;#34;</description></item><item><title>trdsql Log集計</title><link>https://noborus.github.io/blog/08_log/</link><pubDate>Sun, 08 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/08_log/</guid><description>Log集計 ApacheやnginxなどのLogをLTSVフォーマットで出力する方法も定着してきました。
そのようなLogをtrdsqlで解析する例です。
出力する側は、apacheのLogFormatの設定を以下のようにカスタマイズフォーマットにします。
LogFormat &amp;quot;host:%h\tident:%l\tuser:%u\ttime:%t\treq:%r\tstatus:%&amp;gt;s\tsize:%b\treferer:\%{Referer}i\tua:%{User-Agent}i&amp;quot; combined_ltsv host,ident,user,time,req,status,size,referer,uaの項目が出力されます。
実際のLogは以下のようになります。
host:176.99.192.42 ident:- user:- time:[21/Oct/2019:21:33:53 +0900] req:GET /category/software HTTP/1.1 status:200 size:138 referer:- ua:Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0) host:192.54.157.102 ident:- user:- time:[21/Oct/2019:21:33:53 +0900] req:GET /item/electronics/4478 HTTP/1.1 status:200 size:60 referer:/category/sports ua:Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:9.0.1) Gecko/20100101 Firefox/9.0.1 host:88.60.137.115 ident:- user:- time:[21/Oct/2019:21:33:53 +0900] req:POST /search/?c=Games+Electronics HTTP/1.1 status:200 size:98 referer:/item/networking/929 ua:Mozilla/5.0 (iPhone; CPU iPhone OS 5_0_1 like Mac OS X) AppleWebKit/534.</description></item><item><title>trdsql GROUP集計</title><link>https://noborus.github.io/blog/07_group/</link><pubDate>Sat, 07 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/07_group/</guid><description>GROUP集計 全体の合計を計算することもありますが、グループ毎の合計をまとめて出力したい場合もあります。 そこで使うのがGROUP BYです。
前回の例をもう一度使用します。
name,price apple,100 orange,50 melon,500 apple,90 apple,90 orange,40 orange,40 ここでappleやorange毎の合計を出したい場合は、以下のように検索条件で絞れば計算できますが、nameの種類の数だけ実行するとなると大変な作業になります。
trdsql -ih &amp;#34;SELECT name,SUM(CAST(price AS INT)) as sum FROM sample.csv WHERE name=&amp;#39;apple&amp;#39;&amp;#34; apple,280 trdsql -ih &amp;#34;SELECT name,SUM(CAST(price AS INT)) as sum FROM sample.csv WHERE name=&amp;#39;orange&amp;#39;&amp;#34; orange,130 そこでGROUP BYを使ってnameをグループとして扱うことで、それぞれの集計結果を求めることができます。
trdsql -ih &amp;#34;SELECT name,SUM(CAST(price AS INT)) as sum FROM sample.csv GROUP BY name&amp;#34; apple,280 melon,500 orange,130 前回の集計を少し変えてname毎に出すように出力してみます。 出力は-oat(Ascii Table)を使うと見やすく表示できます。
trdsql -ih -oat \ &amp;#34;SELECT name, COUNT(name) as count, MIN(CAST(price AS INT)) AS min, MAX(CAST(price AS INT)) as max, SUM(CAST(price AS INT)) as sum, AVG(CAST(price AS INT)) as avg FROM sample.</description></item><item><title>trdsql 集計計算</title><link>https://noborus.github.io/blog/06_calculation/</link><pubDate>Fri, 06 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/06_calculation/</guid><description>集計計算 集計には、COUNT()だけでなく集計計算することも当然できます。SQLには数値に対して計算をおこなう集計関数があらかじめ揃っています。
ここでは以下のようなCSVファイルを例に説明します。
name,price apple,100 orange,50 melon,500 apple,90 apple,90 orange,40 orange,40 SUM 合計を計算します。price列をすべて足します。
trdsql -ih &amp;#34;SELECT SUM(price) FROM sample.csv&amp;#34; 910 前にも書いたようにtrdsqlは列をテキスト型として扱いますので、本来はCASTして数値型にしてから計算する必要があります。ただ、集計の関数を使用する場合は、暗黙のCASTがされて省略できる場合があります（使用するデータベースによります）。
明示的にCASTする場合は以下のようにします。
trdsql -ih &amp;#34;SELECT SUM(CAST(price AS int)) FROM sample.csv&amp;#34; 910 AVG 平均を計算します。合計/件数で計算できますが、関数が用意されているので、使用したほうがわかりやすく書けます。この例では、平均の意味はそれほどないかもしれませんが。
trdsql -ih &amp;#34;SELECT AVG(CAST(price AS int)) FROM sample.csv&amp;#34; 130 MIN,MAX 最小値や最大値を出力します。
trdsql -ih -oh &amp;#34;SELECT MIN(CAST(price AS INT)),MAX(CAST(price AS INT)) FROM sample.csv&amp;#34; MIN(CAST(price AS INT)),MAX(CAST(price AS INT)) 40,500 MINやMAXはテキスト型でも使用できるため、明示的にCASTする必要があります。</description></item><item><title>trdsql 集計</title><link>https://noborus.github.io/blog/05_aggregate/</link><pubDate>Thu, 05 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/05_aggregate/</guid><description>COUNT(*) 最初はCOUNT(*)です。全体の件数を数えることが出来ます。
集計関数を使用すると元の行と列のデータは出力されず、そこから集計された結果が出力されます。
以下の例は結果が１行なので、CSVの様に見えませんが、1行1列(ヘッダー付き)のCSVとして出力されています。
単純に件数を数えるだけですが、ヘッダーと解釈して数に含まないか等の注意が必要です。 trdsql -icsv -ih -oh &amp;#34;SELECT COUNT(*) FROM header.csv&amp;#34; count(*) 3 検索条件の指定が出来ます。検索条件にあてはまる件数を知りたい時に使用します。
trdsql -icsv -ih -oh &amp;#34;SELECT COUNT(*) FROM header.csv WHERE id&amp;lt;&amp;#39;1&amp;#39;&amp;#34; count(*) 2 COUNT(列名) COUNT(列名) もよく使用します。RDBMSではNULLが除外されるので、COUNT(*)とは区別して使われます。
また、COUNTとDISTINCTを組み合わせると重複を省いた件数を出力できます。
以下のようなCSVファイルで実行してみます。
id,name 1,aaa 2,bbb 3,ccc 4,aaa trdsql -icsv -ih -oh &amp;#34;SELECT COUNT(name) FROM abc.csv&amp;#34; count(name) 4 trdsql -ih -oh &amp;#34;SELECT COUNT(DISTINCT name) FROM abc.csv&amp;#34; COUNT(DISTINCT name) 3 集計関数は一度に実行することもできます。</description></item><item><title>trdsql 簡単なSQL その２</title><link>https://noborus.github.io/blog/04_sql2/</link><pubDate>Wed, 04 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/04_sql2/</guid><description>検索条件 前回、列の並べ替え、抽出、行の並べ替えをしたので、今回は行の抽出です。 行を抽出するには、WHEREを付けて、検索条件を書きます。
前回と同じ例のファイルを使います。
trdsql -ih &amp;#34;SELECT id, \`name\` FROM header.csv WHERE id=1&amp;#34; 1,Orange SQLのメインな機能ですね。検索条件を書くだけで、該当する行を出力できます。
AND, OR AND や OR や ()括弧を使用することにより複雑な条件が書けます。
trdsql -ih &amp;#34;SELECT id, \`name\` FROM header.csv WHERE id=&amp;#39;1&amp;#39; OR id=&amp;#39;2&amp;#39;&amp;#34; 1,Orange 2,Melon trdsql -ih &amp;#34;SELECT id, \`name\` FROM header.csv &amp;#34; &amp;#34;WHERE (id=&amp;#39;1&amp;#39; OR id=&amp;#39;2&amp;#39;) AND \`name\`=&amp;#39;Orange&amp;#39;&amp;#34; 1,Orange 前回にも書いたようにtrdsqlでは、CSVやLTSV、JSONの値をtext型として扱っています。そのため、「=」の条件で書いているときには、暗黙のCASTが効いて型をそれほど意識しなくても良いですが、範囲を指定するときには結果が変わってしまうので、CASTする必要があります。
trdsql -ih &amp;#34;SELECT id,\`name\` FROM header.csv &amp;#34; &amp;#34;WHERE CAST(id as int)&amp;gt;1&amp;#34; 2,Melon 3,Apple SELECTを使用するときは、列の指定のところでCASTを使用して、そのCASTした列を指定して検索条件やORDER BYを書くことが出来ます。</description></item><item><title>trdsql 簡単なSQL</title><link>https://noborus.github.io/blog/03_sql/</link><pubDate>Tue, 03 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/03_sql/</guid><description>trdsqlと簡単なSQLを使用することで、他のUNIXツールを組み合わせて出来るようなことが一発で出来るようになります。
ファイル解析 SELECT * FROMから進んで簡単なSQLを実行する場合、あらかじめ列名を把握しておく必要があります。 trdsql に -aオプションにファイル名を付けて実行するとファイルを解析して情報を出力してくれます。
（CSVファイルの拡張子が.csvの様な場合は、-icsvを省略することが出来ます。-ih ヘッダを解釈、 -is スキップ数の指定等のオプションを必要に応じて付けないと意図しない解析結果になることがあります）。
trdsql -ih -a header.csv The table name is header.csv. The file type is CSV. Data types: +-------------+------+ | column name | type | +-------------+------+ | id | text | | \`name\` | text | +-------------+------+ Data samples: +----+----------+ | id | \`name\` | +----+----------+ | 1 | Orange | +----+----------+ Examples: trdsql -ih &amp;quot;SELECT id, \`name\` FROM header.</description></item><item><title>trdsql ファイルフォーマット変換</title><link>https://noborus.github.io/blog/02_convert/</link><pubDate>Mon, 02 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/02_convert/</guid><description>trdsqlはCSV等のファイルをSQLで処理するツールとして説明していますが、単純にファイル形式を変換するツールとしても使用できます。
その場合、SQLは以下の定型句さえ覚えておけば、十分です。 ファイル内のすべての行と列を出力します。
SELECT * FROM ファイル名 後は、オプションとして入力形式(-i&amp;hellip;)と出力形式(-o&amp;hellip;)を指定してあげればファイル形式の変換が可能です。 CSV、LTSV、JSON等の相互変換ができます。
CSV(-icsv)からLTSV(-oltsv)への変換は以下のようにします。
trdsql -icsv -oltsv &amp;#34;SELECT * FROM ファイル名&amp;#34; CSV header CSVファイルはヘッダーに列名がついている場合 -ih でヘッダーを解釈して列名として使用できます。
header.csv
id,name 1,Orange 2,Melon 3,Apple trdsql -icsv -ih -oltsv &amp;#34;SELECT * FROM header.csv&amp;#34; &amp;gt; test.ltsv test.ltsv
id:1 name:Orange id:2 name:Melon id:3 name:Apple ヘッダーが無い場合は、列名はc1,c2,c3&amp;hellip;の連番になります。
LTSV入力 上記で出力されたLTSVを入力に使用すれば、CSVに戻ります。
trdsql -iltsv -ocsv -oh &amp;#34;SELECT * FROM test.ltsv&amp;#34; id,name 1,Orange 2,Melon 3,Apple 区切り文字の変更（TSV） また、CSVはComma-Separated Valuesではなく、Character-separated valuesとも呼ばれたりすることがあるように、区切り文字として「,」以外を使用できます。</description></item><item><title>trdsql インストール</title><link>https://noborus.github.io/blog/01_install/</link><pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/01_install/</guid><description>概要 trdsqlはテーブル（表）形式のテキストに対してSQLを実行するCLIツールです。 テーブル形式とは、行と列で構成される以下のようなデータです。
1列 2列 1行 a1 a2 2行 b1 b2 結果をざまざまなフォーマットに出力できるので、テーブル形式データのフォーマット変換にも使用できます。
インストール Linux/Windows/macOSの場合は、GitHubのリリースページからバイナリをダウンロードできます。 Goで作られていて、他に依存ライブラリがない１バイナリなので、展開してすぐに実行できます。
Docker Dockerが使用できる環境であればDockerでも実行できます。Docker Hubからdocker pullも使用できるので、以下のようにしてpullしてください。
docker pull noborus/trdsql 入力ファイルの場所をマウントして使用して下さい。結果は標準出力に出るので、そのままリダイレクトで受け取れます。
カレントディレクトリにあるtest.csvに対して実行するときは以下のようになります。
docker run --rm -it -v $(pwd):$(pwd) --workdir $(pwd) noborus/trdsql &amp;#34;SELECT * FROM test.csv&amp;#34; &amp;gt; test_new.csv Homebrew macOSが無いので、実際には試していませんが、以下でインストールできるのではないかと思ってます。
brew tap noborus/trdsql brew install trdsql go get go のビルド環境があれば自分でビルドすることもできます。
go get -u -d github.</description></item></channel></rss>