<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>json on 斉藤登のページ</title><link>https://noborus.github.io/ja/tags/json/index.html</link><description>Recent content in json on 斉藤登のページ</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Sat, 09 Jul 2022 07:00:00 +0900</lastBuildDate><atom:link href="https://noborus.github.io/ja/tags/json/index.xml" rel="self" type="application/rss+xml"/><item><title>trdsql JSON解析</title><link>https://noborus.github.io/ja/trdsql/21_json_parse/index.html</link><pubDate>Sat, 21 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/ja/trdsql/21_json_parse/index.html</guid><description>これまでtrdsqlでは、JSONの入力が可能と書きましたが、例として書いたのは基本的にフラットな構造のJSONでした。 ただ、２階層以上の階層構造が含まれるJSONはエラーになる訳ではなく、そのまま文字列として扱われます。
以下のようなJSONがあるとします。
sample.json
[ { &amp;#34;color&amp;#34;: &amp;#34;white&amp;#34;, &amp;#34;category&amp;#34;: &amp;#34;value&amp;#34;, &amp;#34;code&amp;#34;: { &amp;#34;rgba&amp;#34;: [0, 0, 0, 1], &amp;#34;hex&amp;#34;: &amp;#34;#FFF&amp;#34; } }, { &amp;#34;color&amp;#34;: &amp;#34;red&amp;#34;, &amp;#34;category&amp;#34;: &amp;#34;hue&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;primary&amp;#34;, &amp;#34;code&amp;#34;: { &amp;#34;rgba&amp;#34;: [255, 0, 0, 1], &amp;#34;hex&amp;#34;: &amp;#34;#FF0&amp;#34; } }, { &amp;#34;color&amp;#34;: &amp;#34;blue&amp;#34;, &amp;#34;category&amp;#34;: &amp;#34;hue&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;primary&amp;#34;, &amp;#34;code&amp;#34;: { &amp;#34;rgba&amp;#34;: [0, 0, 255, 1], &amp;#34;hex&amp;#34;: &amp;#34;#00F&amp;#34; } } ] これをそのままtrdsqlを実行すると以下のようになります(見やすいように-oatを付けています。CSV出力にすると「&amp;quot;」が含まれる文字列のためエスケープされて出力されます。)
trdsql -oat &amp;#34;SELECT color,category,code FROM sample.json&amp;#34; +-------+----------+-----------------------------------+ | color | category | code | +-------+----------+-----------------------------------+ | white | value | {&amp;#34;hex&amp;#34;:&amp;#34;#FFF&amp;#34;,&amp;#34;rgba&amp;#34;:[0,0,0,1]} | | red | hue | {&amp;#34;hex&amp;#34;:&amp;#34;#FF0&amp;#34;,&amp;#34;rgba&amp;#34;:[255,0,0,1]} | | blue | hue | {&amp;#34;hex&amp;#34;:&amp;#34;#00F&amp;#34;,&amp;#34;rgba&amp;#34;:[0,0,255,1]} | +-------+----------+-----------------------------------+ このcodeは文字列の扱いですが、各データベースは既にJSONを扱える関数を備えているため、データベース側の関数を使って変更できます。</description></item><item><title>trdsql JSON出力</title><link>https://noborus.github.io/ja/trdsql/22_json_output/index.html</link><pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/ja/trdsql/22_json_output/index.html</guid><description>CSVやLTSVなどのフラットな形式のデータは、JSONにしたいときには（-ojsonによる）JSON出力をすれば良いですが、JSONは本来より深い階層も表現できるフォーマットです。
そのようなJSONは、データベースのJSON関数を使用することにより作成できます。
以下のCSVからJSON関数でJSON出力をしてみます。
id,name 1,Orange 2,Melon 3,Apple JSON関数で出力する場合は、「”」等がエスケープされない-orawを使用して出力すると、有効なJSONとして出力できます。
SQLite3、MySQL SQLite3、MySQLでは、json_array()やjson_object()を使用することによりJSONを生成できます。 ここでは「名前:値」の形式で出力するためjson_objectを使用します。2つペアの引数で、指定していきます。
trdsql -ih -oraw &amp;#34;SELECT json_object(&amp;#39;id&amp;#39;,id,&amp;#39;name&amp;#39;,name) FROM header.csv&amp;#34; {&amp;#34;id&amp;#34;:&amp;#34;1&amp;#34;,&amp;#34;name&amp;#34;:&amp;#34;Orange&amp;#34;} {&amp;#34;id&amp;#34;:&amp;#34;2&amp;#34;,&amp;#34;name&amp;#34;:&amp;#34;Melon&amp;#34;} {&amp;#34;id&amp;#34;:&amp;#34;3&amp;#34;,&amp;#34;name&amp;#34;:&amp;#34;Apple&amp;#34;} 階層を深くするには、json_object()を内部でさらに使います。 SQLite3にはjson_pretty()関数が無いので、jqで見やすくしています。
trdsql -ih -oraw &amp;#34;SELECT json_object(&amp;#39;fruits&amp;#39;, json_object(&amp;#39;id&amp;#39;,id,&amp;#39;name&amp;#39;,name)) FROM header.csv&amp;#34;|jq . { &amp;#34;fruits&amp;#34;: { &amp;#34;id&amp;#34;: &amp;#34;1&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Orange&amp;#34; } } { &amp;#34;fruits&amp;#34;: { &amp;#34;id&amp;#34;: &amp;#34;2&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Melon&amp;#34; } } { &amp;#34;fruits&amp;#34;: { &amp;#34;id&amp;#34;: &amp;#34;3&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Apple&amp;#34; } } 上記の結果は1行1JSONで出力されています。これをさらに配列にして、一つのJSONにするには、SQLite3では json_group_array()、MySQLではjson_arrayagg()でグループ化して出力できます。
SQLite3 trdsql -ih -oraw &amp;#34;SELECT json_group_array(json_object(&amp;#39;fruits&amp;#39;, json_object(&amp;#39;id&amp;#39;,id,&amp;#39;name&amp;#39;,name))) FROM header.csv&amp;#34;|jq .</description></item><item><title>trdsql jq構文</title><link>https://noborus.github.io/ja/trdsql/35_jq/index.html</link><pubDate>Sat, 09 Jul 2022 07:00:00 +0900</pubDate><guid>https://noborus.github.io/ja/trdsql/35_jq/index.html</guid><description>これまでtdsqlが対象とするJSONはフラットなJSONでした。そのためSQLの対象となるのはトップレベルのオブジェクトでした。
[ {&amp;#34;age&amp;#34;: &amp;#34;26&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Tanaka&amp;#34;}, {&amp;#34;age&amp;#34;: &amp;#34;32&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Suzuki&amp;#34;} ] JSONは階層を深くすることができるので、さらに下の階層をSQLの対象としたい場合がありました。 SQLの関数を使用して、アクセスすることも出来ますが、少し面倒でした。
{ &amp;#34;list&amp;#34;: [ {&amp;#34;age&amp;#34;: &amp;#34;26&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Tanaka&amp;#34;}, {&amp;#34;age&amp;#34;: &amp;#34;32&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Suzuki&amp;#34;} ] } tdsqlではJSONに対し、まずjqの構文を使用して処理し、その結果に対してSQLを実行できます。 jqの構文はファイル名の後に&amp;quot;::&amp;ldquo;を付け、その後に書きます。 jqの構文なので、主に&amp;rdquo;.&amp;ldquo;ドットではじまり、中の値にアクセスします。
（jsonを対象とすると配列全体を１つの列と解釈してしまう）。
trdsql &amp;#34;SELECT * FROM example0-s.json &amp;#34;[{&amp;#34;&amp;#34;age&amp;#34;&amp;#34;:&amp;#34;&amp;#34;26&amp;#34;&amp;#34;,&amp;#34;&amp;#34;name&amp;#34;&amp;#34;:&amp;#34;&amp;#34;Tanaka&amp;#34;&amp;#34;},{&amp;#34;&amp;#34;age&amp;#34;&amp;#34;:&amp;#34;&amp;#34;32&amp;#34;&amp;#34;,&amp;#34;&amp;#34;name&amp;#34;&amp;#34;:&amp;#34;&amp;#34;Suzuki&amp;#34;&amp;#34;}]&amp;#34; （listをテーブルとして解釈して、中のオブジェクトを列にする）。
trdsql &amp;#34;SELECT * FROM example0-s.json::.list 26,Tanaka 32,Suzuki 深い階層にアクセスしたいときは、jqの構文では .list.menu.itemのようにドットで繋いでいけば簡単にアクセスすることができます。 階層途中に配列があってもjqの構文（[]等が含まれる場合は「&amp;quot;」で括る等してください）が書ければアクセスすることができます。
trdsql &amp;#34;SELECT * FROM example0-s.json::\&amp;#34;.list[1].name\&amp;#34;&amp;#34; 複雑な集計をjqで書くのは難しいため、対象をテーブル化することでSQLで集計するといったことができます。 また、CSVや他の形式に変換するのもtrdsqlでは簡単です。</description></item><item><title>trdsql jq構文</title><link>https://noborus.github.io/ja/blog/35_jq/index.html</link><pubDate>Sat, 09 Jul 2022 07:00:00 +0900</pubDate><guid>https://noborus.github.io/ja/blog/35_jq/index.html</guid><description>これまでtdsqlが対象とするJSONはフラットなJSONでした。そのためSQLの対象となるのはトップレベルのオブジェクトでした。
[ {&amp;#34;age&amp;#34;: &amp;#34;26&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Tanaka&amp;#34;}, {&amp;#34;age&amp;#34;: &amp;#34;32&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Suzuki&amp;#34;} ] JSONは階層を深くすることができるので、さらに下の階層をSQLの対象としたい場合がありました。 SQLの関数を使用して、アクセスすることも出来ますが、少し面倒でした。
{ &amp;#34;list&amp;#34;: [ {&amp;#34;age&amp;#34;: &amp;#34;26&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Tanaka&amp;#34;}, {&amp;#34;age&amp;#34;: &amp;#34;32&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Suzuki&amp;#34;} ] } tdsqlではJSONに対し、まずjqの構文を使用して処理し、その結果に対してSQLを実行できます。 jqの構文はファイル名の後に&amp;quot;::&amp;ldquo;を付け、その後に書きます。 jqの構文なので、主に&amp;rdquo;.&amp;ldquo;ドットではじまり、中の値にアクセスします。
（jsonを対象とすると配列全体を１つの列と解釈してしまう）。
trdsql &amp;#34;SELECT * FROM example0-s.json &amp;#34;[{&amp;#34;&amp;#34;age&amp;#34;&amp;#34;:&amp;#34;&amp;#34;26&amp;#34;&amp;#34;,&amp;#34;&amp;#34;name&amp;#34;&amp;#34;:&amp;#34;&amp;#34;Tanaka&amp;#34;&amp;#34;},{&amp;#34;&amp;#34;age&amp;#34;&amp;#34;:&amp;#34;&amp;#34;32&amp;#34;&amp;#34;,&amp;#34;&amp;#34;name&amp;#34;&amp;#34;:&amp;#34;&amp;#34;Suzuki&amp;#34;&amp;#34;}]&amp;#34; （listをテーブルとして解釈して、中のオブジェクトを列にする）。
trdsql &amp;#34;SELECT * FROM example0-s.json::.list 26,Tanaka 32,Suzuki 深い階層にアクセスしたいときは、jqの構文では .list.menu.itemのようにドットで繋いでいけば簡単にアクセスすることができます。 階層途中に配列があってもjqの構文（[]等が含まれる場合は「&amp;quot;」で括る等してください）が書ければアクセスすることができます。
trdsql &amp;#34;SELECT * FROM example0-s.json::\&amp;#34;.list[1].name\&amp;#34;&amp;#34; 複雑な集計をjqで書くのは難しいため、対象をテーブル化することでSQLで集計するといったことができます。 また、CSVや他の形式に変換するのもtrdsqlでは簡単です。</description></item><item><title>trdsql JSON出力</title><link>https://noborus.github.io/ja/blog/22_json_output/index.html</link><pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/ja/blog/22_json_output/index.html</guid><description>CSVやLTSVなどのフラットな形式のデータは、JSONにしたいときには（-ojsonによる）JSON出力をすれば良いですが、JSONは本来より深い階層も表現できるフォーマットです。
そのようなJSONは、データベースのJSON関数を使用することにより作成できます。
以下のCSVからJSON関数でJSON出力をしてみます。
id,name 1,Orange 2,Melon 3,Apple JSON関数で出力する場合は、「”」等がエスケープされない-orawを使用して出力すると、有効なJSONとして出力できます。
SQLite3、MySQL SQLite3、MySQLでは、json_array()やjson_object()を使用することによりJSONを生成できます。 ここでは「名前:値」の形式で出力するためjson_objectを使用します。2つペアの引数で、指定していきます。
trdsql -ih -oraw &amp;#34;SELECT json_object(&amp;#39;id&amp;#39;,id,&amp;#39;name&amp;#39;,name) FROM header.csv&amp;#34; {&amp;#34;id&amp;#34;:&amp;#34;1&amp;#34;,&amp;#34;name&amp;#34;:&amp;#34;Orange&amp;#34;} {&amp;#34;id&amp;#34;:&amp;#34;2&amp;#34;,&amp;#34;name&amp;#34;:&amp;#34;Melon&amp;#34;} {&amp;#34;id&amp;#34;:&amp;#34;3&amp;#34;,&amp;#34;name&amp;#34;:&amp;#34;Apple&amp;#34;} 階層を深くするには、json_object()を内部でさらに使います。 SQLite3にはjson_pretty()関数が無いので、jqで見やすくしています。
trdsql -ih -oraw &amp;#34;SELECT json_object(&amp;#39;fruits&amp;#39;, json_object(&amp;#39;id&amp;#39;,id,&amp;#39;name&amp;#39;,name)) FROM header.csv&amp;#34;|jq . { &amp;#34;fruits&amp;#34;: { &amp;#34;id&amp;#34;: &amp;#34;1&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Orange&amp;#34; } } { &amp;#34;fruits&amp;#34;: { &amp;#34;id&amp;#34;: &amp;#34;2&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Melon&amp;#34; } } { &amp;#34;fruits&amp;#34;: { &amp;#34;id&amp;#34;: &amp;#34;3&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Apple&amp;#34; } } 上記の結果は1行1JSONで出力されています。これをさらに配列にして、一つのJSONにするには、SQLite3では json_group_array()、MySQLではjson_arrayagg()でグループ化して出力できます。
SQLite3 trdsql -ih -oraw &amp;#34;SELECT json_group_array(json_object(&amp;#39;fruits&amp;#39;, json_object(&amp;#39;id&amp;#39;,id,&amp;#39;name&amp;#39;,name))) FROM header.csv&amp;#34;|jq .</description></item><item><title>trdsql JSON解析</title><link>https://noborus.github.io/ja/blog/21_json_parse/index.html</link><pubDate>Sat, 21 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/ja/blog/21_json_parse/index.html</guid><description>これまでtrdsqlでは、JSONの入力が可能と書きましたが、例として書いたのは基本的にフラットな構造のJSONでした。 ただ、２階層以上の階層構造が含まれるJSONはエラーになる訳ではなく、そのまま文字列として扱われます。
以下のようなJSONがあるとします。
sample.json
[ { &amp;#34;color&amp;#34;: &amp;#34;white&amp;#34;, &amp;#34;category&amp;#34;: &amp;#34;value&amp;#34;, &amp;#34;code&amp;#34;: { &amp;#34;rgba&amp;#34;: [0, 0, 0, 1], &amp;#34;hex&amp;#34;: &amp;#34;#FFF&amp;#34; } }, { &amp;#34;color&amp;#34;: &amp;#34;red&amp;#34;, &amp;#34;category&amp;#34;: &amp;#34;hue&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;primary&amp;#34;, &amp;#34;code&amp;#34;: { &amp;#34;rgba&amp;#34;: [255, 0, 0, 1], &amp;#34;hex&amp;#34;: &amp;#34;#FF0&amp;#34; } }, { &amp;#34;color&amp;#34;: &amp;#34;blue&amp;#34;, &amp;#34;category&amp;#34;: &amp;#34;hue&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;primary&amp;#34;, &amp;#34;code&amp;#34;: { &amp;#34;rgba&amp;#34;: [0, 0, 255, 1], &amp;#34;hex&amp;#34;: &amp;#34;#00F&amp;#34; } } ] これをそのままtrdsqlを実行すると以下のようになります(見やすいように-oatを付けています。CSV出力にすると「&amp;quot;」が含まれる文字列のためエスケープされて出力されます。)
trdsql -oat &amp;#34;SELECT color,category,code FROM sample.json&amp;#34; +-------+----------+-----------------------------------+ | color | category | code | +-------+----------+-----------------------------------+ | white | value | {&amp;#34;hex&amp;#34;:&amp;#34;#FFF&amp;#34;,&amp;#34;rgba&amp;#34;:[0,0,0,1]} | | red | hue | {&amp;#34;hex&amp;#34;:&amp;#34;#FF0&amp;#34;,&amp;#34;rgba&amp;#34;:[255,0,0,1]} | | blue | hue | {&amp;#34;hex&amp;#34;:&amp;#34;#00F&amp;#34;,&amp;#34;rgba&amp;#34;:[0,0,255,1]} | +-------+----------+-----------------------------------+ このcodeは文字列の扱いですが、各データベースは既にJSONを扱える関数を備えているため、データベース側の関数を使って変更できます。</description></item></channel></rss>