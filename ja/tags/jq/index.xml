<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>jq on 斉藤登のページ</title><link>https://noborus.github.io/ja/tags/jq/index.html</link><description>Recent content in jq on 斉藤登のページ</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Sat, 09 Jul 2022 07:00:00 +0900</lastBuildDate><atom:link href="https://noborus.github.io/ja/tags/jq/index.xml" rel="self" type="application/rss+xml"/><item><title>trdsql jq構文</title><link>https://noborus.github.io/ja/trdsql/35_jq/index.html</link><pubDate>Sat, 09 Jul 2022 07:00:00 +0900</pubDate><guid>https://noborus.github.io/ja/trdsql/35_jq/index.html</guid><description>これまでtdsqlが対象とするJSONはフラットなJSONでした。そのためSQLの対象となるのはトップレベルのオブジェクトでした。
[ {&amp;#34;age&amp;#34;: &amp;#34;26&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Tanaka&amp;#34;}, {&amp;#34;age&amp;#34;: &amp;#34;32&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Suzuki&amp;#34;} ]JSONは階層を深くすることができるので、さらに下の階層をSQLの対象としたい場合がありました。 SQLの関数を使用して、アクセスすることも出来ますが、少し面倒でした。
{ &amp;#34;list&amp;#34;: [ {&amp;#34;age&amp;#34;: &amp;#34;26&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Tanaka&amp;#34;}, {&amp;#34;age&amp;#34;: &amp;#34;32&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Suzuki&amp;#34;} ] }tdsqlではJSONに対し、まずjqの構文を使用して処理し、その結果に対してSQLを実行できます。 jqの構文はファイル名の後に&amp;quot;::&amp;ldquo;を付け、その後に書きます。 jqの構文なので、主に&amp;rdquo;.&amp;ldquo;ドットではじまり、中の値にアクセスします。
（jsonを対象とすると配列全体を１つの列と解釈してしまう）。
trdsql &amp;#34;SELECT * FROM example0-s.json &amp;#34;[{&amp;#34;&amp;#34;age&amp;#34;&amp;#34;:&amp;#34;&amp;#34;26&amp;#34;&amp;#34;,&amp;#34;&amp;#34;name&amp;#34;&amp;#34;:&amp;#34;&amp;#34;Tanaka&amp;#34;&amp;#34;},{&amp;#34;&amp;#34;age&amp;#34;&amp;#34;:&amp;#34;&amp;#34;32&amp;#34;&amp;#34;,&amp;#34;&amp;#34;name&amp;#34;&amp;#34;:&amp;#34;&amp;#34;Suzuki&amp;#34;&amp;#34;}]&amp;#34; （listをテーブルとして解釈して、中のオブジェクトを列にする）。
trdsql &amp;#34;SELECT * FROM example0-s.json::.list 26,Tanaka 32,Suzuki 深い階層にアクセスしたいときは、jqの構文では .list.menu.itemのようにドットで繋いでいけば簡単にアクセスすることができます。 階層途中に配列があってもjqの構文（[]等が含まれる場合は「&amp;quot;」で括る等してください）が書ければアクセスすることができます。
trdsql &amp;#34;SELECT * FROM example0-s.json::\&amp;#34;.list[1].name\&amp;#34;&amp;#34; 複雑な集計をjqで書くのは難しいため、対象をテーブル化することでSQLで集計するといったことができます。 また、CSVや他の形式に変換するのもtrdsqlでは簡単です。</description></item><item><title>trdsql jq構文</title><link>https://noborus.github.io/ja/blog/35_jq/index.html</link><pubDate>Sat, 09 Jul 2022 07:00:00 +0900</pubDate><guid>https://noborus.github.io/ja/blog/35_jq/index.html</guid><description>これまでtdsqlが対象とするJSONはフラットなJSONでした。そのためSQLの対象となるのはトップレベルのオブジェクトでした。
[ {&amp;#34;age&amp;#34;: &amp;#34;26&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Tanaka&amp;#34;}, {&amp;#34;age&amp;#34;: &amp;#34;32&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Suzuki&amp;#34;} ]JSONは階層を深くすることができるので、さらに下の階層をSQLの対象としたい場合がありました。 SQLの関数を使用して、アクセスすることも出来ますが、少し面倒でした。
{ &amp;#34;list&amp;#34;: [ {&amp;#34;age&amp;#34;: &amp;#34;26&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Tanaka&amp;#34;}, {&amp;#34;age&amp;#34;: &amp;#34;32&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Suzuki&amp;#34;} ] }tdsqlではJSONに対し、まずjqの構文を使用して処理し、その結果に対してSQLを実行できます。 jqの構文はファイル名の後に&amp;quot;::&amp;ldquo;を付け、その後に書きます。 jqの構文なので、主に&amp;rdquo;.&amp;ldquo;ドットではじまり、中の値にアクセスします。
（jsonを対象とすると配列全体を１つの列と解釈してしまう）。
trdsql &amp;#34;SELECT * FROM example0-s.json &amp;#34;[{&amp;#34;&amp;#34;age&amp;#34;&amp;#34;:&amp;#34;&amp;#34;26&amp;#34;&amp;#34;,&amp;#34;&amp;#34;name&amp;#34;&amp;#34;:&amp;#34;&amp;#34;Tanaka&amp;#34;&amp;#34;},{&amp;#34;&amp;#34;age&amp;#34;&amp;#34;:&amp;#34;&amp;#34;32&amp;#34;&amp;#34;,&amp;#34;&amp;#34;name&amp;#34;&amp;#34;:&amp;#34;&amp;#34;Suzuki&amp;#34;&amp;#34;}]&amp;#34; （listをテーブルとして解釈して、中のオブジェクトを列にする）。
trdsql &amp;#34;SELECT * FROM example0-s.json::.list 26,Tanaka 32,Suzuki 深い階層にアクセスしたいときは、jqの構文では .list.menu.itemのようにドットで繋いでいけば簡単にアクセスすることができます。 階層途中に配列があってもjqの構文（[]等が含まれる場合は「&amp;quot;」で括る等してください）が書ければアクセスすることができます。
trdsql &amp;#34;SELECT * FROM example0-s.json::\&amp;#34;.list[1].name\&amp;#34;&amp;#34; 複雑な集計をjqで書くのは難しいため、対象をテーブル化することでSQLで集計するといったことができます。 また、CSVや他の形式に変換するのもtrdsqlでは簡単です。</description></item><item><title>trdsql+PostgreSQL 14でJSONを処理する</title><link>https://noborus.github.io/ja/blog/trdsql_jq/index.html</link><pubDate>Sat, 18 Dec 2021 15:40:00 +0900</pubDate><guid>https://noborus.github.io/ja/blog/trdsql_jq/index.html</guid><description>trdsql はCSVやLTSVと共にJSONに対してもSQLを実行できるツールですが、SQLを使用するため得意な対象はフラットなJSONです。 ただし、v0.9.0からjqの構文が使え、SQL内でもSQLの関数が使えるため、内容によっては簡単に書くことができる場合があります。
デフォルトのsqlite3にもJSON関数がありますが、ここではよりJSON関数が充実しているPostgreSQL 14を使用します。
基本的な使用法 SQLを実行する対象として複数の列のリストの形になっているものが対象です。 以下のように{``}で囲まれた複数の名前: 値が,で並べられたJSONが基本的な形です。 改行で区切られた（実際には）複数のJSONが並べられたLDJSONやJSONLと呼ばれるものは一番SQLで実行しやすい形です。
{ &amp;#34;name&amp;#34;: &amp;#34;Tanaka&amp;#34;, &amp;#34;age&amp;#34;: 26 } { &amp;#34;name&amp;#34;: &amp;#34;Suzuki&amp;#34;, &amp;#34;age&amp;#34;: 32 }一つのJSONの場合は上記を配列化します。
[ { &amp;#34;age&amp;#34;: &amp;#34;26&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Tanaka&amp;#34; }, { &amp;#34;age&amp;#34;: &amp;#34;32&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Suzuki&amp;#34; } ]どちらもそのままSELECT name, age FROM example0.jsonのようにtrdsqlのSQLとして実行できます。
JSONはオブジェクトや配列で入れ子に出来るため、ルートが対象とならない場合があります。以下の場合は、そのまま実行すると menu 列が一つに中身がすべて入っていることになります。
{ &amp;#34;menu&amp;#34;: { &amp;#34;id&amp;#34;: &amp;#34;file&amp;#34;, &amp;#34;value&amp;#34;: &amp;#34;File&amp;#34;, &amp;#34;popup&amp;#34;: { &amp;#34;menuitem&amp;#34;: [ { &amp;#34;value&amp;#34;: &amp;#34;New&amp;#34;, &amp;#34;onclick&amp;#34;: &amp;#34;CreateDoc()&amp;#34; }, { &amp;#34;value&amp;#34;: &amp;#34;Open&amp;#34;, &amp;#34;onclick&amp;#34;: &amp;#34;OpenDoc()&amp;#34; }, { &amp;#34;value&amp;#34;: &amp;#34;Save&amp;#34;, &amp;#34;onclick&amp;#34;: &amp;#34;SaveDoc()&amp;#34; } ] } } }SQLのJSON関数を使用することで内部のオブジェクトにアクセスできますが、ほとんどがJSON関数の記述になってしまうのでSQLで実行するメリットが感じられません。</description></item></channel></rss>