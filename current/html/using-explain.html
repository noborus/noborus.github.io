<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>14.1. EXPLAINの利用</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="performance-tips.html" title="第14章 性能に関するヒント" /><link rel="next" href="planner-stats.html" title="14.2. プランナで使用される統計情報" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 11.5文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="performance-tips.html" title="第14章 性能に関するヒント">第14章 性能に関するヒント</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 11.5 &#10;                      using-explain.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="performance-tips.html" title="第14章 性能に関するヒント">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="performance-tips.html" title="第14章 性能に関するヒント">上へ</a></td><td width="60%" align="center">14.1. <code class="command">EXPLAIN</code>の利用</td><td width="20%" align="right"> <a accesskey="n" href="planner-stats.html" title="14.2. プランナで使用される統計情報">次へ</a></td></tr></table><hr /></div><div class="sect1" id="USING-EXPLAIN"><div class="titlepage"><div><div><h2 class="title" style="clear: both">14.1. <code class="command">EXPLAIN</code>の利用</h2></div></div></div><span class="original">
  &lt;title&gt;Using &lt;command&gt;EXPLAIN&lt;/command&gt;&lt;/title&gt;
</span><a id="id-1.5.13.4.2" class="indexterm"></a><a id="id-1.5.13.4.3" class="indexterm"></a><p>
<span class="original">
    &lt;productname&gt;PostgreSQL&lt;/productname&gt; devises a &lt;firstterm&gt;query
    plan&lt;/firstterm&gt; for each query it receives.  Choosing the right
    plan to match the query structure and the properties of the data
    is absolutely critical for good performance, so the system includes
    a complex &lt;firstterm&gt;planner&lt;/firstterm&gt; that tries to choose good plans.
    You can use the &lt;xref linkend="sql-explain"/&gt; command
    to see what query plan the planner creates for any query.
    Plan-reading is an art that requires some experience to master,
    but this section attempts to cover the basics.
</span>
<span class="productname">PostgreSQL</span>は受理した問い合わせから<em class="firstterm">問い合わせ計画</em>を作り出します。
問い合わせの構造と含まれるデータの性質に適した正しい問い合わせ計画を選択することが、良い性能を得るために非常に重要になります。
ですので、システムには優れた計画の選択を試みる複雑な<em class="firstterm">プランナ</em>が存在します。
<a class="xref" href="sql-explain.html" title="EXPLAIN"><span class="refentrytitle">EXPLAIN</span></a>コマンドを使えば、任意の問い合わせに対してプランナがどのような問い合わせ計画を作ったのかわかります。
問い合わせ計画を読みこなすには、ある程度の経験が必要です。
本節ではその基本を提供しようと考えます。
   </p><p>
<span class="original">
    Examples in this section are drawn from the regression test database
    after doing a &lt;command&gt;VACUUM ANALYZE&lt;/command&gt;, using 9.3 development sources.
    You should be able to get similar results if you try the examples
    yourself, but your estimated costs and row counts might vary slightly
    because &lt;command&gt;ANALYZE&lt;/command&gt;'s statistics are random samples rather
    than exact, and because costs are inherently somewhat platform-dependent.
</span>
本節の例は、9.3の開発版ソースを用いて<code class="command">VACUUM ANALYZE</code>を実行した後でリグレッションテストデータベースから取り出したものです。
実際にこの例を試すと、似たような結果になるはずですが、おそらく推定コストや行数は多少異なることになるでしょう。
<code class="command">ANALYZE</code>による統計情報は厳密なものではなくランダムなサンプリングを行った結果であり、また、コストは本質的にプラットフォームに何かしら依存するためです。
   </p><p>
<span class="original">
    The examples use &lt;command&gt;EXPLAIN&lt;/command&gt;'s default &lt;quote&gt;text&lt;/quote&gt; output
    format, which is compact and convenient for humans to read.
    If you want to feed &lt;command&gt;EXPLAIN&lt;/command&gt;'s output to a program for further
    analysis, you should use one of its machine-readable output formats
    (XML, JSON, or YAML) instead.
</span>
例では、簡潔で人が読みやすい<code class="command">EXPLAIN</code>のデフォルトの<span class="quote">「<span class="quote">text</span>」</span>出力書式を使用します。
今後の解析で<code class="command">EXPLAIN</code>の出力をプログラムに渡すことを考えているのであれば、代わりに機械読み取りが容易な出力書式（XML、JSON、YAML）のいずれかを使用すべきです。
   </p><div class="sect2" id="USING-EXPLAIN-BASICS"><div class="titlepage"><div><div><h3 class="title">14.1.1. <code class="command">EXPLAIN</code>の基本</h3></div></div></div><span class="original">
   &lt;title&gt;&lt;command&gt;EXPLAIN&lt;/command&gt; Basics&lt;/title&gt;
</span><p>
<span class="original">
    The structure of a query plan is a tree of &lt;firstterm&gt;plan nodes&lt;/firstterm&gt;.
    Nodes at the bottom level of the tree are scan nodes: they return raw rows
    from a table.  There are different types of scan nodes for different
    table access methods: sequential scans, index scans, and bitmap index
    scans.  There are also non-table row sources, such as &lt;literal&gt;VALUES&lt;/literal&gt;
    clauses and set-returning functions in &lt;literal&gt;FROM&lt;/literal&gt;, which have their
    own scan node types.
    If the query requires joining, aggregation, sorting, or other
    operations on the raw rows, then there will be additional nodes
    above the scan nodes to perform these operations.  Again,
    there is usually more than one possible way to do these operations,
    so different node types can appear here too.  The output
    of &lt;command&gt;EXPLAIN&lt;/command&gt; has one line for each node in the plan
    tree, showing the basic node type plus the cost estimates that the planner
    made for the execution of that plan node.  Additional lines might appear,
    indented from the node's summary line,
    to show additional properties of the node.
    The very first line (the summary line for the topmost
    node) has the estimated total execution cost for the plan; it is this
    number that the planner seeks to minimize.
</span>
問い合わせ計画は<em class="firstterm">計画ノード</em>のツリー構造です。
ツリー構造の最下層ノードはスキャンノードで、テーブルから行そのものを返します。
シーケンシャルスキャン、インデックススキャン、ビットマップインデックススキャンといったテーブルアクセス方法の違いに応じ、スキャンノードの種類に違いがあります。
また、<code class="literal">VALUES</code>句や<code class="literal">FROM</code>内の集合を返す関数など独自のスキャンノード種類を持つ、テーブル行を元にしないものがあります。
問い合わせが結合、集約、ソートなど、行そのものに対する操作を必要としている場合、スキャンノードの上位に更に、これらの操作を行うためのノードが追加されます。
これらの操作の実現方法にも通常複数の方法がありますので、異なった種類のノードがここに出現することもあり得ます。
<code class="command">EXPLAIN</code>には計画ツリー内の各ノードにつき1行の出力があり、基本ノード種類とプランナが生成したその計画ノードの実行に要するコスト推定値を示します。
さらに、ノードの追加属性を表示するためにノードの要約行からインデント付けされた行が出力される可能性があります。
最初の1行目（最上位ノード）には、計画全体の実行コスト推定値が含まれます。
プランナはこの値が最小になるように動作します。
   </p><p>
<span class="original">
    Here is a trivial example, just to show what the output looks like:
</span>
どのような出力となるのかを示すためだけに、ここで簡単な例を示します。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1;

                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)
</pre><p>
   </p><p>
<span class="original">
    Since this query has no &lt;literal&gt;WHERE&lt;/literal&gt; clause, it must scan all the
    rows of the table, so the planner has chosen to use a simple sequential
    scan plan.  The numbers that are quoted in parentheses are (left
    to right):
</span>
この問い合わせには<code class="literal">WHERE</code>句がありませんので、テーブル行をすべてスキャンしなければなりません。
このためプランナは単純なシーケンシャルスキャン計画を使用することを選びました。
（左から右に）括弧で囲まれた数値には以下のものがあります。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
       Estimated start-up cost.  This is the time expended before the output
       phase can begin, e.g., time to do the sorting in a sort node.
</span>
初期処理の推定コスト。
出力段階が開始できるようになる前に消費される時間、例えば、SORTノードで実行されるソート処理の時間です。
      </p></li><li class="listitem"><p>
<span class="original">
       Estimated total cost.  This is stated on the assumption that the plan
       node is run to completion, i.e., all available rows are retrieved.
       In practice a node's parent node might stop short of reading all
       available rows (see the &lt;literal&gt;LIMIT&lt;/literal&gt; example below).
</span>
全体推定コスト。
これは計画ノードが実行完了である、つまりすべての利用可能な行を受け取ることを前提として示されます。
実際には、ノードの親ノードはすべての利用可能な行を読む前に停止する可能性があります（以下の<code class="literal">LIMIT</code>の例を参照）。
      </p></li><li class="listitem"><p>
<span class="original">
       Estimated number of rows output by this plan node.  Again, the node
       is assumed to be run to completion.
</span>
この計画ノードが出力する行の推定数。ここでも、ノードが実行を完了することを前提としています。
      </p></li><li class="listitem"><p>
<span class="original">
       Estimated average width of rows output by this plan node (in bytes).
</span>
この計画ノードが出力する行の（バイト単位での）推定平均幅。
      </p></li></ul></div><p>
   </p><p>
<span class="original">
    The costs are measured in arbitrary units determined by the planner's
    cost parameters (see &lt;xref linkend="runtime-config-query-constants"/&gt;).
    Traditional practice is to measure the costs in units of disk page
    fetches; that is, &lt;xref linkend="guc-seq-page-cost"/&gt; is conventionally
    set to &lt;literal&gt;1.0&lt;/literal&gt; and the other cost parameters are set relative
    to that.  The examples in this section are run with the default cost
    parameters.
</span>
コストはプランナのコストパラメータ（<a class="xref" href="runtime-config-query.html#RUNTIME-CONFIG-QUERY-CONSTANTS" title="19.7.2. プランナコスト定数">19.7.2</a>参照）によって決まる任意の単位で測定されます。
取り出すディスクページ単位でコストを測定することが、伝統的な方式です。
つまり、<a class="xref" href="runtime-config-query.html#GUC-SEQ-PAGE-COST">seq_page_cost</a>を慣習的に<code class="literal">1.0</code>に設定し、他のコストパラメータを相対的に設定します。
本節の例では、デフォルトのコストパラメータで実行しています。
   </p><p>
<span class="original">
    It's important to understand that the cost of an upper-level node includes
    the cost of all its child nodes.  It's also important to realize that
    the cost only reflects things that the planner cares about.
    In particular, the cost does not consider the time spent transmitting
    result rows to the client, which could be an important
    factor in the real elapsed time; but the planner ignores it because
    it cannot change it by altering the plan.  (Every correct plan will
    output the same row set, we trust.)
</span>
上位ノードのコストには、すべての子ノードのコストもその中に含まれていることを理解することは重要です。
このコストはプランナが関与するコストのみ反映する点もまた重要です。
とりわけ、結果の行をクライアントに転送するコストは、実際の処理時間の重要な要因となる可能性があるにもかかわらず、考慮されません。
プランナは、計画をいかに変更しようと、どうすることもできないため、これを無視します。
（正しい計画はどんなものであれ、すべて同じ行を結果として出力すると信じています。）
   </p><p>
<span class="original">
    The &lt;literal&gt;rows&lt;/literal&gt; value is a little tricky because it is
    not the number of rows processed or scanned by the
    plan node, but rather the number emitted by the node.  This is often
    less than the number scanned, as a result of filtering by any
    &lt;literal&gt;WHERE&lt;/literal&gt;-clause conditions that are being applied at the node.
    Ideally the top-level rows estimate will approximate the number of rows
    actually returned, updated, or deleted by the query.
</span>
<code class="literal">rows</code>の値は、計画ノードによって処理あるいはスキャンされた行数を表しておらず、ノードによって発行された行数を表すので、多少扱いにくくなっています。
該当ノードに適用されるすべての<code class="literal">WHERE</code>句条件によるフィルタ処理の結果、スキャンされる行より少ない行数になることがよくあります。
理想的には、最上位の行数の推定値は、実際に問い合わせによって返され、更新され、あるいは削除された概算の行数となります。
   </p><p>
<span class="original">
    Returning to our example:
</span>
例に戻ります。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1;

                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)
</pre><p>
   </p><p>
<span class="original">
    These numbers are derived very straightforwardly.  If you do:
</span>
この数は非常に素直に導かれます。

</p><pre class="programlisting">
SELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1';
</pre><p>

<span class="original">
    you will find that &lt;classname&gt;tenk1&lt;/classname&gt; has 358 disk
    pages and 10000 rows.  The estimated cost is computed as (disk pages read *
    &lt;xref linkend="guc-seq-page-cost"/&gt;) + (rows scanned *
    &lt;xref linkend="guc-cpu-tuple-cost"/&gt;).  By default,
    &lt;varname&gt;seq_page_cost&lt;/varname&gt; is 1.0 and &lt;varname&gt;cpu_tuple_cost&lt;/varname&gt; is 0.01,
    so the estimated cost is (358 * 1.0) + (10000 * 0.01) = 458.
</span>
を実行すると、<code class="classname">tenk1</code>には358のディスクページと10000の行があることがわかります。
推定コストは（ディスクページ読み取り * <a class="xref" href="runtime-config-query.html#GUC-SEQ-PAGE-COST">seq_page_cost</a>）+（スキャンした行 * <a class="xref" href="runtime-config-query.html#GUC-CPU-TUPLE-COST">cpu_tuple_cost</a>）と計算されます。
デフォルトでは、<code class="varname">seq_page_cost</code>は1.0、<code class="varname">cpu_tuple_cost</code>は0.01です。
ですから、推定コストは(358 * 1.0) + (10000 * 0.01) = 458となります。
   </p><p>
<span class="original">
    Now let's modify the query to add a &lt;literal&gt;WHERE&lt;/literal&gt; condition:
</span>
では、<code class="literal">WHERE</code>条件を加えて、問い合わせを変更してみます。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 7000;

                         QUERY PLAN
------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=7001 width=244)
   Filter: (unique1 &lt; 7000)
</pre><p>

<span class="original">
    Notice that the &lt;command&gt;EXPLAIN&lt;/command&gt; output shows the &lt;literal&gt;WHERE&lt;/literal&gt;
    clause being applied as a &lt;quote&gt;filter&lt;/quote&gt; condition attached to the Seq
    Scan plan node.  This means that
    the plan node checks the condition for each row it scans, and outputs
    only the ones that pass the condition.
    The estimate of output rows has been reduced because of the
    &lt;literal&gt;WHERE&lt;/literal&gt; clause.
    However, the scan will still have to visit all 10000 rows, so the cost
    hasn't decreased; in fact it has gone up a bit (by 10000 * &lt;xref
    linkend="guc-cpu-operator-cost"/&gt;, to be exact) to reflect the extra CPU
    time spent checking the &lt;literal&gt;WHERE&lt;/literal&gt; condition.
</span>
<code class="command">EXPLAIN</code>の出力が、Seq Scan計画ノードに付随する<span class="quote">「<span class="quote">フィルタ</span>」</span>条件として適用される<code class="literal">WHERE</code>句を表示していることに注意してください。
これは、この計画ノードがスキャンした各行に対してその条件を検査することを意味し、その条件を通過したもののみが出力されます。
<code class="literal">WHERE</code>句があるため、推定出力行数が小さくなっています。
しかし、依然として10000行すべてをスキャンする必要があるため、コストは小さくなっていません。
実際には、<code class="literal">WHERE</code>条件を検査するためにCPU時間が余計にかかることを反映して、ほんの少し（正確には10000 * <a class="xref" href="runtime-config-query.html#GUC-CPU-OPERATOR-COST">cpu_operator_cost</a>）ですがコストが上昇しています。
   </p><p>
<span class="original">
    The actual number of rows this query would select is 7000, but the &lt;literal&gt;rows&lt;/literal&gt;
    estimate is only approximate.  If you try to duplicate this experiment,
    you will probably get a slightly different estimate; moreover, it can
    change after each &lt;command&gt;ANALYZE&lt;/command&gt; command, because the
    statistics produced by &lt;command&gt;ANALYZE&lt;/command&gt; are taken from a
    randomized sample of the table.
</span>
この問い合わせが選択する実際の行数は7000です。
しかし、<code class="literal">rows</code>の推定行数は概算値に過ぎません。
この実験を2回実行した場合、おそらく多少異なる推定値を得るでしょう。
もっと言うと、これは<code class="command">ANALYZE</code>コマンドを行う度に変化することがあり得ます。
なぜなら、<code class="command">ANALYZE</code>で生成される統計情報は、テーブルのランダムな標本から取り出されるからです。
   </p><p>
<span class="original">
    Now, let's make the condition more restrictive:
</span>
では、条件をより強く制限してみます。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100;

                                  QUERY PLAN
------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=5.07..229.20 rows=101 width=244)
   Recheck Cond: (unique1 &lt; 100)
   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0)
         Index Cond: (unique1 &lt; 100)
</pre><p>

<span class="original">
    Here the planner has decided to use a two-step plan: the child plan
    node visits an index to find the locations of rows matching the index
    condition, and then the upper plan node actually fetches those rows
    from the table itself.  Fetching rows separately is much more
    expensive than reading them sequentially, but because not all the pages
    of the table have to be visited, this is still cheaper than a sequential
    scan.  (The reason for using two plan levels is that the upper plan
    node sorts the row locations identified by the index into physical order
    before reading them, to minimize the cost of separate fetches.
    The &lt;quote&gt;bitmap&lt;/quote&gt; mentioned in the node names is the mechanism that
    does the sorting.)
</span>
ここでは、プランナは2段階の計画を使用することを決定しました。
子の計画ノードは、インデックスを使用して、インデックス条件に合う行の場所を検索します。
そして、上位計画ノードが実際にテーブル自体からこれらの行を取り出します。
行を別々に取り出すことは、シーケンシャルな読み取りに比べ非常に高価です。
しかし、テーブルのすべてのページを読み取る必要はありませんので、シーケンシャルスキャンより低価になります。
（2段階の計画を使用する理由は、別々に行を取り出すコストを最小にするために、上位の計画ノードがインデックスにより識別された行の位置を読み取る前に物理的な順序でソートすることです。
ノードで記載されている<span class="quote">「<span class="quote">bitmap</span>」</span>は、ソートを行う機構の名前です。）
   </p><p>
<span class="original">
    Now let's add another condition to the &lt;literal&gt;WHERE&lt;/literal&gt; clause:
</span>
ここで<code class="literal">WHERE</code>句に別の条件を付与してみましょう。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND stringu1 = 'xxx';

                                  QUERY PLAN
------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=5.04..229.43 rows=1 width=244)
   Recheck Cond: (unique1 &lt; 100)
   Filter: (stringu1 = 'xxx'::name)
   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0)
         Index Cond: (unique1 &lt; 100)
</pre><p>

<span class="original">
    The added condition &lt;literal&gt;stringu1 = 'xxx'&lt;/literal&gt; reduces the
    output row count estimate, but not the cost because we still have to visit
    the same set of rows.  Notice that the &lt;literal&gt;stringu1&lt;/literal&gt; clause
    cannot be applied as an index condition, since this index is only on
    the &lt;literal&gt;unique1&lt;/literal&gt; column.  Instead it is applied as a filter on
    the rows retrieved by the index.  Thus the cost has actually gone up
    slightly to reflect this extra checking.
</span>
追加された<code class="literal">stringu1 = 'xxx'</code>条件は出力行数推定値を減らしますが、同じ行集合にアクセスしなければなりませんので、コストは減りません。
このインデックスが<code class="literal">unique1</code>列に対してのみ存在するため、<code class="literal">stringu1</code>句をインデックス条件として適用できないことに注意してください。
代わりに、インデックスによって取り出される行に対するフィルタとして適用されます。
これにより、追加の検査分を反映するため、コストは実際には少し上がります。
   </p><p>
<span class="original">
    In some cases the planner will prefer a &lt;quote&gt;simple&lt;/quote&gt; index scan plan:
</span>
場合によってはプランナは<span class="quote">「<span class="quote">単純な</span>」</span>インデックススキャン計画を選択します。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1 WHERE unique1 = 42;

                                 QUERY PLAN
-----------------------------------------------------------------------------
 Index Scan using tenk1_unique1 on tenk1  (cost=0.29..8.30 rows=1 width=244)
   Index Cond: (unique1 = 42)
</pre><p>

<span class="original">
    In this type of plan the table rows are fetched in index order, which
    makes them even more expensive to read, but there are so few that the
    extra cost of sorting the row locations is not worth it.  You'll most
    often see this plan type for queries that fetch just a single row.  It's
    also often used for queries that have an &lt;literal&gt;ORDER BY&lt;/literal&gt; condition
    that matches the index order, because then no extra sorting step is needed
    to satisfy the &lt;literal&gt;ORDER BY&lt;/literal&gt;.
</span>
この種の計画では、テーブル行はインデックス順で取り出されます。
このため読み取りがより高価になりますが、この場合取り出す行数が少ないため、改めて行位置をソートし直すための追加コストは割に合いません。
単一の行のみを取り出す問い合わせでは、この計画種類がよく現れます。
また、<code class="literal">ORDER BY</code>を満たすために必要となる余分な必要なソート処理がないため、インデックスの順序に一致する<code class="literal">ORDER BY</code>条件を持つ問い合わせでよく使用されます。
   </p><p>
<span class="original">
    If there are separate indexes on several of the columns referenced
    in &lt;literal&gt;WHERE&lt;/literal&gt;, the planner might choose to use an AND or OR
    combination of the indexes:
</span>
<code class="literal">WHERE</code>句で参照される複数の列に対して別々のインデックスが存在する場合、プランナはインデックスをANDやORで組み合わせて使用することを選択する可能性があります。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000;

                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=25.08..60.21 rows=10 width=244)
   Recheck Cond: ((unique1 &lt; 100) AND (unique2 &gt; 9000))
   -&gt;  BitmapAnd  (cost=25.08..25.08 rows=10 width=0)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0)
               Index Cond: (unique1 &lt; 100)
         -&gt;  Bitmap Index Scan on tenk1_unique2  (cost=0.00..19.78 rows=999 width=0)
               Index Cond: (unique2 &gt; 9000)
</pre><p>

<span class="original">
    But this requires visiting both indexes, so it's not necessarily a win
    compared to using just one index and treating the other condition as
    a filter.  If you vary the ranges involved you'll see the plan change
    accordingly.
</span>
しかし、これは両方のインデックスを参照する必要があります。
そのため、インデックスを1つ使用し、他の条件についてはフィルタとして扱う方法と比べて常に勝るとは限りません。
含まれる範囲を変更すると、それに伴い計画も変わることが分かるでしょう。
   </p><p>
<span class="original">
    Here is an example showing the effects of &lt;literal&gt;LIMIT&lt;/literal&gt;:
</span>
以下に<code class="literal">LIMIT</code>の影響を示す例を示します。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000 LIMIT 2;

                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Limit  (cost=0.29..14.48 rows=2 width=244)
   -&gt;  Index Scan using tenk1_unique2 on tenk1  (cost=0.29..71.27 rows=10 width=244)
         Index Cond: (unique2 &gt; 9000)
         Filter: (unique1 &lt; 100)
</pre><p>
   </p><p>
<span class="original">
    This is the same query as above, but we added a &lt;literal&gt;LIMIT&lt;/literal&gt; so that
    not all the rows need be retrieved, and the planner changed its mind about
    what to do.  Notice that the total cost and row count of the Index Scan
    node are shown as if it were run to completion.  However, the Limit node
    is expected to stop after retrieving only a fifth of those rows, so its
    total cost is only a fifth as much, and that's the actual estimated cost
    of the query.  This plan is preferred over adding a Limit node to the
    previous plan because the Limit could not avoid paying the startup cost
    of the bitmap scan, so the total cost would be something over 25 units
    with that approach.
</span>
これは上と同じ問い合わせですが、すべての行を取り出す必要がないため<code class="literal">LIMIT</code>を付けています。
プランナはどうすべきかについて考えを変えました。
インデックススキャンノードの総コストと総行数があたかも実行完了したかのように表示されていることに注意してください。
しかしLimitノードが、これらの内５行のみを取り出した後で停止することが想定されています。
そのため総コストは1/5程度のみとなり、これが問い合わせの実際の推定コストとなります。
この計画は、以前の計画にLimitノードを追加することより好まれます。
Limitはビットマップスキャンの起動コストを払うことを避けることができないためです。
このため総コストはこの方法に25単位ほど増加します。
   </p><p>
<span class="original">
    Let's try joining two tables, using the columns we have been discussing:
</span>
今まで説明に使ってきたフィールドを使って2つのテーブルを結合してみましょう。

</p><pre class="screen">
EXPLAIN SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2;

                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Nested Loop  (cost=4.65..118.62 rows=10 width=488)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 width=244)
         Recheck Cond: (unique1 &lt; 10)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 width=0)
               Index Cond: (unique1 &lt; 10)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..7.91 rows=1 width=244)
         Index Cond: (unique2 = t1.unique2)
</pre><p>
   </p><p>
<span class="original">
    In this plan, we have a nested-loop join node with two table scans as
    inputs, or children.  The indentation of the node summary lines reflects
    the plan tree structure.  The join's first, or &lt;quote&gt;outer&lt;/quote&gt;, child
    is a bitmap scan similar to those we saw before.  Its cost and row count
    are the same as we'd get from &lt;literal&gt;SELECT ... WHERE unique1 &amp;lt; 10&lt;/literal&gt;
    because we are
    applying the &lt;literal&gt;WHERE&lt;/literal&gt; clause &lt;literal&gt;unique1 &amp;lt; 10&lt;/literal&gt;
    at that node.
    The &lt;literal&gt;t1.unique2 = t2.unique2&lt;/literal&gt; clause is not relevant yet,
    so it doesn't affect the row count of the outer scan.  The nested-loop
    join node will run its second,
    or &lt;quote&gt;inner&lt;/quote&gt; child once for each row obtained from the outer child.
    Column values from the current outer row can be plugged into the inner
    scan; here, the &lt;literal&gt;t1.unique2&lt;/literal&gt; value from the outer row is available,
    so we get a plan and costs similar to what we saw above for a simple
    &lt;literal&gt;SELECT ... WHERE t2.unique2 = &lt;replaceable&gt;constant&lt;/replaceable&gt;&lt;/literal&gt; case.
    (The estimated cost is actually a bit lower than what was seen above,
    as a result of caching that's expected to occur during the repeated
    index scans on &lt;literal&gt;t2&lt;/literal&gt;.)  The
    costs of the loop node are then set on the basis of the cost of the outer
    scan, plus one repetition of the inner scan for each outer row (10 * 7.91,
    here), plus a little CPU time for join processing.
</span>
この計画では、入力または子として２つのテーブルスキャンを持つネステッドループ結合ノードがあります。
計画のツリー構造を反映して、ノード要約行はインデント付けされます。
結合の先頭、<span class="quote">「<span class="quote">外部</span>」</span>、子は以前に説明したものと似たビットマップスキャンです。
そのコストと行数は、該当ノードに<code class="literal">unique1 &lt; 10</code> <code class="literal">WHERE</code>句が適用されるため、<code class="literal">SELECT ... WHERE unique1 &lt; 10</code>で得られたものと同じです。
この段階では<code class="literal">t1.unique2 = t2.unique2</code>句は関係しておらず、外部スキャンにおける出力行数に影響していません。
ネステッドループ結合ノードは、外部の子から得られた行毎に、その２番目または<span class="quote">「<span class="quote">内部の</span>」</span>子を一回実行します。
現在の外部の行からの列の値は内部スキャンに組み込まれます。
ここで、外部行からの<code class="literal">t1.unique2</code>の値が利用できますので、上述の単純な<code class="literal">SELECT ... WHERE t2.unique2 = <em class="replaceable"><code>constant</code></em></code>の場合に示したものと似た計画とコストが得られます。
（実際、推定コストは、<code class="literal">t2</code>に対するインデックススキャンが繰り返される間に発生することが想定されるキャッシュの結果、上で示した値よりわずかに低くなります。）
ループノードのコストは、外部スキャンのコストと、各々の外部の行に対して内部スキャンが繰り返されることによるコスト（ここでは10 * 7.91）を加え、さらに結合処理を行うための少々のCPU時間を加えたものになります。
   </p><p>
<span class="original">
    In this example the join's output row count is the same as the product
    of the two scans' row counts, but that's not true in all cases because
    there can be additional &lt;literal&gt;WHERE&lt;/literal&gt; clauses that mention both tables
    and so can only be applied at the join point, not to either input scan.
    Here's an example:
</span>
この例では、結合の出力行数は2つのスキャンの出力行数の積に等しくなっていますが、いつもそうなるわけではありません。
2つのテーブルに関係する<code class="literal">WHERE</code>句は、入力スキャン時ではなく、結合を行う際に適用されるからです。
以下が例です。

</p><pre class="screen">
EXPLAIN SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 10 AND t2.unique2 &lt; 10 AND t1.hundred &lt; t2.hundred;

                                         QUERY PLAN
---------------------------------------------------------------------------------------------
 Nested Loop  (cost=4.65..49.46 rows=33 width=488)
   Join Filter: (t1.hundred &lt; t2.hundred)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 width=244)
         Recheck Cond: (unique1 &lt; 10)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 width=0)
               Index Cond: (unique1 &lt; 10)
   -&gt;  Materialize  (cost=0.29..8.51 rows=10 width=244)
         -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..8.46 rows=10 width=244)
               Index Cond: (unique2 &lt; 10)
</pre><p>

<span class="original">
    The condition &lt;literal&gt;t1.hundred &amp;lt; t2.hundred&lt;/literal&gt; can't be
    tested in the &lt;literal&gt;tenk2_unique2&lt;/literal&gt; index, so it's applied at the
    join node.  This reduces the estimated output row count of the join node,
    but does not change either input scan.
</span>
条件<code class="literal">t1.hundred &lt; t2.hundred</code>は<code class="literal">tenk2_unique2</code>インデックスの中では試験されません。
このため結合ノードで適用されます。
これは結合ノードの推定出力行数を減らしはしますが、入力スキャンには影響しません。
   </p><p>
<span class="original">
    Notice that here the planner has chosen to &lt;quote&gt;materialize&lt;/quote&gt; the inner
    relation of the join, by putting a Materialize plan node atop it.  This
    means that the &lt;literal&gt;t2&lt;/literal&gt; index scan will be done just once, even
    though the nested-loop join node needs to read that data ten times, once
    for each row from the outer relation.  The Materialize node saves the data
    in memory as it's read, and then returns the data from memory on each
    subsequent pass.
</span>
ここではプランナが、具体化計画ノードをその上に挿入することで、結合の内部リレーションの<span class="quote">「<span class="quote">具体化</span>」</span>を選択していることに注意してください。
これは、たとえネステッドループ結合ノードが外部リレーションから各行につき一度、そのデータを10回読む必要があったとしても、<code class="literal">t2</code>インデックススキャンが一度だけ行なわれることを意味します。
具体化ノードはそのデータを読んだときにメモリに保存し、その後の読み出しではそのデータをメモリから返します。
   </p><p>
<span class="original">
    When dealing with outer joins, you might see join plan nodes with both
    &lt;quote&gt;Join Filter&lt;/quote&gt; and plain &lt;quote&gt;Filter&lt;/quote&gt; conditions attached.
    Join Filter conditions come from the outer join's &lt;literal&gt;ON&lt;/literal&gt; clause,
    so a row that fails the Join Filter condition could still get emitted as
    a null-extended row.  But a plain Filter condition is applied after the
    outer-join rules and so acts to remove rows unconditionally.  In an inner
    join there is no semantic difference between these types of filters.
</span>
外部結合を扱う時、<span class="quote">「<span class="quote">結合フィルタ</span>」</span>および通常の<span class="quote">「<span class="quote">フィルタ</span>」</span>の両方が付随する結合計画ノードが現れる可能性があります。
結合フィルタ条件は外部結合の<code class="literal">ON</code>句を元にしますので、結合フィルタ条件に合わない行がNULLで展開された行として発行され続けます。
しかし通常のフィルタ条件が外部結合規則の後に適用され、条件に合わない行は削除されます。
内部結合では、これらのフィルタ種類の間に意味的な違いはありません。
   </p><p>
<span class="original">
    If we change the query's selectivity a bit, we might get a very different
    join plan:
</span>
問い合わせの選択性を少し変更すると、非常に異なる結合計画が得られるかもしれません。

</p><pre class="screen">
EXPLAIN SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;

                                        QUERY PLAN
------------------------------------------------------------------------------------------
 Hash Join  (cost=230.47..713.98 rows=101 width=488)
   Hash Cond: (t2.unique2 = t1.unique2)
   -&gt;  Seq Scan on tenk2 t2  (cost=0.00..445.00 rows=10000 width=244)
   -&gt;  Hash  (cost=229.20..229.20 rows=101 width=244)
         -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=5.07..229.20 rows=101 width=244)
               Recheck Cond: (unique1 &lt; 100)
               -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0)
                     Index Cond: (unique1 &lt; 100)
</pre><p>
   </p><p>
<span class="original">
    Here, the planner has chosen to use a hash join, in which rows of one
    table are entered into an in-memory hash table, after which the other
    table is scanned and the hash table is probed for matches to each row.
    Again note how the indentation reflects the plan structure: the bitmap
    scan on &lt;literal&gt;tenk1&lt;/literal&gt; is the input to the Hash node, which constructs
    the hash table.  That's then returned to the Hash Join node, which reads
    rows from its outer child plan and searches the hash table for each one.
</span>
ここでプランナはハッシュ結合の使用を選択しました。
片方のテーブルの行がメモリ内のハッシュテーブルに格納され、もう片方のテーブルがスキャンされた後、各行に対して一致するかどうかハッシュテーブルを探索します。
繰り返しますが、インデント付けにより計画の構造が表されます。
<code class="literal">tenk1</code>に対するビットマップスキャンはハッシュノードへの入力です。
外部の子計画から行を読み取り、各行に対してハッシュテーブルを検索します。
   </p><p>
<span class="original">
    Another possible type of join is a merge join, illustrated here:
</span>
他にも、以下に示すようなマージ結合という結合があり得ます。

</p><pre class="screen">
EXPLAIN SELECT *
FROM tenk1 t1, onek t2
WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;

                                        QUERY PLAN
------------------------------------------------------------------------------------------
 Merge Join  (cost=198.11..268.19 rows=10 width=488)
   Merge Cond: (t1.unique2 = t2.unique2)
   -&gt;  Index Scan using tenk1_unique2 on tenk1 t1  (cost=0.29..656.28 rows=101 width=244)
         Filter: (unique1 &lt; 100)
   -&gt;  Sort  (cost=197.83..200.33 rows=1000 width=244)
         Sort Key: t2.unique2
         -&gt;  Seq Scan on onek t2  (cost=0.00..148.00 rows=1000 width=244)
</pre><p>
   </p><p>
<span class="original">
    Merge join requires its input data to be sorted on the join keys.  In this
    plan the &lt;literal&gt;tenk1&lt;/literal&gt; data is sorted by using an index scan to visit
    the rows in the correct order, but a sequential scan and sort is preferred
    for &lt;literal&gt;onek&lt;/literal&gt;, because there are many more rows to be visited in
    that table.
    (Sequential-scan-and-sort frequently beats an index scan for sorting many rows,
    because of the nonsequential disk access required by the index scan.)
</span>
マージ結合は、結合キーでソートされる入力データを必要とします。
この計画では、正確な順序で行をアクセスするために<code class="literal">tenk1</code>データがインデックススキャンを用いてソートされます。
しかし、このテーブルの中でより多くの行がアクセスされるため、<code class="literal">onek</code>ではシーケンシャルスキャンとソートが好まれています。
（多くの行をソートする場合、インデックススキャンでは非シーケンシャルなディスクアクセスが必要となるため、シーケンシャルスキャンとソートの方がインデックススキャンより優れています。）
   </p><p>
<span class="original">
    One way to look at variant plans is to force the planner to disregard
    whatever strategy it thought was the cheapest, using the enable/disable
    flags described in &lt;xref linkend="runtime-config-query-enable"/&gt;.
    (This is a crude tool, but useful.  See
    also &lt;xref linkend="explicit-joins"/&gt;.)
    For example, if we're unconvinced that sequential-scan-and-sort is the best way to
    deal with table &lt;literal&gt;onek&lt;/literal&gt; in the previous example, we could try
</span>
<a class="xref" href="runtime-config-query.html#RUNTIME-CONFIG-QUERY-ENABLE" title="19.7.1. プランナメソッド設定">19.7.1</a>に記載したenable/disableフラグを使用して、プランナが最も良いと考えている戦略を強制的に無視させる方法により、異なった計画を観察することができます。
（非常に原始的なツールですが、利用価値があります。
<a class="xref" href="explicit-joins.html" title="14.3. 明示的なJOIN句でプランナを制御する">14.3</a>も参照してください。）
例えば、前の例にて<code class="literal">onek</code>テーブルを扱う最善の方法がシーケンシャルスキャンとソートであると納得できなければ、以下を試みることができます。

</p><pre class="screen">
SET enable_sort = off;

EXPLAIN SELECT *
FROM tenk1 t1, onek t2
WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;

                                        QUERY PLAN
------------------------------------------------------------------------------------------
 Merge Join  (cost=0.56..292.65 rows=10 width=488)
   Merge Cond: (t1.unique2 = t2.unique2)
   -&gt;  Index Scan using tenk1_unique2 on tenk1 t1  (cost=0.29..656.28 rows=101 width=244)
         Filter: (unique1 &lt; 100)
   -&gt;  Index Scan using onek_unique2 on onek t2  (cost=0.28..224.79 rows=1000 width=244)
</pre><p>

<span class="original">
    which shows that the planner thinks that sorting &lt;literal&gt;onek&lt;/literal&gt; by
    index-scanning is about 12% more expensive than sequential-scan-and-sort.
    Of course, the next question is whether it's right about that.
    We can investigate that using &lt;command&gt;EXPLAIN ANALYZE&lt;/command&gt;, as discussed
    below.
</span>
これは、プランナが、シーケンシャルスキャンとソートよりインデックススキャンによる<code class="literal">onek</code>のソート処理がおよそ12%程高価であるとみなしたことを示します。
当然ながら、次の疑問はこれが正しいかどうかでしょう。
後で説明する<code class="command">EXPLAIN ANALYZE</code>を使用することで調査することができます。
   </p></div><div class="sect2" id="USING-EXPLAIN-ANALYZE"><div class="titlepage"><div><div><h3 class="title">14.1.2. <code class="command">EXPLAIN ANALYZE</code></h3></div></div></div><p>
<span class="original">
    It is possible to check the accuracy of the planner's estimates
    by using &lt;command&gt;EXPLAIN&lt;/command&gt;'s &lt;literal&gt;ANALYZE&lt;/literal&gt; option.  With this
    option, &lt;command&gt;EXPLAIN&lt;/command&gt; actually executes the query, and then displays
    the true row counts and true run time accumulated within each plan node,
    along with the same estimates that a plain &lt;command&gt;EXPLAIN&lt;/command&gt;
    shows.  For example, we might get a result like this:
</span>
<code class="command">EXPLAIN</code>の<code class="literal">ANALYZE</code>オプションを使用して、プランナが推定するコストの精度を点検することができます。
このオプションを付けると<code class="command">EXPLAIN</code>は実際にその問い合わせを実行し、計画ノードごとに実際の行数と要した実際の実行時間を、普通の<code class="command">EXPLAIN</code>が示すものと同じ推定値と一緒に表示します。
例えば、以下のような結果を得ることができます。

</p><pre class="screen">
EXPLAIN ANALYZE SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2;

                                                           QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=4.65..118.62 rows=10 width=488) (actual time=0.128..0.377 rows=10 loops=1)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 width=244) (actual time=0.057..0.121 rows=10 loops=1)
         Recheck Cond: (unique1 &lt; 10)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 width=0) (actual time=0.024..0.024 rows=10 loops=1)
               Index Cond: (unique1 &lt; 10)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..7.91 rows=1 width=244) (actual time=0.021..0.022 rows=1 loops=10)
         Index Cond: (unique2 = t1.unique2)
 Planning time: 0.181 ms
 Execution time: 0.501 ms
</pre><p>

<span class="original">
    Note that the &lt;quote&gt;actual time&lt;/quote&gt; values are in milliseconds of
    real time, whereas the &lt;literal&gt;cost&lt;/literal&gt; estimates are expressed in
    arbitrary units; so they are unlikely to match up.
    The thing that's usually most important to look for is whether the
    estimated row counts are reasonably close to reality.  In this example
    the estimates were all dead-on, but that's quite unusual in practice.
</span>
<span class="quote">「<span class="quote">actual time</span>」</span>値は実時間をミリ秒単位で表されていること、<code class="literal">cost</code>推定値は何らかの単位で表されていることに注意してください。
ですからそのまま比較することはできません。
注目すべきもっとも重要な点は通常、推定行数が実際の値と合理的に近いかどうかです。
この例では、推定はすべて正確ですが、現実的にはあまりありません。
   </p><p>
<span class="original">
    In some query plans, it is possible for a subplan node to be executed more
    than once.  For example, the inner index scan will be executed once per
    outer row in the above nested-loop plan.  In such cases, the
    &lt;literal&gt;loops&lt;/literal&gt; value reports the
    total number of executions of the node, and the actual time and rows
    values shown are averages per-execution.  This is done to make the numbers
    comparable with the way that the cost estimates are shown.  Multiply by
    the &lt;literal&gt;loops&lt;/literal&gt; value to get the total time actually spent in
    the node.  In the above example, we spent a total of 0.220 milliseconds
    executing the index scans on &lt;literal&gt;tenk2&lt;/literal&gt;.
</span>
問い合わせ計画の中には、何回も副計画ノードを実行する可能性のあるものがあります。
例えば、上述のネステッドループの計画では、内部インデックススキャンは外部の行ごとに一度行われます。
このような場合、<code class="literal">loops</code>値はそのノードを実行する総回数を報告し、表示される実際の時間と行数は1実行当たりの平均です。
これで値を表示された推定コストと比較できるようになります。
<code class="literal">loops</code>値をかけることで、そのノードで実際に費やされた総時間を得ることができます。
上の例では、<code class="literal">tenk2</code>に対するインデックススキャンの実行のために合計0.220ミリ秒要しています。
   </p><p>
<span class="original">
    In some cases &lt;command&gt;EXPLAIN ANALYZE&lt;/command&gt; shows additional execution
    statistics beyond the plan node execution times and row counts.
    For example, Sort and Hash nodes provide extra information:
</span>
場合によっては、<code class="command">EXPLAIN ANALYZE</code>は計画ノードの実行時間と行数以上の実行統計情報をさらに表示します。
例えば、ソートとハッシュノードでは以下のような追加情報を提供します。

</p><pre class="screen">
EXPLAIN ANALYZE SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2 ORDER BY t1.fivethous;

                                                                 QUERY PLAN
--------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=717.34..717.59 rows=101 width=488) (actual time=7.761..7.774 rows=100 loops=1)
   Sort Key: t1.fivethous
   Sort Method: quicksort  Memory: 77kB
   -&gt;  Hash Join  (cost=230.47..713.98 rows=101 width=488) (actual time=0.711..7.427 rows=100 loops=1)
         Hash Cond: (t2.unique2 = t1.unique2)
         -&gt;  Seq Scan on tenk2 t2  (cost=0.00..445.00 rows=10000 width=244) (actual time=0.007..2.583 rows=10000 loops=1)
         -&gt;  Hash  (cost=229.20..229.20 rows=101 width=244) (actual time=0.659..0.659 rows=100 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 28kB
               -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=5.07..229.20 rows=101 width=244) (actual time=0.080..0.526 rows=100 loops=1)
                     Recheck Cond: (unique1 &lt; 100)
                     -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0) (actual time=0.049..0.049 rows=100 loops=1)
                           Index Cond: (unique1 &lt; 100)
 Planning time: 0.194 ms
 Execution time: 8.008 ms
</pre><p>

<span class="original">
    The Sort node shows the sort method used (in particular, whether the sort
    was in-memory or on-disk) and the amount of memory or disk space needed.
    The Hash node shows the number of hash buckets and batches as well as the
    peak amount of memory used for the hash table.  (If the number of batches
    exceeds one, there will also be disk space usage involved, but that is not
    shown.)
</span>
ソートノードは使用されるソート方式（具体的にはソートがメモリ内かディスク上か）および必要なメモリまたはディスクの容量を表示します。
ハッシュノードでは、ハッシュバケット数とバッチ数、ハッシュテーブルで使用されるメモリのピーク容量が表示されます。
（バッチ数が１を超える場合、同時にディスクの使用容量も含まれますが、表示はされません。）
   </p><p>
<span class="original">
    Another type of extra information is the number of rows removed by a
    filter condition:
</span>
他の種類の追加情報はフィルタ条件によって除外される行数があります。

</p><pre class="screen">
EXPLAIN ANALYZE SELECT * FROM tenk1 WHERE ten &lt; 7;

                                               QUERY PLAN
---------------------------------------------------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=7000 width=244) (actual time=0.016..5.107 rows=7000 loops=1)
   Filter: (ten &lt; 7)
   Rows Removed by Filter: 3000
 Planning time: 0.083 ms
 Execution time: 5.905 ms
</pre><p>

<span class="original">
    These counts can be particularly valuable for filter conditions applied at
    join nodes.  The &lt;quote&gt;Rows Removed&lt;/quote&gt; line only appears when at least
    one scanned row, or potential join pair in the case of a join node,
    is rejected by the filter condition.
</span>
特に結合ノードで適用されるフィルタ条件ではこれらの数が有用です。
<span class="quote">「<span class="quote">Rows Removed</span>」</span>行は、少なくともスキャンされた１行、結合ノードにおける結合組み合わせの可能性がフィルタ条件によって拒絶された時にのみ現れます。
   </p><p>
<span class="original">
    A case similar to filter conditions occurs with &lt;quote&gt;lossy&lt;/quote&gt;
    index scans.  For example, consider this search for polygons containing a
    specific point:
</span>
<span class="quote">「<span class="quote">非可逆</span>」</span>インデックススキャンはフィルタ条件に似た状況です。
例えば、特定の点を含有する多角形の検索を考えてみます。

</p><pre class="screen">
EXPLAIN ANALYZE SELECT * FROM polygon_tbl WHERE f1 @&gt; polygon '(0.5,2.0)';

                                              QUERY PLAN
------------------------------------------------------------------------------------------------------
 Seq Scan on polygon_tbl  (cost=0.00..1.05 rows=1 width=32) (actual time=0.044..0.044 rows=0 loops=1)
   Filter: (f1 @&gt; '((0.5,2))'::polygon)
   Rows Removed by Filter: 4
 Planning time: 0.040 ms
 Execution time: 0.083 ms
</pre><p>

<span class="original">
    The planner thinks (quite correctly) that this sample table is too small
    to bother with an index scan, so we have a plain sequential scan in which
    all the rows got rejected by the filter condition.  But if we force an
    index scan to be used, we see:
</span>
プランナは（ほぼ正確に）、インデックススキャンを考慮するには例のテーブルが小さ過ぎるとみなします。
このため、フィルタ条件によってすべての行が拒絶される、普通のシーケンシャルスキャンとなります。
しかしインデックススキャンの使用を強制するのであれば、以下のようにします。

</p><pre class="screen">
SET enable_seqscan TO off;

EXPLAIN ANALYZE SELECT * FROM polygon_tbl WHERE f1 @&gt; polygon '(0.5,2.0)';

                                                        QUERY PLAN
--------------------------------------------------------------------------------------------------------------------------
 Index Scan using gpolygonind on polygon_tbl  (cost=0.13..8.15 rows=1 width=32) (actual time=0.062..0.062 rows=0 loops=1)
   Index Cond: (f1 @&gt; '((0.5,2))'::polygon)
   Rows Removed by Index Recheck: 1
 Planning time: 0.034 ms
 Execution time: 0.144 ms
</pre><p>

<span class="original">
    Here we can see that the index returned one candidate row, which was
    then rejected by a recheck of the index condition.  This happens because a
    GiST index is &lt;quote&gt;lossy&lt;/quote&gt; for polygon containment tests: it actually
    returns the rows with polygons that overlap the target, and then we have
    to do the exact containment test on those rows.
</span>
ここで、インデックスが１つの候補行を返し、それがインデックス条件の再検査により拒絶されることが分かります。
多角形の含有試験ではGiSTインデックスが<span class="quote">「<span class="quote">非可逆</span>」</span>であるため、これは発生します。
実際には対象と重なる多角形を持つ行を返し、そしてこれらの行が正確に含有関係であることを試験しなければなりません。
   </p><p>
<span class="original">
    &lt;command&gt;EXPLAIN&lt;/command&gt; has a &lt;literal&gt;BUFFERS&lt;/literal&gt; option that can be used with
    &lt;literal&gt;ANALYZE&lt;/literal&gt; to get even more run time statistics:
</span>
<code class="command">EXPLAIN</code>には、より多くの実行時統計情報を取り出すために、<code class="literal">ANALYZE</code>に付与できる<code class="literal">BUFFERS</code>オプションがあります。

</p><pre class="screen">
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000;

                                                           QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=25.08..60.21 rows=10 width=244) (actual time=0.323..0.342 rows=10 loops=1)
   Recheck Cond: ((unique1 &lt; 100) AND (unique2 &gt; 9000))
   Buffers: shared hit=15
   -&gt;  BitmapAnd  (cost=25.08..25.08 rows=10 width=0) (actual time=0.309..0.309 rows=0 loops=1)
         Buffers: shared hit=7
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0) (actual time=0.043..0.043 rows=100 loops=1)
               Index Cond: (unique1 &lt; 100)
               Buffers: shared hit=2
         -&gt;  Bitmap Index Scan on tenk1_unique2  (cost=0.00..19.78 rows=999 width=0) (actual time=0.227..0.227 rows=999 loops=1)
               Index Cond: (unique2 &gt; 9000)
               Buffers: shared hit=5
 Planning time: 0.088 ms
 Execution time: 0.423 ms
</pre><p>

<span class="original">
    The numbers provided by &lt;literal&gt;BUFFERS&lt;/literal&gt; help to identify which parts
    of the query are the most I/O-intensive.
</span>
<code class="literal">BUFFERS</code>により提供される数は、問い合わせのどの部分がもっとも大きいI/Oであるかを識別する役に立ちます。
   </p><p>
<span class="original">
    Keep in mind that because &lt;command&gt;EXPLAIN ANALYZE&lt;/command&gt; actually
    runs the query, any side-effects will happen as usual, even though
    whatever results the query might output are discarded in favor of
    printing the &lt;command&gt;EXPLAIN&lt;/command&gt; data.  If you want to analyze a
    data-modifying query without changing your tables, you can
    roll the command back afterwards, for example:
</span>
<code class="command">EXPLAIN ANALYZE</code>が実際に問い合わせを実行しますので、<code class="command">EXPLAIN</code>のデータを出力することを優先して問い合わせの出力が破棄されたとしても、何らかの副作用が通常通り発生することに注意してください。
テーブルを変更すること無くデータ変更問い合わせの解析を行いたければ、以下の例のように、実行後コマンドをロールバックしてください。

</p><pre class="screen">
BEGIN;

EXPLAIN ANALYZE UPDATE tenk1 SET hundred = hundred + 1 WHERE unique1 &lt; 100;

                                                           QUERY PLAN
--------------------------------------------------------------------------------------------------------------------------------
 Update on tenk1  (cost=5.07..229.46 rows=101 width=250) (actual time=14.628..14.628 rows=0 loops=1)
   -&gt;  Bitmap Heap Scan on tenk1  (cost=5.07..229.46 rows=101 width=250) (actual time=0.101..0.439 rows=100 loops=1)
         Recheck Cond: (unique1 &lt; 100)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0) (actual time=0.043..0.043 rows=100 loops=1)
               Index Cond: (unique1 &lt; 100)
 Planning time: 0.079 ms
 Execution time: 14.727 ms

ROLLBACK;
</pre><p>
   </p><p>
<span class="original">
    As seen in this example, when the query is an &lt;command&gt;INSERT&lt;/command&gt;,
    &lt;command&gt;UPDATE&lt;/command&gt;, or &lt;command&gt;DELETE&lt;/command&gt; command, the actual work of
    applying the table changes is done by a top-level Insert, Update,
    or Delete plan node.  The plan nodes underneath this node perform
    the work of locating the old rows and/or computing the new data.
    So above, we see the same sort of bitmap table scan we've seen already,
    and its output is fed to an Update node that stores the updated rows.
    It's worth noting that although the data-modifying node can take a
    considerable amount of run time (here, it's consuming the lion's share
    of the time), the planner does not currently add anything to the cost
    estimates to account for that work.  That's because the work to be done is
    the same for every correct query plan, so it doesn't affect planning
    decisions.
</span>
この例で分かるように、問い合わせが<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>である場合、テーブル変更を行うための実作業は最上位のInsert、Update、Delete計画ノードで行われます。
このノード以下にある計画ノードは、古い行の検索、新しいデータの計算、あるいはその両方を行います。
このため、前に述べたものと同じ種類のビットマップテーブルスキャンがあり、その出力が更新される行を格納するUpdateノードに渡されることが分かります。
データ変更ノードが実行時間の多くを費やす可能性があります（現在これが一番多くの時間を費やしています）が、プランナは現在その作業を考慮してコスト推定に何も加えません。
これは、行われる作業がすべての正確な問い合わせ計画の作業と同一であるためであり、このため計画の決定に影響を与えません。
   </p><p>
<span class="original">
    When an &lt;command&gt;UPDATE&lt;/command&gt; or &lt;command&gt;DELETE&lt;/command&gt; command affects an
    inheritance hierarchy, the output might look like this:
</span>
<code class="command">UPDATE</code>もしくは<code class="command">DELETE</code>コマンドが継承階層に影響する場合には、出力は以下のようになるでしょう。

</p><pre class="screen">
EXPLAIN UPDATE parent SET f2 = f2 + 1 WHERE f1 = 101;
                                    QUERY PLAN
-----------------------------------------------------------------------------------
 Update on parent  (cost=0.00..24.53 rows=4 width=14)
   Update on parent
   Update on child1
   Update on child2
   Update on child3
   -&gt;  Seq Scan on parent  (cost=0.00..0.00 rows=1 width=14)
         Filter: (f1 = 101)
   -&gt;  Index Scan using child1_f1_key on child1  (cost=0.15..8.17 rows=1 width=14)
         Index Cond: (f1 = 101)
   -&gt;  Index Scan using child2_f1_key on child2  (cost=0.15..8.17 rows=1 width=14)
         Index Cond: (f1 = 101)
   -&gt;  Index Scan using child3_f1_key on child3  (cost=0.15..8.17 rows=1 width=14)
         Index Cond: (f1 = 101)
</pre><p>

<span class="original">
    In this example the Update node needs to consider three child tables as
    well as the originally-mentioned parent table.  So there are four input
    scanning subplans, one per table.  For clarity, the Update node is
    annotated to show the specific target tables that will be updated, in the
    same order as the corresponding subplans.  (These annotations are new as
    of &lt;productname&gt;PostgreSQL&lt;/productname&gt; 9.5; in prior versions the reader had to
    intuit the target tables by inspecting the subplans.)
</span>
この例では、Updateノードは元々言及されている親テーブルに加えて3つの子テーブルを考慮することが必要です。
そのため、テーブル毎に1つ、4つの入力スキャン副計画があります。
明確にするため、Updateノードには対応する副計画と同じ順に更新される特定の対象テーブルを示す注釈が付けられています。
(この注釈は<span class="productname">PostgreSQL</span> 9.5からの新しいものです。以前のバージョンでは副計画を調べることで対象テーブルを勘で当てなければなりませんでした。)
   </p><p>
<span class="original">
    The &lt;literal&gt;Planning time&lt;/literal&gt; shown by &lt;command&gt;EXPLAIN
    ANALYZE&lt;/command&gt; is the time it took to generate the query plan from the
    parsed query and optimize it. It does not include parsing or rewriting.
</span>
<code class="command">EXPLAIN ANALYZE</code>で表示される<code class="literal">Planning time</code>は、解析された問い合わせから問い合わせ計画を生成し最適化するのに掛かった時間です。
解析と書き換えは含みません。
   </p><p>
<span class="original">
    The &lt;literal&gt;Execution time&lt;/literal&gt; shown by &lt;command&gt;EXPLAIN
    ANALYZE&lt;/command&gt; includes executor start-up and shut-down time, as well
    as the time to run any triggers that are fired, but it does not include
    parsing, rewriting, or planning time.
    Time spent executing &lt;literal&gt;BEFORE&lt;/literal&gt; triggers, if any, is included in
    the time for the related Insert, Update, or Delete node; but time
    spent executing &lt;literal&gt;AFTER&lt;/literal&gt; triggers is not counted there because
    &lt;literal&gt;AFTER&lt;/literal&gt; triggers are fired after completion of the whole plan.
    The total time spent in each trigger
    (either &lt;literal&gt;BEFORE&lt;/literal&gt; or &lt;literal&gt;AFTER&lt;/literal&gt;) is also shown separately.
    Note that deferred constraint triggers will not be executed
    until end of transaction and are thus not considered at all by
    &lt;command&gt;EXPLAIN ANALYZE&lt;/command&gt;.
</span>
<code class="command">EXPLAIN ANALYZE</code>で表示される<code class="literal">Execution time</code>（実行時間）にはエクゼキュータの起動、停止時間、発行される何らかのトリガの実行時間も含まれますが、解析や書き換え、計画作成の時間は含まれません。
<code class="literal">BEFORE</code>トリガがあればその実行時間は関連するInsert、Update、Deleteノード用の時間に含まれます。
しかし、<code class="literal">AFTER</code>トリガは計画全体が完了した後に発行されますので、<code class="literal">AFTER</code>トリガの実行時間は計上されません。
また、各トリガ（<code class="literal">BEFORE</code>、<code class="literal">AFTER</code>のいずれか）で費やされる総時間は別々に表示されます。
しかし、遅延制約トリガはトランザクションが終わるまで実行されませんので、<code class="command">EXPLAIN ANALYZE</code>では考慮されないことに注意してください。
   </p></div><div class="sect2" id="USING-EXPLAIN-CAVEATS"><div class="titlepage"><div><div><h3 class="title">14.1.3. 警告</h3></div></div></div><span class="original">
   &lt;title&gt;Caveats&lt;/title&gt;
</span><p>
<span class="original">
    There are two significant ways in which run times measured by
    &lt;command&gt;EXPLAIN ANALYZE&lt;/command&gt; can deviate from normal execution of
    the same query.  First, since no output rows are delivered to the client,
    network transmission costs and I/O conversion costs are not included.
    Second, the measurement overhead added by &lt;command&gt;EXPLAIN
    ANALYZE&lt;/command&gt; can be significant, especially on machines with slow
    &lt;function&gt;gettimeofday()&lt;/function&gt; operating-system calls. You can use the
    &lt;xref linkend="pgtesttiming"/&gt; tool to measure the overhead of timing
    on your system.
</span>
<code class="command">EXPLAIN ANALYZE</code>により測定される実行時間が同じ問い合わせを普通に実行する場合と大きくそれる可能性がある、２つの重大な点があります。
１つ目は、出力行がクライアントに配信されませんので、ネットワーク転送コストとI/O変換に関するコストが含まれないことです。
２つ目は、<code class="command">EXPLAIN ANALYZE</code>によって加わる測定オーバーヘッドが大きくなることが、特に<code class="function">gettimeofday()</code>オペレーティングシステムコールが低速なマシンであり得ることです。
<a class="xref" href="pgtesttiming.html" title="pg_test_timing"><span class="refentrytitle"><span class="application">pg_test_timing</span></span></a>を用いて、使用中のシステムの時間測定にかかるオーバーヘッドを測ることができます。
   </p><p>
<span class="original">
    &lt;command&gt;EXPLAIN&lt;/command&gt; results should not be extrapolated to situations
    much different from the one you are actually testing; for example,
    results on a toy-sized table cannot be assumed to apply to large tables.
    The planner's cost estimates are not linear and so it might choose
    a different plan for a larger or smaller table.  An extreme example
    is that on a table that only occupies one disk page, you'll nearly
    always get a sequential scan plan whether indexes are available or not.
    The planner realizes that it's going to take one disk page read to
    process the table in any case, so there's no value in expending additional
    page reads to look at an index.  (We saw this happening in the
    &lt;literal&gt;polygon_tbl&lt;/literal&gt; example above.)
</span>
<code class="command">EXPLAIN</code>の結果を試験を行ったものと大きく異なる状況の推定に使ってはいけません。
例えば、小さなテーブルの結果は、巨大なテーブルに適用できるとは仮定できません。
プランナの推定コストは線形ではなく、そのため、テーブルの大小によって異なる計画を選択する可能性があります。
極端な例ですが、テーブルが1ディスクページしか占めない場合、インデックスが使用できる、できないに関係なく、ほとんど常にシーケンシャルスキャン計画を得ることになります。
プランナは、どのような場合でもテーブルを処理するために1ディスクページ読み取りを行うので、インデックスを参照するための追加的ページ読み取りを行う価値がないことを知っています。
（上述の<code class="literal">polygon_tbl</code>の例でこれが起こることを示しています。）
   </p><p>
<span class="original">
    There are cases in which the actual and estimated values won't match up
    well, but nothing is really wrong.  One such case occurs when
    plan node execution is stopped short by a &lt;literal&gt;LIMIT&lt;/literal&gt; or similar
    effect.  For example, in the &lt;literal&gt;LIMIT&lt;/literal&gt; query we used before,
</span>
実際の値と推定値がうまく合わないが本当は間違ったものがない場合があります。
こうした状況の１つは、<code class="literal">LIMIT</code>や同様な効果により計画ノードの実行が短時間で終わる時に起こります。
例えば、以前に使用した<code class="literal">LIMIT</code>問い合わせでは

</p><pre class="screen">
EXPLAIN ANALYZE SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000 LIMIT 2;

                                                          QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..14.71 rows=2 width=244) (actual time=0.177..0.249 rows=2 loops=1)
   -&gt;  Index Scan using tenk1_unique2 on tenk1  (cost=0.29..72.42 rows=10 width=244) (actual time=0.174..0.244 rows=2 loops=1)
         Index Cond: (unique2 &gt; 9000)
         Filter: (unique1 &lt; 100)
         Rows Removed by Filter: 287
 Planning time: 0.096 ms
 Execution time: 0.336 ms
</pre><p>

<span class="original">
    the estimated cost and row count for the Index Scan node are shown as
    though it were run to completion.  But in reality the Limit node stopped
    requesting rows after it got two, so the actual row count is only 2 and
    the run time is less than the cost estimate would suggest.  This is not
    an estimation error, only a discrepancy in the way the estimates and true
    values are displayed.
</span>
インデックススキャンノードの推定コストと行数が実行完了したかのように表示されます。
しかし現実では、Limitノードが２行を取り出した後に行の要求を停止します。
このため実際の行数は２行のみであり、実行時間は提示された推定コストより小さくなります。
これは推定間違いではなく、単なる推定値と本当の値を表示する方法における矛盾です。
   </p><p>
<span class="original">
    Merge joins also have measurement artifacts that can confuse the unwary.
    A merge join will stop reading one input if it's exhausted the other input
    and the next key value in the one input is greater than the last key value
    of the other input; in such a case there can be no more matches and so no
    need to scan the rest of the first input.  This results in not reading all
    of one child, with results like those mentioned for &lt;literal&gt;LIMIT&lt;/literal&gt;.
    Also, if the outer (first) child contains rows with duplicate key values,
    the inner (second) child is backed up and rescanned for the portion of its
    rows matching that key value.  &lt;command&gt;EXPLAIN ANALYZE&lt;/command&gt; counts these
    repeated emissions of the same inner rows as if they were real additional
    rows.  When there are many outer duplicates, the reported actual row count
    for the inner child plan node can be significantly larger than the number
    of rows that are actually in the inner relation.
</span>
またマージ結合には、注意しないと混乱を招く測定上の乱れがあります。
マージ結合は他の入力が使い尽くされ、ある入力の次のキー値が他の入力の最後のキー値より大きい場合、その入力の読み取りを停止します。
このような場合、これ以上一致することはあり得ず、最初の入力の残りをスキャンする必要がありません。
この結果、子のすべては読み取られず、<code class="literal">LIMIT</code>の説明のようになります。
また、外部（最初）の子が重複するキー値を持つ行を含む場合、内部（２番目）の子はバックアップされ、そのキー値が一致する行部分を再度スキャンされます。
<code class="command">EXPLAIN ANALYZE</code>はこうした繰り返される同じ内部行の排出を実際の追加される行と同様に計上します。
外部で多くの重複がある場合、内部の子計画ノードで繰り返される実際の行数は、内部リレーションにおける実際の行数より非常に多くなることがあり得ます。
   </p><p>
<span class="original">
    BitmapAnd and BitmapOr nodes always report their actual row counts as zero,
    due to implementation limitations.
</span>
実装上の制限のため、BitmapAndおよびBitmapOrノードは常に実際の行数をゼロと報告します。
   </p><p>
<span class="original">
    Generally, the &lt;command&gt;EXPLAIN&lt;/command&gt; output will display details for
    every plan node which was generated by the query planner.  However, there
    are cases where the executor is able to determine that certain nodes are
    not required; currently, the only node type to support this is the
    &lt;literal&gt;Append&lt;/literal&gt; node.  This node type has the ability to discard
    subnodes which it is able to determine won't contain any records required
    by the query.  It is possible to determine that nodes have been removed in
    this way by the presence of a "Subplans Removed" property in the
    &lt;command&gt;EXPLAIN&lt;/command&gt; output.
</span>
一般に、<code class="command">EXPLAIN</code>の出力は、問い合わせプランナが生成したすべてのプランの詳細を表示します。
しかし、あるノードをエクゼキューターが不要であると判断できるケースがあります。
今の所、これができるのは<code class="literal">Append</code>ノードだけです。
このノード型では、問い合わせで必要となるレコードを下位ノードが含んでいないことを決定し、それらを廃棄することができます。
このようにしてノードが削除されたことを、<code class="command">EXPLAIN</code>出力の中に"Subplans Removed"という属性が存在することによって確認することができます。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="performance-tips.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="performance-tips.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="planner-stats.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第14章 性能に関するヒント </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 14.2. プランナで使用される統計情報</td></tr></table></div></body></html>