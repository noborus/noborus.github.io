<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>59.1. カスタムスキャンパスの作成</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="custom-scan.html" title="第59章 カスタムスキャンプロバイダの作成" /><link rel="next" href="custom-scan-plan.html" title="59.2. カスタムスキャン計画の作成" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 11.4文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="custom-scan.html" title="第59章 カスタムスキャンプロバイダの作成">第59章 カスタムスキャンプロバイダの作成</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 11.4 &#10;                      custom-scan-path.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="custom-scan.html" title="第59章 カスタムスキャンプロバイダの作成">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="custom-scan.html" title="第59章 カスタムスキャンプロバイダの作成">上へ</a></td><td width="60%" align="center">59.1. カスタムスキャンパスの作成</td><td width="20%" align="right"> <a accesskey="n" href="custom-scan-plan.html" title="59.2. カスタムスキャン計画の作成">次へ</a></td></tr></table><hr /></div><div class="sect1" id="CUSTOM-SCAN-PATH"><div class="titlepage"><div><div><h2 class="title" style="clear: both">59.1. カスタムスキャンパスの作成</h2></div></div></div><span class="original">
  &lt;title&gt;Creating Custom Scan Paths&lt;/title&gt;
</span><p>
<span class="original">
    A custom scan provider will typically add paths for a base relation by
    setting the following hook, which is called after the core code has
    generated all the access paths it can for the relation (except for
    Gather paths, which are made after this call so that they can use
    partial paths added by the hook):
</span>
カスタムスキャンプロバイダは、典型的には、以下のフックを設定することでベースリレーションのためのパスを追加します。
このフックはコアのコードがそのリレーションへのすべてのアクセスパスを生成した後で呼び出されます。
（フックの呼び出しの後に作成されるギャザーパス(Gather path)を除きます。フックが追加した部分パスをギャザーパスが利用できるようにするためです。）
</p><pre class="programlisting">
typedef void (*set_rel_pathlist_hook_type) (PlannerInfo *root,
                                            RelOptInfo *rel,
                                            Index rti,
                                            RangeTblEntry *rte);
extern PGDLLIMPORT set_rel_pathlist_hook_type set_rel_pathlist_hook;
</pre><p>
  </p><p>
<span class="original">
    Although this hook function can be used to examine, modify, or remove
    paths generated by the core system, a custom scan provider will typically
    confine itself to generating &lt;structname&gt;CustomPath&lt;/structname&gt; objects and adding
    them to &lt;literal&gt;rel&lt;/literal&gt; using &lt;function&gt;add_path&lt;/function&gt;.  The custom scan
    provider is responsible for initializing the &lt;structname&gt;CustomPath&lt;/structname&gt;
    object, which is declared like this:
</span>
このフックはコアシステムが生成したパスを検査し、修正し、あるいは削除するために使うことができますが、カスタムスキャンプロバイダは、典型的には<code class="structname">CustomPath</code>オブジェクトを生成し、<code class="function">add_path</code>を使ってそれを<code class="literal">rel</code>に追加することのみを行います。
カスタムスキャンプロバイダは<code class="structname">CustomPath</code>オブジェクトの初期化を担当します。
このオブジェクトは以下のように宣言されています。
</p><pre class="programlisting">
typedef struct CustomPath
{
    Path      path;
    uint32    flags;
    List     *custom_paths;
    List     *custom_private;
    const CustomPathMethods *methods;
} CustomPath;
</pre><p>
  </p><p>
<span class="original">
    &lt;structfield&gt;path&lt;/structfield&gt; must be initialized as for any other path, including
    the row-count estimate, start and total cost, and sort ordering provided
    by this path.  &lt;structfield&gt;flags&lt;/structfield&gt; is a bit mask, which should include
    &lt;literal&gt;CUSTOMPATH_SUPPORT_BACKWARD_SCAN&lt;/literal&gt; if the custom path can support
    a backward scan and &lt;literal&gt;CUSTOMPATH_SUPPORT_MARK_RESTORE&lt;/literal&gt; if it
    can support mark and restore.  Both capabilities are optional.
    An optional &lt;structfield&gt;custom_paths&lt;/structfield&gt; is a list of &lt;structname&gt;Path&lt;/structname&gt;
    nodes used by this custom-path node; these will be transformed into
    &lt;structname&gt;Plan&lt;/structname&gt; nodes by planner.
    &lt;structfield&gt;custom_private&lt;/structfield&gt; can be used to store the custom path's
    private data.  Private data should be stored in a form that can be handled
    by &lt;literal&gt;nodeToString&lt;/literal&gt;, so that debugging routines that attempt to
    print the custom path will work as designed.  &lt;structfield&gt;methods&lt;/structfield&gt; must
    point to a (usually statically allocated) object implementing the required
    custom path methods, of which there is currently only one.  The
    &lt;structfield&gt;LibraryName&lt;/structfield&gt; and &lt;structfield&gt;SymbolName&lt;/structfield&gt; fields must also
    be initialized so that the dynamic loader can resolve them to locate the
    method table.
</span>
<code class="structfield">path</code>は、他のすべてのパスと同じく、行数の推定値、開始とトータルのコスト、このパスで提供されるソート順を含めて初期化される必要があります。
<code class="structfield">flags</code>はビットマスクで、カスタムパスが逆向きスキャンをサポートできるなら<code class="literal">CUSTOMPATH_SUPPORT_BACKWARD_SCAN</code>を、マークとリストアがサポートできるなら<code class="literal">CUSTOMPATH_SUPPORT_MARK_RESTORE</code>を含めます。
いずれの機能も必須ではありません。
オプションの<code class="structfield">custom_paths</code>はこのカスタムパスのノードで使用される<code class="structname">Path</code>のノードのリストです。
プランナがこれを<code class="structname">Plan</code>のノードに変換します。
<code class="structfield">custom_private</code>はカスタムパスのプライベートデータを格納するために使うことができます。
プライベートデータは<code class="literal">nodeToString</code>が処理できるような形式で格納してください。
そうすることで、カスタムパスを出力するデバッグルーチンが設計通りに動作します。
<code class="structfield">methods</code>は要求されるカスタムパスのメソッドのオブジェクト（通常は静的に割り当てられる）を指している必要があり、現在は1つのみとなります。
<code class="structfield">LibraryName</code>フィールドと<code class="structfield">SymbolName</code>フィールドは、動的ローダがそれらのメソッドテーブルの位置を解決できるように、初期化されていなければなりません。
  </p><p>
<span class="original">
   A custom scan provider can also provide join paths.  Just as for base
   relations, such a path must produce the same output as would normally be
   produced by the join it replaces.  To do this, the join provider should
   set the following hook, and then within the hook function,
   create &lt;structname&gt;CustomPath&lt;/structname&gt; path(s) for the join relation.
</span>
カスタムスキャンプロバイダは結合(join)のパスを提供することもできます。
ベースのリレーションの場合と同様、そのようなパスは置換される結合が普通に生成したであろうものと同じ結果を生成しなければなりません。
そのために、結合のプロバイダは以下のフックをセットし、フック関数内で結合リレーション用に<code class="structname">CustomPath</code>のパスを作成します。
</p><pre class="programlisting">
typedef void (*set_join_pathlist_hook_type) (PlannerInfo *root,
                                             RelOptInfo *joinrel,
                                             RelOptInfo *outerrel,
                                             RelOptInfo *innerrel,
                                             JoinType jointype,
                                             JoinPathExtraData *extra);
extern PGDLLIMPORT set_join_pathlist_hook_type set_join_pathlist_hook;
</pre><p>

<span class="original">
   This hook will be invoked repeatedly for the same join relation, with
   different combinations of inner and outer relations; it is the
   responsibility of the hook to minimize duplicated work.
</span>
このフックは、同じ結合リレーションについて、内側あるいは外側のリレーションとの様々な組み合わせで繰り返し呼び出されます。
繰り返しの作業を最小化するのはフック側の責任です。
  </p><div class="sect2" id="CUSTOM-SCAN-PATH-CALLBACKS"><div class="titlepage"><div><div><h3 class="title">59.1.1. カスタムスキャンパスのコールバック</h3></div></div></div><span class="original">
  &lt;title&gt;Custom Scan Path Callbacks&lt;/title&gt;
</span><p>
</p><pre class="programlisting">
Plan *(*PlanCustomPath) (PlannerInfo *root,
                         RelOptInfo *rel,
                         CustomPath *best_path,
                         List *tlist,
                         List *clauses,
                         List *custom_plans);
</pre><p>
<span class="original">
    Convert a custom path to a finished plan.  The return value will generally
    be a &lt;literal&gt;CustomScan&lt;/literal&gt; object, which the callback must allocate and
    initialize.  See &lt;xref linkend="custom-scan-plan"/&gt; for more details.
</span>
カスタムパスを完成した計画に変換します。
戻り値は一般的には<code class="literal">CustomScan</code>オブジェクトで、その領域はコールバックが割り当てて初期化しなければなりません。
詳しくは<a class="xref" href="custom-scan-plan.html" title="59.2. カスタムスキャン計画の作成">59.2</a>を参照してください。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="custom-scan.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="custom-scan.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="custom-scan-plan.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第59章 カスタムスキャンプロバイダの作成 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 59.2. カスタムスキャン計画の作成</td></tr></table></div></body></html>