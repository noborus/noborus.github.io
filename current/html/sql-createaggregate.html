<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE AGGREGATE</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-create-access-method.html" title="CREATE ACCESS METHOD" /><link rel="next" href="sql-createcast.html" title="CREATE CAST" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 11.5文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="sql-commands.html" title="SQLコマンド">SQLコマンド</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 11.5 &#10;                      sql-createaggregate.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-create-access-method.html" title="CREATE ACCESS METHOD">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">上へ</a></td><td width="60%" align="center">CREATE AGGREGATE</td><td width="20%" align="right"> <a accesskey="n" href="sql-createcast.html" title="CREATE CAST">次へ</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATEAGGREGATE"><div class="titlepage"></div><a id="id-1.9.3.57.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE AGGREGATE</span></h2><p>CREATE AGGREGATE<span class="original">
  &lt;refpurpose&gt;define a new aggregate function&lt;/refpurpose&gt;
</span> — 新しい集約関数を定義する</p></div><div class="refsynopsisdiv"><h2>概要</h2><pre class="synopsis">
CREATE AGGREGATE <em class="replaceable"><code>name</code></em> ( [ <em class="replaceable"><code>argmode</code></em> ] [ <em class="replaceable"><code>argname</code></em> ] <em class="replaceable"><code>arg_data_type</code></em> [ , ... ] ) (
    SFUNC = <em class="replaceable"><code>sfunc</code></em>,
    STYPE = <em class="replaceable"><code>state_data_type</code></em>
    [ , SSPACE = <em class="replaceable"><code>state_data_size</code></em> ]
    [ , FINALFUNC = <em class="replaceable"><code>ffunc</code></em> ]
    [ , FINALFUNC_EXTRA ]
    [ , FINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , COMBINEFUNC = <em class="replaceable"><code>combinefunc</code></em> ]
    [ , SERIALFUNC = <em class="replaceable"><code>serialfunc</code></em> ]
    [ , DESERIALFUNC = <em class="replaceable"><code>deserialfunc</code></em> ]
    [ , INITCOND = <em class="replaceable"><code>initial_condition</code></em> ]
    [ , MSFUNC = <em class="replaceable"><code>msfunc</code></em> ]
    [ , MINVFUNC = <em class="replaceable"><code>minvfunc</code></em> ]
    [ , MSTYPE = <em class="replaceable"><code>mstate_data_type</code></em> ]
    [ , MSSPACE = <em class="replaceable"><code>mstate_data_size</code></em> ]
    [ , MFINALFUNC = <em class="replaceable"><code>mffunc</code></em> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MFINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , MINITCOND = <em class="replaceable"><code>minitial_condition</code></em> ]
    [ , SORTOP = <em class="replaceable"><code>sort_operator</code></em> ]
    [ , PARALLEL = { SAFE | RESTRICTED | UNSAFE } ]
)

CREATE AGGREGATE <em class="replaceable"><code>name</code></em> ( [ [ <em class="replaceable"><code>argmode</code></em> ] [ <em class="replaceable"><code>argname</code></em> ] <em class="replaceable"><code>arg_data_type</code></em> [ , ... ] ]
                        ORDER BY [ <em class="replaceable"><code>argmode</code></em> ] [ <em class="replaceable"><code>argname</code></em> ] <em class="replaceable"><code>arg_data_type</code></em> [ , ... ] ) (
    SFUNC = <em class="replaceable"><code>sfunc</code></em>,
    STYPE = <em class="replaceable"><code>state_data_type</code></em>
    [ , SSPACE = <em class="replaceable"><code>state_data_size</code></em> ]
    [ , FINALFUNC = <em class="replaceable"><code>ffunc</code></em> ]
    [ , FINALFUNC_EXTRA ]
    [ , FINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , INITCOND = <em class="replaceable"><code>initial_condition</code></em> ]
    [ , PARALLEL = { SAFE | RESTRICTED | UNSAFE } ]
    [ , HYPOTHETICAL ]
)

<span class="original">
&lt;phrase&gt;or the old syntax&lt;/phrase&gt;
</span>
<span class="phrase">または以下の旧構文</span>

CREATE AGGREGATE <em class="replaceable"><code>name</code></em> (
    BASETYPE = <em class="replaceable"><code>base_type</code></em>,
    SFUNC = <em class="replaceable"><code>sfunc</code></em>,
    STYPE = <em class="replaceable"><code>state_data_type</code></em>
    [ , SSPACE = <em class="replaceable"><code>state_data_size</code></em> ]
    [ , FINALFUNC = <em class="replaceable"><code>ffunc</code></em> ]
    [ , FINALFUNC_EXTRA ]
    [ , FINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , COMBINEFUNC = <em class="replaceable"><code>combinefunc</code></em> ]
    [ , SERIALFUNC = <em class="replaceable"><code>serialfunc</code></em> ]
    [ , DESERIALFUNC = <em class="replaceable"><code>deserialfunc</code></em> ]
    [ , INITCOND = <em class="replaceable"><code>initial_condition</code></em> ]
    [ , MSFUNC = <em class="replaceable"><code>msfunc</code></em> ]
    [ , MINVFUNC = <em class="replaceable"><code>minvfunc</code></em> ]
    [ , MSTYPE = <em class="replaceable"><code>mstate_data_type</code></em> ]
    [ , MSSPACE = <em class="replaceable"><code>mstate_data_size</code></em> ]
    [ , MFINALFUNC = <em class="replaceable"><code>mffunc</code></em> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MFINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , MINITCOND = <em class="replaceable"><code>minitial_condition</code></em> ]
    [ , SORTOP = <em class="replaceable"><code>sort_operator</code></em> ]
)
</pre></div><div class="refsect1" id="id-1.9.3.57.5"><h2>説明</h2><span class="original">
  &lt;title&gt;Description&lt;/title&gt;
</span><p>
<span class="original">
   &lt;command&gt;CREATE AGGREGATE&lt;/command&gt; defines a new aggregate
   function. Some basic and commonly-used aggregate functions are
   included with the distribution; they are documented in &lt;xref
   linkend="functions-aggregate"/&gt;. If one defines new types or needs
   an aggregate function not already provided, then &lt;command&gt;CREATE
   AGGREGATE&lt;/command&gt; can be used to provide the desired features.
</span>
<code class="command">CREATE AGGREGATE</code>は、新しい集約関数を定義します。
配布物には基本的、かつ、よく使用される集約関数がいくつか含まれています。これらの集約関数については、<a class="xref" href="functions-aggregate.html" title="9.20. 集約関数">9.20</a>に文書化されています。
新しい型を定義する場合、またはまだ提供されていない集約関数が必要な場合、必要な機能を実現するために<code class="command">CREATE AGGREGATE</code>を使うことができます。
  </p><p>
<span class="original">
   If a schema name is given (for example, &lt;literal&gt;CREATE AGGREGATE
   myschema.myagg ...&lt;/literal&gt;) then the aggregate function is created in the
   specified schema.  Otherwise it is created in the current schema.
</span>
スキーマ名が付けられている場合（例えば、<code class="literal">CREATE AGGREGATE myschema.myagg ...</code>）、集約関数は指定されたスキーマに作成されます。
スキーマ名がなければ、集約関数は現在のスキーマに作成されます。
  </p><p>
<span class="original">
   An aggregate function is identified by its name and input data type(s).
   Two aggregates in the same schema can have the same name if they operate on
   different input types.  The
   name and input data type(s) of an aggregate must also be distinct from
   the name and input data type(s) of every ordinary function in the same
   schema.
   This behavior is identical to overloading of ordinary function names
   (see &lt;xref linkend="sql-createfunction"/&gt;).
</span>
集約関数は名前と入力データ型(複数可)の組み合わせによって識別されます。
演算の対象となる入力データ型が異なっていれば、同じスキーマ内に同じ名前の集約関数があっても構いません。
1つのスキーマ内では、集約関数の名前と入力データ型の組み合わせは、通常の関数の名前と入力データ型の組み合わせと異なる必要があります。
この動作は通常の関数名についてオーバーロードする時と同じです(<a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>を参照してください)。
  </p><p>
<span class="original">
   A simple aggregate function is made from one or two ordinary
   functions:
   a state transition function
   &lt;replaceable class="parameter"&gt;sfunc&lt;/replaceable&gt;,
   and an optional final calculation function
   &lt;replaceable class="parameter"&gt;ffunc&lt;/replaceable&gt;.
   These are used as follows:
</span>
単純な集約関数は1つか2つの通常の関数から作られます。
状態遷移関数<em class="replaceable"><code>sfunc</code></em>と最終計算関数<em class="replaceable"><code>ffunc</code></em>(省略可能)です。
これらは以下のように使われます。
</p><pre class="programlisting">
<span class="original">
&lt;replaceable class="parameter"&gt;sfunc&lt;/replaceable&gt;( internal-state, next-data-values ) &amp;#045;&amp;#045;&amp;#045;&gt; next-internal-state
&lt;replaceable class="parameter"&gt;ffunc&lt;/replaceable&gt;( internal-state ) &amp;#045;&amp;#045;&amp;#045;&gt; aggregate-value
</span>
<em class="replaceable"><code>sfunc</code></em>( 内部状態, 次のデータ値 ) ---&gt; 次の内部状態
<em class="replaceable"><code>ffunc</code></em>( 内部状態 ) ---&gt; 集約の結果
</pre><p>
  </p><p>
<span class="original">
   &lt;productname&gt;PostgreSQL&lt;/productname&gt; creates a temporary variable
   of data type &lt;replaceable class="parameter"&gt;stype&lt;/replaceable&gt;
   to hold the current internal state of the aggregate.  At each input row,
   the aggregate argument value(s) are calculated and
   the state transition function is invoked with the current state value
   and the new argument value(s) to calculate a new
   internal state value.  After all the rows have been processed,
   the final function is invoked once to calculate the aggregate's return
   value.  If there is no final function then the ending state value
   is returned as-is.
</span>
<span class="productname">PostgreSQL</span>は、集約の現在の内部状態を保持する<em class="replaceable"><code>stype</code></em>データ型の一時変数を作成します。
それぞれの入力行に対して、集約引数の値が計算され、現在の状態値と新しい引数値で状態遷移関数が呼び出され、新しい内部状態変数が計算されます。
全ての行が処理されると、最終関数が1回呼び出され、集約の出力値が計算されます。
最終関数がない場合は、終了時の状態値がそのまま返されます。
  </p><p>
<span class="original">
   An aggregate function can provide an initial condition,
   that is, an initial value for the internal state value.
   This is specified and stored in the database as a value of type
   &lt;type&gt;text&lt;/type&gt;, but it must be a valid external representation
   of a constant of the state value data type.  If it is not supplied
   then the state value starts out null.
</span>
集約関数は、初期条件、つまり内部状態値の初期値を提供することができます。
これは<code class="type">text</code>型の値としてデータベースに格納されますが、状態値データ型の定数として有効な外部表現でなければいけません。
初期状態が与えられていない場合、状態値はNULLから始まります。
  </p><p>
<span class="original">
   If the state transition function is declared &lt;quote&gt;strict&lt;/quote&gt;,
   then it cannot be called with null inputs.  With such a transition
   function, aggregate execution behaves as follows.  Rows with any null input
   values are ignored (the function is not called and the previous state value
   is retained).  If the initial state value is null, then at the first row
   with all-nonnull input values, the first argument value replaces the state
   value, and the transition function is invoked at each subsequent row with
   all-nonnull input values.
   This is handy for implementing aggregates like &lt;function&gt;max&lt;/function&gt;.
   Note that this behavior is only available when
   &lt;replaceable class="parameter"&gt;state_data_type&lt;/replaceable&gt;
   is the same as the first
   &lt;replaceable class="parameter"&gt;arg_data_type&lt;/replaceable&gt;.
   When these types are different, you must supply a nonnull initial
   condition or use a nonstrict transition function.
</span>
状態遷移関数が<span class="quote">「<span class="quote">strict</span>」</span>と宣言されている場合、NULLを入力値にして呼び出すことはできません。
そのような遷移関数では、集約は次のように実行されます。
NULL入力値を持つ行は無視されます。
（関数は呼び出されず、前回の状態値が保持されます。）
初期状態値がNULLである場合、初めて入力行がすべて非NULL入力値であった時にその最初の引数の値で状態値を置き換え、以後、すべて非NULL入力値のそれぞれの行について、遷移関数が呼び出されます。
このような動作は、<code class="function">max</code>のような集約を実装するには便利です。
ただし、<em class="replaceable"><code>state_data_type</code></em>が最初の<em class="replaceable"><code>arg_data_type</code></em>と同じ時にのみ有効であることに注意してください。
これらの型が異なる時は、非NULL初期値を供給するか、strictでない遷移関数を使わなければいけません。
  </p><p>
<span class="original">
   If the state transition function is not strict, then it will be called
   unconditionally at each input row, and must deal with null inputs
   and null state values for itself.  This allows the aggregate
   author to have full control over the aggregate's handling of null values.
</span>
状態遷移関数がstrictでない場合は、それぞれの入力行に対してその関数が無条件に呼び出されるので、NULL入力とNULL状態値を自分で処理しなければいけません。
これは、関数の作成者が、集約関数におけるNULL値の扱いを完全に制御できることを意味します。
  </p><p>
<span class="original">
   If the final function is declared &lt;quote&gt;strict&lt;/quote&gt;, then it will not
   be called when the ending state value is null; instead a null result
   will be returned automatically.  (Of course this is just the normal
   behavior of strict functions.)  In any case the final function has
   the option of returning a null value.  For example, the final function for
   &lt;function&gt;avg&lt;/function&gt; returns null when it sees there were zero
   input rows.
</span>
最終関数が<span class="quote">「<span class="quote">strict</span>」</span>と宣言されていると、終了状態値がNULLの時は、最終関数が呼び出されません。
その場合、NULLという結果が自動的に出力されます
（もちろんこれは、strictな関数の一般的な動作に過ぎません）。
いずれにせよ、最終関数はNULLを返すことができます。
例えば、<code class="function">avg</code>の最終関数は、入力が0行だとわかるとNULLを返します。
  </p><p>
<span class="original">
   Sometimes it is useful to declare the final function as taking not just
   the state value, but extra parameters corresponding to the aggregate's
   input values.  The main reason for doing this is if the final function
   is polymorphic and the state value's data type would be inadequate to
   pin down the result type.  These extra parameters are always passed as
   NULL (and so the final function must not be strict when
   the &lt;literal&gt;FINALFUNC_EXTRA&lt;/literal&gt; option is used), but nonetheless they
   are valid parameters.  The final function could for example make use
   of &lt;function&gt;get_fn_expr_argtype&lt;/function&gt; to identify the actual argument type
   in the current call.
</span>
最終関数を、状態値だけでなく、集約の入力値に対応する追加パラメータも取るように宣言すると便利なことがあります。
こうすることの主な理由に、最終関数が多様型で、状態値のデータ型だけでは結果の型を決定するのに不十分である、ということがあります。
これらの追加パラメータは必ずNULLとして渡されます(従って<code class="literal">FINALFUNC_EXTRA</code>オプションが使われている場合、最終関数はstrictであってはいけません)が、それでも有効なパラメータです。
最終関数は、現在の呼び出しでの実際の引数の型を特定するために、例えば<code class="function">get_fn_expr_argtype</code>を使うことができます。
  </p><p>
<span class="original">
   An aggregate can optionally support &lt;firstterm&gt;moving-aggregate mode&lt;/firstterm&gt;,
   as described in &lt;xref linkend="xaggr-moving-aggregates"/&gt;.  This requires
   specifying the &lt;literal&gt;MSFUNC&lt;/literal&gt;, &lt;literal&gt;MINVFUNC&lt;/literal&gt;,
   and &lt;literal&gt;MSTYPE&lt;/literal&gt; parameters, and optionally
   the &lt;literal&gt;MSPACE&lt;/literal&gt;, &lt;literal&gt;MFINALFUNC&lt;/literal&gt;,
   &lt;literal&gt;MFINALFUNC_EXTRA&lt;/literal&gt;, &lt;literal&gt;MFINALFUNC_MODIFY&lt;/literal&gt;,
   and &lt;literal&gt;MINITCOND&lt;/literal&gt; parameters.  Except for &lt;literal&gt;MINVFUNC&lt;/literal&gt;,
   these parameters work like the corresponding simple-aggregate parameters
   without &lt;literal&gt;M&lt;/literal&gt;; they define a separate implementation of the
   aggregate that includes an inverse transition function.
</span>
集約は、<a class="xref" href="xaggr.html#XAGGR-MOVING-AGGREGATES" title="38.11.1. 移動集約モード">38.11.1</a>に記述されているように<em class="firstterm">移動集約モード</em>をサポートすることができます。
このためには、<code class="literal">MSFUNC</code>、<code class="literal">MINVFUNC</code>、<code class="literal">MSTYPE</code>のパラメータを指定する必要があり、またオプションで<code class="literal">MSPACE</code>、<code class="literal">MFINALFUNC</code>、<code class="literal">MFINALFUNC_EXTRA</code>、<code class="literal">MFINALFUNC_MODIFY</code>、<code class="literal">MINITCOND</code>のパラメータを指定できます。
<code class="literal">MINVFUNC</code>を除き、これらのパラメータは、<code class="literal">M</code>のない単純集約の対応するパラメータのように動作しますが、集約について逆変換関数を含む別の実装を定義します。
  </p><p>
<span class="original">
   The syntax with &lt;literal&gt;ORDER BY&lt;/literal&gt; in the parameter list creates
   a special type of aggregate called an &lt;firstterm&gt;ordered-set
   aggregate&lt;/firstterm&gt;; or if &lt;literal&gt;HYPOTHETICAL&lt;/literal&gt; is specified, then
   a &lt;firstterm&gt;hypothetical-set aggregate&lt;/firstterm&gt; is created.  These
   aggregates operate over groups of sorted values in order-dependent ways,
   so that specification of an input sort order is an essential part of a
   call.  Also, they can have &lt;firstterm&gt;direct&lt;/firstterm&gt; arguments, which are
   arguments that are evaluated only once per aggregation rather than once
   per input row.  Hypothetical-set aggregates are a subclass of ordered-set
   aggregates in which some of the direct arguments are required to match,
   in number and data types, the aggregated argument columns.  This allows
   the values of those direct arguments to be added to the collection of
   aggregate-input rows as an additional &lt;quote&gt;hypothetical&lt;/quote&gt; row.
</span>
パラメータのリストに<code class="literal">ORDER BY</code>を含む構文は、<em class="firstterm">順序集合集約</em>と呼ばれる特別な種類の集約を作ります。
また<code class="literal">HYPOTHETICAL</code>が指定されている場合は、<em class="firstterm">仮想集合集約</em>が作られます。
これらの集約は、ソートされた値のグループに対して、順序に依存した方法で作用するため、入力についてのソート順の指定は、呼び出しにおける本質的な部分になります。
また、これらの集約は<em class="firstterm">直接</em>引数をとることができます。
直接引数は、行毎に一度ではなく、集約に対して一度だけ評価されます。
仮想集合集約は、順序集合集約のサブクラスで、直接引数のいくつかが、集約される引数の列と、数とデータ型についてマッチする必要があります。
これにより、直接引数の値を、<span class="quote">「<span class="quote">仮想的な</span>」</span>行として、集約の入力行の集合に加えることができます。
  </p><p>
<span class="original">
   An aggregate can optionally support &lt;firstterm&gt;partial aggregation&lt;/firstterm&gt;,
   as described in &lt;xref linkend="xaggr-partial-aggregates"/&gt;.
   This requires specifying the &lt;literal&gt;COMBINEFUNC&lt;/literal&gt; parameter.
   If the &lt;replaceable class="parameter"&gt;state_data_type&lt;/replaceable&gt;
   is &lt;type&gt;internal&lt;/type&gt;, it's usually also appropriate to provide the
   &lt;literal&gt;SERIALFUNC&lt;/literal&gt; and &lt;literal&gt;DESERIALFUNC&lt;/literal&gt; parameters so that
   parallel aggregation is possible.  Note that the aggregate must also be
   marked &lt;literal&gt;PARALLEL SAFE&lt;/literal&gt; to enable parallel aggregation.
</span>
<a class="xref" href="xaggr.html#XAGGR-PARTIAL-AGGREGATES" title="38.11.4. 部分集約">38.11.4</a>で説明されている通り、集約では<em class="firstterm">部分集約</em>をサポートすることができます。
このためには<code class="literal">COMBINEFUNC</code>パラメータを指定する必要があります。
<em class="replaceable"><code>state_data_type</code></em>が<code class="type">internal</code>の場合、通常は<code class="literal">SERIALFUNC</code>および<code class="literal">DESERIALFUNC</code>パラメータも提供して、並列集約を可能にするのが適切でしょう。
並列集約を可能にするには、集約に<code class="literal">PARALLEL SAFE</code>の印をつける必要もあることに注意してください。
  </p><p>
<span class="original">
   Aggregates that behave like &lt;function&gt;MIN&lt;/function&gt; or &lt;function&gt;MAX&lt;/function&gt; can
   sometimes be optimized by looking into an index instead of scanning every
   input row.  If this aggregate can be so optimized, indicate it by
   specifying a &lt;firstterm&gt;sort operator&lt;/firstterm&gt;.  The basic requirement is that
   the aggregate must yield the first element in the sort ordering induced by
   the operator; in other words:
</span>
<code class="function">MIN</code>や<code class="function">MAX</code>のような振舞いをする集約では、すべての入力行を走査せずにインデックスを検索することで最適化できることがあります。
このように最適化される集約の場合、<em class="firstterm">ソート演算子</em>を指定することで明示してください。
その演算子で生成されるソート順で集約の最初の要素が生成されなければならないということが基本的な必要条件です。
言い換えると、
</p><pre class="programlisting">
SELECT agg(col) FROM tab;
</pre><p>
<span class="original">
   must be equivalent to:
</span>
が
</p><pre class="programlisting">
SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;
</pre><p>
と同じでなければならないということです。
<span class="original">

   Further assumptions are that the aggregate ignores null inputs, and that
   it delivers a null result if and only if there were no non-null inputs.
   Ordinarily, a data type's &lt;literal&gt;&amp;lt;&lt;/literal&gt; operator is the proper sort
   operator for &lt;function&gt;MIN&lt;/function&gt;, and &lt;literal&gt;&amp;gt;&lt;/literal&gt; is the proper sort
   operator for &lt;function&gt;MAX&lt;/function&gt;.  Note that the optimization will never
   actually take effect unless the specified operator is the &lt;quote&gt;less
   than&lt;/quote&gt; or &lt;quote&gt;greater than&lt;/quote&gt; strategy member of a B-tree
   index operator class.
</span>
更に、集約がNULL入力を無視すること、および、NULL以外の入力がまったくなかった時にのみNULLという結果を返すことも前提となります。
通常、データ型の<code class="literal">&lt;</code>演算子は<code class="function">MIN</code>のソート演算子として、また、<code class="literal">&gt;</code>演算子は<code class="function">MAX</code>のソート演算子として適切です。
指定した演算子がB-treeインデックス演算子クラスの<span class="quote">「<span class="quote">より小さい</span>」</span>ストラテジか<span class="quote">「<span class="quote">より大きい</span>」</span>ストラテジのメンバでない限り、最適化が実際には効果がないことに注意してください。
  </p><p>
<span class="original">
   To be able to create an aggregate function, you must
   have &lt;literal&gt;USAGE&lt;/literal&gt; privilege on the argument types, the state
   type(s), and the return type, as well as &lt;literal&gt;EXECUTE&lt;/literal&gt;
   privilege on the supporting functions.
</span>
集約関数を作成するためには、引数の型、状態の型、戻り値の型に対する<code class="literal">USAGE</code>権限およびサポート関数に対する<code class="literal">EXECUTE</code>権限を持たなければなりません。
  </p></div><div class="refsect1" id="id-1.9.3.57.6"><h2>パラメータ</h2><span class="original">
  &lt;title&gt;Parameters&lt;/title&gt;
</span><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>name</code></em></span></dt><dd><p>
<span class="original">
      The name (optionally schema-qualified) of the aggregate function
      to create.
</span>
      作成する集約関数の名前です（スキーマ修飾名も可）。
     </p></dd><dt><span class="term"><em class="replaceable"><code>argmode</code></em></span></dt><dd><p>
<span class="original">
      The mode of an argument: &lt;literal&gt;IN&lt;/literal&gt; or &lt;literal&gt;VARIADIC&lt;/literal&gt;.
      (Aggregate functions do not support &lt;literal&gt;OUT&lt;/literal&gt; arguments.)
      If omitted, the default is &lt;literal&gt;IN&lt;/literal&gt;.  Only the last argument
      can be marked &lt;literal&gt;VARIADIC&lt;/literal&gt;.
</span>
引数のモードで、<code class="literal">IN</code>または<code class="literal">VARIADIC</code>です。
(集約関数は<code class="literal">OUT</code>の引数をサポートしません。)
省略した場合のデフォルトは<code class="literal">IN</code>です。
<code class="literal">VARIADIC</code>を指定できるのは、最後の引数だけです。
     </p></dd><dt><span class="term"><em class="replaceable"><code>argname</code></em></span></dt><dd><p>
<span class="original">
      The name of an argument.  This is currently only useful for
      documentation purposes.  If omitted, the argument has no name.
</span>
引数の名前です。
現在は、文書化を目的とする場合にのみ有効です。
省略した場合、引数には名前がありません。
     </p></dd><dt><span class="term"><em class="replaceable"><code>arg_data_type</code></em></span></dt><dd><p>
<span class="original">
      An input data type on which this aggregate function operates.
      To create a zero-argument aggregate function, write &lt;literal&gt;*&lt;/literal&gt;
      in place of the list of argument specifications.  (An example of such an
      aggregate is &lt;function&gt;count(*)&lt;/function&gt;.)
</span>
集約関数が演算する入力データ型です。
引数が存在しない集約関数を作成するには、引数指定のリストに<code class="literal">*</code>と記載してください
（例えば <code class="function">count(*)</code>などの集約です）。
     </p></dd><dt><span class="term"><em class="replaceable"><code>base_type</code></em></span></dt><dd><p>
<span class="original">
      In the old syntax for &lt;command&gt;CREATE AGGREGATE&lt;/command&gt;, the input data type
      is specified by a &lt;literal&gt;basetype&lt;/literal&gt; parameter rather than being
      written next to the aggregate name.  Note that this syntax allows
      only one input parameter.  To define a zero-argument aggregate function
      with this syntax, specify the &lt;literal&gt;basetype&lt;/literal&gt; as
      &lt;literal&gt;"ANY"&lt;/literal&gt; (not &lt;literal&gt;*&lt;/literal&gt;).
      Ordered-set aggregates cannot be defined with the old syntax.
</span>
<code class="command">CREATE AGGREGATE</code>の旧構文では、入力データ型は集約の名前の次に記載されたものではなく<code class="literal">basetype</code>パラメータにより指定されます。
この構文では入力パラメータを1つしかとれないことに注意してください。
この構文で引数を持たない集約を定義するためには、<code class="literal">basetype</code>を<code class="literal">"ANY"</code> （<code class="literal">*</code>ではありません）と指定してください。
順序集合集約関数は旧構文では定義できません。
     </p></dd><dt><span class="term"><em class="replaceable"><code>sfunc</code></em></span></dt><dd><p>
<span class="original">
      The name of the state transition function to be called for each
      input row.  For a normal &lt;replaceable class="parameter"&gt;N&lt;/replaceable&gt;-argument
      aggregate function, the &lt;replaceable class="parameter"&gt;sfunc&lt;/replaceable&gt;
      must take &lt;replaceable class="parameter"&gt;N&lt;/replaceable&gt;+1 arguments,
      the first being of type &lt;replaceable
      class="parameter"&gt;state_data_type&lt;/replaceable&gt; and the rest
      matching the declared input data type(s) of the aggregate.
      The function must return a value of type &lt;replaceable
      class="parameter"&gt;state_data_type&lt;/replaceable&gt;.  This function
      takes the current state value and the current input data value(s),
      and returns the next state value.
</span>
それぞれの入力行に対して呼び出される状態遷移関数の名前です。
通常の<em class="replaceable"><code>N</code></em>引数を持つ集約関数では、<em class="replaceable"><code>sfunc</code></em>は<em class="replaceable"><code>N</code></em>+1個の引数を取らなければなりません。
最初の引数は<em class="replaceable"><code>state_data_type</code></em>型で、残りはその集約の入力データ型として宣言したものと一致していなければなりません。
この関数は<em class="replaceable"><code>state_data_type</code></em>型の値を返さなければなりません。
この関数は、現在の状態値と現在の入力データ値を受け取り、次の状態値を返します。
     </p><p>
<span class="original">
      For ordered-set (including hypothetical-set) aggregates, the state
      transition function receives only the current state value and the
      aggregated arguments, not the direct arguments.  Otherwise it is the
      same.
</span>
順序集合(仮想集合を含む)集約では、状態遷移関数は現在値と集約引数のみを受け取り、直接引数は受け取りません。
それ以外の点は全く同じです。
     </p></dd><dt><span class="term"><em class="replaceable"><code>state_data_type</code></em></span></dt><dd><p>
<span class="original">
      The data type for the aggregate's state value.
</span>
集約の状態値のデータ型です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>state_data_size</code></em></span></dt><dd><p>
<span class="original">
      The approximate average size (in bytes) of the aggregate's state value.
      If this parameter is omitted or is zero, a default estimate is used
      based on the &lt;replaceable&gt;state_data_type&lt;/replaceable&gt;.
      The planner uses this value to estimate the memory required for a
      grouped aggregate query.  The planner will consider using hash
      aggregation for such a query only if the hash table is estimated to fit
      in &lt;xref linkend="guc-work-mem"/&gt;; therefore, large values of this
      parameter discourage use of hash aggregation.
</span>
集約の状態値のおおよその平均サイズ(単位はバイト)です。
このパラメータを省略した場合、あるいはゼロを指定した場合、<em class="replaceable"><code>state_data_type</code></em>に基づいたデフォルトの推定が使われます。
プランナは、グループ化された集約のクエリに必要なメモリを推定するのに、この値を使います。
プランナは、ハッシュテーブルが<a class="xref" href="runtime-config-resource.html#GUC-WORK-MEM">work_mem</a>に収まると見積もられる場合にのみ、ハッシュ集約の使用を検討します。
従って、このパラメータに大きな値を設定すると、ハッシュ集約が使われないようになります。
     </p></dd><dt><span class="term"><em class="replaceable"><code>ffunc</code></em></span></dt><dd><p>
<span class="original">
      The name of the final function called to compute the aggregate's
      result after all input rows have been traversed.
      For a normal aggregate, this function
      must take a single argument of type &lt;replaceable
      class="parameter"&gt;state_data_type&lt;/replaceable&gt;.  The return
      data type of the aggregate is defined as the return type of this
      function.  If &lt;replaceable class="parameter"&gt;ffunc&lt;/replaceable&gt;
      is not specified, then the ending state value is used as the
      aggregate's result, and the return type is &lt;replaceable
      class="parameter"&gt;state_data_type&lt;/replaceable&gt;.
</span>
最終関数の名前です。最終関数は、全ての入力行に対する処理が終わった後、集約の結果を計算するために呼び出されます。
通常の集約では、この関数は<em class="replaceable"><code>state_data_type</code></em>型の引数を1つ取らなければなりません。
集約の出力データ型はこの関数の返り値として定義されます。
<em class="replaceable"><code>ffunc</code></em>が指定されない場合には、集約の結果として終了時の状態値が使われます。出力型は<em class="replaceable"><code>state_data_type</code></em>になります。
     </p><p>
<span class="original">
      For ordered-set (including hypothetical-set) aggregates, the
      final function receives not only the final state value,
      but also the values of all the direct arguments.
</span>
順序集合(仮想集合を含む)集約では、最終関数は終了時の状態値だけでなく、すべての直接引数の値も受け取ります。
     </p><p>
<span class="original">
      If &lt;literal&gt;FINALFUNC_EXTRA&lt;/literal&gt; is specified, then in addition to the
      final state value and any direct arguments, the final function
      receives extra NULL values corresponding to the aggregate's regular
      (aggregated) arguments.  This is mainly useful to allow correct
      resolution of the aggregate result type when a polymorphic aggregate
      is being defined.
</span>
<code class="literal">FINALFUNC_EXTRA</code>が指定された場合、最終関数は、終了時の状態値と直接引数に加えて、集約の通常の(集約された)引数に対応する追加のNULL値を受け取ります。
これは主に、多様型の集約が定義されているときに、集約の結果の型を正しく解決するのに役立ちます。
     </p></dd><dt><span class="term"><code class="literal">FINALFUNC_MODIFY</code> = { <code class="literal">READ_ONLY</code> | <code class="literal">SHAREABLE</code> | <code class="literal">READ_WRITE</code> }</span></dt><dd><p>
<span class="original">
      This option specifies whether the final function is a pure function
      that does not modify its arguments.  &lt;literal&gt;READ_ONLY&lt;/literal&gt; indicates
      it does not; the other two values indicate that it may change the
      transition state value.  See &lt;xref linkend="sql-createaggregate-notes"
      endterm="sql-createaggregate-notes-title"/&gt; below for more detail.  The
      default is &lt;literal&gt;READ_ONLY&lt;/literal&gt;, except for ordered-set aggregates,
      for which the default is &lt;literal&gt;READ_WRITE&lt;/literal&gt;.
</span>
このオプションは、最終関数が引数を変更しない純粋な関数であるかどうかを指定します。
<code class="literal">READ_ONLY</code>は変更しないことを示します。他の2つの値は遷移状態値を変更するかもしれないことを示します。
さらなる詳細は以下の<a class="xref" href="sql-createaggregate.html#SQL-CREATEAGGREGATE-NOTES" title="注釈">注釈</a>をご覧ください。
順序集合集約ではデフォルトが<code class="literal">READ_WRITE</code>であることを除き、デフォルトは<code class="literal">READ_ONLY</code>です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>combinefunc</code></em></span></dt><dd><p>
<span class="original">
      The &lt;replaceable class="parameter"&gt;combinefunc&lt;/replaceable&gt; function
      may optionally be specified to allow the aggregate function to support
      partial aggregation.  If provided,
      the &lt;replaceable class="parameter"&gt;combinefunc&lt;/replaceable&gt; must
      combine two &lt;replaceable class="parameter"&gt;state_data_type&lt;/replaceable&gt;
      values, each containing the result of aggregation over some subset of
      the input values, to produce a
      new &lt;replaceable class="parameter"&gt;state_data_type&lt;/replaceable&gt; that
      represents the result of aggregating over both sets of inputs.  This
      function can be thought of as
      an &lt;replaceable class="parameter"&gt;sfunc&lt;/replaceable&gt;, where instead of
      acting upon an individual input row and adding it to the running
      aggregate state, it adds another aggregate state to the running state.
</span>
集約関数が部分集約をサポートできるようにするために、<em class="replaceable"><code>combinefunc</code></em>を指定することができます。
これが指定されると、<em class="replaceable"><code>combinefunc</code></em>は、入力値の何らかの部分集合に対する集約の結果を含む2つの<em class="replaceable"><code>state_data_type</code></em>値を結合し、両方の入力に対する集約結果を表す新しい<em class="replaceable"><code>state_data_type</code></em>を生成しなければなりません。
この関数は、個々の入力行に対して作用してそれを集約中の状態に追加するのではなく、実行中の状態に別の集約状態を追加する<em class="replaceable"><code>sfunc</code></em>として考えることができます。
     </p><p>
<span class="original">
      The &lt;replaceable class="parameter"&gt;combinefunc&lt;/replaceable&gt; must be
      declared as taking two arguments of
      the &lt;replaceable class="parameter"&gt;state_data_type&lt;/replaceable&gt; and
      returning a value of
      the &lt;replaceable class="parameter"&gt;state_data_type&lt;/replaceable&gt;.
      Optionally this function may be &lt;quote&gt;strict&lt;/quote&gt;. In this case the
      function will not be called when either of the input states are null;
      the other state will be taken as the correct result.
</span>
<em class="replaceable"><code>combinefunc</code></em>は、<em class="replaceable"><code>state_data_type</code></em>の引数を2つ取り、<em class="replaceable"><code>state_data_type</code></em>の値を返すものとして宣言されなければなりません。
この関数は<span class="quote">「<span class="quote">strict</span>」</span>とすることもできます。
その場合、入力状態の一方がNULLのときは関数が呼び出されず、他方の状態が正しい結果であると見なされます。
     </p><p>
<span class="original">
      For aggregate functions
      whose &lt;replaceable class="parameter"&gt;state_data_type&lt;/replaceable&gt;
      is &lt;type&gt;internal&lt;/type&gt;,
      the &lt;replaceable class="parameter"&gt;combinefunc&lt;/replaceable&gt; must not
      be strict. In this case
      the &lt;replaceable class="parameter"&gt;combinefunc&lt;/replaceable&gt; must
      ensure that null states are handled correctly and that the state being
      returned is properly stored in the aggregate memory context.
</span>
<em class="replaceable"><code>state_data_type</code></em>が<code class="type">internal</code>の集約関数では、<em class="replaceable"><code>combinefunc</code></em>をSTRICTにすることはできません。
この場合、<em class="replaceable"><code>combinefunc</code></em>はNULL状態を正しく処理し、返される状態が集約のメモリコンテキスト内に適切に保存されることを確実にする必要があります。
     </p></dd><dt><span class="term"><em class="replaceable"><code>serialfunc</code></em></span></dt><dd><p>
<span class="original">
      An aggregate function
      whose &lt;replaceable class="parameter"&gt;state_data_type&lt;/replaceable&gt;
      is &lt;type&gt;internal&lt;/type&gt; can participate in parallel aggregation only if it
      has a &lt;replaceable class="parameter"&gt;serialfunc&lt;/replaceable&gt; function,
      which must serialize the aggregate state into a &lt;type&gt;bytea&lt;/type&gt; value for
      transmission to another process.  This function must take a single
      argument of type &lt;type&gt;internal&lt;/type&gt; and return type &lt;type&gt;bytea&lt;/type&gt;.  A
      corresponding &lt;replaceable class="parameter"&gt;deserialfunc&lt;/replaceable&gt;
      is also required.
</span>
<em class="replaceable"><code>state_data_type</code></em>が<code class="type">internal</code>の集約関数は、<em class="replaceable"><code>serialfunc</code></em>関数がある場合に限り、並列集約に参加することができます。
<em class="replaceable"><code>serialfunc</code></em>は、集約の状態を他のプロセスに転送するために<code class="type">bytea</code>の値にシリアライズしなければなりません。
この関数は<code class="type">internal</code>型の引数を1つ取り、<code class="type">bytea</code>型を返さなければなりません。
これに対応する<em class="replaceable"><code>deserialfunc</code></em>も必要です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>deserialfunc</code></em></span></dt><dd><p>
<span class="original">
      Deserialize a previously serialized aggregate state back into
      &lt;replaceable class="parameter"&gt;state_data_type&lt;/replaceable&gt;. This
      function must take two arguments of types &lt;type&gt;bytea&lt;/type&gt;
      and &lt;type&gt;internal&lt;/type&gt;, and produce a result of type &lt;type&gt;internal&lt;/type&gt;.
      (Note: the second, &lt;type&gt;internal&lt;/type&gt; argument is unused, but is required
      for type safety reasons.)
</span>
以前にシリアライズされた集約状態をデシリアライズして<em class="replaceable"><code>state_data_type</code></em>に戻します。
この関数は<code class="type">bytea</code>型および<code class="type">internal</code>型の2つの引数を取り、<code class="type">internal</code>型の結果を生成しなければなりません。
（注意：2番目の<code class="type">internal</code>の引数は使用されませんが、型の安全性の理由から必要となっています。）
     </p></dd><dt><span class="term"><em class="replaceable"><code>initial_condition</code></em></span></dt><dd><p>
<span class="original">
      The initial setting for the state value.  This must be a string
      constant in the form accepted for the data type &lt;replaceable
      class="parameter"&gt;state_data_type&lt;/replaceable&gt;.  If not
      specified, the state value starts out null.
</span>
状態値の初期設定です。
データ型<em class="replaceable"><code>state_data_type</code></em>として受け取り可能な文字列定数でなければいけません。
このパラメータが指定されない場合、状態値はNULLから始まります。
     </p></dd><dt><span class="term"><em class="replaceable"><code>msfunc</code></em></span></dt><dd><p>
<span class="original">
      The name of the forward state transition function to be called for each
      input row in moving-aggregate mode.  This is exactly like the regular
      transition function, except that its first argument and result are of
      type &lt;replaceable&gt;mstate_data_type&lt;/replaceable&gt;, which might be different
      from &lt;replaceable&gt;state_data_type&lt;/replaceable&gt;.
</span>
移動集約モードにおいて、それぞれの入力行に対して呼び出される前方状態遷移関数の名前です。
これは最初の引数と結果が<em class="replaceable"><code>mstate_data_type</code></em>型で、<em class="replaceable"><code>state_data_type</code></em>とは異なるかもしれないことを除けば、通常の遷移関数と全く同じです。
     </p></dd><dt><span class="term"><em class="replaceable"><code>minvfunc</code></em></span></dt><dd><p>
<span class="original">
      The name of the inverse state transition function to be used in
      moving-aggregate mode.  This function has the same argument and
      result types as &lt;replaceable&gt;msfunc&lt;/replaceable&gt;, but it is used to remove
      a value from the current aggregate state, rather than add a value to
      it.  The inverse transition function must have the same strictness
      attribute as the forward state transition function.
</span>
移動集約モードで使われる逆状態遷移関数の名前です。
この関数は<em class="replaceable"><code>msfunc</code></em>と同じ引数および結果型を持ちますが、現在の集約状態に対して、値を追加するのではなく、取り除くために使われます。
逆遷移関数は前方状態遷移関数と同じstrictさの属性を持っていなければなりません。
     </p></dd><dt><span class="term"><em class="replaceable"><code>mstate_data_type</code></em></span></dt><dd><p>
<span class="original">
      The data type for the aggregate's state value, when using
      moving-aggregate mode.
</span>
移動集約モードを使うときの、集約状態値のデータ型です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>mstate_data_size</code></em></span></dt><dd><p>
<span class="original">
      The approximate average size (in bytes) of the aggregate's state
      value, when using moving-aggregate mode.  This works the same as
      &lt;replaceable&gt;state_data_size&lt;/replaceable&gt;.
</span>
移動集約モードを使うときの、集約状態値のおおよその平均サイズ(バイト単位)です。
<em class="replaceable"><code>state_data_size</code></em>と同じように作用します。
     </p></dd><dt><span class="term"><em class="replaceable"><code>mffunc</code></em></span></dt><dd><p>
<span class="original">
      The name of the final function called to compute the aggregate's
      result after all input rows have been traversed, when using
      moving-aggregate mode.  This works the same as &lt;replaceable&gt;ffunc&lt;/replaceable&gt;,
      except that its first argument's type
      is &lt;replaceable&gt;mstate_data_type&lt;/replaceable&gt; and extra dummy arguments are
      specified by writing &lt;literal&gt;MFINALFUNC_EXTRA&lt;/literal&gt;.
      The aggregate result type determined by &lt;replaceable&gt;mffunc&lt;/replaceable&gt;
      or &lt;replaceable&gt;mstate_data_type&lt;/replaceable&gt; must match that determined by the
      aggregate's regular implementation.
</span>
移動集約モードを使うときに、すべての入力行が走査された後で、集約結果を計算するために呼び出される最終関数の名前です。
これは、最初の引数の型が<em class="replaceable"><code>mstate_data_type</code></em>であり、<code class="literal">MFINALFUNC_EXTRA</code>により追加のダミー引数を指定できることを除けば、<em class="replaceable"><code>ffunc</code></em>と同じように作用します。
<em class="replaceable"><code>mffunc</code></em>または<em class="replaceable"><code>mstate_data_type</code></em>によって決定される集約結果の型は、集約の通常の実装によって決定される型と適合しなければなりません。
     </p></dd><dt><span class="term"><code class="literal">MFINALFUNC_MODIFY</code> = { <code class="literal">READ_ONLY</code> | <code class="literal">SHAREABLE</code> | <code class="literal">READ_WRITE</code> }</span></dt><dd><p>
<span class="original">
      This option is like &lt;literal&gt;FINALFUNC_MODIFY&lt;/literal&gt;, but it describes
      the behavior of the moving-aggregate final function.
</span>
このオプションは<code class="literal">FINALFUNC_MODIFY</code>と似ていますが、移動集約最終関数の挙動を記述します。
     </p></dd><dt><span class="term"><em class="replaceable"><code>minitial_condition</code></em></span></dt><dd><p>
<span class="original">
      The initial setting for the state value, when using moving-aggregate
      mode.  This works the same as &lt;replaceable&gt;initial_condition&lt;/replaceable&gt;.
</span>
移動集約モードを使うときの、状態値の初期設定です。
これは、<em class="replaceable"><code>initial_condition</code></em>と同じように作用します。
     </p></dd><dt><span class="term"><em class="replaceable"><code>sort_operator</code></em></span></dt><dd><p>
<span class="original">
      The associated sort operator for a &lt;function&gt;MIN&lt;/function&gt;- or
      &lt;function&gt;MAX&lt;/function&gt;-like aggregate.
      This is just an operator name (possibly schema-qualified).
      The operator is assumed to have the same input data types as
      the aggregate (which must be a single-argument normal aggregate).
</span>
<code class="function">MIN</code>または<code class="function">MAX</code>のような集約に対して関連付けされるソート演算子です。
これは単なる演算子の名前です（スキーマ修飾可能）。
この演算子は集約（これは単一引数の通常の集約でなければなりません）と同じ入力データ型を持つと前提されています。
     </p></dd><dt><span class="term"><code class="literal">PARALLEL =</code> { <code class="literal">SAFE</code> | <code class="literal">RESTRICTED</code> | <code class="literal">UNSAFE</code> }</span></dt><dd><p>
<span class="original">
      The meanings of &lt;literal&gt;PARALLEL SAFE&lt;/literal&gt;, &lt;literal&gt;PARALLEL
      RESTRICTED&lt;/literal&gt;, and &lt;literal&gt;PARALLEL UNSAFE&lt;/literal&gt; are the same as
      in &lt;xref linkend="sql-createfunction"/&gt;.  An aggregate will not be
      considered for parallelization if it is marked &lt;literal&gt;PARALLEL
      UNSAFE&lt;/literal&gt; (which is the default!) or &lt;literal&gt;PARALLEL RESTRICTED&lt;/literal&gt;.
      Note that the parallel-safety markings of the aggregate's support
      functions are not consulted by the planner, only the marking of the
      aggregate itself.
</span>
<code class="literal">PARALLEL SAFE</code>、<code class="literal">PARALLEL RESTRICTED</code>、<code class="literal">PARALLEL UNSAFE</code>の意味は<a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>におけるものと同じです。
集約は、その印が<code class="literal">PARALLEL UNSAFE</code>（これがデフォルトです！）あるいは<code class="literal">PARALLEL RESTRICTED</code>となっている場合、並列処理での使用を考慮されません。
プランナは集約のサポート関数の並列処理安全性の印を考慮せず、集約自体の印のみを参照することに注意してください。
     </p></dd><dt><span class="term"><code class="literal">HYPOTHETICAL</code></span></dt><dd><p>
<span class="original">
      For ordered-set aggregates only, this flag specifies that the aggregate
      arguments are to be processed according to the requirements for
      hypothetical-set aggregates: that is, the last few direct arguments must
      match the data types of the aggregated (&lt;literal&gt;WITHIN GROUP&lt;/literal&gt;)
      arguments.  The &lt;literal&gt;HYPOTHETICAL&lt;/literal&gt; flag has no effect on
      run-time behavior, only on parse-time resolution of the data types and
      collations of the aggregate's arguments.
</span>
順序集合集約についてのみ、このフラグは、仮想集合集約の要求に従って集約の引数が処理されることを指定します。
つまり、最後のいくつかの引数が、集約される(<code class="literal">WITHIN GROUP</code>の)引数と適合しなければなりません。
<code class="literal">HYPOTHETICAL</code>フラグは実行時の動作には何の影響もなく、集約の引数のデータ型と照合についての解析時の解決にのみ影響します。
     </p></dd></dl></div><p>
<span class="original">
   The parameters of &lt;command&gt;CREATE AGGREGATE&lt;/command&gt; can be
   written in any order, not just the order illustrated above.
</span>
<code class="command">CREATE AGGREGATE</code>のパラメータは、任意の順番で記述することができます。上記の順番で記述する必要はありません。
  </p></div><div class="refsect1" id="SQL-CREATEAGGREGATE-NOTES"><h2>注釈</h2><span class="original">
  &lt;title id="sql-createaggregate-notes-title"&gt;Notes&lt;/title&gt;
</span><p>
<span class="original">
    In parameters that specify support function names, you can write
    a schema name if needed, for example &lt;literal&gt;SFUNC = public.sum&lt;/literal&gt;.
    Do not write argument types there, however &amp;mdash; the argument types
    of the support functions are determined from other parameters.
</span>
サポート関数名を指定するパラメータでは、必要なら、<code class="literal">SFUNC = public.sum</code>のようにスキーマ名を書くことができます。
しかし、引数の型をそこに書くことはできません。
サポート関数の引数の型は、他のパラメータにより決定されるからです。
   </p><p>
<span class="original">
    Ordinarily, PostgreSQL functions are expected to be true functions that
    do not modify their input values.  However, an aggregate transition
    function, &lt;emphasis&gt;when used in the context of an aggregate&lt;/emphasis&gt;,
    is allowed to cheat and modify its transition-state argument in place.
    This can provide substantial performance benefits compared to making
    a fresh copy of the transition state each time.
</span>
通常PostgreSQL関数は入力値を変更しない純粋な関数であることが期待されます。
しかし<span class="emphasis"><em>集約のコンテキストで使用される場合には</em></span>、集約遷移関数は、これを偽ってその状態遷移引数を直接変更することが許されます。
これにより、遷移状態の新しいコピーを都度作るのに比べると、かなりの性能上の利点が期待できます。
   </p><p>
<span class="original">
    Likewise, while an aggregate final function is normally expected not to
    modify its input values, sometimes it is impractical to avoid modifying
    the transition-state argument.  Such behavior must be declared using
    the &lt;literal&gt;FINALFUNC_MODIFY&lt;/literal&gt; parameter.
    The &lt;literal&gt;READ_WRITE&lt;/literal&gt;
    value indicates that the final function modifies the transition state in
    unspecified ways.  This value prevents use of the aggregate as a window
    function, and it also prevents merging of transition states for aggregate
    calls that share the same input values and transition functions.
    The &lt;literal&gt;SHAREABLE&lt;/literal&gt; value indicates that the transition function
    cannot be applied after the final function, but multiple final-function
    calls can be performed on the ending transition state value.  This value
    prevents use of the aggregate as a window function, but it allows merging
    of transition states.  (That is, the optimization of interest here is not
    applying the same final function repeatedly, but applying different final
    functions to the same ending transition state value.  This is allowed as
    long as none of the final functions are marked &lt;literal&gt;READ_WRITE&lt;/literal&gt;.)
</span>
同様に、集約最終関数は入力値を変更しない純粋な関数であることが期待されますが、状態遷移引数を変更するのを避けることが実用的でないことがあります。
そうした挙動は<code class="literal">FINALFUNC_MODIFY</code>引数を使って宣言しなければなりません。
<code class="literal">READ_WRITE</code>値は、最終関数が遷移状態を明示されていない方法で変更することを示します。
この値はwindow関数として集約を使うことを回避します。
また、同じ入力値と遷移関数を共有する集約の遷移状態をマージすることを回避します。
<code class="literal">SHAREABLE</code>値は、遷移関数が最終関数の後に適用できないが、最終関数の複数回の呼び出しを終了遷移状態値に適用できることを示します。
この値はwindow関数として集約を使うことを回避しますが、遷移状態のマージを許容します。
（つまり、ここでの最適化の眼目は、同じ最終関数を繰り返し適用することではなく、異なる最終関数を同じ終了遷移状態値に適用することです。
これは最終関数のうち<code class="literal">READ_WRITE</code>と印付けられているものが一つもない限り許容されます。）
   </p><p>
<span class="original">
    If an aggregate supports moving-aggregate mode, it will improve
    calculation efficiency when the aggregate is used as a window function
    for a window with moving frame start (that is, a frame start mode other
    than &lt;literal&gt;UNBOUNDED PRECEDING&lt;/literal&gt;).  Conceptually, the forward
    transition function adds input values to the aggregate's state when
    they enter the window frame from the bottom, and the inverse transition
    function removes them again when they leave the frame at the top.  So,
    when values are removed, they are always removed in the same order they
    were added.  Whenever the inverse transition function is invoked, it will
    thus receive the earliest added but not yet removed argument value(s).
    The inverse transition function can assume that at least one row will
    remain in the current state after it removes the oldest row.  (When this
    would not be the case, the window function mechanism simply starts a
    fresh aggregation, rather than using the inverse transition function.)
</span>
集約が移動集約モードをサポートしていると、移動フレームの開始のあるウィンドウ（つまり、<code class="literal">UNBOUNDED PRECEDING</code>以外のフレーム開始モード)として集約が使われる場合に計算の効率が向上します。
概念的には、前方遷移関数はウィンドウフレームに下から入るときに集約の状態に入力値を追加し、逆遷移関数はフレームを上から抜けるときにそれを取り除きます。
従って、値が取り除かれるときは、必ず追加された時と同じ順番で取り除かれます。
従って、逆遷移関数が実行される時は、いつでも最も早く追加されたけれども、まだ取り除かれていない引き数値を受け取ります。
逆遷移関数は、最も古い行を取り除いた後、現在の状態に少なくとも1行が残ることを前提とできます。
(そうならない場合は、ウィンドウ関数の仕組みは、逆遷移関数を使うのでなく、単純に新しい集約を開始します。)
   </p><p>
<span class="original">
    The forward transition function for moving-aggregate mode is not
    allowed to return NULL as the new state value. If the inverse
    transition function returns NULL, this is taken as an indication that
    the inverse function cannot reverse the state calculation for this
    particular input, and so the aggregate calculation will be redone from
    scratch for the current frame starting position.  This convention
    allows moving-aggregate mode to be used in situations where there are
    some infrequent cases that are impractical to reverse out of the
    running state value.
</span>
移動集約モードの前方遷移関数は、新しい集約値としてNULLを返すことは許されません。
逆遷移関数がNULLを返した場合、それは、逆関数がその入力値について状態計算を元に戻すことができなかったと見なされるため、集約の計算は現在のフレームの開始位置からやり直しとなります。
こうすることで、実行中の状態値を元に戻すのが現実的でないということが稀に起こるような場合でも、移動集約モードを使うことができます。
   </p><p>
<span class="original">
    If no moving-aggregate implementation is supplied,
    the aggregate can still be used with moving frames,
    but &lt;productname&gt;PostgreSQL&lt;/productname&gt; will recompute the whole
    aggregation whenever the start of the frame moves.
    Note that whether or not the aggregate supports moving-aggregate
    mode, &lt;productname&gt;PostgreSQL&lt;/productname&gt; can handle a moving frame
    end without recalculation; this is done by continuing to add new values
    to the aggregate's state.  This is why use of an aggregate as a window
    function requires that the final function be read-only: it must
    not damage the aggregate's state value, so that the aggregation can be
    continued even after an aggregate result value has been obtained for
    one set of frame boundaries.
</span>
移動集約が実装されていない場合でも、集約は移動フレームを使うことができますが、フレームの開始が移動した場合、<span class="productname">PostgreSQL</span>は必ず集約全体を再計算します。
集約が移動集約モードをサポートするかどうかに関わらず、<span class="productname">PostgreSQL</span>は移動フレームの終了を再計算なしに処理することができます。
これは、集約の状態に新しい値を追加し続けることで処理できます。
これがwindow関数として集約を利用するためには最終関数が読み出し専用でなければならない理由です。
最終関数は集約の状態値を破壊しないものとされるので、フレームの境界の集合に対して集約結果の値が得られた後でも、集約を続行することが可能です。
   </p><p>
<span class="original">
    The syntax for ordered-set aggregates allows &lt;literal&gt;VARIADIC&lt;/literal&gt;
    to be specified for both the last direct parameter and the last
    aggregated (&lt;literal&gt;WITHIN GROUP&lt;/literal&gt;) parameter.  However, the
    current implementation restricts use of &lt;literal&gt;VARIADIC&lt;/literal&gt;
    in two ways.  First, ordered-set aggregates can only use
    &lt;literal&gt;VARIADIC "any"&lt;/literal&gt;, not other variadic array types.
    Second, if the last direct parameter is &lt;literal&gt;VARIADIC "any"&lt;/literal&gt;,
    then there can be only one aggregated parameter and it must also
    be &lt;literal&gt;VARIADIC "any"&lt;/literal&gt;.  (In the representation used in the
    system catalogs, these two parameters are merged into a single
    &lt;literal&gt;VARIADIC "any"&lt;/literal&gt; item, since &lt;structname&gt;pg_proc&lt;/structname&gt; cannot
    represent functions with more than one &lt;literal&gt;VARIADIC&lt;/literal&gt; parameter.)
    If the aggregate is a hypothetical-set aggregate, the direct arguments
    that match the &lt;literal&gt;VARIADIC "any"&lt;/literal&gt; parameter are the hypothetical
    ones; any preceding parameters represent additional direct arguments
    that are not constrained to match the aggregated arguments.
</span>
順序集合集約の構文では、<code class="literal">VARIADIC</code>を最後の直接パラメータと、最後の集約(<code class="literal">WITHIN GROUP</code>)パラメータの両方について指定することができます。
しかし、現在の実装では<code class="literal">VARIADIC</code>の使用を2つの方法に制限しています。
1つ目は、順序集合集約では、<code class="literal">VARIADIC "any"</code>のみが利用でき、他のvariadicの配列型は利用できないことです。
2つ目は、最後の直接パラメータが<code class="literal">VARIADIC "any"</code>の場合、集約パラメータは1つだけしか使えず、かつそれも<code class="literal">VARIADIC "any"</code>でなければならない、ということです。
(システムカタログで使われる表現において、これらの2つのパラメータは、1つの<code class="literal">VARIADIC "any"</code>要素に統合されています。
なぜなら、<code class="structname">pg_proc</code>は2つ以上の<code class="literal">VARIADIC</code>パラメータがある関数を表現できないからです。)
仮想集合集約の場合、<code class="literal">VARIADIC "any"</code>パラメータに対応する直接引数は仮想的なパラメータで、それより前のパラメータは、集約引数に対応する制約のない、追加の直接引数となります。
   </p><p>
<span class="original">
    Currently, ordered-set aggregates do not need to support
    moving-aggregate mode, since they cannot be used as window functions.
</span>
現在は、順序集合集約は、ウィンドウ関数として使うことはできないので、移動集約モードをサポートする必要はありません。
   </p><p>
<span class="original">
    Partial (including parallel) aggregation is currently not supported for
    ordered-set aggregates.  Also, it will never be used for aggregate calls
    that include &lt;literal&gt;DISTINCT&lt;/literal&gt; or &lt;literal&gt;ORDER BY&lt;/literal&gt; clauses, since
    those semantics cannot be supported during partial aggregation.
</span>
部分集約（並列集約を含む）は現在のところ、順序集約ではサポートされません。
また、部分集約は<code class="literal">DISTINCT</code>あるいは<code class="literal">ORDER BY</code>句を含む集約の呼び出しでは決して使われることはありません。
なぜなら、部分集約ではそれらを意味論的にサポートできないからです。
  </p></div><div class="refsect1" id="id-1.9.3.57.8"><h2>例</h2><span class="original">
  &lt;title&gt;Examples&lt;/title&gt;
</span><p>
<span class="original">
   See &lt;xref linkend="xaggr"/&gt;.
</span>
<a class="xref" href="xaggr.html" title="38.11. ユーザ定義の集約">38.11</a>を参照してください。
  </p></div><div class="refsect1" id="id-1.9.3.57.9"><h2>互換性</h2><span class="original">
  &lt;title&gt;Compatibility&lt;/title&gt;
</span><p>
<span class="original">
   &lt;command&gt;CREATE AGGREGATE&lt;/command&gt; is a
   &lt;productname&gt;PostgreSQL&lt;/productname&gt; language extension.  The SQL
   standard does not provide for user-defined aggregate functions.
</span>
<code class="command">CREATE AGGREGATE</code>は<span class="productname">PostgreSQL</span>の言語拡張です。
標準SQLには、ユーザ定義の集約関数を使用する機能はありません。
  </p></div><div class="refsect1" id="id-1.9.3.57.10"><h2>関連項目</h2><span class="original">
  &lt;title&gt;See Also&lt;/title&gt;
</span><span class="simplelist"><a class="xref" href="sql-alteraggregate.html" title="ALTER AGGREGATE"><span class="refentrytitle">ALTER AGGREGATE</span></a>, <a class="xref" href="sql-dropaggregate.html" title="DROP AGGREGATE"><span class="refentrytitle">DROP AGGREGATE</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-create-access-method.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createcast.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE ACCESS METHOD </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> CREATE CAST</td></tr></table></div></body></html>