<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.7. パターンマッチ</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="functions-bitstring.html" title="9.6. ビット文字列関数と演算子" /><link rel="next" href="functions-formatting.html" title="9.8. データ型書式設定関数" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 11.4文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="functions.html" title="第9章 関数と演算子">第9章 関数と演算子</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 11.4 &#10;                      functions-matching.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-bitstring.html" title="9.6. ビット文字列関数と演算子">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="第9章 関数と演算子">上へ</a></td><td width="60%" align="center">9.7. パターンマッチ</td><td width="20%" align="right"> <a accesskey="n" href="functions-formatting.html" title="9.8. データ型書式設定関数">次へ</a></td></tr></table><hr /></div><div class="sect1" id="FUNCTIONS-MATCHING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.7. パターンマッチ</h2></div></div></div><span class="original">
  &lt;title&gt;Pattern Matching&lt;/title&gt;
</span><a id="id-1.5.8.12.2" class="indexterm"></a><p>
<span class="original">
    There are three separate approaches to pattern matching provided
    by &lt;productname&gt;PostgreSQL&lt;/productname&gt;: the traditional
    &lt;acronym&gt;SQL&lt;/acronym&gt; &lt;function&gt;LIKE&lt;/function&gt; operator, the
    more recent &lt;function&gt;SIMILAR TO&lt;/function&gt; operator (added in
    SQL:1999), and &lt;acronym&gt;POSIX&lt;/acronym&gt;-style regular
    expressions.  Aside from the basic &lt;quote&gt;does this string match
    this pattern?&lt;/quote&gt; operators, functions are available to extract
    or replace matching substrings and to split a string at matching
    locations.
</span>
<span class="productname">PostgreSQL</span>には、パターンマッチを行うに際して3つの異なった手法があります。伝統的な<acronym class="acronym">SQL</acronym>の<code class="function">LIKE</code>演算子、これより新しい<code class="function">SIMILAR TO</code>演算子（SQL:1999で追加されました）、および<acronym class="acronym">POSIX</acronym>様式の正規表現です。
基本の<span class="quote">「<span class="quote">この文字列はこのパターンに一致するか？</span>」</span>を別としても、一致した部分文字列を取り出したり置換したり、そして一致部分で文字列を分割する関数が用意されています。
   </p><div class="tip"><h3 class="title">ヒント</h3><p>
<span class="original">
     If you have pattern matching needs that go beyond this,
     consider writing a user-defined function in Perl or Tcl.
</span>
上記の手法では検索できないようなパターンマッチが必要な場合は、PerlもしくはTclでユーザ定義関数を作成することを検討してください。
    </p></div><div class="caution"><h3 class="title">注意</h3><p>
<span class="original">
     While most regular-expression searches can be executed very quickly,
     regular expressions can be contrived that take arbitrary amounts of
     time and memory to process.  Be wary of accepting regular-expression
     search patterns from hostile sources.  If you must do so, it is
     advisable to impose a statement timeout.
</span>
ほとんどの正規表現検索はとても速く実行されますが、正規表現は処理するのに任意の時間とメモリを使う可能性があります。
悪意のあるソースから正規表現検索パターンを受け取ることに用心してください。
そうしなければならないのであれば、文のタイムアウトを強制するのが賢明です。
    </p><p>
<span class="original">
     Searches using &lt;function&gt;SIMILAR TO&lt;/function&gt; patterns have the same
     security hazards, since &lt;function&gt;SIMILAR TO&lt;/function&gt; provides many
     of the same capabilities as &lt;acronym&gt;POSIX&lt;/acronym&gt;-style regular
     expressions.
</span>
<code class="function">SIMILAR TO</code>が<acronym class="acronym">POSIX</acronym>書式の正規表現と同じ多くの機能を提供するので、<code class="function">SIMILAR TO</code>パターンを使う検索は同様のセキュリティ問題を抱えています。
    </p><p>
<span class="original">
     &lt;function&gt;LIKE&lt;/function&gt; searches, being much simpler than the other
     two options, are safer to use with possibly-hostile pattern sources.
</span>
<code class="function">LIKE</code>検索は、他の2つの方法よりずっと単純ですので、悪意があるかもしれないパターンのソースで使うのにはより安全です。
    </p></div><div class="sect2" id="FUNCTIONS-LIKE"><div class="titlepage"><div><div><h3 class="title">9.7.1. <code class="function">LIKE</code></h3></div></div></div><a id="id-1.5.8.12.6.2" class="indexterm"></a><pre class="synopsis">
<em class="replaceable"><code>string</code></em> LIKE <em class="replaceable"><code>pattern</code></em> [<span class="optional">ESCAPE <em class="replaceable"><code>escape-character</code></em></span>]
<em class="replaceable"><code>string</code></em> NOT LIKE <em class="replaceable"><code>pattern</code></em> [<span class="optional">ESCAPE <em class="replaceable"><code>escape-character</code></em></span>]
</pre><p>
<span class="original">
     The &lt;function&gt;LIKE&lt;/function&gt; expression returns true if the
     &lt;replaceable&gt;string&lt;/replaceable&gt; matches the supplied
     &lt;replaceable&gt;pattern&lt;/replaceable&gt;.  (As
     expected, the &lt;function&gt;NOT LIKE&lt;/function&gt; expression returns
     false if &lt;function&gt;LIKE&lt;/function&gt; returns true, and vice versa.
     An equivalent expression is
     &lt;literal&gt;NOT (&lt;replaceable&gt;string&lt;/replaceable&gt; LIKE
      &lt;replaceable&gt;pattern&lt;/replaceable&gt;)&lt;/literal&gt;.)
</span>
<code class="function">LIKE</code>式は供給された<em class="replaceable"><code>pattern</code></em>に<em class="replaceable"><code>string</code></em>が一致すれば真を返します。
（想像される通り、<code class="function">NOT LIKE</code>式は<code class="function">LIKE</code>式が真を返す場合には偽を返し、その逆もまた同じです。
同等の式として<code class="literal">NOT (<em class="replaceable"><code>string</code></em> LIKE <em class="replaceable"><code>pattern</code></em>)</code>とも表現できます。）
    </p><p>
<span class="original">
     If &lt;replaceable&gt;pattern&lt;/replaceable&gt; does not contain percent
     signs or underscores, then the pattern only represents the string
     itself; in that case &lt;function&gt;LIKE&lt;/function&gt; acts like the
     equals operator.  An underscore (&lt;literal&gt;_&lt;/literal&gt;) in
     &lt;replaceable&gt;pattern&lt;/replaceable&gt; stands for (matches) any single
     character; a percent sign (&lt;literal&gt;%&lt;/literal&gt;) matches any sequence
     of zero or more characters.
</span>
<em class="replaceable"><code>pattern</code></em>がパーセント記号もしくはアンダースコアを含んでいない場合patternは自身の文字列そのものです。この場合<code class="function">LIKE</code>式は等号演算子のように振舞います。
<em class="replaceable"><code>pattern</code></em>の中にあるアンダースコア（<code class="literal">_</code>）は任意の一文字との一致を意味し、パーセント記号（<code class="literal">%</code>）は0文字以上の並びとの一致を意味します。
    </p><p>
<span class="original">
    Some examples:
</span>
例：
</p><pre class="programlisting">
'abc' LIKE 'abc'    <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' LIKE 'a%'     <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' LIKE '_b_'    <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' LIKE 'c'      <em class="lineannotation"><span class="lineannotation">false</span></em>
</pre><p>
   </p><p>
<span class="original">
    &lt;function&gt;LIKE&lt;/function&gt; pattern matching always covers the entire
    string.  Therefore, if it's desired to match a sequence anywhere within
    a string, the pattern must start and end with a percent sign.
</span>
<code class="function">LIKE</code>によるパターン一致は常に文字列全体に対して行われます。
従って、文字列内の任意位置における並びと一致させたい場合には、パーセント記号を先頭と末尾に付ける必要があります。
   </p><p>
<span class="original">
    To match a literal underscore or percent sign without matching
    other characters, the respective character in
    &lt;replaceable&gt;pattern&lt;/replaceable&gt; must be
    preceded by the escape character.  The default escape
    character is the backslash but a different one can be selected by
    using the &lt;literal&gt;ESCAPE&lt;/literal&gt; clause.  To match the escape
    character itself, write two escape characters.
</span>
他の文字の一致に使用するのではなく、アンダースコアやパーセント記号そのものを一致させたい場合には、<em class="replaceable"><code>pattern</code></em>の中のそれぞれのアンダースコアとパーセント記号の前にエスケープ文字を付けなければなりません。
デフォルトのエスケープ文字はバックスラッシュですが、<code class="literal">ESCAPE</code>句で他の文字を指定することができます。エスケープ文字そのものを一致させるにはエスケープ文字を2つ書きます。
   </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
     If you have &lt;xref linkend="guc-standard-conforming-strings"/&gt; turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See &lt;xref linkend="sql-syntax-strings"/&gt; for more information.
</span>
<a class="xref" href="runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS">standard_conforming_strings</a>パラメータをoffにしている場合、リテラル文字列定数に記述するバックスラッシュを二重にする必要があります。
詳細は<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS" title="4.1.2.1. 文字列定数">4.1.2.1</a>を参照してください。
    </p></div><p>
<span class="original">
    It's also possible to select no escape character by writing
    &lt;literal&gt;ESCAPE ''&lt;/literal&gt;.  This effectively disables the
    escape mechanism, which makes it impossible to turn off the
    special meaning of underscore and percent signs in the pattern.
</span>
同時に<code class="literal">ESCAPE ''</code>と記述することでエスケープ文字を選択しないことも可能です。
これにより、事実上エスケープ機構が働かなくなります。つまり、パターン内のアンダースコアおよびパーセント記号の特別な意味を解除することはできなくなります。
   </p><p>
<span class="original">
    The key word &lt;token&gt;ILIKE&lt;/token&gt; can be used instead of
    &lt;token&gt;LIKE&lt;/token&gt; to make the match case-insensitive according
    to the active locale.  This is not in the &lt;acronym&gt;SQL&lt;/acronym&gt; standard but is a
    &lt;productname&gt;PostgreSQL&lt;/productname&gt; extension.
</span>
現在のロケールに従って大文字小文字を区別しない一致を行うのであれば、<code class="token">LIKE</code>の代わりに<code class="token">ILIKE</code>キーワードを使うことができます。
これは標準<acronym class="acronym">SQL</acronym>ではなく、<span class="productname">PostgreSQL</span>の拡張です。
   </p><p>
<span class="original">
    The operator &lt;literal&gt;~~&lt;/literal&gt; is equivalent to
    &lt;function&gt;LIKE&lt;/function&gt;, and &lt;literal&gt;~~*&lt;/literal&gt; corresponds to
    &lt;function&gt;ILIKE&lt;/function&gt;.  There are also
    &lt;literal&gt;!~~&lt;/literal&gt; and &lt;literal&gt;!~~*&lt;/literal&gt; operators that
    represent &lt;function&gt;NOT LIKE&lt;/function&gt; and &lt;function&gt;NOT
    ILIKE&lt;/function&gt;, respectively.  All of these operators are
    &lt;productname&gt;PostgreSQL&lt;/productname&gt;-specific.
</span>
<code class="literal">~~</code>演算子は<code class="function">LIKE</code>式と等価で、<code class="literal">~~*</code>は<code class="function">ILIKE</code>に対応します。
また<code class="function">NOT LIKE</code>および<code class="function">NOT ILIKE</code>を表す<code class="literal">!~~</code>および<code class="literal">!~~*</code>演算子があります。
これら全ての演算子は<span class="productname">PostgreSQL</span>固有のものです。
   </p><p>
<span class="original">
    There is also the prefix operator &lt;literal&gt;^@&lt;/literal&gt; and corresponding
    &lt;function&gt;starts_with&lt;/function&gt; function which covers cases when only
    searching by beginning of the string is needed.
</span>
単に文字列の先頭からの開始が必要なだけのケースであれば、接頭辞演算子<code class="literal">^@</code>とそれに対応する<code class="function">starts_with</code>関数もあります。
   </p></div><div class="sect2" id="FUNCTIONS-SIMILARTO-REGEXP"><div class="titlepage"><div><div><h3 class="title">9.7.2. <code class="function">SIMILAR TO</code>正規表現</h3></div></div></div><span class="original">
   &lt;title&gt;&lt;function&gt;SIMILAR TO&lt;/function&gt; Regular Expressions&lt;/title&gt;
</span><a id="id-1.5.8.12.7.2" class="indexterm"></a><a id="id-1.5.8.12.7.3" class="indexterm"></a><a id="id-1.5.8.12.7.4" class="indexterm"></a><pre class="synopsis">
<em class="replaceable"><code>string</code></em> SIMILAR TO <em class="replaceable"><code>pattern</code></em> [<span class="optional">ESCAPE <em class="replaceable"><code>escape-character</code></em></span>]
<em class="replaceable"><code>string</code></em> NOT SIMILAR TO <em class="replaceable"><code>pattern</code></em> [<span class="optional">ESCAPE <em class="replaceable"><code>escape-character</code></em></span>]
</pre><p>
<span class="original">
    The &lt;function&gt;SIMILAR TO&lt;/function&gt; operator returns true or
    false depending on whether its pattern matches the given string.
    It is similar to &lt;function&gt;LIKE&lt;/function&gt;, except that it
    interprets the pattern using the SQL standard's definition of a
    regular expression.  SQL regular expressions are a curious cross
    between &lt;function&gt;LIKE&lt;/function&gt; notation and common regular
    expression notation.
</span>
<code class="function">SIMILAR TO</code>演算子は、そのパターンが与えられた文字列に一致するかどうかにより、真もしくは偽を返します。
これは、標準SQLの正規表現定義を使用してパターンを解釈するという点以外は、<code class="function">LIKE</code>に類似しています。
SQLの正規表現は、<code class="function">LIKE</code>表記と一般的な正規表現の表記とを混ぜ合わせたようなものになっています。
   </p><p>
<span class="original">
    Like &lt;function&gt;LIKE&lt;/function&gt;, the &lt;function&gt;SIMILAR TO&lt;/function&gt;
    operator succeeds only if its pattern matches the entire string;
    this is unlike common regular expression behavior where the pattern
    can match any part of the string.
    Also like
    &lt;function&gt;LIKE&lt;/function&gt;, &lt;function&gt;SIMILAR TO&lt;/function&gt; uses
    &lt;literal&gt;_&lt;/literal&gt; and &lt;literal&gt;%&lt;/literal&gt; as wildcard characters denoting
    any single character and any string, respectively (these are
    comparable to &lt;literal&gt;.&lt;/literal&gt; and &lt;literal&gt;.*&lt;/literal&gt; in POSIX regular
    expressions).
</span>
<code class="function">LIKE</code>と同様、<code class="function">SIMILAR TO</code>演算子は、そのパターンが文字列全体に一致した場合のみ真を返します。これは、パターンが文字列の一部分であっても一致する、一般的な正規表現の動作とは異なっています。
また、<code class="function">LIKE</code>と同様、<code class="function">SIMILAR TO</code>では、<code class="literal">%</code>および<code class="literal">_</code>を、それぞれ任意の文字列および任意の単一文字を意味するワイルドカード文字として使用します（これらは、POSIX正規表現での<code class="literal">.*</code>および<code class="literal">.</code>に相当します）。
   </p><p>
<span class="original">
    In addition to these facilities borrowed from &lt;function&gt;LIKE&lt;/function&gt;,
    &lt;function&gt;SIMILAR TO&lt;/function&gt; supports these pattern-matching
    metacharacters borrowed from POSIX regular expressions:
</span>
<code class="function">LIKE</code>から取り入れた上記の機能に加え、<code class="function">SIMILAR TO</code>では、以下のようにPOSIX正規表現から取り入れたパターンマッチメタ文字もサポートしています。

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
      &lt;literal&gt;|&lt;/literal&gt; denotes alternation (either of two alternatives).
</span>
<code class="literal">|</code>は、二者択一（2つの選択肢のうちいずれか）を意味します。
     </p></li><li class="listitem"><p>
<span class="original">
      &lt;literal&gt;*&lt;/literal&gt; denotes repetition of the previous item zero
      or more times.
</span>
<code class="literal">*</code>は、直前の項目の0回以上の繰り返しを意味します。
     </p></li><li class="listitem"><p>
<span class="original">
      &lt;literal&gt;+&lt;/literal&gt; denotes repetition of the previous item one
      or more times.
</span>
<code class="literal">+</code>は、直前の項目の1回以上の繰り返しを意味します。
     </p></li><li class="listitem"><p>
<span class="original">
      &lt;literal&gt;?&lt;/literal&gt; denotes repetition of the previous item zero
      or one time.
</span>
<code class="literal">?</code>は、直前の項目の0回もしくは1回の繰り返しを意味します。
     </p></li><li class="listitem"><p>
<span class="original">
      &lt;literal&gt;{&lt;/literal&gt;&lt;replaceable&gt;m&lt;/replaceable&gt;&lt;literal&gt;}&lt;/literal&gt; denotes repetition
      of the previous item exactly &lt;replaceable&gt;m&lt;/replaceable&gt; times.
</span>
<code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}</code>は、直前の項目の正確な<em class="replaceable"><code>m</code></em>回の繰り返しを意味します。
     </p></li><li class="listitem"><p>
<span class="original">
      &lt;literal&gt;{&lt;/literal&gt;&lt;replaceable&gt;m&lt;/replaceable&gt;&lt;literal&gt;,}&lt;/literal&gt; denotes repetition
      of the previous item &lt;replaceable&gt;m&lt;/replaceable&gt; or more times.
</span>
      <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,}</code>は、直前の項目の<em class="replaceable"><code>m</code></em>回以上の繰り返しを意味します。
     </p></li><li class="listitem"><p>
<span class="original">
      &lt;literal&gt;{&lt;/literal&gt;&lt;replaceable&gt;m&lt;/replaceable&gt;&lt;literal&gt;,&lt;/literal&gt;&lt;replaceable&gt;n&lt;/replaceable&gt;&lt;literal&gt;}&lt;/literal&gt;
      denotes repetition of the previous item at least &lt;replaceable&gt;m&lt;/replaceable&gt; and
      not more than &lt;replaceable&gt;n&lt;/replaceable&gt; times.
</span>
<code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}</code>は、直前の項目の<em class="replaceable"><code>m</code></em>回以上かつ<em class="replaceable"><code>n</code></em>回以下の繰り返しを意味します。
     </p></li><li class="listitem"><p>
<span class="original">
      Parentheses &lt;literal&gt;()&lt;/literal&gt; can be used to group items into
      a single logical item.
</span>
丸括弧<code class="literal">()</code>は、項目を1つの論理項目にグループ化することができます。
     </p></li><li class="listitem"><p>
<span class="original">
      A bracket expression &lt;literal&gt;[...]&lt;/literal&gt; specifies a character
      class, just as in POSIX regular expressions.
</span>
大括弧式<code class="literal">[...]</code>は、POSIX正規表現と同様に文字クラスを指定します。
     </p></li></ul></div><p>

<span class="original">
    Notice that the period (&lt;literal&gt;.&lt;/literal&gt;) is not a metacharacter
    for &lt;function&gt;SIMILAR TO&lt;/function&gt;.
</span>
<code class="function">SIMILAR TO</code>ではピリオド（<code class="literal">.</code>）はメタ文字ではないことに注意してください。
   </p><p>
<span class="original">
    As with &lt;function&gt;LIKE&lt;/function&gt;, a backslash disables the special meaning
    of any of these metacharacters; or a different escape character can
    be specified with &lt;literal&gt;ESCAPE&lt;/literal&gt;.
</span>
<code class="function">LIKE</code>と同様、バックスラッシュは全てのメタ文字の特殊な意味を無効にします。
また、異なるエスケープ文字を<code class="literal">ESCAPE</code>で指定することが可能です。
   </p><p>
<span class="original">
    Some examples:
</span>
例：
</p><pre class="programlisting">
'abc' SIMILAR TO 'abc'      <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' SIMILAR TO 'a'        <em class="lineannotation"><span class="lineannotation">false</span></em>
'abc' SIMILAR TO '%(b|d)%'  <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' SIMILAR TO '(b|c)%'   <em class="lineannotation"><span class="lineannotation">false</span></em>
</pre><p>
   </p><p>
<span class="original">
    The &lt;function&gt;substring&lt;/function&gt; function with three parameters,
    &lt;function&gt;substring(&lt;replaceable&gt;string&lt;/replaceable&gt; from
    &lt;replaceable&gt;pattern&lt;/replaceable&gt; for
    &lt;replaceable&gt;escape-character&lt;/replaceable&gt;)&lt;/function&gt;, provides
    extraction of a substring that matches an SQL
    regular expression pattern.  As with &lt;literal&gt;SIMILAR TO&lt;/literal&gt;, the
    specified pattern must match the entire data string, or else the
    function fails and returns null.  To indicate the part of the
    pattern that should be returned on success, the pattern must contain
    two occurrences of the escape character followed by a double quote
    (&lt;literal&gt;"&lt;/literal&gt;). &lt;!&amp;#045;- 原文コメント " font-lock sanity &amp;#045;-&gt;
    The text matching the portion of the pattern
    between these markers is returned.
</span>
3つのパラメータを持つ<code class="function">substring</code>関数、<code class="function">substring(<em class="parameter"><code>string</code></em> from <em class="replaceable"><code>pattern</code></em> for <em class="replaceable"><code>escape-character</code></em>)</code>を使用して、SQL正規表現パターンに一致する部分文字列を取り出すことができます。
<code class="literal">SIMILAR TO</code>と同様、指定したパターンがデータ文字列全体に一致する必要があります。一致しない場合、関数は終了し、NULLを返します。一致した場合に返されるべきパターンの一部を示すために、エスケープ文字の後に二重引用符（<code class="literal">"</code>）を繋げたものを2つパターンに含める必要があります。<span class="original"> " font-lock sanity </span>
これらの印で括られたパターンの一部に一致するテキストが返されます。
   </p><p>
<span class="original">
    Some examples, with &lt;literal&gt;#&amp;quot;&lt;/literal&gt; delimiting the return string:
</span>
例：<code class="literal">#"</code>を使用して返される文字列を区切ります。
</p><pre class="programlisting">
substring('foobar' from '%#"o_b#"%' for '#')   <em class="lineannotation"><span class="lineannotation">oob</span></em>
substring('foobar' from '#"o_b#"%' for '#')    <em class="lineannotation"><span class="lineannotation">NULL</span></em>
</pre><p>
   </p></div><div class="sect2" id="FUNCTIONS-POSIX-REGEXP"><div class="titlepage"><div><div><h3 class="title">9.7.3. <acronym class="acronym">POSIX</acronym>正規表現</h3></div></div></div><span class="original">
   &lt;title&gt;&lt;acronym&gt;POSIX&lt;/acronym&gt; Regular Expressions&lt;/title&gt;
</span><a id="id-1.5.8.12.8.2" class="indexterm"></a><a id="id-1.5.8.12.8.3" class="indexterm"></a><a id="id-1.5.8.12.8.4" class="indexterm"></a><a id="id-1.5.8.12.8.5" class="indexterm"></a><a id="id-1.5.8.12.8.6" class="indexterm"></a><a id="id-1.5.8.12.8.7" class="indexterm"></a><a id="id-1.5.8.12.8.8" class="indexterm"></a><p>
<span class="original">
    &lt;xref linkend="functions-posix-table"/&gt; lists the available
    operators for pattern matching using POSIX regular expressions.
</span>
<a class="xref" href="functions-matching.html#FUNCTIONS-POSIX-TABLE" title="表9.14 正規表現マッチ演算子">表 9.14</a>に、POSIX正規表現を使ったパターンマッチに使用可能な演算子を列挙します。
   </p><div class="table" id="FUNCTIONS-POSIX-TABLE"><p class="title"><strong>表9.14 正規表現マッチ演算子</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;Regular Expression Match Operators&lt;/title&gt;
</span><table class="table" summary="正規表現マッチ演算子" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>演算子</th><th>説明</th><th>例</th></tr></thead><tbody><tr><td> <code class="literal">~</code> </td><td>正規表現にマッチ、大文字小文字の区別あり</td><td><code class="literal">'thomas' ~ '.*thomas.*'</code></td></tr><tr><td> <code class="literal">~*</code> </td><td>正規表現にマッチ、大文字小文字の区別なし</td><td><code class="literal">'thomas' ~* '.*Thomas.*'</code></td></tr><tr><td> <code class="literal">!~</code> </td><td>正規表現にマッチしない、大文字小文字の区別あり</td><td><code class="literal">'thomas' !~ '.*Thomas.*'</code></td></tr><tr><td> <code class="literal">!~*</code> </td><td>正規表現にマッチしない、大文字小文字の区別なし</td><td><code class="literal">'thomas' !~* '.*vadim.*'</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
     &lt;acronym&gt;POSIX&lt;/acronym&gt; regular expressions provide a more
     powerful means for pattern matching than the &lt;function&gt;LIKE&lt;/function&gt; and
     &lt;function&gt;SIMILAR TO&lt;/function&gt; operators.
     Many Unix tools such as &lt;command&gt;egrep&lt;/command&gt;,
     &lt;command&gt;sed&lt;/command&gt;, or &lt;command&gt;awk&lt;/command&gt; use a pattern
     matching language that is similar to the one described here.
</span>
<acronym class="acronym">POSIX</acronym>正規表現は、パターンマッチという意味合いでは、<code class="function">LIKE</code>および<code class="function">SIMILAR TO</code>演算子よりもさらに強力です。
<code class="command">egrep</code>、<code class="command">sed</code>、あるいは<code class="command">awk</code>のような多くのUnixツールはここで解説しているのと類似したパターンマッチ言語を使用しています。
    </p><p>
<span class="original">
     A regular expression is a character sequence that is an
     abbreviated definition of a set of strings (a &lt;firstterm&gt;regular
     set&lt;/firstterm&gt;).  A string is said to match a regular expression
     if it is a member of the regular set described by the regular
     expression.  As with &lt;function&gt;LIKE&lt;/function&gt;, pattern characters
     match string characters exactly unless they are special characters
     in the regular expression language &amp;mdash; but regular expressions use
     different special characters than &lt;function&gt;LIKE&lt;/function&gt; does.
     Unlike &lt;function&gt;LIKE&lt;/function&gt; patterns, a
     regular expression is allowed to match anywhere within a string, unless
     the regular expression is explicitly anchored to the beginning or
     end of the string.
</span>
正規表現とは文字列の集合（<em class="firstterm">正規集合</em>）の簡略された定義である文字が連なっているものです。
ある文字列が正規表現で記述された正規集合の要素になっていれば、その文字列は正規表現にマッチしていると呼ばれます。
<code class="function">LIKE</code>と同様、正規表現言語で特殊文字とされているもの以外、パターン文字は文字列と完全にマッチされます。とは言っても、正規表現は<code class="function">LIKE</code>関数が使用するのとは異なる特殊文字を使用します。
<code class="function">LIKE</code>関数のパターンと違って正規表現は、明示的に正規表現が文字列の最初または最後からと位置指定されていない限り文字列内のどの位置でもマッチを行えます。
    </p><p>
<span class="original">
     Some examples:
</span>
例：
</p><pre class="programlisting">
'abc' ~ 'abc'    <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' ~ '^a'     <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' ~ '(b|d)'  <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' ~ '^(b|c)' <em class="lineannotation"><span class="lineannotation">false</span></em>
</pre><p>
    </p><p>
<span class="original">
     The &lt;acronym&gt;POSIX&lt;/acronym&gt; pattern language is described in much
     greater detail below.
</span>
<acronym class="acronym">POSIX</acronym>パターン言語について以下により詳しく説明します。
    </p><p>
<span class="original">
     The &lt;function&gt;substring&lt;/function&gt; function with two parameters,
     &lt;function&gt;substring(&lt;replaceable&gt;string&lt;/replaceable&gt; from
     &lt;replaceable&gt;pattern&lt;/replaceable&gt;)&lt;/function&gt;, provides extraction of a
     substring
     that matches a POSIX regular expression pattern.  It returns null if
     there is no match, otherwise the portion of the text that matched the
     pattern.  But if the pattern contains any parentheses, the portion
     of the text that matched the first parenthesized subexpression (the
     one whose left parenthesis comes first) is
     returned.  You can put parentheses around the whole expression
     if you want to use parentheses within it without triggering this
     exception.  If you need parentheses in the pattern before the
     subexpression you want to extract, see the non-capturing parentheses
     described below.
</span>
2つのパラメータを持つ<code class="function">substring</code>関数、<code class="function">substring(<em class="parameter"><code>string</code></em> from <em class="replaceable"><code>pattern</code></em>)</code>を使用して、POSIX正規表現パターンにマッチする部分文字列を取り出すことができます。
この関数は、マッチするものがない場合にはNULLを返し、ある場合はパターンにマッチしたテキストの一部を返します。
しかし、丸括弧を持つパターンの場合、最初の丸括弧内部分正規表現（左丸括弧が最初に来るもの）にマッチするテキストの一部が返されます。
この例外を起こさずにパターン中に丸括弧を使用したいのであれば、常に正規表現全体を丸括弧で囲むことができます。
パターン内の抽出対象の部分文字列より前に丸括弧が必要な場合、後述の捕捉されない丸括弧を参照してください。
    </p><p>
<span class="original">
    Some examples:
</span>
例：
</p><pre class="programlisting">
substring('foobar' from 'o.b')     <em class="lineannotation"><span class="lineannotation">oob</span></em>
substring('foobar' from 'o(.)b')   <em class="lineannotation"><span class="lineannotation">o</span></em>
</pre><p>
   </p><p>
<span class="original">
     The &lt;function&gt;regexp_replace&lt;/function&gt; function provides substitution of
     new text for substrings that match POSIX regular expression patterns.
     It has the syntax
     &lt;function&gt;regexp_replace&lt;/function&gt;(&lt;replaceable&gt;source&lt;/replaceable&gt;,
     &lt;replaceable&gt;pattern&lt;/replaceable&gt;, &lt;replaceable&gt;replacement&lt;/replaceable&gt;
     &lt;optional&gt;, &lt;replaceable&gt;flags&lt;/replaceable&gt; &lt;/optional&gt;).
     The &lt;replaceable&gt;source&lt;/replaceable&gt; string is returned unchanged if
     there is no match to the &lt;replaceable&gt;pattern&lt;/replaceable&gt;.  If there is a
     match, the &lt;replaceable&gt;source&lt;/replaceable&gt; string is returned with the
     &lt;replaceable&gt;replacement&lt;/replaceable&gt; string substituted for the matching
     substring.  The &lt;replaceable&gt;replacement&lt;/replaceable&gt; string can contain
     &lt;literal&gt;\&lt;/literal&gt;&lt;replaceable&gt;n&lt;/replaceable&gt;, where &lt;replaceable&gt;n&lt;/replaceable&gt; is 1
     through 9, to indicate that the source substring matching the
     &lt;replaceable&gt;n&lt;/replaceable&gt;'th parenthesized subexpression of the pattern should be
     inserted, and it can contain &lt;literal&gt;\&amp;amp;&lt;/literal&gt; to indicate that the
     substring matching the entire pattern should be inserted.  Write
     &lt;literal&gt;\\&lt;/literal&gt; if you need to put a literal backslash in the replacement
     text.
     The &lt;replaceable&gt;flags&lt;/replaceable&gt; parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  Flag &lt;literal&gt;i&lt;/literal&gt; specifies case-insensitive
     matching, while flag &lt;literal&gt;g&lt;/literal&gt; specifies replacement of each matching
     substring rather than only the first one.  Supported flags (though
     not &lt;literal&gt;g&lt;/literal&gt;) are
     described in &lt;xref linkend="posix-embedded-options-table"/&gt;.
</span>
<code class="function">regexp_replace</code>関数は、POSIX正規表現パターンにマッチする部分文字列を新規テキストと置換します。
構文は、<code class="function">regexp_replace</code>(<em class="replaceable"><code>source</code></em>, <em class="replaceable"><code>pattern</code></em>, <em class="replaceable"><code>replacement</code></em> [<span class="optional">, <em class="replaceable"><code>flags</code></em> </span>])です。
<em class="replaceable"><code>pattern</code></em>にマッチしない場合は、<em class="replaceable"><code>source</code></em>文字列がそのまま返されます。
マッチすると、マッチ部分文字列を<em class="replaceable"><code>replacement</code></em>文字列で置換した<em class="replaceable"><code>source</code></em>文字列が返されます。
<em class="replaceable"><code>replacement</code></em>文字列に<code class="literal">\</code><em class="replaceable"><code>n</code></em>（<em class="replaceable"><code>n</code></em>は1から9までの数字）を入れて、パターン内の<em class="replaceable"><code>n</code></em>番目の丸括弧つき部分表現にマッチする元の部分文字列を挿入することができます。
また、<code class="literal">\&amp;</code>を入れて、パターン全体とマッチする部分文字列を挿入することもできます。
置換テキスト内にバックスラッシュそのものを挿入する必要がある時は<code class="literal">\\</code>と記述します。
<em class="replaceable"><code>flags</code></em>パラメータは、関数の動作を変更するゼロもしくはそれ以上の1文字フラグを含むオプションのテキスト文字列です。フラグ<code class="literal">i</code>は大文字小文字を区別しないマッチを指定する一方、フラグ<code class="literal">g</code>は、最初にマッチしたもののみではなく、それぞれマッチした部分文字列の置換を指定します。
有効なフラグは(<code class="literal">g</code>を除く)<a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="表9.22 ARE埋め込みオプション文字">表 9.22</a>に記述されています。
    </p><p>
<span class="original">
    Some examples:
</span>
    例：
</p><pre class="programlisting">
regexp_replace('foobarbaz', 'b..', 'X')
                                   <em class="lineannotation"><span class="lineannotation">fooXbaz</span></em>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <em class="lineannotation"><span class="lineannotation">fooXX</span></em>
regexp_replace('foobarbaz', 'b(..)', 'X\1Y', 'g')
                                   <em class="lineannotation"><span class="lineannotation">fooXarYXazY</span></em>
</pre><p>
   </p><p>
<span class="original">
     The &lt;function&gt;regexp_match&lt;/function&gt; function returns a text array of
     captured substring(s) resulting from the first match of a POSIX
     regular expression pattern to a string.  It has the syntax
     &lt;function&gt;regexp_match&lt;/function&gt;(&lt;replaceable&gt;string&lt;/replaceable&gt;,
     &lt;replaceable&gt;pattern&lt;/replaceable&gt; &lt;optional&gt;, &lt;replaceable&gt;flags&lt;/replaceable&gt; &lt;/optional&gt;).
     If there is no match, the result is &lt;literal&gt;NULL&lt;/literal&gt;.
     If a match is found, and the &lt;replaceable&gt;pattern&lt;/replaceable&gt; contains no
     parenthesized subexpressions, then the result is a single-element text
     array containing the substring matching the whole pattern.
     If a match is found, and the &lt;replaceable&gt;pattern&lt;/replaceable&gt; contains
     parenthesized subexpressions, then the result is a text array
     whose &lt;replaceable&gt;n&lt;/replaceable&gt;'th element is the substring matching
     the &lt;replaceable&gt;n&lt;/replaceable&gt;'th parenthesized subexpression of
     the &lt;replaceable&gt;pattern&lt;/replaceable&gt; (not counting &lt;quote&gt;non-capturing&lt;/quote&gt;
     parentheses; see below for details).
     The &lt;replaceable&gt;flags&lt;/replaceable&gt; parameter is an optional text string
     containing zero or more single-letter flags that change the function's
     behavior.  Supported flags are described
     in &lt;xref linkend="posix-embedded-options-table"/&gt;.
</span>
<code class="function">regexp_match</code>関数はPOSIX正規表現パターンを文字列にマッチさせた結果、捕捉された最初の部分文字列のテキスト配列を返します。
<code class="function">regexp_match</code>(<em class="replaceable"><code>string</code></em>, <em class="replaceable"><code>pattern</code></em> [<span class="optional">, <em class="replaceable"><code>flags</code></em> </span>])の構文になります。
マッチするものがなければ、結果は<code class="literal">NULL</code>となります。
マッチする部分があり、かつ<em class="replaceable"><code>pattern</code></em>が丸括弧で括られた部分文字列を含まない場合、結果はパターン全体にマッチする部分文字列を含む単一要素のテキスト配列となります。
マッチする部分があり、かつ<em class="replaceable"><code>pattern</code></em>が丸括弧で括られた部分文字列を含む場合、結果はテキスト配列で、その<em class="replaceable"><code>n</code></em>番目の要素は<em class="replaceable"><code>pattern</code></em>の<em class="replaceable"><code>n</code></em>番目に丸括弧で括られた部分文字列にマッチする部分文字列となります（<span class="quote">「<span class="quote">捕捉されない</span>」</span>丸括弧は数えません。詳細は以下を参照してください）。
<em class="replaceable"><code>flags</code></em>パラメータは、関数の動作を変更するゼロもしくは複数の単一文字フラグを含むオプションのテキスト文字列です。
有効なフラグは<a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="表9.22 ARE埋め込みオプション文字">表 9.22</a>に記載されています。
    </p><p>
<span class="original">
    Some examples:
</span>
例を示します。
</p><pre class="programlisting">
SELECT regexp_match('foobarbequebaz', 'bar.*que');
 regexp_match
--------------
 {barbeque}
(1 row)

SELECT regexp_match('foobarbequebaz', '(bar)(beque)');
 regexp_match
--------------
 {bar,beque}
(1 row)
</pre><p>
<span class="original">
    In the common case where you just want the whole matching substring
    or &lt;literal&gt;NULL&lt;/literal&gt; for no match, write something like
</span>
マッチするときはマッチする部分文字列全体、マッチしないときは<code class="literal">NULL</code>を返したいというよくあるケースは、以下のように書くことができます。
</p><pre class="programlisting">
SELECT (regexp_match('foobarbequebaz', 'bar.*que'))[1];
 regexp_match
--------------
 barbeque
(1 row)
</pre><p>
   </p><p>
<span class="original">
     The &lt;function&gt;regexp_matches&lt;/function&gt; function returns a set of text arrays
     of captured substring(s) resulting from matching a POSIX regular
     expression pattern to a string.  It has the same syntax as
     &lt;function&gt;regexp_match&lt;/function&gt;.
     This function returns no rows if there is no match, one row if there is
     a match and the &lt;literal&gt;g&lt;/literal&gt; flag is not given, or &lt;replaceable&gt;N&lt;/replaceable&gt;
     rows if there are &lt;replaceable&gt;N&lt;/replaceable&gt; matches and the &lt;literal&gt;g&lt;/literal&gt; flag
     is given.  Each returned row is a text array containing the whole
     matched substring or the substrings matching parenthesized
     subexpressions of the &lt;replaceable&gt;pattern&lt;/replaceable&gt;, just as described above
     for &lt;function&gt;regexp_match&lt;/function&gt;.
     &lt;function&gt;regexp_matches&lt;/function&gt; accepts all the flags shown
     in &lt;xref linkend="posix-embedded-options-table"/&gt;, plus
     the &lt;literal&gt;g&lt;/literal&gt; flag which commands it to return all matches, not
     just the first one.
</span>
<code class="function">regexp_matches</code>関数はPOSIX正規表現パターンを文字列にマッチさせた結果、捕捉された部分文字列のテキスト配列の集合を返します。
構文は<code class="function">regexp_match</code>と同じです。
この関数は、マッチするものがないときは行を返しませんが、マッチするものがあり、<code class="literal">g</code>フラグが指定されていないときは1行だけ、マッチするものが<em class="replaceable"><code>N</code></em>個あり、<code class="literal">g</code>フラグが指定されているときは<em class="replaceable"><code>N</code></em>行を返します。
返される各行は上で<code class="function">regexp_match</code>について説明したのと全く同じで、マッチする部分文字列全体、または丸括弧で括られた部分文字列にマッチする部分文字列を含むテキスト配列です。
<code class="function">regexp_matches</code>は<a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="表9.22 ARE埋め込みオプション文字">表 9.22</a>に示すすべてのフラグに加え、最初のマッチだけでなくすべてのマッチを返す<code class="literal">g</code>を受け付けます。
    </p><p>
<span class="original">
    Some examples:
</span>
例を示します。
</p><pre class="programlisting">
SELECT regexp_matches('foo', 'not there');
 regexp_matches
----------------
(0 rows)

SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches
----------------
 {bar,beque}
 {bazil,barf}
(2 rows)
</pre><p>
   </p><div class="tip"><h3 class="title">ヒント</h3><p>
<span class="original">
     In most cases &lt;function&gt;regexp_matches()&lt;/function&gt; should be used with
     the &lt;literal&gt;g&lt;/literal&gt; flag, since if you only want the first match, it's
     easier and more efficient to use &lt;function&gt;regexp_match()&lt;/function&gt;.
     However, &lt;function&gt;regexp_match()&lt;/function&gt; only exists
     in &lt;productname&gt;PostgreSQL&lt;/productname&gt; version 10 and up.  When working in older
     versions, a common trick is to place a &lt;function&gt;regexp_matches()&lt;/function&gt;
     call in a sub-select, for example:
</span>
最初にマッチするものだけが必要なときは<code class="function">regexp_match()</code>を使う方がより簡単で効率的ですから、<code class="function">regexp_matches()</code>はほとんどの場合<code class="literal">g</code>フラグを指定して使われるでしょう。
しかし、<code class="function">regexp_match()</code>は<span class="productname">PostgreSQL</span>のバージョン10以上でのみ利用できます。
古いバージョンを使う時によくある手法は、以下の例のように、副SELECTの中に<code class="function">regexp_matches()</code>の呼び出しを入れることです。
</p><pre class="programlisting">
SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;
</pre><p>
<span class="original">
     This produces a text array if there's a match, or &lt;literal&gt;NULL&lt;/literal&gt; if
     not, the same as &lt;function&gt;regexp_match()&lt;/function&gt; would do.  Without the
     sub-select, this query would produce no output at all for table rows
     without a match, which is typically not the desired behavior.
</span>
これは<code class="function">regexp_match()</code>と同じく、マッチするものがあればテキスト配列を生成し、マッチしなければ<code class="literal">NULL</code>となります。
副SELECTを使わなければ、マッチするものがないテーブル行については問い合わせの出力が生成されず、多くの場合に期待される動作と異なります。
    </p></div><p>
<span class="original">
     The &lt;function&gt;regexp_split_to_table&lt;/function&gt; function splits a string using a POSIX
     regular expression pattern as a delimiter.  It has the syntax
     &lt;function&gt;regexp_split_to_table&lt;/function&gt;(&lt;replaceable&gt;string&lt;/replaceable&gt;, &lt;replaceable&gt;pattern&lt;/replaceable&gt;
     &lt;optional&gt;, &lt;replaceable&gt;flags&lt;/replaceable&gt; &lt;/optional&gt;).
     If there is no match to the &lt;replaceable&gt;pattern&lt;/replaceable&gt;, the function returns the
     &lt;replaceable&gt;string&lt;/replaceable&gt;.  If there is at least one match, for each match it returns
     the text from the end of the last match (or the beginning of the string)
     to the beginning of the match.  When there are no more matches, it
     returns the text from the end of the last match to the end of the string.
     The &lt;replaceable&gt;flags&lt;/replaceable&gt; parameter is an optional text string containing
     zero or more single-letter flags that change the function's behavior.
     &lt;function&gt;regexp_split_to_table&lt;/function&gt; supports the flags described in
     &lt;xref linkend="posix-embedded-options-table"/&gt;.
</span>
<code class="function">regexp_split_to_table</code>関数はPOSIX正規表現パターンを区切り文字として使用し、文字列を分割します。<code class="function">regexp_split_to_table</code>(<em class="replaceable"><code>string</code></em>, <em class="replaceable"><code>pattern</code></em> [<span class="optional">, <em class="replaceable"><code>flags</code></em> </span>])の構文になります。
<em class="replaceable"><code>pattern</code></em>にマッチしない場合、関数は<em class="replaceable"><code>string</code></em>を返します。
少なくともひとつのマッチがあれば、それぞれのマッチに対して関数は最後のマッチの終わり（あるいは文字列の始め）から最初のマッチまでのテキストを返します。
もはやマッチしなくなると最後のマッチの終わりから文字列の最後までテキストを返します。
<em class="replaceable"><code>flags</code></em>パラメータは、関数の動作を変更するゼロもしくは複数の単一文字フラグを含むオプションのテキスト文字列です。
<code class="function">regexp_split_to_table</code>は<a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="表9.22 ARE埋め込みオプション文字">表 9.22</a>で記載されているフラグをサポートします。
    </p><p>
<span class="original">
     The &lt;function&gt;regexp_split_to_array&lt;/function&gt; function behaves the same as
     &lt;function&gt;regexp_split_to_table&lt;/function&gt;, except that &lt;function&gt;regexp_split_to_array&lt;/function&gt;
     returns its result as an array of &lt;type&gt;text&lt;/type&gt;.  It has the syntax
     &lt;function&gt;regexp_split_to_array&lt;/function&gt;(&lt;replaceable&gt;string&lt;/replaceable&gt;, &lt;replaceable&gt;pattern&lt;/replaceable&gt;
     &lt;optional&gt;, &lt;replaceable&gt;flags&lt;/replaceable&gt; &lt;/optional&gt;).
     The parameters are the same as for &lt;function&gt;regexp_split_to_table&lt;/function&gt;.
</span>
<code class="function">regexp_split_to_array</code>関数は、<code class="function">regexp_split_to_array</code>がその結果を<code class="type">text</code>配列で返すことを除いて、<code class="function">regexp_split_to_table</code>と同じ動作をします。
<code class="function">regexp_split_to_array</code>(<em class="replaceable"><code>string</code></em>, <em class="replaceable"><code>pattern</code></em> [<span class="optional">, <em class="replaceable"><code>flags</code></em> </span>])の構文になります。
パラメータは<code class="function">regexp_split_to_table</code>のものと同じです。
    </p><p>
<span class="original">
    Some examples:
</span>
例：
</p><pre class="programlisting">

SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', '\s+') AS foo;
  foo   
-------
 the    
 quick  
 brown  
 fox    
 jumps 
 over   
 the    
 lazy   
 dog    
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', '\s+');
              regexp_split_to_array             
-----------------------------------------------
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', '\s*') AS foo;
 foo 
-----
 t         
 h         
 e         
 q         
 u         
 i         
 c         
 k         
 b         
 r         
 o         
 w         
 n         
 f         
 o         
 x         
(16 rows)
</pre><p>
   </p><p>
<span class="original">
    As the last example demonstrates, the regexp split functions ignore
    zero-length matches that occur at the start or end of the string
    or immediately after a previous match.  This is contrary to the strict
    definition of regexp matching that is implemented by
    &lt;function&gt;regexp_match&lt;/function&gt; and
    &lt;function&gt;regexp_matches&lt;/function&gt;, but is usually the most convenient behavior
    in practice.  Other software systems such as Perl use similar definitions.
</span>
最後の例が明らかにしているように、regexp分割関数は文字列の最初あるいは終わり、もしくは前のマッチの直後に発生する長さを持たないマッチを無視します。
<code class="function">regexp_match</code>および<code class="function">regexp_matches</code>で実装されたregexpマッチの厳格な定義にこれは相容れませんが、実務上は最も使い勝手の良い動作です。
Perlのような他のソフトウェアシステムも似たような定義を使用します。
   </p><span class="original"> derived from the re_syntax.n man page </span><div class="sect3" id="POSIX-SYNTAX-DETAILS"><div class="titlepage"><div><div><h4 class="title">9.7.3.1. 正規表現の詳細</h4></div></div></div><span class="original">
    &lt;title&gt;Regular Expression Details&lt;/title&gt;
</span><p>
<span class="original">
    &lt;productname&gt;PostgreSQL&lt;/productname&gt;'s regular expressions are implemented
    using a software package written by Henry Spencer.  Much of
    the description of regular expressions below is copied verbatim from his
    manual.
</span>
<span class="productname">PostgreSQL</span>の正規表現はHenry Spencerにより書かれたソフトウェアパッケージを使用して実装されています。
以下に説明する正規表現の多くの部分は同氏のマニュアルから一字一句複製したものです。
   </p><p>
<span class="original">
    Regular expressions (&lt;acronym&gt;RE&lt;/acronym&gt;s), as defined in
    &lt;acronym&gt;POSIX&lt;/acronym&gt; 1003.2, come in two forms:
    &lt;firstterm&gt;extended&lt;/firstterm&gt; &lt;acronym&gt;RE&lt;/acronym&gt;s or &lt;acronym&gt;ERE&lt;/acronym&gt;s
    (roughly those of &lt;command&gt;egrep&lt;/command&gt;), and
    &lt;firstterm&gt;basic&lt;/firstterm&gt; &lt;acronym&gt;RE&lt;/acronym&gt;s or &lt;acronym&gt;BRE&lt;/acronym&gt;s
    (roughly those of &lt;command&gt;ed&lt;/command&gt;).
    &lt;productname&gt;PostgreSQL&lt;/productname&gt; supports both forms, and
    also implements some extensions
    that are not in the POSIX standard, but have become widely used
    due to their availability in programming languages such as Perl and Tcl.
    &lt;acronym&gt;RE&lt;/acronym&gt;s using these non-POSIX extensions are called
    &lt;firstterm&gt;advanced&lt;/firstterm&gt; &lt;acronym&gt;RE&lt;/acronym&gt;s or &lt;acronym&gt;ARE&lt;/acronym&gt;s
    in this documentation.  AREs are almost an exact superset of EREs,
    but BREs have several notational incompatibilities (as well as being
    much more limited).
    We first describe the ARE and ERE forms, noting features that apply
    only to AREs, and then describe how BREs differ.
</span>
<acronym class="acronym">POSIX</acronym> 1003.2の定義によると、正規表現（<acronym class="acronym">RE</acronym>）には2つの形式があるとされます。<em class="firstterm">拡張</em><acronym class="acronym">RE</acronym>もしくは<acronym class="acronym">ERE</acronym>（大まかにいって<code class="command">egrep</code>に代表されるもの）、および<em class="firstterm">基本</em><acronym class="acronym">RE</acronym>もしくは<acronym class="acronym">BRE</acronym>（大まかにいって<code class="command">ed</code>に代表されるもの）です。
<span class="productname">PostgreSQL</span>は両方の形式をサポートし、さらに、POSIX標準にはないけれどもPerlやTclなどのプログラミング言語で利用できることから広く使用されるようになった、いくつかの拡張もサポートしています。
本書では、非POSIX拡張を使用した<acronym class="acronym">RE</acronym>を<em class="firstterm">高度な</em><acronym class="acronym">RE</acronym>もしくは<acronym class="acronym">ARE</acronym>と呼びます。AREはEREの正確な上位セットですが、BREとは複数の記法上の非互換な点があります（さらに非常に多くの制限が課されています）。
まず、AREとERE形式について説明し、そして、AREにのみ適用される機能の注意を、さらにBREとの違いについて説明します。
   </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
     &lt;productname&gt;PostgreSQL&lt;/productname&gt; always initially presumes that a regular
     expression follows the ARE rules.  However, the more limited ERE or
     BRE rules can be chosen by prepending an &lt;firstterm&gt;embedded option&lt;/firstterm&gt;
     to the RE pattern, as described in &lt;xref linkend="posix-metasyntax"/&gt;.
     This can be useful for compatibility with applications that expect
     exactly the &lt;acronym&gt;POSIX&lt;/acronym&gt; 1003.2 rules.
</span>
<span class="productname">PostgreSQL</span>は常に、まず正規表現はARE規則に従うと推測します。
しかし、REパターンの前に、<a class="xref" href="functions-matching.html#POSIX-METASYNTAX" title="9.7.3.4. 正規表現メタ構文">9.7.3.4</a>に記載されているような<em class="firstterm">埋め込みオプション</em>を追加することにより、より限られたERE、あるいはBRE規則を選択することができます。
これは、<acronym class="acronym">POSIX</acronym>1003.2の規則を正確に期待しているアプリケーションとの互換性に関して有用です。
    </p></div><p>
<span class="original">
    A regular expression is defined as one or more
    &lt;firstterm&gt;branches&lt;/firstterm&gt;, separated by
    &lt;literal&gt;|&lt;/literal&gt;.  It matches anything that matches one of the
    branches.
</span>
正規表現は<code class="literal">|</code>で区切られた、1つまたは複数の<em class="firstterm">ブランチ</em>として定義されます。
ブランチのいずれか1つにマッチすればマッチしたことになります。
   </p><p>
<span class="original">
    A branch is zero or more &lt;firstterm&gt;quantified atoms&lt;/firstterm&gt; or
    &lt;firstterm&gt;constraints&lt;/firstterm&gt;, concatenated.
    It matches a match for the first, followed by a match for the second, etc;
    an empty branch matches the empty string.
</span>
ブランチはゼロ個以上の<em class="firstterm">量化アトム</em>もしくは<em class="firstterm">制約</em>の連結です。
最初のものにマッチに、次に第２番目のものにマッチを、というふうにマッチします。なお、空のブランチは空文字列にマッチします。
   </p><p>
<span class="original">
    A quantified atom is an &lt;firstterm&gt;atom&lt;/firstterm&gt; possibly followed
    by a single &lt;firstterm&gt;quantifier&lt;/firstterm&gt;.
    Without a quantifier, it matches a match for the atom.
    With a quantifier, it can match some number of matches of the atom.
    An &lt;firstterm&gt;atom&lt;/firstterm&gt; can be any of the possibilities
    shown in &lt;xref linkend="posix-atoms-table"/&gt;.
    The possible quantifiers and their meanings are shown in
    &lt;xref linkend="posix-quantifiers-table"/&gt;.
</span>
量化アトムとは、単一の<em class="firstterm">量指定子</em>が後ろに付く<em class="firstterm">アトム</em>のことです。
量指定子がないと、アトムにマッチするものがマッチしたことになります。
量指定子がある場合、アトムとのマッチが何回あるかでマッチしたことになります。
<em class="firstterm">アトム</em>は、<a class="xref" href="functions-matching.html#POSIX-ATOMS-TABLE" title="表9.15 正規表現のアトム">表 9.15</a>に示したもののいずれかを取ることができます。
  <a class="xref" href="functions-matching.html#POSIX-QUANTIFIERS-TABLE" title="表9.16 正規表現量指定子">表 9.16</a>に設定可能な量指定子とその意味を示します。
   </p><p>
<span class="original">
    A &lt;firstterm&gt;constraint&lt;/firstterm&gt; matches an empty string, but matches only when
    specific conditions are met.  A constraint can be used where an atom
    could be used, except it cannot be followed by a quantifier.
    The simple constraints are shown in
    &lt;xref linkend="posix-constraints-table"/&gt;;
    some more constraints are described later.
</span>
<em class="firstterm">制約</em>は空文字に、特定の条件に合う場合のみにマッチします。
アトムを使用できるところには制約を使用することができます。ただしその後に量指定子を付けることはできません。
単純な制約を<a class="xref" href="functions-matching.html#POSIX-CONSTRAINTS-TABLE" title="表9.17 正規表現制約">表 9.17</a>に示します。後で他のいくつかの制約を説明します。
   </p><div class="table" id="POSIX-ATOMS-TABLE"><p class="title"><strong>表9.15 正規表現のアトム</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;Regular Expression Atoms&lt;/title&gt;
</span><table class="table" summary="正規表現のアトム" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>アトム</th><th>説明</th></tr></thead><tbody><tr><td> <code class="literal">(</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td>（ここで<em class="replaceable"><code>re</code></em> は任意の正規表現で、）<em class="replaceable"><code>re</code></em>とのマッチに適合するもです。 マッチは可能である報告用と意味づけられます。</td></tr><tr><td> <code class="literal">(?:</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td>上と同じ。ただし、マッチは報告用と意味づけられません。（<span class="quote">「<span class="quote">捕捉されない</span>」</span>括弧の集合）（AREのみ）</td></tr><tr><td> <code class="literal">.</code> </td><td>任意の1文字にマッチします。</td></tr><tr><td> <code class="literal">[</code><em class="replaceable"><code>chars</code></em><code class="literal">]</code> </td><td>
        <em class="firstterm">ブラケット式</em>。
        <em class="replaceable"><code>chars</code></em>のいずれか1つにマッチします
       （詳細は<a class="xref" href="functions-matching.html#POSIX-BRACKET-EXPRESSIONS" title="9.7.3.2. ブラケット式">9.7.3.2</a>を参照してください）。
       </td></tr><tr><td> <code class="literal">\</code><em class="replaceable"><code>k</code></em> </td><td>（ここで<em class="replaceable"><code>k</code></em>は英数字以外です。）普通の文字として指定した文字にマッチします。例えば、<code class="literal">\\</code>はバックスラッシュ文字です。</td></tr><tr><td> <code class="literal">\</code><em class="replaceable"><code>c</code></em> </td><td>ここで<em class="replaceable"><code>c</code></em>は英数字です
       （おそらく他の文字が後に続きます）。
       <em class="firstterm">エスケープ</em>です。
       <a class="xref" href="functions-matching.html#POSIX-ESCAPE-SEQUENCES" title="9.7.3.3. 正規表現エスケープ">9.7.3.3</a>を参照してください
       （AREのみ、EREとBREではこれは<em class="replaceable"><code>c</code></em>にマッチします）。
       </td></tr><tr><td> <code class="literal">{</code> </td><td>直後に数字以外がある場合、左中括弧<code class="literal">{</code>にマッチします。
直後に数字が続く場合、<em class="replaceable"><code>bound</code></em>（後述）の始まりです。</td></tr><tr><td> <em class="replaceable"><code>x</code></em> </td><td>ここで<em class="replaceable"><code>x</code></em>は他に意味を持たない1文字です。
<em class="replaceable"><code>x</code></em>にマッチします。</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
    An RE cannot end with a backslash (&lt;literal&gt;\&lt;/literal&gt;).
</span>
REはバックスラッシュ<code class="literal">\</code>を終端とすることはできません。
   </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
     If you have &lt;xref linkend="guc-standard-conforming-strings"/&gt; turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See &lt;xref linkend="sql-syntax-strings"/&gt; for more information.
</span>
もし<a class="xref" href="runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS">standard_conforming_strings</a>パラメータをoffにしていた場合、リテラル文字列定数に記述するバックスラッシュは2倍必要となります。
  詳細は<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS" title="4.1.2.1. 文字列定数">4.1.2.1</a>を参照してください。
    </p></div><div class="table" id="POSIX-QUANTIFIERS-TABLE"><p class="title"><strong>表9.16 正規表現量指定子</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;Regular Expression Quantifiers&lt;/title&gt;
</span><table class="table" summary="正規表現量指定子" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>量指定子</th><th>マッチ</th></tr></thead><tbody><tr><td> <code class="literal">*</code> </td><td>アトムの0個以上複数の並びにマッチ</td></tr><tr><td> <code class="literal">+</code> </td><td>アトムの1個以上複数の並びにマッチ</td></tr><tr><td> <code class="literal">?</code> </td><td>アトムの0個または1個の並びにマッチ</td></tr><tr><td> <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}</code> </td><td>アトムの正確に<em class="replaceable"><code>m</code></em>個の並びにマッチ</td></tr><tr><td> <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,}</code> </td><td>アトムの<em class="replaceable"><code>m</code></em>個以上の並びにマッチ</td></tr><tr><td>
       <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}</code> </td><td> アトムの<em class="replaceable"><code>m</code></em>個以上<em class="replaceable"><code>n</code></em>以下の並びにマッチ。
<em class="replaceable"><code>m</code></em>は<em class="replaceable"><code>n</code></em>を超えることはできません。</td></tr><tr><td> <code class="literal">*?</code> </td><td><code class="literal">*</code>の最短マッチを行うバージョン</td></tr><tr><td> <code class="literal">+?</code> </td><td><code class="literal">+</code>の最短マッチを行うバージョン</td></tr><tr><td> <code class="literal">??</code> </td><td><code class="literal">?</code>の最短マッチを行うバージョン</td></tr><tr><td> <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}?</code> </td><td><code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}</code>の最短マッチを行うバージョン</td></tr><tr><td> <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,}?</code> </td><td><code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,}</code>の最短マッチを行うバージョン</td></tr><tr><td>
       <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}?</code> </td><td><code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}</code>の最短マッチを行うバージョン</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
    The forms using &lt;literal&gt;{&lt;/literal&gt;&lt;replaceable&gt;...&lt;/replaceable&gt;&lt;literal&gt;}&lt;/literal&gt;
    are known as &lt;firstterm&gt;bounds&lt;/firstterm&gt;.
    The numbers &lt;replaceable&gt;m&lt;/replaceable&gt; and &lt;replaceable&gt;n&lt;/replaceable&gt; within a bound are
    unsigned decimal integers with permissible values from 0 to 255 inclusive.
</span>
<code class="literal">{</code><em class="replaceable"><code>...</code></em><code class="literal">}</code>を使用する形式は<em class="firstterm">バウンド</em>として知られています。
バウンド内の<em class="replaceable"><code>m</code></em>と<em class="replaceable"><code>n</code></em>という数は符号なし10進整数であり、0以上255以下の値を取ることができます。
   </p><p>
<span class="original">
     &lt;firstterm&gt;Non-greedy&lt;/firstterm&gt; quantifiers (available in AREs only) match the
     same possibilities as their corresponding normal (&lt;firstterm&gt;greedy&lt;/firstterm&gt;)
     counterparts, but prefer the smallest number rather than the largest
     number of matches.
     See &lt;xref linkend="posix-matching-rules"/&gt; for more detail.
</span>
<em class="firstterm">最短マッチを行う</em>量指定子（AREのみで使用可能）は、対応する通常の（<em class="firstterm">欲張りの</em>）ものと同じものにマッチしますが、最大のマッチではなく最小のマッチを取ります。
詳細は<a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. 正規表現マッチ規則">9.7.3.5</a>を参照してください。
   </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
     A quantifier cannot immediately follow another quantifier, e.g.,
     &lt;literal&gt;**&lt;/literal&gt; is invalid.
     A quantifier cannot
     begin an expression or subexpression or follow
     &lt;literal&gt;^&lt;/literal&gt; or &lt;literal&gt;|&lt;/literal&gt;.
</span>
量指定子の直後に量指定子を続けることはできません。例えば<code class="literal">**</code>は無効です。
量指定子から式や副式を始めることはできず、また、<code class="literal">^</code>や<code class="literal">|</code>の直後に付けることもできません。
    </p></div><div class="table" id="POSIX-CONSTRAINTS-TABLE"><p class="title"><strong>表9.17 正規表現制約</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;Regular Expression Constraints&lt;/title&gt;
</span><table class="table" summary="正規表現制約" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>制約</th><th>説明</th></tr></thead><tbody><tr><td> <code class="literal">^</code> </td><td>文字列の先頭にマッチ</td></tr><tr><td> <code class="literal">$</code> </td><td>文字列の末尾にマッチ</td></tr><tr><td> <code class="literal">(?=</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td><em class="firstterm">先行肯定検索</em>は、<em class="replaceable"><code>re</code></em>にマッチする部分文字列が始まる任意の場所にマッチします（AREのみ）。</td></tr><tr><td> <code class="literal">(?!</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td><em class="firstterm">先行否定検索</em>は、<em class="replaceable"><code>re</code></em>にマッチしない部分文字列が始まる任意の場所にマッチします（AREのみ）。</td></tr><tr><td> <code class="literal">(?&lt;=</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td> <em class="firstterm">後方肯定検索</em>は<em class="replaceable"><code>re</code></em>にマッチする部分文字列が終わる任意の場所にマッチします（AREのみ）。</td></tr><tr><td> <code class="literal">(?&lt;!</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td> <em class="firstterm">後方否定検索</em><em class="replaceable"><code>re</code></em>にマッチしない部分文字列が終わる任意の場所にマッチします（AREのみ）。</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
    Lookahead and lookbehind constraints cannot contain &lt;firstterm&gt;back
    references&lt;/firstterm&gt; (see &lt;xref linkend="posix-escape-sequences"/&gt;),
    and all parentheses within them are considered non-capturing.
</span>
先行検索制約および後方検索制約には<em class="firstterm">後方参照</em>（<a class="xref" href="functions-matching.html#POSIX-ESCAPE-SEQUENCES" title="9.7.3.3. 正規表現エスケープ">9.7.3.3</a>を参照）を含めることはできません。また、その中の括弧は全て取り込むものではないとみなされます。
   </p></div><div class="sect3" id="POSIX-BRACKET-EXPRESSIONS"><div class="titlepage"><div><div><h4 class="title">9.7.3.2. ブラケット式</h4></div></div></div><span class="original">
    &lt;title&gt;Bracket Expressions&lt;/title&gt;
</span><p>
<span class="original">
    A &lt;firstterm&gt;bracket expression&lt;/firstterm&gt; is a list of
    characters enclosed in &lt;literal&gt;[]&lt;/literal&gt;.  It normally matches
    any single character from the list (but see below).  If the list
    begins with &lt;literal&gt;^&lt;/literal&gt;, it matches any single character
    &lt;emphasis&gt;not&lt;/emphasis&gt; from the rest of the list.
    If two characters
    in the list are separated by &lt;literal&gt;-&lt;/literal&gt;, this is
    shorthand for the full range of characters between those two
    (inclusive) in the collating sequence,
    e.g., &lt;literal&gt;[0-9]&lt;/literal&gt; in &lt;acronym&gt;ASCII&lt;/acronym&gt; matches
    any decimal digit.  It is illegal for two ranges to share an
    endpoint, e.g.,  &lt;literal&gt;a-c-e&lt;/literal&gt;.  Ranges are very
    collating-sequence-dependent, so portable programs should avoid
    relying on them.
</span>
<em class="firstterm">ブラケット式</em>とは、<code class="literal">[]</code>内の文字のリストです。
通常これはそのリスト内の任意の1文字にマッチします（しかし、以降を参照してください）。
リストが<code class="literal">^</code>から始まる場合、そのリストの残りには<span class="emphasis"><em>ない</em></span>任意の1文字にマッチします。
リスト内の2文字が<code class="literal">-</code>で区切られていた場合、これは2つ（を含む）の間にある文字範囲全体を表す省略形となります。例えば、<acronym class="acronym">ASCII</acronym>における<code class="literal">[0-9]</code>は全ての数字にマッチします。
例えば<code class="literal">a-c-e</code>といった、終端を共有する2つの範囲は不正です。
範囲は並びの照合順に非常に依存しています。ですので、移植予定のプログラムではこれに依存してはなりません。
   </p><p>
<span class="original">
    To include a literal &lt;literal&gt;]&lt;/literal&gt; in the list, make it the
    first character (after &lt;literal&gt;^&lt;/literal&gt;, if that is used).  To
    include a literal &lt;literal&gt;-&lt;/literal&gt;, make it the first or last
    character, or the second endpoint of a range.  To use a literal
    &lt;literal&gt;-&lt;/literal&gt; as the first endpoint of a range, enclose it
    in &lt;literal&gt;[.&lt;/literal&gt; and &lt;literal&gt;.]&lt;/literal&gt; to make it a
    collating element (see below).  With the exception of these characters,
    some combinations using &lt;literal&gt;[&lt;/literal&gt;
    (see next paragraphs), and escapes (AREs only), all other special
    characters lose their special significance within a bracket expression.
    In particular, &lt;literal&gt;\&lt;/literal&gt; is not special when following
    ERE or BRE rules, though it is special (as introducing an escape)
    in AREs.
</span>
このリストに<code class="literal">]</code>そのものを含めるには、それを先頭文字（もしそれが使用されれば<code class="literal">^</code>の後）にしてください。
<code class="literal">-</code>そのものを含めるには、それを先頭もしくは末尾の文字とするか、範囲の2番目の終端としてください。
<code class="literal">-</code>を範囲の最初の終端で使用するには、<code class="literal">[.</code>と<code class="literal">.]</code>でそれを囲み、照合要素（後述）にしてください。
これら文字と、<code class="literal">[</code>（次段落を参照）のなんらかの組み合わせ、およびエスケープ（AREのみ）を例外として、他の全ての特殊文字はブラケット式内では特殊な意味を持ちません。
特に、<code class="literal">\</code>はEREとBRE規則に従う場合は特別でなくなります。しかし、AREでは（エスケープの始まりとして）特別な意味を持ちます。
   </p><p>
<span class="original">
    Within a bracket expression, a collating element (a character, a
    multiple-character sequence that collates as if it were a single
    character, or a collating-sequence name for either) enclosed in
    &lt;literal&gt;[.&lt;/literal&gt; and &lt;literal&gt;.]&lt;/literal&gt; stands for the
    sequence of characters of that collating element.  The sequence is
    treated as a single element of the bracket expression's list.  This
    allows a bracket
    expression containing a multiple-character collating element to
    match more than one character, e.g., if the collating sequence
    includes a &lt;literal&gt;ch&lt;/literal&gt; collating element, then the RE
    &lt;literal&gt;[[.ch.]]*c&lt;/literal&gt; matches the first five characters of
    &lt;literal&gt;chchcc&lt;/literal&gt;.
</span>
ブラケット式内に、照合要素（文字、単一文字であるかのように照合する複数文字の並び、もしくはそれぞれの照合並びの名前）が<code class="literal">[.</code>と<code class="literal">.]</code>の間にあると、その照合要素の文字の並びを意味します。
この並びはブラケット式のリストの一要素として取り扱われます。
このことにより、ブラケット式は要素を照合する複数文字を含むブラケット式を1文字以上にマッチさせることができます。例えば、照合並びが<code class="literal">ch</code>照合要素を含む場合、正規表現<code class="literal">[[.ch.]]*c</code>は<code class="literal">chchcc</code>という文字の最初の5文字にマッチします。
   </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
     &lt;productname&gt;PostgreSQL&lt;/productname&gt; currently does not support multi-character collating
     elements. This information describes possible future behavior.
</span>
今のところ、<span class="productname">PostgreSQL</span>は複数文字照合要素をサポートしません。
この情報は将来の振舞いの可能性を説明したものです。
    </p></div><p>
<span class="original">
    Within a bracket expression, a collating element enclosed in
    &lt;literal&gt;[=&lt;/literal&gt; and &lt;literal&gt;=]&lt;/literal&gt; is an &lt;firstterm&gt;equivalence
    class&lt;/firstterm&gt;, standing for the sequences of characters of all collating
    elements equivalent to that one, including itself.  (If there are
    no other equivalent collating elements, the treatment is as if the
    enclosing delimiters were &lt;literal&gt;[.&lt;/literal&gt; and
    &lt;literal&gt;.]&lt;/literal&gt;.)  For example, if &lt;literal&gt;o&lt;/literal&gt; and
    &lt;literal&gt;^&lt;/literal&gt; are the members of an equivalence class, then
    &lt;literal&gt;[[=o=]]&lt;/literal&gt;, &lt;literal&gt;[[=^=]]&lt;/literal&gt;, and
    &lt;literal&gt;[o^]&lt;/literal&gt; are all synonymous.  An equivalence class
    cannot be an endpoint of a range.
</span>
ブラケット式内の<code class="literal">[=</code>と<code class="literal">=]</code>の間に照合要素は<em class="firstterm">同値クラス</em>です。全ての照合要素の文字の並びが自身を含むものと等価であることを示します。
（他に等価な照合要素がある場合、<code class="literal">[.</code>と<code class="literal">.]</code>で囲まれたかのように扱われます。）
例えば、<code class="literal">[[=o=]]</code>、<code class="literal">[[=^=]]</code>および<code class="literal">[o^]</code>が全て同意語であれば、<code class="literal">o</code>と<code class="literal">^</code>は同値クラスのメンバです。
同値クラスは範囲の終端にはなりません。
   </p><p>
<span class="original">
    Within a bracket expression, the name of a character class
    enclosed in &lt;literal&gt;[:&lt;/literal&gt; and &lt;literal&gt;:]&lt;/literal&gt; stands
    for the list of all characters belonging to that class.  Standard
    character class names are: &lt;literal&gt;alnum&lt;/literal&gt;,
    &lt;literal&gt;alpha&lt;/literal&gt;, &lt;literal&gt;blank&lt;/literal&gt;,
    &lt;literal&gt;cntrl&lt;/literal&gt;, &lt;literal&gt;digit&lt;/literal&gt;,
    &lt;literal&gt;graph&lt;/literal&gt;, &lt;literal&gt;lower&lt;/literal&gt;,
    &lt;literal&gt;print&lt;/literal&gt;, &lt;literal&gt;punct&lt;/literal&gt;,
    &lt;literal&gt;space&lt;/literal&gt;, &lt;literal&gt;upper&lt;/literal&gt;,
    &lt;literal&gt;xdigit&lt;/literal&gt;.  These stand for the character classes
    defined in
    &lt;citerefentry&gt;&lt;refentrytitle&gt;ctype&lt;/refentrytitle&gt;&lt;manvolnum&gt;3&lt;/manvolnum&gt;&lt;/citerefentry&gt;.
    A locale can provide others.  A character class cannot be used as
    an endpoint of a range.
</span>
ブラケット式内では、<code class="literal">[:</code>と<code class="literal">:]</code>の間にある文字クラスの名称は、そのクラスに属する全ての文字のリストを意味します。
標準文字クラス名は、<code class="literal">alnum</code>、<code class="literal">alpha</code>、<code class="literal">blank</code>、<code class="literal">cntrl</code>、<code class="literal">digit</code>、<code class="literal">graph</code>、<code class="literal">lower</code>、<code class="literal">print</code>、<code class="literal">punct</code>、<code class="literal">space</code>、<code class="literal">upper</code>、<code class="literal">xdigit</code>です。
これらは<span class="citerefentry"><span class="refentrytitle">ctype</span></span>で定義された文字クラスを意味します。
ロケールは別のものを提供可能です。
文字クラスは範囲の終端では使用することができません。
   </p><p>
<span class="original">
    There are two special cases of bracket expressions:  the bracket
    expressions &lt;literal&gt;[[:&amp;lt;:]]&lt;/literal&gt; and
    &lt;literal&gt;[[:&amp;gt;:]]&lt;/literal&gt; are constraints,
    matching empty strings at the beginning
    and end of a word respectively.  A word is defined as a sequence
    of word characters that is neither preceded nor followed by word
    characters.  A word character is an &lt;literal&gt;alnum&lt;/literal&gt; character (as
    defined by
    &lt;citerefentry&gt;&lt;refentrytitle&gt;ctype&lt;/refentrytitle&gt;&lt;manvolnum&gt;3&lt;/manvolnum&gt;&lt;/citerefentry&gt;)
    or an underscore.  This is an extension, compatible with but not
    specified by &lt;acronym&gt;POSIX&lt;/acronym&gt; 1003.2, and should be used with
    caution in software intended to be portable to other systems.
    The constraint escapes described below are usually preferable; they
    are no more standard, but are easier to type.
</span>
ブラケット式には2つの特殊な場合があります。<code class="literal">[[:&lt;:]]</code>と<code class="literal">[[:&gt;:]]</code>というブラケット式は、先頭と終端の単語がそれぞれ空文字であることにマッチする制約です。
単語は、単語文字が前後に付かない単語文字の並びとして定義されます。
単語文字とは（<span class="citerefentry"><span class="refentrytitle">ctype</span></span>で定義されている）1つの<code class="literal">alnum</code>文字またはアンダースコアです。
これは、<acronym class="acronym">POSIX</acronym> 1003.2との互換性はありますが、そこでは定義されていない式です。ですので、他システムへ移植予定のソフトウェアでの使用には注意が必要です。
通常後述の制約エスケープの方がよく使われます。これはもはや標準ではありませんが、入力しやすいものです。
   </p></div><div class="sect3" id="POSIX-ESCAPE-SEQUENCES"><div class="titlepage"><div><div><h4 class="title">9.7.3.3. 正規表現エスケープ</h4></div></div></div><span class="original">
    &lt;title&gt;Regular Expression Escapes&lt;/title&gt;
</span><p>
<span class="original">
    &lt;firstterm&gt;Escapes&lt;/firstterm&gt; are special sequences beginning with &lt;literal&gt;\&lt;/literal&gt;
    followed by an alphanumeric character. Escapes come in several varieties:
    character entry, class shorthands, constraint escapes, and back references.
    A &lt;literal&gt;\&lt;/literal&gt; followed by an alphanumeric character but not constituting
    a valid escape is illegal in AREs.
    In EREs, there are no escapes: outside a bracket expression,
    a &lt;literal&gt;\&lt;/literal&gt; followed by an alphanumeric character merely stands for
    that character as an ordinary character, and inside a bracket expression,
    &lt;literal&gt;\&lt;/literal&gt; is an ordinary character.
    (The latter is the one actual incompatibility between EREs and AREs.)
</span>
<em class="firstterm">エスケープ</em>とは、<code class="literal">\</code>から始まり英数字がその後に続く特殊な並びです。
エスケープには、文字エントリ、クラス省略、制約エスケープ、後方参照といった様々な変種があります。
<code class="literal">\</code>の後に英数字が続くけれども、有効なエスケープを構成しない並びはAREでは不正です。
EREにはエスケープはありません。ブラケット式の外側では、<code class="literal">\</code>の後に英数字が続く並びは単に普通の文字としてその文字を意味します。ブラケット式の内側では、<code class="literal">\</code>は普通の文字です。
（後者はEREとARE間の非互換性の1つです。）
   </p><p>
<span class="original">
    &lt;firstterm&gt;Character-entry escapes&lt;/firstterm&gt; exist to make it easier to specify
    non-printing and other inconvenient characters in REs.  They are
    shown in &lt;xref linkend="posix-character-entry-escapes-table"/&gt;.
</span>
<em class="firstterm">文字エントリエスケープ</em>は非印字文字やRE内でその他の不便な文字の指定を簡略化するために存在します。
これらを<a class="xref" href="functions-matching.html#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE" title="表9.18 正規表現文字エントリエスケープ">表 9.18</a>に示します。
   </p><p>
<span class="original">
    &lt;firstterm&gt;Class-shorthand escapes&lt;/firstterm&gt; provide shorthands for certain
    commonly-used character classes.  They are
    shown in &lt;xref linkend="posix-class-shorthand-escapes-table"/&gt;.
</span>
<em class="firstterm">クラス省略エスケープ</em>は、あるよく使用される文字クラスの省略形を提供します。
これらを<a class="xref" href="functions-matching.html#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE" title="表9.19 正規表現クラス省略エスケープ">表 9.19</a>に示します。
   </p><p>
<span class="original">
    A &lt;firstterm&gt;constraint escape&lt;/firstterm&gt; is a constraint,
    matching the empty string if specific conditions are met,
    written as an escape.  They are
    shown in &lt;xref linkend="posix-constraint-escapes-table"/&gt;.
</span>
<em class="firstterm">制約エスケープ</em>は、指定した条件に合う場合に空文字にマッチする制約をエスケープとして表したものです。
これらを<a class="xref" href="functions-matching.html#POSIX-CONSTRAINT-ESCAPES-TABLE" title="表9.20 正規表現制約エスケープ">表 9.20</a>に示します。
   </p><p>
<span class="original">
    A &lt;firstterm&gt;back reference&lt;/firstterm&gt; (&lt;literal&gt;\&lt;/literal&gt;&lt;replaceable&gt;n&lt;/replaceable&gt;) matches the
    same string matched by the previous parenthesized subexpression specified
    by the number &lt;replaceable&gt;n&lt;/replaceable&gt;
    (see &lt;xref linkend="posix-constraint-backref-table"/&gt;).  For example,
    &lt;literal&gt;([bc])\1&lt;/literal&gt; matches &lt;literal&gt;bb&lt;/literal&gt; or &lt;literal&gt;cc&lt;/literal&gt;
    but not &lt;literal&gt;bc&lt;/literal&gt; or &lt;literal&gt;cb&lt;/literal&gt;.
    The subexpression must entirely precede the back reference in the RE.
    Subexpressions are numbered in the order of their leading parentheses.
    Non-capturing parentheses do not define subexpressions.
</span>
<em class="firstterm">後方参照</em>（<code class="literal">\</code><em class="replaceable"><code>n</code></em>）は、直前に括弧で囲まれた副式によってマッチされた、<em class="replaceable"><code>n</code></em>番目の同一文字列にマッチします（<a class="xref" href="functions-matching.html#POSIX-CONSTRAINT-BACKREF-TABLE" title="表9.21 正規表現後方参照">表 9.21</a>を参照してください）。
  例えば、<code class="literal">([bc])\1</code>は<code class="literal">bb</code>もしくは<code class="literal">cc</code>にマッチしますが、<code class="literal">bc</code>や<code class="literal">cb</code>にはマッチしません。REでは副式全体は後方参照の前になければなりません。
副式は開括弧の順番で番号付けされます。
取り込まない括弧は副式を定義しません。
   </p><div class="table" id="POSIX-CHARACTER-ENTRY-ESCAPES-TABLE"><p class="title"><strong>表9.18 正規表現文字エントリエスケープ</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;Regular Expression Character-entry Escapes&lt;/title&gt;
</span><table class="table" summary="正規表現文字エントリエスケープ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>エスケープ</th><th>説明</th></tr></thead><tbody><tr><td> <code class="literal">\a</code> </td><td>C言語と同じ警報（ベル）文字</td></tr><tr><td> <code class="literal">\b</code> </td><td>C言語と同じバックスペース</td></tr><tr><td> <code class="literal">\B</code> </td><td> バックスラッシュの必要な二重化回数を減らすためのバックスラッシュ（<code class="literal">\</code>）の同義語</td></tr><tr><td> <code class="literal">\c</code><em class="replaceable"><code>X</code></em> </td><td>（ここで<em class="replaceable"><code>X</code></em>は任意の文字で）その下位5ビットが<em class="replaceable"><code>X</code></em>と同一、その他のビットが0となる文字 </td></tr><tr><td> <code class="literal">\e</code> </td><td>照合順名が<code class="literal">ESC</code>となる文字、それに失敗したら、<code class="literal">033</code>という8進数値を持つ文字。</td></tr><tr><td> <code class="literal">\f</code> </td><td>C言語と同じ改ページ</td></tr><tr><td> <code class="literal">\n</code> </td><td>C言語と同じ改行</td></tr><tr><td> <code class="literal">\r</code> </td><td>C言語と同じ復帰</td></tr><tr><td> <code class="literal">\t</code> </td><td>C言語と同じ水平タブ</td></tr><tr><td> <code class="literal">\u</code><em class="replaceable"><code>wxyz</code></em> </td><td>（ここで<em class="replaceable"><code>wxyz</code></em>は正確に4桁の16進数で）その16進数での値が<code class="literal">0x</code><em class="replaceable"><code>wxyz</code></em>という文字
       </td></tr><tr><td> <code class="literal">\U</code><em class="replaceable"><code>stuvwxyz</code></em> </td><td>（ここで<em class="replaceable"><code>stuvwxyz</code></em>は正確に8桁の16進数で）その16進数での値が<code class="literal">0x</code><em class="replaceable"><code>stuvwxyz</code></em>という文字
       </td></tr><tr><td> <code class="literal">\v</code> </td><td>C言語と同じ垂直タブ</td></tr><tr><td> <code class="literal">\x</code><em class="replaceable"><code>hhh</code></em> </td><td>（ここで<em class="replaceable"><code>hhh</code></em>は任意の16進数の並びで）その文字の16進数値が<code class="literal">0x</code><em class="replaceable"><code>hhh</code></em>となる文字（使用される16進数の桁数にかかわらず単一の文字）
       </td></tr><tr><td> <code class="literal">\0</code> </td><td>その値が<code class="literal">0</code>（NULLバイト）となる文字</td></tr><tr><td> <code class="literal">\</code><em class="replaceable"><code>xy</code></em> </td><td>（ここで<em class="replaceable"><code>xy</code></em>は正確に2桁の8進数で、<em class="firstterm">後方参照</em>ではない）その値が<code class="literal">0</code><em class="replaceable"><code>xy</code></em>となる文字</td></tr><tr><td> <code class="literal">\</code><em class="replaceable"><code>xyz</code></em> </td><td>（ここで<em class="replaceable"><code>xyz</code></em>は正確に3桁の8進数で、<em class="firstterm">後方参照</em>ではない）その値が<code class="literal">0</code><em class="replaceable"><code>xyz</code></em>となる文字</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
    Hexadecimal digits are &lt;literal&gt;0&lt;/literal&gt;-&lt;literal&gt;9&lt;/literal&gt;,
    &lt;literal&gt;a&lt;/literal&gt;-&lt;literal&gt;f&lt;/literal&gt;, and &lt;literal&gt;A&lt;/literal&gt;-&lt;literal&gt;F&lt;/literal&gt;.
    Octal digits are &lt;literal&gt;0&lt;/literal&gt;-&lt;literal&gt;7&lt;/literal&gt;.
</span>
16進数の桁とは<code class="literal">0</code>-<code class="literal">9</code>、<code class="literal">a</code>-<code class="literal">f</code>、<code class="literal">A</code>-<code class="literal">F</code>です。
8進数の桁とは<code class="literal">0</code>-<code class="literal">7</code>です。
   </p><p>
<span class="original">
    Numeric character-entry escapes specifying values outside the ASCII range
    (0-127) have meanings dependent on the database encoding.  When the
    encoding is UTF-8, escape values are equivalent to Unicode code points,
    for example &lt;literal&gt;\u1234&lt;/literal&gt; means the character &lt;literal&gt;U+1234&lt;/literal&gt;.
    For other multibyte encodings, character-entry escapes usually just
    specify the concatenation of the byte values for the character.  If the
    escape value does not correspond to any legal character in the database
    encoding, no error will be raised, but it will never match any data.
</span>
ASCIIの範囲(0-127)外の値を指定した数字のエントリエスケープは、その意味がデータベースエンコーディングに依存します。
エンコーディングがUTF-8の場合、エスケープ値はユニコード符号位置に相当します。例えば、<code class="literal">\u1234</code>は文字<code class="literal">U+1234</code>を意味します。
その他のマルチバイトエンコーディングでは、文字エントリエスケープはたいてい文字のバイト値の連結を指定します。
エスケープ値がデータベースエンコーディングでのいかなる正当な文字にも対応しない場合、エラーは起こりませんが、いかなるデータにもマッチしません。
   </p><p>
<span class="original">
    The character-entry escapes are always taken as ordinary characters.
    For example, &lt;literal&gt;\135&lt;/literal&gt; is &lt;literal&gt;]&lt;/literal&gt; in ASCII, but
    &lt;literal&gt;\135&lt;/literal&gt; does not terminate a bracket expression.
</span>
この文字エントリエスケープは常に普通の文字と解釈されます。
例えば、<code class="literal">\135</code>はASCIIの<code class="literal">]</code>となり、<code class="literal">\135</code>はブラケット式の終端にはなりません。
   </p><div class="table" id="POSIX-CLASS-SHORTHAND-ESCAPES-TABLE"><p class="title"><strong>表9.19 正規表現クラス省略エスケープ</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;Regular Expression Class-shorthand Escapes&lt;/title&gt;
</span><table class="table" summary="正規表現クラス省略エスケープ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>エスケープ</th><th>説明</th></tr></thead><tbody><tr><td> <code class="literal">\d</code> </td><td> <code class="literal">[[:digit:]]</code> </td></tr><tr><td> <code class="literal">\s</code> </td><td> <code class="literal">[[:space:]]</code> </td></tr><tr><td> <code class="literal">\w</code> </td><td> <code class="literal">[[:alnum:]_]</code>
<span class="original">
       (note underscore is included) &lt;/entry&gt;
</span>
       （アンダースコアが含まれることに注意）</td></tr><tr><td> <code class="literal">\D</code> </td><td> <code class="literal">[^[:digit:]]</code> </td></tr><tr><td> <code class="literal">\S</code> </td><td> <code class="literal">[^[:space:]]</code> </td></tr><tr><td> <code class="literal">\W</code> </td><td> <code class="literal">[^[:alnum:]_]</code>
<span class="original">
       (note underscore is included) &lt;/entry&gt;
</span>
       （アンダースコアが含まれることに注意）</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
    Within bracket expressions, &lt;literal&gt;\d&lt;/literal&gt;, &lt;literal&gt;\s&lt;/literal&gt;,
    and &lt;literal&gt;\w&lt;/literal&gt; lose their outer brackets,
    and &lt;literal&gt;\D&lt;/literal&gt;, &lt;literal&gt;\S&lt;/literal&gt;, and &lt;literal&gt;\W&lt;/literal&gt; are illegal.
    (So, for example, &lt;literal&gt;[a-c\d]&lt;/literal&gt; is equivalent to
    &lt;literal&gt;[a-c[:digit:]]&lt;/literal&gt;.
    Also, &lt;literal&gt;[a-c\D]&lt;/literal&gt;, which is equivalent to
    &lt;literal&gt;[a-c^[:digit:]]&lt;/literal&gt;, is illegal.)
</span>
ブラケット式内では、<code class="literal">\d</code>、<code class="literal">\s</code>、および<code class="literal">\w</code>はその外側の大括弧を失い、<code class="literal">\D</code>、<code class="literal">\S</code>および<code class="literal">\W</code>は不正です。
（ですから、例えば<code class="literal">[a-c\d]</code>は<code class="literal">[a-c[:digit:]]</code>と同じになります。また、<code class="literal">[a-c\D]</code>は<code class="literal">[a-c^[:digit:]]</code>と同じになり、不正です。）
   </p><div class="table" id="POSIX-CONSTRAINT-ESCAPES-TABLE"><p class="title"><strong>表9.20 正規表現制約エスケープ</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;Regular Expression Constraint Escapes&lt;/title&gt;
</span><table class="table" summary="正規表現制約エスケープ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>エスケープ</th><th>説明</th></tr></thead><tbody><tr><td> <code class="literal">\A</code> </td><td>文字列の先頭にのみマッチします（<code class="literal">^</code>との違いについては<a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. 正規表現マッチ規則">9.7.3.5</a>を参照してください）。</td></tr><tr><td> <code class="literal">\m</code> </td><td> 単語の先頭にのみマッチします。 </td></tr><tr><td> <code class="literal">\M</code> </td><td> 単語の末尾にのみマッチします。 </td></tr><tr><td> <code class="literal">\y</code> </td><td> 単語の先頭もしくは末尾にのみマッチします。</td></tr><tr><td> <code class="literal">\Y</code> </td><td>単語の先頭もしくは末尾以外の場所にのみマッチします。</td></tr><tr><td> <code class="literal">\Z</code> </td><td>文字列の末尾にのみマッチします（<code class="literal">$</code>との違いについては<a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. 正規表現マッチ規則">9.7.3.5</a>を参照してください）。</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
    A word is defined as in the specification of
    &lt;literal&gt;[[:&amp;lt;:]]&lt;/literal&gt; and &lt;literal&gt;[[:&amp;gt;:]]&lt;/literal&gt; above.
    Constraint escapes are illegal within bracket expressions.
</span>
    単語は前述の<code class="literal">[[:&lt;:]]</code>と<code class="literal">[[:&gt;:]]</code>の規定通りに定義されます。ブラケット式内では制約エスケープは不正です。
   </p><div class="table" id="POSIX-CONSTRAINT-BACKREF-TABLE"><p class="title"><strong>表9.21 正規表現後方参照</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;Regular Expression Back References&lt;/title&gt;
</span><table class="table" summary="正規表現後方参照" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>エスケープ</th><th>説明</th></tr></thead><tbody><tr><td> <code class="literal">\</code><em class="replaceable"><code>m</code></em> </td><td>（ここで<em class="replaceable"><code>m</code></em>は非ゼロの数です。）副式の<em class="replaceable"><code>m</code></em>番目への後方参照</td></tr><tr><td> <code class="literal">\</code><em class="replaceable"><code>mnn</code></em> </td><td>（ここで<em class="replaceable"><code>m</code></em>は非ゼロの数です。<em class="replaceable"><code>nn</code></em>でさらに桁を指定します。<em class="replaceable"><code>mnn</code></em>10進数値は取り込み括弧の数よりも多くてはなりません。）副式の<em class="replaceable"><code>mnn</code></em>番目への後方参照</td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
     There is an inherent ambiguity between octal character-entry
     escapes and back references, which is resolved by the following heuristics,
     as hinted at above.
     A leading zero always indicates an octal escape.
     A single non-zero digit, not followed by another digit,
     is always taken as a back reference.
     A multi-digit sequence not starting with a zero is taken as a back
     reference if it comes after a suitable subexpression
     (i.e., the number is in the legal range for a back reference),
     and otherwise is taken as octal.
</span>
8進数の文字エントリエスケープと後方参照の間には曖昧性があります。上でヒントとして示したようにこれは以下の発見的手法で解決されます。
先頭の0は常に8進数エスケープを示します。
その後に数字が続かない単一の非ゼロ数字は常に後方参照として解釈されます。
ゼロから始まらない複数数字の並びは、適切な副式の後にあれば（つまり、その番号が後方参照用の範囲内にあれば）後方参照として解釈されます。さもなくば、8進数として解釈されます。
    </p></div></div><div class="sect3" id="POSIX-METASYNTAX"><div class="titlepage"><div><div><h4 class="title">9.7.3.4. 正規表現メタ構文</h4></div></div></div><span class="original">
    &lt;title&gt;Regular Expression Metasyntax&lt;/title&gt;
</span><p>
<span class="original">
    In addition to the main syntax described above, there are some special
    forms and miscellaneous syntactic facilities available.
</span>
上述の主構文の他に、特殊な形式や雑多な構文的な機能が使用可能です。
   </p><p>
<span class="original">
    An RE can begin with one of two special &lt;firstterm&gt;director&lt;/firstterm&gt; prefixes.
    If an RE begins with &lt;literal&gt;***:&lt;/literal&gt;,
    the rest of the RE is taken as an ARE.  (This normally has no effect in
    &lt;productname&gt;PostgreSQL&lt;/productname&gt;, since REs are assumed to be AREs;
    but it does have an effect if ERE or BRE mode had been specified by
    the &lt;replaceable&gt;flags&lt;/replaceable&gt; parameter to a regex function.)
    If an RE begins with &lt;literal&gt;***=&lt;/literal&gt;,
    the rest of the RE is taken to be a literal string,
    with all characters considered ordinary characters.
</span>
REは、2つの特殊な<em class="firstterm">決定子</em>前置詞のどちらかから始まります。
REが<code class="literal">***:</code>から始まるものであれば、REの残りはAREと解釈されます。
(<span class="productname">PostgreSQL</span>はREをAREとして推測するため、通常は影響を受けません。ただし、正規表現関数に対して<em class="replaceable"><code>flags</code></em>パラメータを指定されたEREやBREモードでは影響を受けます。)
REが<code class="literal">***=</code>から始まるものであれば、REの残りは、全ての文字を普通の文字とみなしたリテラル文字列と解釈されます。
   </p><p>
<span class="original">
    An ARE can begin with &lt;firstterm&gt;embedded options&lt;/firstterm&gt;:
    a sequence &lt;literal&gt;(?&lt;/literal&gt;&lt;replaceable&gt;xyz&lt;/replaceable&gt;&lt;literal&gt;)&lt;/literal&gt;
    (where &lt;replaceable&gt;xyz&lt;/replaceable&gt; is one or more alphabetic characters)
    specifies options affecting the rest of the RE.
    These options override any previously determined options &amp;mdash;
    in particular, they can override the case-sensitivity behavior implied by
    a regex operator, or the &lt;replaceable&gt;flags&lt;/replaceable&gt; parameter to a regex
    function.
    The available option letters are
    shown in &lt;xref linkend="posix-embedded-options-table"/&gt;.
    Note that these same option letters are used in the &lt;replaceable&gt;flags&lt;/replaceable&gt;
    parameters of regex functions.
</span>
AREは<em class="firstterm">埋め込みオプション</em>から始められます。<code class="literal">(?</code><em class="replaceable"><code>xyz</code></em><code class="literal">)</code>という並びで残りのREに影響するオプションを指定します（ここで<em class="replaceable"><code>xyz</code></em>は1つ以上の英字です）。
このオプションは、事前に決定されたオプションを上書きします。— 特に、正規表現演算子、もしくは正規表現関数に与えられた<em class="replaceable"><code>flags</code></em>パラメータにより示される大文字小文字の区別を上書きします。
使用可能なオプション文字を<a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="表9.22 ARE埋め込みオプション文字">表 9.22</a>に示します。
これらの同じオプション文字が、正規表現関数の<em class="replaceable"><code>flags</code></em>パラメータで使用されることに注意して下さい。
   </p><div class="table" id="POSIX-EMBEDDED-OPTIONS-TABLE"><p class="title"><strong>表9.22 ARE埋め込みオプション文字</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;ARE Embedded-option Letters&lt;/title&gt;
</span><table class="table" summary="ARE埋め込みオプション文字" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>オプション</th><th>説明</th></tr></thead><tbody><tr><td> <code class="literal">b</code> </td><td> 残りのREはBRE </td></tr><tr><td> <code class="literal">c</code> </td><td> 大文字小文字を区別するマッチ（演算子で規定される大文字小文字の区別よりこの指定が優先されます）。 </td></tr><tr><td> <code class="literal">e</code> </td><td> 残りのREはERE </td></tr><tr><td> <code class="literal">i</code> </td><td> 大文字小文字を区別しないマッチ（<a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. 正規表現マッチ規則">9.7.3.5</a>を参照）（演算子で規定される大文字小文字の区別よりこの指定が優先されます）。 </td></tr><tr><td> <code class="literal">m</code> </td><td> <code class="literal">n</code>の歴史的な同義語 </td></tr><tr><td> <code class="literal">n</code> </td><td> 改行を区別するマッチ（<a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. 正規表現マッチ規則">9.7.3.5</a>を参照）</td></tr><tr><td> <code class="literal">p</code> </td><td> 部分的な改行を区別するマッチ（<a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. 正規表現マッチ規則">9.7.3.5</a>を参照）</td></tr><tr><td> <code class="literal">q</code> </td><td> 残りのREはリテラル（<span class="quote">「<span class="quote">引用符付けされた</span>」</span>）文字列、全て普通の文字</td></tr><tr><td> <code class="literal">s</code> </td><td> 改行を区別しないマッチ（デフォルト）</td></tr><tr><td> <code class="literal">t</code> </td><td> 厳しめの構文（デフォルト、後述） </td></tr><tr><td> <code class="literal">w</code> </td><td> 部分的な改行区別の逆（<span class="quote">「<span class="quote">ワイアード</span>」</span>）マッチ（<a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. 正規表現マッチ規則">9.7.3.5</a>を参照）</td></tr><tr><td> <code class="literal">x</code> </td><td> 拡張構文（後述） </td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
    Embedded options take effect at the &lt;literal&gt;)&lt;/literal&gt; terminating the sequence.
    They can appear only at the start of an ARE (after the
    &lt;literal&gt;***:&lt;/literal&gt; director if any).
</span>
埋め込みオプションはその並びの終端<code class="literal">)</code>で有効になります。
AREの先頭（もし<code class="literal">***:</code>決定子があればその後）でのみ利用可能です。
   </p><p>
<span class="original">
    In addition to the usual (&lt;firstterm&gt;tight&lt;/firstterm&gt;) RE syntax, in which all
    characters are significant, there is an &lt;firstterm&gt;expanded&lt;/firstterm&gt; syntax,
    available by specifying the embedded &lt;literal&gt;x&lt;/literal&gt; option.
    In the expanded syntax,
    white-space characters in the RE are ignored, as are
    all characters between a &lt;literal&gt;#&lt;/literal&gt;
    and the following newline (or the end of the RE).  This
    permits paragraphing and commenting a complex RE.
    There are three exceptions to that basic rule:
</span>
全ての文字が意味を持つ、通常の（<em class="firstterm">厳しめの</em>）RE構文に加え、<code class="literal">x</code>埋め込みオプションを指定することで利用できる<em class="firstterm">拡張</em>構文があります。
拡張構文では、RE内の空白文字は無視され、<code class="literal">#</code>とその後の改行（もしくはREの終端）の間の全ての文字も同様です。
これにより、段落付けや複雑なREのコメント付けが可能になります。
基本規則に対して3つの例外があります。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
       a white-space character or &lt;literal&gt;#&lt;/literal&gt; preceded by &lt;literal&gt;\&lt;/literal&gt; is
       retained
</span>
直前に<code class="literal">\</code>が付いた空白文字もしくは<code class="literal">#</code>は保持されます。
      </p></li><li class="listitem"><p>
<span class="original">
       white space or &lt;literal&gt;#&lt;/literal&gt; within a bracket expression is retained
</span>
ブラケット式内の空白文字もしくは<code class="literal">#</code>は保持されます。
      </p></li><li class="listitem"><p>
<span class="original">
       white space and comments cannot appear within multi-character symbols,
       such as &lt;literal&gt;(?:&lt;/literal&gt;
</span>
<code class="literal">(?:</code>などの複数文字シンボルでは、空白文字とコメントは不正です。
      </p></li></ul></div><p>

<span class="original">
    For this purpose, white-space characters are blank, tab, newline, and
    any character that belongs to the &lt;replaceable&gt;space&lt;/replaceable&gt; character class.
</span>
ここでの空白文字とは、空白、タブ、改行、<em class="replaceable"><code>スペース</code></em>文字クラスに属する文字です。
   </p><p>
<span class="original">
    Finally, in an ARE, outside bracket expressions, the sequence
    &lt;literal&gt;(?#&lt;/literal&gt;&lt;replaceable&gt;ttt&lt;/replaceable&gt;&lt;literal&gt;)&lt;/literal&gt;
    (where &lt;replaceable&gt;ttt&lt;/replaceable&gt; is any text not containing a &lt;literal&gt;)&lt;/literal&gt;)
    is a comment, completely ignored.
    Again, this is not allowed between the characters of
    multi-character symbols, like &lt;literal&gt;(?:&lt;/literal&gt;.
    Such comments are more a historical artifact than a useful facility,
    and their use is deprecated; use the expanded syntax instead.
</span>
最後に、AREのブラケット式の外側では、<code class="literal">(?#</code><em class="replaceable"><code>ttt</code></em><code class="literal">)</code>という並びはコメントになります（ここで<em class="replaceable"><code>ttt</code></em>は<code class="literal">)</code>を含まない任意のテキストです）。
繰り返しになりますが、これは<code class="literal">(?:</code>などの複数文字シンボルの文字間では使用できません。
こうしたコメントは実用性というより歴史的所産です。そのため、この使用は勧めません。代わりに拡張構文を使用してください。
   </p><p>
<span class="original">
    &lt;emphasis&gt;None&lt;/emphasis&gt; of these metasyntax extensions is available if
    an initial &lt;literal&gt;***=&lt;/literal&gt; director
    has specified that the user's input be treated as a literal string
    rather than as an RE.
</span>
初めに<code class="literal">***=</code>決定子が指定され、ユーザの入力がREではなくリテラルとして扱われる場合、これらのメタ構文拡張は使用<span class="emphasis"><em>できません</em></span>。
   </p></div><div class="sect3" id="POSIX-MATCHING-RULES"><div class="titlepage"><div><div><h4 class="title">9.7.3.5. 正規表現マッチ規則</h4></div></div></div><span class="original">
    &lt;title&gt;Regular Expression Matching Rules&lt;/title&gt;
</span><p>
<span class="original">
    In the event that an RE could match more than one substring of a given
    string, the RE matches the one starting earliest in the string.
    If the RE could match more than one substring starting at that point,
    either the longest possible match or the shortest possible match will
    be taken, depending on whether the RE is &lt;firstterm&gt;greedy&lt;/firstterm&gt; or
    &lt;firstterm&gt;non-greedy&lt;/firstterm&gt;.
</span>
REが文字列の中の1つ以上の部分文字列とマッチする場合において、REは最初にマッチが始まった部分文字列とマッチします。
その位置からまた1つ以上の部分文字列とマッチした際は、正規表現は<em class="firstterm">最短マッチを行わない（欲張り型）</em>か<em class="firstterm">最短マッチを行う（非欲張り型）</em>かによって、最長マッチもしくは最短マッチの文字列のどちらかにマッチします
   </p><p>
<span class="original">
    Whether an RE is greedy or not is determined by the following rules:
</span>
REが最長マッチかどうかは以下の規則によって決まります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
       Most atoms, and all constraints, have no greediness attribute (because
       they cannot match variable amounts of text anyway).
</span>
ほとんどのアトムおよび全ての式は欲張り属性を持ちません（これらは変動する量のテキストにまったくマッチしないからです）。
      </p></li><li class="listitem"><p>
<span class="original">
       Adding parentheses around an RE does not change its greediness.
</span>
REを括弧で括ることは欲張りかどうかを変更しません。
      </p></li><li class="listitem"><p>
<span class="original">
       A quantified atom with a fixed-repetition quantifier
       (&lt;literal&gt;{&lt;/literal&gt;&lt;replaceable&gt;m&lt;/replaceable&gt;&lt;literal&gt;}&lt;/literal&gt;
       or
       &lt;literal&gt;{&lt;/literal&gt;&lt;replaceable&gt;m&lt;/replaceable&gt;&lt;literal&gt;}?&lt;/literal&gt;)
       has the same greediness (possibly none) as the atom itself.
</span>
<code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}</code>もしくは<code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}?</code>といった固定繰り返し数の量指定子を持つ量指定付きアトムは、アトム自身と同一の欲張りさを持ちます（まったく持たない可能性もあります）。
      </p></li><li class="listitem"><p>
<span class="original">
       A quantified atom with other normal quantifiers (including
       &lt;literal&gt;{&lt;/literal&gt;&lt;replaceable&gt;m&lt;/replaceable&gt;&lt;literal&gt;,&lt;/literal&gt;&lt;replaceable&gt;n&lt;/replaceable&gt;&lt;literal&gt;}&lt;/literal&gt;
       with &lt;replaceable&gt;m&lt;/replaceable&gt; equal to &lt;replaceable&gt;n&lt;/replaceable&gt;)
       is greedy (prefers longest match).
</span>
他の通常の量指定子（<code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}</code>、<em class="replaceable"><code>m</code></em>と<em class="replaceable"><code>n</code></em>が等しい場合も含みます）を持つ量指定付きアトムは欲張り型です（最長マッチを使用します）。
      </p></li><li class="listitem"><p>
<span class="original">
       A quantified atom with a non-greedy quantifier (including
       &lt;literal&gt;{&lt;/literal&gt;&lt;replaceable&gt;m&lt;/replaceable&gt;&lt;literal&gt;,&lt;/literal&gt;&lt;replaceable&gt;n&lt;/replaceable&gt;&lt;literal&gt;}?&lt;/literal&gt;
       with &lt;replaceable&gt;m&lt;/replaceable&gt; equal to &lt;replaceable&gt;n&lt;/replaceable&gt;)
       is non-greedy (prefers shortest match).
</span>
他の非欲張り型量指定子（<code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}?</code>、<em class="replaceable"><code>m</code></em>と<em class="replaceable"><code>n</code></em>が等しい場合も含みます）を持つ量指定付きアトムは非欲張り型です（最短マッチを使用します）。
      </p></li><li class="listitem"><p>
<span class="original">
       A branch &amp;mdash; that is, an RE that has no top-level
       &lt;literal&gt;|&lt;/literal&gt; operator &amp;mdash; has the same greediness as the first
       quantified atom in it that has a greediness attribute.
</span>
最上位レベルの<code class="literal">|</code>演算子を持たないREであるブランチは、最初の欲張り属性を持つ量指定付きアトムと同一の欲張り属性を持ちます。
      </p></li><li class="listitem"><p>
<span class="original">
       An RE consisting of two or more branches connected by the
       &lt;literal&gt;|&lt;/literal&gt; operator is always greedy.
</span>
<code class="literal">|</code>演算子で接続された2つ以上のブランチからなるREは常に欲張り型です。
      </p></li></ul></div><p>
   </p><p>
<span class="original">
    The above rules associate greediness attributes not only with individual
    quantified atoms, but with branches and entire REs that contain quantified
    atoms.  What that means is that the matching is done in such a way that
    the branch, or whole RE, matches the longest or shortest possible
    substring &lt;emphasis&gt;as a whole&lt;/emphasis&gt;.  Once the length of the entire match
    is determined, the part of it that matches any particular subexpression
    is determined on the basis of the greediness attribute of that
    subexpression, with subexpressions starting earlier in the RE taking
    priority over ones starting later.
</span>
上の規則は、個々の量指定付きアトムだけではなく、量指定付きアトムを複数含むブランチやRE全体の欲張り属性に関連します。
つまり、ブランチやRE全体が<span class="emphasis"><em>全体として</em></span>最長または最短の部分文字列にマッチするという方法でマッチ処理が行われます。
全体のマッチの長さが決まると、特定の部分式にマッチする部分がその部分式の欲張り属性によって決まります。この時、RE内でより前にある部分式が後にある部分式よりも高い優先度を持ちます。
   </p><p>
<span class="original">
    An example of what this means:
</span>
この意味の例を示します。
</p><pre class="screen">
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<em class="lineannotation"><span class="lineannotation">Result: </span></em><code class="computeroutput">123</code>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<em class="lineannotation"><span class="lineannotation">Result: </span></em><code class="computeroutput">1</code>
</pre><p>
<span class="original">
    In the first case, the RE as a whole is greedy because &lt;literal&gt;Y*&lt;/literal&gt;
    is greedy.  It can match beginning at the &lt;literal&gt;Y&lt;/literal&gt;, and it matches
    the longest possible string starting there, i.e., &lt;literal&gt;Y123&lt;/literal&gt;.
    The output is the parenthesized part of that, or &lt;literal&gt;123&lt;/literal&gt;.
    In the second case, the RE as a whole is non-greedy because &lt;literal&gt;Y*?&lt;/literal&gt;
    is non-greedy.  It can match beginning at the &lt;literal&gt;Y&lt;/literal&gt;, and it matches
    the shortest possible string starting there, i.e., &lt;literal&gt;Y1&lt;/literal&gt;.
    The subexpression &lt;literal&gt;[0-9]{1,3}&lt;/literal&gt; is greedy but it cannot change
    the decision as to the overall match length; so it is forced to match
    just &lt;literal&gt;1&lt;/literal&gt;.
</span>
最初の例では、<code class="literal">Y*</code>が欲張り型であるため、REは全体として欲張り型です。
マッチは<code class="literal">Y</code>の位置から始まり、そこから可能な限り最長の文字列にマッチします。つまり<code class="literal">Y123</code>となります。
出力は括弧で括られた部分、つまり<code class="literal">123</code>となります。
2番目の例では、<code class="literal">Y*?</code>が非欲張り型のため、REは全体として非欲張り型です。
マッチは<code class="literal">Y</code>の位置から始まり、そこから可能な限り最短の文字列にマッチします。つまり<code class="literal">Y1</code>となります。
部分式<code class="literal">[0-9]{1,3}</code>は欲張り型ですが、決定されたマッチする全体の長さを変更することはできません。したがって、強制的に<code class="literal">1</code>にマッチすることになります。
   </p><p>
<span class="original">
    In short, when an RE contains both greedy and non-greedy subexpressions,
    the total match length is either as long as possible or as short as
    possible, according to the attribute assigned to the whole RE.  The
    attributes assigned to the subexpressions only affect how much of that
    match they are allowed to &lt;quote&gt;eat&lt;/quote&gt; relative to each other.
</span>
まとめると、REが欲張り型部分式と非欲張り型部分式の両方を持つ場合、全体のマッチ長はRE全体に割り当てられる属性に応じて、最長マッチ長か最短マッチ長のどちらかになります。
部分式に割り当てられた属性は、部分式の中でどれだけの量をその部分式の中で<span class="quote">「<span class="quote">消費</span>」</span>できるかのみに影響します。
   </p><p>
<span class="original">
    The quantifiers &lt;literal&gt;{1,1}&lt;/literal&gt; and &lt;literal&gt;{1,1}?&lt;/literal&gt;
    can be used to force greediness or non-greediness, respectively,
    on a subexpression or a whole RE.
    This is useful when you need the whole RE to have a greediness attribute
    different from what's deduced from its elements.  As an example,
    suppose that we are trying to separate a string containing some digits
    into the digits and the parts before and after them.  We might try to
    do that like this:
</span>
<code class="literal">{1,1}</code>および<code class="literal">{1,1}?</code>量指定子を副式もしくはRE全体に使用して、それぞれ、欲張りか欲張りでないかを強制することが可能です。
RE全体に対してはその要素から推論されるものと異なる欲張りさの属性が必要な場合に、これは便利です。
例として、数字をいくつか含む文字列を数字とその前後の部分に分けようとしているとします。
次のようにしてみるかもしれません。
</p><pre class="screen">
SELECT regexp_match('abc01234xyz', '(.*)(\d+)(.*)');
<em class="lineannotation"><span class="lineannotation">Result: </span></em><code class="computeroutput">{abc0123,4,xyz}</code>
</pre><p>
<span class="original">
    That didn't work: the first &lt;literal&gt;.*&lt;/literal&gt; is greedy so
    it &lt;quote&gt;eats&lt;/quote&gt; as much as it can, leaving the &lt;literal&gt;\d+&lt;/literal&gt; to
    match at the last possible place, the last digit.  We might try to fix
    that by making it non-greedy:
</span>
上手くいきませんでした。最初の<code class="literal">.*</code>が欲張りで、可能なだけ<span class="quote">「<span class="quote">消費</span>」</span>してしまい、<code class="literal">\d+</code>は最後の可能な場所で最後の数字にマッチします。
欲張りでなくすることで直そうとするかもしれません。
</p><pre class="screen">
SELECT regexp_match('abc01234xyz', '(.*?)(\d+)(.*)');
<em class="lineannotation"><span class="lineannotation">Result: </span></em><code class="computeroutput">{abc,0,""}</code>
</pre><p>
<span class="original">
    That didn't work either, because now the RE as a whole is non-greedy
    and so it ends the overall match as soon as possible.  We can get what
    we want by forcing the RE as a whole to be greedy:
</span>
またもや上手くいきませんでした。今度は、REが全体として欲張りでなくなってしまい、できる限り早く全体に渡るマッチを終わらせてしまうからです。
RE全体として欲張りにすることで欲しいものが得られます。
</p><pre class="screen">
SELECT regexp_match('abc01234xyz', '(?:(.*?)(\d+)(.*)){1,1}');
<em class="lineannotation"><span class="lineannotation">Result: </span></em><code class="computeroutput">{abc,01234,xyz}</code>
</pre><p>
<span class="original">
    Controlling the RE's overall greediness separately from its components'
    greediness allows great flexibility in handling variable-length patterns.
</span>
REの全体に渡る欲張りさをその要素の欲張りさと別に制御すれば、可変長のパターンを非常に柔軟に扱えます。
   </p><p>
<span class="original">
    When deciding what is a longer or shorter match,
    match lengths are measured in characters, not collating elements.
    An empty string is considered longer than no match at all.
    For example:
    &lt;literal&gt;bb*&lt;/literal&gt;
    matches the three middle characters of &lt;literal&gt;abbbc&lt;/literal&gt;;
    &lt;literal&gt;(week|wee)(night|knights)&lt;/literal&gt;
    matches all ten characters of &lt;literal&gt;weeknights&lt;/literal&gt;;
    when &lt;literal&gt;(.*).*&lt;/literal&gt;
    is matched against &lt;literal&gt;abc&lt;/literal&gt; the parenthesized subexpression
    matches all three characters; and when
    &lt;literal&gt;(a*)*&lt;/literal&gt; is matched against &lt;literal&gt;bc&lt;/literal&gt;
    both the whole RE and the parenthesized
    subexpression match an empty string.
</span>
マッチが長いか短いかを判断する時には、マッチの長さは照合要素ではなく文字列で測られます。
空文字列はまったくマッチする要素がない文字列よりも長いと考えられます。
例えば、<code class="literal">bb*</code>は<code class="literal">abbbc</code>の真中の3文字とマッチし、<code class="literal">(week|wee)(night|knights)</code>は<code class="literal">weeknights</code>の全ての10文字とマッチし、<code class="literal">abc</code>に対して<code class="literal">(.*).*</code>がマッチされると、括弧内の部分正規表現は3つの文字全てにマッチし、<code class="literal">bc</code>に対して<code class="literal">(a*)*</code>がマッチされると、全体のREと括弧内の正規表現は空文字列にマッチします。
   </p><p>
<span class="original">
    If case-independent matching is specified,
    the effect is much as if all case distinctions had vanished from the
    alphabet.
    When an alphabetic that exists in multiple cases appears as an
    ordinary character outside a bracket expression, it is effectively
    transformed into a bracket expression containing both cases,
    e.g., &lt;literal&gt;x&lt;/literal&gt; becomes &lt;literal&gt;[xX]&lt;/literal&gt;.
    When it appears inside a bracket expression, all case counterparts
    of it are added to the bracket expression, e.g.,
    &lt;literal&gt;[x]&lt;/literal&gt; becomes &lt;literal&gt;[xX]&lt;/literal&gt;
    and &lt;literal&gt;[^x]&lt;/literal&gt; becomes &lt;literal&gt;[^xX]&lt;/literal&gt;.
</span>
もし大文字小文字を区別しないマッチが指定されると、アルファベット文字の大文字小文字の区別がまったくなくなったのと同じ効果を与えます。
ブラケット式の外側にアルファベットの大文字小文字が混ざった通常の文字が出てきた場合、例えば、<code class="literal">x</code>が<code class="literal">[xX]</code>となるように大文字小文字ともにブラケット式に実質的に転換されます。
ブラケット式の中に現れた時は、（例えば）<code class="literal">[x]</code>が<code class="literal">[xX]</code>となり、また<code class="literal">[^x]</code>が<code class="literal">[^xX]</code>となるように、全ての大文字小文字それぞれの対がブラケット式に追加されます。
   </p><p>
<span class="original">
    If newline-sensitive matching is specified, &lt;literal&gt;.&lt;/literal&gt;
    and bracket expressions using &lt;literal&gt;^&lt;/literal&gt;
    will never match the newline character
    (so that matches will never cross newlines unless the RE
    explicitly arranges it)
    and &lt;literal&gt;^&lt;/literal&gt; and &lt;literal&gt;$&lt;/literal&gt;
    will match the empty string after and before a newline
    respectively, in addition to matching at beginning and end of string
    respectively.
    But the ARE escapes &lt;literal&gt;\A&lt;/literal&gt; and &lt;literal&gt;\Z&lt;/literal&gt;
    continue to match beginning or end of string &lt;emphasis&gt;only&lt;/emphasis&gt;.
</span>
改行を区別するマッチが指定されると、<code class="literal">.</code>と<code class="literal">^</code>を使用するブラケット式は（REが明示的に調整されていたとしてもマッチが改行をまたがらないようにするために）改行文字にマッチしなくなります。また、<code class="literal">^</code>と<code class="literal">$</code>はそれぞれ改行直後と直前の空文字列にマッチし、さらに、それぞれ文字列の先頭と末尾にマッチします。
しかし、AREエスケープの<code class="literal">\A</code>と<code class="literal">\Z</code>は、継続して、文字列の先頭と末尾<span class="emphasis"><em>のみ</em></span>にマッチします。
   </p><p>
<span class="original">
    If partial newline-sensitive matching is specified,
    this affects &lt;literal&gt;.&lt;/literal&gt; and bracket expressions
    as with newline-sensitive matching, but not &lt;literal&gt;^&lt;/literal&gt;
    and &lt;literal&gt;$&lt;/literal&gt;.
</span>
部分的に改行を区別するマッチが指定されると、<code class="literal">.</code>とブラケット式は改行を区別するマッチを行うようになりますが、<code class="literal">^</code>と<code class="literal">$</code>は変更されません。
   </p><p>
<span class="original">
    If inverse partial newline-sensitive matching is specified,
    this affects &lt;literal&gt;^&lt;/literal&gt; and &lt;literal&gt;$&lt;/literal&gt;
    as with newline-sensitive matching, but not &lt;literal&gt;.&lt;/literal&gt;
    and bracket expressions.
    This isn't very useful but is provided for symmetry.
</span>
部分的に改行を区別する逆マッチが指定されると、<code class="literal">^</code>と<code class="literal">$</code>は改行を区別するマッチを行うようになりますが、<code class="literal">.</code>とブラケット式は変更されません。
これはあまり有用ではありません。対称性のために提供されています。
   </p></div><div class="sect3" id="POSIX-LIMITS-COMPATIBILITY"><div class="titlepage"><div><div><h4 class="title">9.7.3.6. 制限と互換性</h4></div></div></div><span class="original">
    &lt;title&gt;Limits and Compatibility&lt;/title&gt;
</span><p>
<span class="original">
    No particular limit is imposed on the length of REs in this
    implementation.  However,
    programs intended to be highly portable should not employ REs longer
    than 256 bytes,
    as a POSIX-compliant implementation can refuse to accept such REs.
</span>
本実装ではREの長さに関する制限はありません。
しかし、移植性を高めたいプログラムでは、256バイトを超えるREを使用すべきではありません。POSIX互換の実装ではそうしたREでは混乱する可能性があります。
   </p><p>
<span class="original">
    The only feature of AREs that is actually incompatible with
    POSIX EREs is that &lt;literal&gt;\&lt;/literal&gt; does not lose its special
    significance inside bracket expressions.
    All other ARE features use syntax which is illegal or has
    undefined or unspecified effects in POSIX EREs;
    the &lt;literal&gt;***&lt;/literal&gt; syntax of directors likewise is outside the POSIX
    syntax for both BREs and EREs.
</span>
AREの機能のうち、POSIX EREと実質的な非互換性があるのは、<code class="literal">\</code>がブラケット式の内側で特殊な意味を失わないという点のみです。
他の全てのARE機能は、POSIX EREでは不正、未定義、未指定な効果となる構文を使用しています。決定子の<code class="literal">***</code>構文などはBREおよびEREのPOSIX構文にはありません。
   </p><p>
<span class="original">
    Many of the ARE extensions are borrowed from Perl, but some have
    been changed to clean them up, and a few Perl extensions are not present.
    Incompatibilities of note include &lt;literal&gt;\b&lt;/literal&gt;, &lt;literal&gt;\B&lt;/literal&gt;,
    the lack of special treatment for a trailing newline,
    the addition of complemented bracket expressions to the things
    affected by newline-sensitive matching,
    the restrictions on parentheses and back references in lookahead/lookbehind
    constraints, and the longest/shortest-match (rather than first-match)
    matching semantics.
</span>
多くのARE拡張はPerlから拝借したものです。
しかし、いくつかは整理され、Perlの拡張のいくつかは存在しません。
注意すべき非互換性には、<code class="literal">\b</code>、<code class="literal">\B</code>、改行の取り扱いに関する特殊な措置の欠落、改行を区別するマッチに影響する点について補足したブラケット式の追加、括弧と先行・後方検索制約内の後方参照についての制限、最長/最短（最初にマッチするではなく）マッチのセマンティックがあります。
   </p><p>
<span class="original">
    Two significant incompatibilities exist between AREs and the ERE syntax
    recognized by pre-7.4 releases of &lt;productname&gt;PostgreSQL&lt;/productname&gt;:
</span>
<span class="productname">PostgreSQL</span>リリース7.4より前で認知された、AREとERE構文間で大きな非互換が2つあります。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
       In AREs, &lt;literal&gt;\&lt;/literal&gt; followed by an alphanumeric character is either
       an escape or an error, while in previous releases, it was just another
       way of writing the alphanumeric.
       This should not be much of a problem because there was no reason to
       write such a sequence in earlier releases.
</span>
AREでは、<code class="literal">\</code>の後に英数字が続くものはエスケープもしくはエラーとなります。以前のリリースでは、これは単に、英数字を記述する他の方法でした。
これは、大きな問題にはならないはずです。以前のリリースではこうした並びを記述する理由がないからです。
      </p></li><li class="listitem"><p>
<span class="original">
       In AREs, &lt;literal&gt;\&lt;/literal&gt; remains a special character within
       &lt;literal&gt;[]&lt;/literal&gt;, so a literal &lt;literal&gt;\&lt;/literal&gt; within a bracket
       expression must be written &lt;literal&gt;\\&lt;/literal&gt;.
</span>
AREでは、<code class="literal">\</code>は<code class="literal">[]</code>内でも特別な文字です。したがって、ブラケット式では<code class="literal">\</code>を<code class="literal">\\</code>と記述しなければなりません。
      </p></li></ul></div><p>
   </p></div><div class="sect3" id="POSIX-BASIC-REGEXES"><div class="titlepage"><div><div><h4 class="title">9.7.3.7. 基本正規表現</h4></div></div></div><span class="original">
    &lt;title&gt;Basic Regular Expressions&lt;/title&gt;
</span><p>
<span class="original">
    BREs differ from EREs in several respects.
    In BREs, &lt;literal&gt;|&lt;/literal&gt;, &lt;literal&gt;+&lt;/literal&gt;, and &lt;literal&gt;?&lt;/literal&gt;
    are ordinary characters and there is no equivalent
    for their functionality.
    The delimiters for bounds are
    &lt;literal&gt;\{&lt;/literal&gt; and &lt;literal&gt;\}&lt;/literal&gt;,
    with &lt;literal&gt;{&lt;/literal&gt; and &lt;literal&gt;}&lt;/literal&gt;
    by themselves ordinary characters.
    The parentheses for nested subexpressions are
    &lt;literal&gt;\(&lt;/literal&gt; and &lt;literal&gt;\)&lt;/literal&gt;,
    with &lt;literal&gt;(&lt;/literal&gt; and &lt;literal&gt;)&lt;/literal&gt; by themselves ordinary characters.
    &lt;literal&gt;^&lt;/literal&gt; is an ordinary character except at the beginning of the
    RE or the beginning of a parenthesized subexpression,
    &lt;literal&gt;$&lt;/literal&gt; is an ordinary character except at the end of the
    RE or the end of a parenthesized subexpression,
    and &lt;literal&gt;*&lt;/literal&gt; is an ordinary character if it appears at the beginning
    of the RE or the beginning of a parenthesized subexpression
    (after a possible leading &lt;literal&gt;^&lt;/literal&gt;).
    Finally, single-digit back references are available, and
    &lt;literal&gt;\&amp;lt;&lt;/literal&gt; and &lt;literal&gt;\&amp;gt;&lt;/literal&gt;
    are synonyms for
    &lt;literal&gt;[[:&amp;lt;:]]&lt;/literal&gt; and &lt;literal&gt;[[:&amp;gt;:]]&lt;/literal&gt;
    respectively; no other escapes are available in BREs.
</span>
BREはEREといくつかの面において異なります。
BREにおいては、<code class="literal">|</code>、<code class="literal">+</code>、<code class="literal">?</code>は普通の文字であり、それらの機能と等価なものはありません。
バウンドの区切りは<code class="literal">\{</code>と<code class="literal">\}</code>であり、<code class="literal">{</code>と<code class="literal">}</code>自身は普通の文字です。
副式を入れ子にするための括弧は<code class="literal">\(</code>と<code class="literal">\)</code>であり、<code class="literal">(</code>と<code class="literal">)</code>自身は普通の文字です。
<code class="literal">^</code>は、REの先頭にある場合や括弧内の副式の先頭の場合を除き、普通の文字です。
<code class="literal">$</code>は、REの末尾にある場合や括弧内の副式の末尾の場合を除き、普通の文字です。
また、<code class="literal">*</code>はREの先頭にある場合や括弧内の副式の先頭にある場合には普通の文字になります（その前に<code class="literal">^</code>が付いている可能性もあります）。
最後に、1桁の後方参照を使用することができ、また、BREにおいては、<code class="literal">\&lt;</code>と<code class="literal">\&gt;</code>はそれぞれ<code class="literal">[[:&lt;:]]</code>と<code class="literal">[[:&gt;:]]</code>と同義です。
   </p></div><span class="original"> end re_syntax.n man page </span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-bitstring.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-formatting.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">9.6. ビット文字列関数と演算子 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 9.8. データ型書式設定関数</td></tr></table></div></body></html>