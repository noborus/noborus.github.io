<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.14. XML関数</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="functions-textsearch.html" title="9.13. テキスト検索関数と演算子" /><link rel="next" href="functions-json.html" title="9.15. JSON関数と演算子" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 11.5文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="functions.html" title="第9章 関数と演算子">第9章 関数と演算子</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 11.5 &#10;                      functions-xml.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-textsearch.html" title="9.13. テキスト検索関数と演算子">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="第9章 関数と演算子">上へ</a></td><td width="60%" align="center">9.14. XML関数</td><td width="20%" align="right"> <a accesskey="n" href="functions-json.html" title="9.15. JSON関数と演算子">次へ</a></td></tr></table><hr /></div><div class="sect1" id="FUNCTIONS-XML"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.14. XML関数</h2></div></div></div><span class="original">
  &lt;title&gt;XML Functions&lt;/title&gt;
</span><p>
<span class="original">
   The functions and function-like expressions described in this
   section operate on values of type &lt;type&gt;xml&lt;/type&gt;.  Check &lt;xref
   linkend="datatype-xml"/&gt; for information about the &lt;type&gt;xml&lt;/type&gt;
   type.  The function-like expressions &lt;function&gt;xmlparse&lt;/function&gt;
   and &lt;function&gt;xmlserialize&lt;/function&gt; for converting to and from
   type &lt;type&gt;xml&lt;/type&gt; are not repeated here.  Use of most of these
   functions requires the installation to have been built
   with &lt;command&gt;configure &amp;#045;&amp;#045;with-libxml&lt;/command&gt;.
</span>
この節で説明される関数および擬似関数式は、<code class="type">xml</code>型の値に対して機能します。
<code class="type">xml</code>型についての情報は<a class="xref" href="datatype-xml.html" title="8.13. XML型">8.13</a>を点検してください。
<code class="type">xml</code>型のやりとりを変換する<code class="function">xmlparse</code>および<code class="function">xmlserialize</code>擬似関数式はここでは繰り返しません。
これらの多くの関数を使用するには、インストレーションの際<code class="command">configure --with-libxml</code>付きでビルドされていることが必要です。
  </p><div class="sect2" id="FUNCTIONS-PRODUCING-XML"><div class="titlepage"><div><div><h3 class="title">9.14.1. XML内容の生成</h3></div></div></div><span class="original">
   &lt;title&gt;Producing XML Content&lt;/title&gt;
</span><p>
<span class="original">
    A set of functions and function-like expressions are available for
    producing XML content from SQL data.  As such, they are
    particularly suitable for formatting query results into XML
    documents for processing in client applications.
</span>
SQLデータからXML内容を生成するために関数と擬似関数式の一式が提供されています。
そのようなものとして、クライアントアプリケーションが問い合わせ結果を処理のためXML文書に書式化するのにこれらは特に適しています。
   </p><div class="sect3" id="id-1.5.8.19.3.3"><div class="titlepage"><div><div><h4 class="title">9.14.1.1. <code class="literal">xmlcomment</code></h4></div></div></div><a id="id-1.5.8.19.3.3.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlcomment</code>(<em class="replaceable"><code>text</code></em>)
</pre><p>
<span class="original">
     The function &lt;function&gt;xmlcomment&lt;/function&gt; creates an XML value
     containing an XML comment with the specified text as content.
     The text cannot contain &lt;quote&gt;&lt;literal&gt;&amp;#045;-&lt;/literal&gt;&lt;/quote&gt; or end with a
     &lt;quote&gt;&lt;literal&gt;-&lt;/literal&gt;&lt;/quote&gt; so that the resulting construct is a valid
     XML comment.  If the argument is null, the result is null.
</span>
関数<code class="function">xmlcomment</code>は指定のテキストを内容とするXMLコメントを含んだXML値を作成します。
結果として構築されるXMLコメントが有効になるよう、テキストは<span class="quote">「<span class="quote"><code class="literal">--</code></span>」</span>を含むこと、または<span class="quote">「<span class="quote"><code class="literal">-</code></span>」</span>で終結することはできません。
引数がNULLならば結果もNULLになります。
    </p><p>
<span class="original">
     Example:
</span>
例：
</p><pre class="screen">
SELECT xmlcomment('hello');

  xmlcomment
--------------
 &lt;!--hello--&gt;
</pre><p>
    </p></div><div class="sect3" id="id-1.5.8.19.3.4"><div class="titlepage"><div><div><h4 class="title">9.14.1.2. <code class="literal">xmlconcat</code></h4></div></div></div><a id="id-1.5.8.19.3.4.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlconcat</code>(<em class="replaceable"><code>xml</code></em>[<span class="optional">, ...</span>])
</pre><p>
<span class="original">
     The function &lt;function&gt;xmlconcat&lt;/function&gt; concatenates a list
     of individual XML values to create a single value containing an
     XML content fragment.  Null values are omitted; the result is
     only null if there are no nonnull arguments.
</span>
関数<code class="function">xmlconcat</code>は、個々のXML値のリストを結合し、XMLの内容断片を含む単一の値を作成します。
NULL値は削除され、NULL以外の引数が存在しないときのみ結果はNULLになります。
    </p><p>
<span class="original">
     Example:
</span>
例：
</p><pre class="screen">
SELECT xmlconcat('&lt;abc/&gt;', '&lt;bar&gt;foo&lt;/bar&gt;');

      xmlconcat
----------------------
 &lt;abc/&gt;&lt;bar&gt;foo&lt;/bar&gt;
</pre><p>
    </p><p>
<span class="original">
     XML declarations, if present, are combined as follows.  If all
     argument values have the same XML version declaration, that
     version is used in the result, else no version is used.  If all
     argument values have the standalone declaration value
     &lt;quote&gt;yes&lt;/quote&gt;, then that value is used in the result.  If
     all argument values have a standalone declaration value and at
     least one is &lt;quote&gt;no&lt;/quote&gt;, then that is used in the result.
     Else the result will have no standalone declaration.  If the
     result is determined to require a standalone declaration but no
     version declaration, a version declaration with version 1.0 will
     be used because XML requires an XML declaration to contain a
     version declaration.  Encoding declarations are ignored and
     removed in all cases.
</span>
XML宣言が提示されている場合は次のように組み合わされます。
全ての引数の値が同一のXMLversion宣言を持っていれば、そのversionが結果に使用されます。さもなければversionは使用されません。
全ての引数の値でstandaloneの宣言値が<span class="quote">「<span class="quote">yes</span>」</span>であれば、その値が結果に使用されます。
全ての引数の値にstandalone宣言値があり、その中で１つでも<span class="quote">「<span class="quote">no</span>」</span>がある場合、それが結果に使用されます。
それ以外の場合は、結果はstandalone宣言を持ちません。
standalone宣言を必要とするが、standalone宣言がないという結果になった場合には、version 1.0のversion宣言が使用されます。
これはXMLがXML宣言においてversion宣言を含むことを要求するためです。
encoding宣言は無視され、全ての場合で削除されます。
    </p><p>
<span class="original">
     Example:
</span>
例：
</p><pre class="screen">
SELECT xmlconcat('&lt;?xml version="1.1"?&gt;&lt;foo/&gt;', '&lt;?xml version="1.1" standalone="no"?&gt;&lt;bar/&gt;');

             xmlconcat
-----------------------------------
 &lt;?xml version="1.1"?&gt;&lt;foo/&gt;&lt;bar/&gt;
</pre><p>
    </p></div><div class="sect3" id="id-1.5.8.19.3.5"><div class="titlepage"><div><div><h4 class="title">9.14.1.3. <code class="literal">xmlelement</code></h4></div></div></div><a id="id-1.5.8.19.3.5.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlelement</code>(name <em class="replaceable"><code>name</code></em> [<span class="optional">, xmlattributes(<em class="replaceable"><code>value</code></em> [<span class="optional">AS <em class="replaceable"><code>attname</code></em></span>] [<span class="optional">, ... </span>])</span>] [<span class="optional"><em class="replaceable"><code>, content, ...</code></em></span>])
</pre><p>
<span class="original">
     The &lt;function&gt;xmlelement&lt;/function&gt; expression produces an XML
     element with the given name, attributes, and content.
</span>
<code class="function">xmlelement</code>式は与えられた名前、属性、および内容を持つXML要素を生成します。
    </p><p>
<span class="original">
     Examples:
</span>
例：
</p><pre class="screen">
SELECT xmlelement(name foo);

 xmlelement
------------
 &lt;foo/&gt;

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
------------------
 &lt;foo bar="xyz"/&gt;

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-------------------------------------
 &lt;foo bar="2007-01-26"&gt;content&lt;/foo&gt;
</pre><p>
    </p><p>
<span class="original">
     Element and attribute names that are not valid XML names are
     escaped by replacing the offending characters by the sequence
     &lt;literal&gt;_x&lt;replaceable&gt;HHHH&lt;/replaceable&gt;_&lt;/literal&gt;, where
     &lt;replaceable&gt;HHHH&lt;/replaceable&gt; is the character's Unicode
     codepoint in hexadecimal notation.  For example:
</span>
有効なXML名ではない要素名と属性名は、シーケンス<code class="literal">_x<em class="replaceable"><code>HHHH</code></em>_</code>により障害となる文字を置換することでエスケープされます。ここで、<em class="replaceable"><code>HHHH</code></em>は16進数によるその文字のUnicode文字コード番号です。
例をあげます。
</p><pre class="screen">
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&amp;b"));

            xmlelement
----------------------------------
 &lt;foo_x0024_bar a_x0026_b="xyz"/&gt;
</pre><p>
    </p><p>
<span class="original">
     An explicit attribute name need not be specified if the attribute
     value is a column reference, in which case the column's name will
     be used as the attribute name by default.  In other cases, the
     attribute must be given an explicit name.  So this example is
     valid:
</span>
属性値が列参照の場合、明示的な属性名を指定する必要はありません。この場合、デフォルトで列名が属性名として使用されます。
その他の場合には、属性は明示的な名前で与えられなければなりません。
従って、以下の例は有効です。
</p><pre class="screen">
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
</pre><p>
<span class="original">
     But these are not:
</span>
しかし、以下の例は有効ではありません。
</p><pre class="screen">
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
</pre><p>
    </p><p>
<span class="original">
     Element content, if specified, will be formatted according to
     its data type.  If the content is itself of type &lt;type&gt;xml&lt;/type&gt;,
     complex XML documents can be constructed.  For example:
</span>
もし要素内容が指定されればそのデータ型に従って書式化されます。
もし内容そのものが<code class="type">xml</code>型であれば、複合XML文書が構築されます。
例をあげます。
</p><pre class="screen">
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
----------------------------------------------
 &lt;foo bar="xyz"&gt;&lt;abc/&gt;&lt;!--test--&gt;&lt;xyz/&gt;&lt;/foo&gt;
</pre><p>

<span class="original">
     Content of other types will be formatted into valid XML character
     data.  This means in particular that the characters &amp;lt;, &amp;gt;,
     and &amp;amp; will be converted to entities.  Binary data (data type
     &lt;type&gt;bytea&lt;/type&gt;) will be represented in base64 or hex
     encoding, depending on the setting of the configuration parameter
     &lt;xref linkend="guc-xmlbinary"/&gt;.  The particular behavior for
     individual data types is expected to evolve in order to align the
     SQL and PostgreSQL data types with the XML Schema specification,
     at which point a more precise description will appear.
</span>
そのほかの型の内容は有効なXML文字データにフォーマットされます。
これは特に文字&lt;、&gt;、および&amp;がエンティティに変換されることを意味します。
バイナリデータ（データ型は<code class="type">bytea</code>）は、設定パラメータ<a class="xref" href="runtime-config-client.html#GUC-XMLBINARY">xmlbinary</a>の設定にしたがって、base64もしくは16進符号化方式で表現されます。
個々のデータ型に対する特定の動作は、XMLスキーマ仕様でのSQLおよびPostgreSQLデータ型に調整するため発展すると期待されます。
その時点で記述がより詳細になるでしょう。
    </p></div><div class="sect3" id="id-1.5.8.19.3.6"><div class="titlepage"><div><div><h4 class="title">9.14.1.4. <code class="literal">xmlforest</code></h4></div></div></div><a id="id-1.5.8.19.3.6.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlforest</code>(<em class="replaceable"><code>content</code></em> [<span class="optional">AS <em class="replaceable"><code>name</code></em></span>] [<span class="optional">, ...</span>])
</pre><p>
<span class="original">
     The &lt;function&gt;xmlforest&lt;/function&gt; expression produces an XML
     forest (sequence) of elements using the given names and content.
</span>
<code class="function">xmlforest</code>式は与えられた名前と内容を使用し、要素のXMLフォレスト（シーケンス）を生成します。
    </p><p>
<span class="original">
     Examples:
</span>
例：
</p><pre class="screen">
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
------------------------------
 &lt;foo&gt;abc&lt;/foo&gt;&lt;bar&gt;123&lt;/bar&gt;


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                         xmlforest
-------------------------------------------------------------------------------------------
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&lt;column_name&gt;rolname&lt;/column_name&gt;
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&lt;column_name&gt;rolsuper&lt;/column_name&gt;
 ...
</pre><p>

<span class="original">
     As seen in the second example, the element name can be omitted if
     the content value is a column reference, in which case the column
     name is used by default.  Otherwise, a name must be specified.
</span>
第２の例に見られるように、内容の値が列参照の場合、要素名は省略可能です。この時は、列名がデフォルトで使用されます。
そうでない時は、名前が指定されなければなりません。
    </p><p>
<span class="original">
     Element names that are not valid XML names are escaped as shown
     for &lt;function&gt;xmlelement&lt;/function&gt; above.  Similarly, content
     data is escaped to make valid XML content, unless it is already
     of type &lt;type&gt;xml&lt;/type&gt;.
</span>
有効なXML名ではない要素名は上の<code class="function">xmlelement</code>で説明した通りエスケープされます。
同様にして、既に<code class="type">xml</code>型であるものを除き、内容データは有効なXML内容になるようにエスケープされます。
    </p><p>
<span class="original">
     Note that XML forests are not valid XML documents if they consist
     of more than one element, so it might be useful to wrap
     &lt;function&gt;xmlforest&lt;/function&gt; expressions in
     &lt;function&gt;xmlelement&lt;/function&gt;.
</span>
XMLフォレストは２つ以上の要素からなる場合、有効なXML文書ではないことに注意してください。
したがって、<code class="function">xmlelement</code>内に<code class="function">xmlforest</code>式をラップすることが有用なことがあります。
    </p></div><div class="sect3" id="id-1.5.8.19.3.7"><div class="titlepage"><div><div><h4 class="title">9.14.1.5. <code class="literal">xmlpi</code></h4></div></div></div><a id="id-1.5.8.19.3.7.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlpi</code>(name <em class="replaceable"><code>target</code></em> [<span class="optional">, <em class="replaceable"><code>content</code></em></span>])
</pre><p>
<span class="original">
     The &lt;function&gt;xmlpi&lt;/function&gt; expression creates an XML
     processing instruction.  The content, if present, must not
     contain the character sequence &lt;literal&gt;?&amp;gt;&lt;/literal&gt;.
</span>
<code class="function">xmlpi</code>式はXML処理命令を作成します。
内容が存在すれば、その内容は<code class="literal">?&gt;</code>文字シーケンスを含んではなりません。
    </p><p>
<span class="original">
     Example:
</span>
例：
</p><pre class="screen">
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-----------------------------
 &lt;?php echo "hello world";?&gt;
</pre><p>
    </p></div><div class="sect3" id="id-1.5.8.19.3.8"><div class="titlepage"><div><div><h4 class="title">9.14.1.6. <code class="literal">xmlroot</code></h4></div></div></div><a id="id-1.5.8.19.3.8.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlroot</code>(<em class="replaceable"><code>xml</code></em>, version <em class="replaceable"><code>text</code></em> | no value [<span class="optional">, standalone yes|no|no value</span>])
</pre><p>
<span class="original">
     The &lt;function&gt;xmlroot&lt;/function&gt; expression alters the properties
     of the root node of an XML value.  If a version is specified,
     it replaces the value in the root node's version declaration; if a
     standalone setting is specified, it replaces the value in the
     root node's standalone declaration.
</span>
<code class="function">xmlroot</code>式はXML値のルートノードの属性を変更します。
versionが指定されていると、ルートノードのversion宣言での値を変更し、standalone設定が指定されていると、ルートノードのstandalone宣言での値を変更します。
    </p><p>
</p><pre class="screen">
SELECT xmlroot(xmlparse(document '&lt;?xml version="1.1"?&gt;&lt;content&gt;abc&lt;/content&gt;'),
               version '1.0', standalone yes);

                xmlroot
----------------------------------------
 &lt;?xml version="1.0" standalone="yes"?&gt;
 &lt;content&gt;abc&lt;/content&gt;
</pre><p>
    </p></div><div class="sect3" id="FUNCTIONS-XML-XMLAGG"><div class="titlepage"><div><div><h4 class="title">9.14.1.7. <code class="literal">xmlagg</code></h4></div></div></div><a id="id-1.5.8.19.3.9.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlagg</code>(<em class="replaceable"><code>xml</code></em>)
</pre><p>
<span class="original">
     The function &lt;function&gt;xmlagg&lt;/function&gt; is, unlike the other
     functions described here, an aggregate function.  It concatenates the
     input values to the aggregate function call,
     much like &lt;function&gt;xmlconcat&lt;/function&gt; does, except that concatenation
     occurs across rows rather than across expressions in a single row.
     See &lt;xref linkend="functions-aggregate"/&gt; for additional information
     about aggregate functions.
</span>
ここで説明している他の関数とは異なり、<code class="function">xmlagg</code>関数は集約関数です。
これは<code class="function">xmlconcat</code>が行うように、入力値を連結する集約関数ですが、単一行内の複数の式にまたがった連結ではなく、複数行にまたがった連結を行います。
集約関数についての追加情報は<a class="xref" href="functions-aggregate.html" title="9.20. 集約関数">9.20</a>を参照してください。
    </p><p>
<span class="original">
     Example:
</span>
例：
</p><pre class="screen">
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '&lt;foo&gt;abc&lt;/foo&gt;');
INSERT INTO test VALUES (2, '&lt;bar/&gt;');
SELECT xmlagg(x) FROM test;
        xmlagg
----------------------
 &lt;foo&gt;abc&lt;/foo&gt;&lt;bar/&gt;
</pre><p>
    </p><p>
<span class="original">
     To determine the order of the concatenation, an &lt;literal&gt;ORDER BY&lt;/literal&gt;
     clause may be added to the aggregate call as described in
     &lt;xref linkend="syntax-aggregates"/&gt;. For example:
</span>
連結の順序を決定するため、<a class="xref" href="sql-expressions.html#SYNTAX-AGGREGATES" title="4.2.7. 集約式">4.2.7</a>に記述されているように<code class="literal">ORDER BY</code>句を集計呼び出しに追加することができます。
以下は例です。

</p><pre class="screen">
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
----------------------
 &lt;bar/&gt;&lt;foo&gt;abc&lt;/foo&gt;
</pre><p>
    </p><p>
<span class="original">
     The following non-standard approach used to be recommended
     in previous versions, and may still be useful in specific
     cases:
</span>
下記は以前のバージョンで推奨されていた、非標準的な方法例です。特定のケースでは有用かもしれません。

</p><pre class="screen">
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
----------------------
 &lt;bar/&gt;&lt;foo&gt;abc&lt;/foo&gt;
</pre><p>
    </p></div></div><div class="sect2" id="FUNCTIONS-XML-PREDICATES"><div class="titlepage"><div><div><h3 class="title">9.14.2. XML述語</h3></div></div></div><span class="original">
    &lt;title&gt;XML Predicates&lt;/title&gt;
</span><p>
<span class="original">
     The expressions described in this section check properties
     of &lt;type&gt;xml&lt;/type&gt; values.
</span>
この節で記述されている式は、<code class="type">xml</code>値の属性をチェックします。
    </p><div class="sect3" id="id-1.5.8.19.4.3"><div class="titlepage"><div><div><h4 class="title">9.14.2.1. <code class="literal">IS DOCUMENT</code></h4></div></div></div><a id="id-1.5.8.19.4.3.2" class="indexterm"></a><pre class="synopsis">
<em class="replaceable"><code>xml</code></em> IS DOCUMENT
</pre><p>
<span class="original">
     The expression &lt;literal&gt;IS DOCUMENT&lt;/literal&gt; returns true if the
     argument XML value is a proper XML document, false if it is not
     (that is, it is a content fragment), or null if the argument is
     null.  See &lt;xref linkend="datatype-xml"/&gt; about the difference
     between documents and content fragments.
</span>
式<code class="literal">IS DOCUMENT</code>は引数XML値が適切なXML文書であれば真を返し、そうでなければ（つまり、内容の断片）偽を返すか、もしくは引数がNULLであればNULLを返します。
文書と内容の断片の差異については<a class="xref" href="datatype-xml.html" title="8.13. XML型">8.13</a>を参照してください。
    </p></div><div class="sect3" id="id-1.5.8.19.4.4"><div class="titlepage"><div><div><h4 class="title">9.14.2.2. <code class="literal">IS NOT DOCUMENT</code></h4></div></div></div><a id="id-1.5.8.19.4.4.2" class="indexterm"></a><pre class="synopsis">
<em class="replaceable"><code>xml</code></em> IS NOT DOCUMENT
</pre><p>
<span class="original">
     The expression &lt;literal&gt;IS NOT DOCUMENT&lt;/literal&gt; returns false if the
     argument XML value is a proper XML document, true if it is not (that is,
     it is a content fragment), or null if the argument is null.
</span>
式<code class="literal">IS NOT DOCUMENT</code>は引数XML値が適切なXML文書であれば偽を返し、そうでなければ（つまり、内容の断片）真を返すか、もしくは引数がNULLであればNULLを返します。
    </p></div><div class="sect3" id="XML-EXISTS"><div class="titlepage"><div><div><h4 class="title">9.14.2.3. <code class="literal">XMLEXISTS</code></h4></div></div></div><a id="id-1.5.8.19.4.5.2" class="indexterm"></a><pre class="synopsis">
<code class="function">XMLEXISTS</code>(<em class="replaceable"><code>text</code></em> PASSING [<span class="optional">BY REF</span>] <em class="replaceable"><code>xml</code></em> [<span class="optional">BY REF</span>])
</pre><p>
<span class="original">
     The function &lt;function&gt;xmlexists&lt;/function&gt; returns true if the
     XPath expression in the first argument returns any nodes, and
     false otherwise.  (If either argument is null, the result is
     null.)
</span>
関数<code class="function">xmlexists</code>は第一引数のXPath式が何かしらのノードであれば真を返し、そうでなければ偽を返します。
(もしいずれの引数もNULLであった場合はNULLを返します。)
    </p><p>
<span class="original">
     Example:
</span>
例:
     </p><pre class="screen">
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF '&lt;towns&gt;&lt;town&gt;Toronto&lt;/town&gt;&lt;town&gt;Ottawa&lt;/town&gt;&lt;/towns&gt;');

 xmlexists
------------
 t
(1 row)
</pre><p>
    </p><p>
<span class="original">
     The &lt;literal&gt;BY REF&lt;/literal&gt; clauses have no effect in
     PostgreSQL, but are allowed for SQL conformance and compatibility
     with other implementations.  Per SQL standard, the
     first &lt;literal&gt;BY REF&lt;/literal&gt; is required, the second is
     optional.  Also note that the SQL standard specifies
     the &lt;function&gt;xmlexists&lt;/function&gt; construct to take an XQuery
     expression as first argument, but PostgreSQL currently only
     supports XPath, which is a subset of XQuery.
</span>
<code class="literal">BY REF</code>句は、PostgreSQLには何の影響も与えませんが、他の実装とのSQL互換性や順応性のため、付与することができます。
SQL標準では1つ目の<code class="literal">BY REF</code>を必要としており、2つ目はオプショナルです。
加えてSQL標準では<code class="function">xmlexists</code>はXQuery式を第一引数として取る構成としていますが、PostgreSQLでは現在XQueryのサブセットにあたるXPathのみサポートしていることに注意してください。
    </p></div><div class="sect3" id="XML-IS-WELL-FORMED"><div class="titlepage"><div><div><h4 class="title">9.14.2.4. <code class="literal">xml_is_well_formed</code></h4></div></div></div><a id="id-1.5.8.19.4.6.2" class="indexterm"></a><a id="id-1.5.8.19.4.6.3" class="indexterm"></a><a id="id-1.5.8.19.4.6.4" class="indexterm"></a><pre class="synopsis">
<code class="function">xml_is_well_formed</code>(<em class="replaceable"><code>text</code></em>)
<code class="function">xml_is_well_formed_document</code>(<em class="replaceable"><code>text</code></em>)
<code class="function">xml_is_well_formed_content</code>(<em class="replaceable"><code>text</code></em>)
</pre><p>
<span class="original">
     These functions check whether a &lt;type&gt;text&lt;/type&gt; string is well-formed XML,
     returning a Boolean result.
     &lt;function&gt;xml_is_well_formed_document&lt;/function&gt; checks for a well-formed
     document, while &lt;function&gt;xml_is_well_formed_content&lt;/function&gt; checks
     for well-formed content.  &lt;function&gt;xml_is_well_formed&lt;/function&gt; does
     the former if the &lt;xref linkend="guc-xmloption"/&gt; configuration
     parameter is set to &lt;literal&gt;DOCUMENT&lt;/literal&gt;, or the latter if it is set to
     &lt;literal&gt;CONTENT&lt;/literal&gt;.  This means that
     &lt;function&gt;xml_is_well_formed&lt;/function&gt; is useful for seeing whether
     a simple cast to type &lt;type&gt;xml&lt;/type&gt; will succeed, whereas the other two
     functions are useful for seeing whether the corresponding variants of
     &lt;function&gt;XMLPARSE&lt;/function&gt; will succeed.
</span>
これらの関数は<code class="type">text</code>文字列が整形式かどうかをチェックし、論理値で結果を返します。
<code class="function">xml_is_well_formed_document</code>は文書が整形式かをチェックし、一方<code class="function">xml_is_well_formed_content</code>は内容が整形式かをチェックします。
<code class="function">xml_is_well_formed</code>は、<a class="xref" href="runtime-config-client.html#GUC-XMLOPTION">xmloption</a>パラメータ値が<code class="literal">DOCUMENT</code>に設定されていれば前者を、<code class="literal">CONTENT</code>が設定されていれば後者のチェックを実施します。
これは、<code class="function">xml_is_well_formed</code>は単純な<code class="type">xml</code>型へのキャストが成功するかの判断に有用であり、その他の２つの関数は<code class="function">XMLPARSE</code>の対応による変換が成功するかの判断に有用であることを意味します。
    </p><p>
<span class="original">
     Examples:
</span>
例:

</p><pre class="screen">
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('&lt;&gt;');
 xml_is_well_formed 
--------------------
 f
(1 row)

SELECT xml_is_well_formed('&lt;abc/&gt;');
 xml_is_well_formed 
--------------------
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed 
--------------------
 t
(1 row)

SELECT xml_is_well_formed_document('&lt;pg:foo xmlns:pg="http://postgresql.org/stuff"&gt;bar&lt;/pg:foo&gt;');
 xml_is_well_formed_document 
-----------------------------
 t
(1 row)

SELECT xml_is_well_formed_document('&lt;pg:foo xmlns:pg="http://postgresql.org/stuff"&gt;bar&lt;/my:foo&gt;');
 xml_is_well_formed_document 
-----------------------------
 f
(1 row)
</pre><p>

<span class="original">
     The last example shows that the checks include whether
     namespaces are correctly matched.
</span>
最後の例は、名前空間が正しく一致しているかのチェックも含むことを示しています。
    </p></div></div><div class="sect2" id="FUNCTIONS-XML-PROCESSING"><div class="titlepage"><div><div><h3 class="title">9.14.3. XMLの処理</h3></div></div></div><span class="original">
   &lt;title&gt;Processing XML&lt;/title&gt;
</span><p>
<span class="original">
    To process values of data type &lt;type&gt;xml&lt;/type&gt;, PostgreSQL offers
    the functions &lt;function&gt;xpath&lt;/function&gt; and
    &lt;function&gt;xpath_exists&lt;/function&gt;, which evaluate XPath 1.0
    expressions, and the &lt;function&gt;XMLTABLE&lt;/function&gt;
    table function.
</span>
データ型<code class="type">xml</code>の値を処理するため、PostgreSQLはXPath 1.0式を評価する関数<code class="function">xpath</code>および<code class="function">xpath_exists</code>と、テーブル関数<code class="function">XMLTABLE</code>を提供しています。
   </p><div class="sect3" id="FUNCTIONS-XML-PROCESSING-XPATH"><div class="titlepage"><div><div><h4 class="title">9.14.3.1. <code class="literal">xpath</code></h4></div></div></div><a id="id-1.5.8.19.5.3.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xpath</code>(<em class="replaceable"><code>xpath</code></em>, <em class="replaceable"><code>xml</code></em> [<span class="optional">, <em class="replaceable"><code>nsarray</code></em></span>])
</pre><p>
<span class="original">
     The function &lt;function&gt;xpath&lt;/function&gt; evaluates the XPath
     expression &lt;replaceable&gt;xpath&lt;/replaceable&gt; (a &lt;type&gt;text&lt;/type&gt; value)
     against the XML value
     &lt;replaceable&gt;xml&lt;/replaceable&gt;.  It returns an array of XML values
     corresponding to the node set produced by the XPath expression.
     If the XPath expression returns a scalar value rather than a node set,
     a single-element array is returned.
</span>
関数<code class="function">xpath</code>は、XML値<em class="replaceable"><code>xml</code></em>に対し、XPath式<em class="replaceable"><code>xpath</code></em>(ひとつの<code class="type">text</code>値)を評価します。そして、XPath式で作成されたノードセットに対応するXML値の配列を返します。
もし、XPath式がノードセットではなくスカラー値を返す場合、単一要素の配列が返されます。
    </p><p>
<span class="original">
     The second argument must be a well formed XML document. In particular,
     it must have a single root node element.
</span>
2番目の引数は整形済XML文書でなければなりません。特に、単一のルートノード要素を持たなければなりません。
    </p><p>
<span class="original">
     The optional third argument of the function is an array of namespace
     mappings.  This array should be a two-dimensional &lt;type&gt;text&lt;/type&gt; array with
     the length of the second axis being equal to 2 (i.e., it should be an
     array of arrays, each of which consists of exactly 2 elements).
     The first element of each array entry is the namespace name (alias), the
     second the namespace URI. It is not required that aliases provided in
     this array be the same as those being used in the XML document itself (in
     other words, both in the XML document and in the &lt;function&gt;xpath&lt;/function&gt;
     function context, aliases are &lt;emphasis&gt;local&lt;/emphasis&gt;).
</span>
オプショナルな関数の３番目の引数は名前空間マッピング配列です。
この配列は、第２軸が２に等しい長さをもつ２次元<code class="type">text</code>配列です（つまり、それは配列の配列で、それぞれは正確に２つの要素からなります）。
それぞれの配列のエントリの最初の要素は名前空間の名前（別名）で、２番目は名前空間のURIです。
この配列内で提供される別名がXML文書自身で使用されるものと同じであることは必要ではありません（言い換えると、XML文書内および<code class="function">xpath</code>関数の両方の文脈の中で、別名は<span class="emphasis"><em>ローカル</em></span>です）。
    </p><p>
<span class="original">
     Example:
</span>
例：
</p><pre class="screen">
SELECT xpath('/my:a/text()', '&lt;my:a xmlns:my="http://example.com"&gt;test&lt;/my:a&gt;',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath  
--------
 {test}
(1 row)
</pre><p>
    </p><p>
<span class="original">
     To deal with default (anonymous) namespaces, do something like this:
</span>
デフォルト(匿名)名前空間を取り扱うためには、以下のようなことを実施してください。
</p><pre class="screen">
SELECT xpath('//mydefns:b/text()', '&lt;a xmlns="http://example.com"&gt;&lt;b&gt;test&lt;/b&gt;&lt;/a&gt;',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
</pre><p>
    </p></div><div class="sect3" id="FUNCTIONS-XML-PROCESSING-XPATH-EXISTS"><div class="titlepage"><div><div><h4 class="title">9.14.3.2. <code class="literal">xpath_exists</code></h4></div></div></div><a id="id-1.5.8.19.5.4.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xpath_exists</code>(<em class="replaceable"><code>xpath</code></em>, <em class="replaceable"><code>xml</code></em> [<span class="optional">, <em class="replaceable"><code>nsarray</code></em></span>])
</pre><p>
<span class="original">
     The function &lt;function&gt;xpath_exists&lt;/function&gt; is a specialized form
     of the &lt;function&gt;xpath&lt;/function&gt; function.  Instead of returning the
     individual XML values that satisfy the XPath, this function returns a
     Boolean indicating whether the query was satisfied or not.  This
     function is equivalent to the standard &lt;literal&gt;XMLEXISTS&lt;/literal&gt; predicate,
     except that it also offers support for a namespace mapping argument.
</span>
関数<code class="function">xpath_exists</code>は、<code class="function">xpath</code>関数の特別な形式です。この関数は、XPathを満足する個別のXML値を返す代わりに、問い合わせがそれを満足するかどうかを論理値で返します。
この関数は、名前空間にマッピングされた引数をもサポートする点を除き、標準の<code class="literal">XMLEXISTS</code>述語と同じです。
    </p><p>
<span class="original">
     Example:
</span>
例:
</p><pre class="screen">
SELECT xpath_exists('/my:a/text()', '&lt;my:a xmlns:my="http://example.com"&gt;test&lt;/my:a&gt;',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists  
--------------
 t
(1 row)
</pre><p>
    </p></div><div class="sect3" id="FUNCTIONS-XML-PROCESSING-XMLTABLE"><div class="titlepage"><div><div><h4 class="title">9.14.3.3. <code class="literal">xmltable</code></h4></div></div></div><a id="id-1.5.8.19.5.5.2" class="indexterm"></a><a id="id-1.5.8.19.5.5.3" class="indexterm"></a><pre class="synopsis">
<code class="function">xmltable</code>( [<span class="optional">XMLNAMESPACES(<em class="replaceable"><code>namespace uri</code></em> AS <em class="replaceable"><code>namespace name</code></em>[<span class="optional">, ...</span>]), </span>]
          <em class="replaceable"><code>row_expression</code></em> PASSING [<span class="optional">BY REF</span>] <em class="replaceable"><code>document_expression</code></em> [<span class="optional">BY REF</span>]
          COLUMNS <em class="replaceable"><code>name</code></em> { <em class="replaceable"><code>type</code></em> [<span class="optional">PATH <em class="replaceable"><code>column_expression</code></em></span>] [<span class="optional">DEFAULT <em class="replaceable"><code>default_expression</code></em></span>] [<span class="optional">NOT NULL | NULL</span>]
                        | FOR ORDINALITY }
                   [<span class="optional">, ...</span>]
)
</pre><p>
<span class="original">
     The &lt;function&gt;xmltable&lt;/function&gt; function produces a table based
     on the given XML value, an XPath filter to extract rows, and an
     optional set of column definitions.
</span>
<code class="function">xmltable</code>関数は、与えられたXML値、行を抽出するXPathフィルタ、オプションの列定義の集合に基づいてテーブルを生成します。
    </p><p>
<span class="original">
     The optional &lt;literal&gt;XMLNAMESPACES&lt;/literal&gt; clause is a comma-separated
     list of namespaces.  It specifies the XML namespaces used in
     the document and their aliases. A default namespace specification
     is not currently supported.
</span>
オプションの<code class="literal">XMLNAMESPACES</code>句はカンマで区切られた名前空間のリストです。
これは文書とその別名で使用されるXML名前空間を指定します。
デフォルトの名前空間指定は現在のところサポートされていません。
    </p><p>
<span class="original">
     The required &lt;replaceable&gt;row_expression&lt;/replaceable&gt; argument is an XPath
     expression that is evaluated against the supplied XML document to
     obtain an ordered sequence of XML nodes. This sequence is what
     &lt;function&gt;xmltable&lt;/function&gt; transforms into output rows.
</span>
必須の<em class="replaceable"><code>row_expression</code></em>引数はXPath式で、指定のXML文書に対して評価され、XMLノードの順序付きシーケンスが取得されます。
このシーケンスが<code class="function">xmltable</code>により出力行に変換されます。
    </p><p>
<span class="original">
     &lt;replaceable&gt;document_expression&lt;/replaceable&gt; provides the XML document to
     operate on.
     The &lt;literal&gt;BY REF&lt;/literal&gt; clauses have no effect in PostgreSQL,
     but are allowed for SQL conformance and compatibility with other
     implementations.
     The argument must be a well-formed XML document; fragments/forests
     are not accepted.
</span>
<em class="replaceable"><code>document_expression</code></em>は演算の対象となるXML文書を提供します。
<code class="literal">BY REF</code>句はPostgreSQLでは何の効果もありませんが、SQL準拠および他の実装との互換性のために受け入れられます。
引数は整形されたXMLドキュメントでなければならず、フラグメントやフォレストは受け付けられません。
    </p><p>
<span class="original">
     The mandatory &lt;literal&gt;COLUMNS&lt;/literal&gt; clause specifies the list
     of columns in the output table.
     If the &lt;literal&gt;COLUMNS&lt;/literal&gt; clause is omitted, the rows in the result
     set contain a single column of type &lt;literal&gt;xml&lt;/literal&gt; containing the
     data matched by &lt;replaceable&gt;row_expression&lt;/replaceable&gt;.
     If &lt;literal&gt;COLUMNS&lt;/literal&gt; is specified, each entry describes a
     single column.
     See the syntax summary above for the format.
     The column name and type are required; the path, default and
     nullability clauses are optional.
</span>
必須の<code class="literal">COLUMNS</code>句は、出力テーブルの列のリストを指定します。
<code class="literal">COLUMNS</code>句を省略した場合、結果集合の行には<code class="literal">xml</code>型の列が1つだけ含まれ、そこには<em class="replaceable"><code>row_expression</code></em>にマッチしたデータが含まれます。
<code class="literal">COLUMNS</code>が指定された場合、各エントリは一つの列を表します。
形式については上記の構文サマリーを参照してください。
列名と型は必須ですが、パス、デフォルト値、NULLを許すかどうかの句は省略できます。
    </p><p>
<span class="original">
     A column marked &lt;literal&gt;FOR ORDINALITY&lt;/literal&gt; will be populated
     with row numbers matching the order in which the
     output rows appeared in the original input XML document.
     At most one column may be marked &lt;literal&gt;FOR ORDINALITY&lt;/literal&gt;.
</span>
<code class="literal">FOR ORDINALITY</code>と印がつけられた列には、元の入力XMLドキュメントの中に現れた出力行の順序に対応する行番号が入ります。
<code class="literal">FOR ORDINALITY</code>の印が付けられるのは最大でも1列です。
    </p><p>
<span class="original">
     The &lt;literal&gt;column_expression&lt;/literal&gt; for a column is an XPath expression
     that is evaluated for each row, relative to the result of the
     &lt;replaceable&gt;row_expression&lt;/replaceable&gt;, to find the value of the column.
     If no &lt;literal&gt;column_expression&lt;/literal&gt; is given, then the column name
     is used as an implicit path.
</span>
列の<code class="literal">column_expression</code>はXPath式で、<em class="replaceable"><code>row_expression</code></em>の結果に対応する各行について評価されて、列の値を得ます。
<code class="literal">column_expression</code>が与えられなかった場合は、暗示的なパスとして列名が使用されます。
    </p><p>
<span class="original">
     If a column's XPath expression returns multiple elements, an error
     is raised.
     If the expression matches an empty tag, the result is an
     empty string (not &lt;literal&gt;NULL&lt;/literal&gt;).
     Any &lt;literal&gt;xsi:nil&lt;/literal&gt; attributes are ignored.
</span>
列のXPath式が複数の要素を戻した場合、エラーが発生します。
式が空のタグとマッチした場合、結果は空文字列となります（<code class="literal">NULL</code>ではありません）。
<code class="literal">xsi:nil</code>の属性はすべて無視されます。
    </p><p>
<span class="original">
     The text body of the XML matched by the &lt;replaceable&gt;column_expression&lt;/replaceable&gt;
     is used as the column value. Multiple &lt;literal&gt;text()&lt;/literal&gt; nodes
     within an element are concatenated in order. Any child elements,
     processing instructions, and comments are ignored, but the text contents
     of child elements are concatenated to the result.
     Note that the whitespace-only &lt;literal&gt;text()&lt;/literal&gt; node between two non-text
     elements is preserved, and that leading whitespace on a &lt;literal&gt;text()&lt;/literal&gt;
     node is not flattened.
</span>
<em class="replaceable"><code>column_expression</code></em>にマッチしたXMLのテキスト本体が列の値として使用されます。
要素内の複数の<code class="literal">text()</code>ノードは順番に結合されます。
子要素、処理命令、コメントはすべて無視されますが、子要素のテキストコンテンツは結果に結合されます。
2つの非テキスト要素間にある空白文字のみの<code class="literal">text()</code>ノードは保存されること、また<code class="literal">text()</code>ノードの先頭にある空白文字は削られないことに注意してください。
    </p><p>
<span class="original">
     If the path expression does not match for a given row but
     &lt;replaceable&gt;default_expression&lt;/replaceable&gt; is specified, the value resulting
     from evaluating that expression is used.
     If no &lt;literal&gt;DEFAULT&lt;/literal&gt; clause is given for the column,
     the field will be set to &lt;literal&gt;NULL&lt;/literal&gt;.
     It is possible for a &lt;replaceable&gt;default_expression&lt;/replaceable&gt; to reference
     the value of output columns that appear prior to it in the column list,
     so the default of one column may be based on the value of another
     column.
</span>
パス式が行とマッチせず、<em class="replaceable"><code>default_expression</code></em>が指定されている場合は、その式を評価した結果の値が使用されます。
その列に<code class="literal">DEFAULT</code>句が指定されていない場合は、そのフィールドは<code class="literal">NULL</code>に設定されます。
<em class="replaceable"><code>default_expression</code></em>は列リスト内でそれより前に現れる出力列の値を参照して、ある列のデフォルト値を他の列の値に基づくものにすることができます。
    </p><p>
<span class="original">
     Columns may be marked &lt;literal&gt;NOT NULL&lt;/literal&gt;. If the
     &lt;replaceable&gt;column_expression&lt;/replaceable&gt; for a &lt;literal&gt;NOT NULL&lt;/literal&gt; column
     does not match anything and there is no &lt;literal&gt;DEFAULT&lt;/literal&gt; or the
     &lt;replaceable&gt;default_expression&lt;/replaceable&gt; also evaluates to null, an error
     is reported.
</span>
列には<code class="literal">NOT NULL</code>の印をつけることができます。
<code class="literal">NOT NULL</code>の列の<em class="replaceable"><code>column_expression</code></em>が何にもマッチせず、<code class="literal">DEFAULT</code>がない、あるいは<em class="replaceable"><code>default_expression</code></em>の評価結果もNULLになるという場合はエラーが報告されます。
    </p><p>
<span class="original">
     Unlike regular PostgreSQL functions, &lt;replaceable&gt;column_expression&lt;/replaceable&gt;
     and &lt;replaceable&gt;default_expression&lt;/replaceable&gt; are not evaluated to a simple
     value before calling the function.
     &lt;replaceable&gt;column_expression&lt;/replaceable&gt; is normally evaluated
     exactly once per input row, and &lt;replaceable&gt;default_expression&lt;/replaceable&gt;
     is evaluated each time a default is needed for a field.
     If the expression qualifies as stable or immutable the repeat
     evaluation may be skipped.
     Effectively &lt;function&gt;xmltable&lt;/function&gt; behaves more like a subquery than a
     function call.
     This means that you can usefully use volatile functions like
     &lt;function&gt;nextval&lt;/function&gt; in &lt;replaceable&gt;default_expression&lt;/replaceable&gt;, and
     &lt;replaceable&gt;column_expression&lt;/replaceable&gt; may depend on other parts of the
     XML document.
</span>
PostgreSQLの通常の関数とは異なり、<em class="replaceable"><code>column_expression</code></em>と<em class="replaceable"><code>default_expression</code></em>は関数を呼び出す前には単純な値に評価されません。
<em class="replaceable"><code>column_expression</code></em>は通常は一つの入力行に対してちょうど一度だけ評価され、<em class="replaceable"><code>default_expression</code></em>はフィールドにデフォルト値が必要になる度に評価されます。
式が安定（stable）または不変（immutable）とみなされる場合、評価は繰り返し行われないかもしれません。
実際上、<code class="function">xmltable</code>は関数呼び出しとしてよりも、副問合せのように動作します。
これは<em class="replaceable"><code>default_expression</code></em>の中で<code class="function">nextval</code>のような揮発性（volatile）の関数を有効に使用できること、また<em class="replaceable"><code>column_expression</code></em>はXML文書の他の部分に依存するかもしれないということを意味します。
    </p><p>
<span class="original">
     Examples:
</span>
例：
  </p><pre class="screen">
CREATE TABLE xmldata AS SELECT
xml $$
&lt;ROWS&gt;
  &lt;ROW id="1"&gt;
    &lt;COUNTRY_ID&gt;AU&lt;/COUNTRY_ID&gt;
    &lt;COUNTRY_NAME&gt;Australia&lt;/COUNTRY_NAME&gt;
  &lt;/ROW&gt;
  &lt;ROW id="5"&gt;
    &lt;COUNTRY_ID&gt;JP&lt;/COUNTRY_ID&gt;
    &lt;COUNTRY_NAME&gt;Japan&lt;/COUNTRY_NAME&gt;
    &lt;PREMIER_NAME&gt;Shinzo Abe&lt;/PREMIER_NAME&gt;
    &lt;SIZE unit="sq_mi"&gt;145935&lt;/SIZE&gt;
  &lt;/ROW&gt;
  &lt;ROW id="6"&gt;
    &lt;COUNTRY_ID&gt;SG&lt;/COUNTRY_ID&gt;
    &lt;COUNTRY_NAME&gt;Singapore&lt;/COUNTRY_NAME&gt;
    &lt;SIZE unit="sq_km"&gt;697&lt;/SIZE&gt;
  &lt;/ROW&gt;
&lt;/ROWS&gt;
$$ AS data;

SELECT xmltable.*
  FROM xmldata,
       XMLTABLE('//ROWS/ROW'
                PASSING data
                COLUMNS id int PATH '@id',
                        ordinality FOR ORDINALITY,
                        "COUNTRY_NAME" text,
                        country_id text PATH 'COUNTRY_ID',
                        size_sq_km float PATH 'SIZE[@unit = "sq_km"]',
                        size_other text PATH
                             'concat(SIZE[@unit!="sq_km"], " ", SIZE[@unit!="sq_km"]/@unit)',
                        premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified') ;

 id | ordinality | COUNTRY_NAME | country_id | size_sq_km |  size_other  | premier_name  
----+------------+--------------+------------+------------+--------------+---------------
  1 |          1 | Australia    | AU         |            |              | not specified
  5 |          2 | Japan        | JP         |            | 145935 sq_mi | Shinzo Abe
  6 |          3 | Singapore    | SG         |        697 |              | not specified
</pre><p>

<span class="original">
     The following example shows concatenation of multiple text() nodes,
     usage of the column name as XPath filter, and the treatment of whitespace,
     XML comments and processing instructions:
</span>
以下の例では、複数のtext()ノードの結合、列名のXPathフィルターとしての使用、空白文字、XMLコメント、処理命令の取扱いを示します。

  </p><pre class="screen">
CREATE TABLE xmlelements AS SELECT
xml $$
  &lt;root&gt;
   &lt;element&gt;  Hello&lt;!-- xyxxz --&gt;2a2&lt;?aaaaa?&gt; &lt;!--x--&gt;  bbb&lt;x&gt;xxx&lt;/x&gt;CC  &lt;/element&gt;
  &lt;/root&gt;
$$ AS data;

SELECT xmltable.*
  FROM xmlelements, XMLTABLE('/root' PASSING data COLUMNS element text);
       element        
----------------------
   Hello2a2   bbbCC  
</pre><p>
    </p><p>
<span class="original">
     The following example illustrates how
     the &lt;literal&gt;XMLNAMESPACES&lt;/literal&gt; clause can be used to specify
     a list of namespaces
     used in the XML document as well as in the XPath expressions:
</span>
以下の例では、<code class="literal">XMLNAMESPACES</code>句を使ってXMLドキュメントやXPath式で使われる追加の名前空間のリストを指定する方法を示します。

  </p><pre class="screen">
WITH xmldata(data) AS (VALUES ('
&lt;example xmlns="http://example.com/myns" xmlns:B="http://example.com/b"&gt;
 &lt;item foo="1" B:bar="2"/&gt;
 &lt;item foo="3" B:bar="4"/&gt;
 &lt;item foo="4" B:bar="5"/&gt;
&lt;/example&gt;'::xml)
)
SELECT xmltable.*
  FROM XMLTABLE(XMLNAMESPACES('http://example.com/myns' AS x,
                              'http://example.com/b' AS "B"),
             '/x:example/x:item'
                PASSING (SELECT data FROM xmldata)
                COLUMNS foo int PATH '@foo',
                  bar int PATH '@B:bar');
 foo | bar
-----+-----
   1 |   2
   3 |   4
   4 |   5
(3 rows)
</pre><p>
    </p></div></div><div class="sect2" id="FUNCTIONS-XML-MAPPING"><div class="titlepage"><div><div><h3 class="title">9.14.4. XMLにテーブルをマップ</h3></div></div></div><span class="original">
   &lt;title&gt;Mapping Tables to XML&lt;/title&gt;
</span><a id="id-1.5.8.19.6.2" class="indexterm"></a><p>
<span class="original">
    The following functions map the contents of relational tables to
    XML values.  They can be thought of as XML export functionality:
</span>
以下の関数はリレーショナルテーブルの内容をXML値にマップします。
これらはXMLエクスポート機能と考えることができます。
</p><pre class="synopsis">
table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)
cursor_to_xml(cursor refcursor, count int, nulls boolean,
              tableforest boolean, targetns text)
</pre><p>
<span class="original">
    The return type of each function is &lt;type&gt;xml&lt;/type&gt;.
</span>
それぞれの関数の戻り値型は<code class="type">xml</code>です。
   </p><p>
<span class="original">
    &lt;function&gt;table_to_xml&lt;/function&gt; maps the content of the named
    table, passed as parameter &lt;parameter&gt;tbl&lt;/parameter&gt;.  The
    &lt;type&gt;regclass&lt;/type&gt; type accepts strings identifying tables using the
    usual notation, including optional schema qualifications and
    double quotes.  &lt;function&gt;query_to_xml&lt;/function&gt; executes the
    query whose text is passed as parameter
    &lt;parameter&gt;query&lt;/parameter&gt; and maps the result set.
    &lt;function&gt;cursor_to_xml&lt;/function&gt; fetches the indicated number of
    rows from the cursor specified by the parameter
    &lt;parameter&gt;cursor&lt;/parameter&gt;.  This variant is recommended if
    large tables have to be mapped, because the result value is built
    up in memory by each function.
</span>
<code class="function">table_to_xml</code>は、パラメータ<em class="parameter"><code>tbl</code></em>として渡された名前付きのテーブルの内容をマップします。
<code class="type">regclass</code>型はオプションのスキーマ修飾と二重引用符を含む、通常の表記法を使用しテーブルを特定する文字列を受け付けます。
<code class="function">query_to_xml</code>は、パラメータ<em class="parameter"><code>query</code></em>としてテキストが渡された問い合わせを実行し、結果セットをマップします。
<code class="function">cursor_to_xml</code>は、パラメータ<em class="parameter"><code>cursor</code></em>で指定されたカーソルから提示された行数を取得します。
それぞれの関数により結果値がメモリーに構築されるため、この異形は巨大なテーブルをマップする必要がある場合推奨されます。
   </p><p>
<span class="original">
    If &lt;parameter&gt;tableforest&lt;/parameter&gt; is false, then the resulting
    XML document looks like this:
</span>
<em class="parameter"><code>tableforest</code></em>が偽であれば、結果のXML文書は以下のようになります。
</p><pre class="screen">
&lt;tablename&gt;
  &lt;row&gt;
    &lt;columnname1&gt;data&lt;/columnname1&gt;
    &lt;columnname2&gt;data&lt;/columnname2&gt;
  &lt;/row&gt;

  &lt;row&gt;
    ...
  &lt;/row&gt;

  ...
&lt;/tablename&gt;
</pre><p>

<span class="original">
    If &lt;parameter&gt;tableforest&lt;/parameter&gt; is true, the result is an
    XML content fragment that looks like this:
</span>
<em class="parameter"><code>tableforest</code></em>が真であれば、結果は以下のようなXML文書の断片です。
</p><pre class="screen">
&lt;tablename&gt;
  &lt;columnname1&gt;data&lt;/columnname1&gt;
  &lt;columnname2&gt;data&lt;/columnname2&gt;
&lt;/tablename&gt;

&lt;tablename&gt;
  ...
&lt;/tablename&gt;

...
</pre><p>

<span class="original">
    If no table name is available, that is, when mapping a query or a
    cursor, the string &lt;literal&gt;table&lt;/literal&gt; is used in the first
    format, &lt;literal&gt;row&lt;/literal&gt; in the second format.
</span>
テーブル名が利用できないとき、つまり、問い合わせ、またはカーソルをマップする時は、最初の書式では文字列<code class="literal">table</code>が使用され、２番目の書式では<code class="literal">row</code>が使用されます。
   </p><p>
<span class="original">
    The choice between these formats is up to the user.  The first
    format is a proper XML document, which will be important in many
    applications.  The second format tends to be more useful in the
    &lt;function&gt;cursor_to_xml&lt;/function&gt; function if the result values are to be
    reassembled into one document later on.  The functions for
    producing XML content discussed above, in particular
    &lt;function&gt;xmlelement&lt;/function&gt;, can be used to alter the results
    to taste.
</span>
これらどの書式を選択するのかはユーザ次第です。
最初の書式は適切なXML文書で、多くのアプリケーションにおいて重要です。
第２の書式は、後に結果値が１つの文書に再び組み立てられる場合、<code class="function">cursor_to_xml</code>関数内でより有用になる傾向があります。
上記で説明したXML内容を作成する関数、特に<code class="function">xmlelement</code>は結果を好みにかえるために使用することができます。
   </p><p>
<span class="original">
    The data values are mapped in the same way as described for the
    function &lt;function&gt;xmlelement&lt;/function&gt; above.
</span>
データの値は上記関数<code class="function">xmlelement</code>で説明したのと同じ方法でマップされます。
   </p><p>
<span class="original">
    The parameter &lt;parameter&gt;nulls&lt;/parameter&gt; determines whether null
    values should be included in the output.  If true, null values in
    columns are represented as:
</span>
パラメータ<em class="parameter"><code>nulls</code></em>は出力にNULL値が含まれる必要があるかを決定します。
もし真であれば列内のNULL値は以下のように表現されます。
</p><pre class="screen">
&lt;columnname xsi:nil="true"/&gt;
</pre><p>
<span class="original">
    where &lt;literal&gt;xsi&lt;/literal&gt; is the XML namespace prefix for XML
    Schema Instance.  An appropriate namespace declaration will be
    added to the result value.  If false, columns containing null
    values are simply omitted from the output.
</span>
ここで<code class="literal">xsi</code>はXMLスキーマインスタンスに対するXML名前空間接頭辞です。
適切な名前空間宣言が結果値に追加されます。
もし偽の場合、NULL値を含む列は単に出力から削除されます。
   </p><p>
<span class="original">
    The parameter &lt;parameter&gt;targetns&lt;/parameter&gt; specifies the
    desired XML namespace of the result.  If no particular namespace
    is wanted, an empty string should be passed.
</span>
パラメータ<em class="parameter"><code>targetns</code></em>は結果の希望するXML名前空間を指定します。
特定の名前空間が必要なければ、空文字列を渡す必要があります。
   </p><p>
<span class="original">
    The following functions return XML Schema documents describing the
    mappings performed by the corresponding functions above:
</span>
以下の関数は、対応する上記関数により行われたマッピングを記述するXMLスキーマ文書を返します。
</p><pre class="synopsis">
table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean, targetns text)
</pre><p>
<span class="original">
    It is essential that the same parameters are passed in order to
    obtain matching XML data mappings and XML Schema documents.
</span>
    一致するXMLデータマッピングとXMLスキーマ文書を取得するため、同じパラメータが渡されることが不可欠です。
   </p><p>
<span class="original">
    The following functions produce XML data mappings and the
    corresponding XML Schema in one document (or forest), linked
    together.  They can be useful where self-contained and
    self-describing results are wanted:
</span>
以下の関数は、XMLデータマッピングとそれに対応するXMLスキーマがお互いにリンクされた、１つの文書（またはフォレスト）を作成します。
これらは自己完結した、自己記述的な結果を希望する場合に便利です。
</p><pre class="synopsis">
table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
</pre><p>
   </p><p>
<span class="original">
    In addition, the following functions are available to produce
    analogous mappings of entire schemas or the entire current
    database:
</span>
さらに、以下の関数がスキーマ全体、または現在のデータベース全体の類似マッピングを作成するため利用できます。
</p><pre class="synopsis">
schema_to_xml(schema name, nulls boolean, tableforest boolean, targetns text)
schema_to_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)
schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)

database_to_xml(nulls boolean, tableforest boolean, targetns text)
database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)
database_to_xml_and_xmlschema(nulls boolean, tableforest boolean, targetns text)
</pre><p>

<span class="original">
    Note that these potentially produce a lot of data, which needs to
    be built up in memory.  When requesting content mappings of large
    schemas or databases, it might be worthwhile to consider mapping the
    tables separately instead, possibly even through a cursor.
</span>
これらはメモリー内に作成される必要がある、多くのデータを生成する潜在的可能性があることに注意してください。
巨大なスキーマ、またはデータベースの内容マッピングを要求する際は、その代わりにテーブルを別々にマップすること、さらにはカーソル経由とすることさえ、検討することは無駄ではありません。
   </p><p>
<span class="original">
    The result of a schema content mapping looks like this:
</span>
スキーマ内容マッピングの結果は以下のようになります。

</p><pre class="screen">
&lt;schemaname&gt;

table1-mapping

table2-mapping

...

&lt;/schemaname&gt;</pre><p>

<span class="original">
    where the format of a table mapping depends on the
    &lt;parameter&gt;tableforest&lt;/parameter&gt; parameter as explained above.
</span>
ここで、テーブルマッピング書式は上で説明したとおり<em class="parameter"><code>tableforest</code></em>パラメータに依存します。
   </p><p>
<span class="original">
    The result of a database content mapping looks like this:
</span>
データベース内容マッピング書式は以下のようになります。

</p><pre class="screen">
&lt;dbname&gt;

&lt;schema1name&gt;
  ...
&lt;/schema1name&gt;

&lt;schema2name&gt;
  ...
&lt;/schema2name&gt;

...

&lt;/dbname&gt;</pre><p>

<span class="original">
    where the schema mapping is as above.
</span>
ここで、スキーママッピングは上記のとおりです。
   </p><p>
<span class="original">
    As an example of using the output produced by these functions,
    &lt;xref linkend="xslt-xml-html"/&gt; shows an XSLT stylesheet that
    converts the output of
    &lt;function&gt;table_to_xml_and_xmlschema&lt;/function&gt; to an HTML
    document containing a tabular rendition of the table data.  In a
    similar manner, the results from these functions can be
    converted into other XML-based formats.
</span>
これらの関数で作成された出力を使用する１つの例として、<a class="xref" href="functions-xml.html#XSLT-XML-HTML" title="図9.1 SQL/XML出力をHTMLに変換するXSLTスタイルシート">図 9.1</a>は、テーブルデータの表形式への翻訳を含む<code class="function">table_to_xml_and_xmlschema</code>からHTML文書への出力の変換をおこなうXSLTスタイルシートを示します。
同じようにして、これらの関数の結果は他のXML基準書式に変換されます。
   </p><div class="figure" id="XSLT-XML-HTML"><p class="title"><strong>図9.1 SQL/XML出力をHTMLに変換するXSLTスタイルシート</strong></p><div class="figure-contents"><span class="original">
    &lt;title&gt;XSLT Stylesheet for Converting SQL/XML Output to HTML&lt;/title&gt;
</span><pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
&gt;

  &lt;xsl:output method="xml"
      doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
      doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
      indent="yes"/&gt;

  &lt;xsl:template match="/*"&gt;
    &lt;xsl:variable name="schema" select="//xsd:schema"/&gt;
    &lt;xsl:variable name="tabletypename"
                  select="$schema/xsd:element[@name=name(current())]/@type"/&gt;
    &lt;xsl:variable name="rowtypename"
                  select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name='row']/@type"/&gt;

    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;&lt;xsl:value-of select="name(current())"/&gt;&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;table&gt;
          &lt;tr&gt;
            &lt;xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name"&gt;
              &lt;th&gt;&lt;xsl:value-of select="."/&gt;&lt;/th&gt;
            &lt;/xsl:for-each&gt;
          &lt;/tr&gt;

          &lt;xsl:for-each select="row"&gt;
            &lt;tr&gt;
              &lt;xsl:for-each select="*"&gt;
                &lt;td&gt;&lt;xsl:value-of select="."/&gt;&lt;/td&gt;
              &lt;/xsl:for-each&gt;
            &lt;/tr&gt;
          &lt;/xsl:for-each&gt;
        &lt;/table&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div></div><br class="figure-break" /></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-textsearch.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-json.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">9.13. テキスト検索関数と演算子 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 9.15. JSON関数と演算子</td></tr></table></div></body></html>