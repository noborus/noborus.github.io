<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>13.3. 明示的ロック</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="transaction-iso.html" title="13.2. トランザクションの分離" /><link rel="next" href="applevel-consistency.html" title="13.4. アプリケーションレベルでのデータの一貫性チェック" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 11.3文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="mvcc.html" title="第13章 同時実行制御">第13章 同時実行制御</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 11.3 &#10;                      explicit-locking.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="transaction-iso.html" title="13.2. トランザクションの分離">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="mvcc.html" title="第13章 同時実行制御">上へ</a></td><td width="60%" align="center">13.3. 明示的ロック</td><td width="20%" align="right"> <a accesskey="n" href="applevel-consistency.html" title="13.4. アプリケーションレベルでのデータの一貫性チェック">次へ</a></td></tr></table><hr /></div><div class="sect1" id="EXPLICIT-LOCKING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">13.3. 明示的ロック</h2></div></div></div><span class="original">
   &lt;title&gt;Explicit Locking&lt;/title&gt;
</span><a id="id-1.5.12.6.2" class="indexterm"></a><p>
<span class="original">
    &lt;productname&gt;PostgreSQL&lt;/productname&gt; provides various lock modes
    to control concurrent access to data in tables.  These modes can
    be used for application-controlled locking in situations where
    &lt;acronym&gt;MVCC&lt;/acronym&gt; does not give the desired behavior.  Also,
    most &lt;productname&gt;PostgreSQL&lt;/productname&gt; commands automatically
    acquire locks of appropriate modes to ensure that referenced
    tables are not dropped or modified in incompatible ways while the
    command executes.  (For example, &lt;command&gt;TRUNCATE&lt;/command&gt; cannot safely be
    executed concurrently with other operations on the same table, so it
    obtains an exclusive lock on the table to enforce that.)
</span>
<span class="productname">PostgreSQL</span>は、テーブル内のデータに対する同時アクセスを制御するために様々な種類のロックモードを備えています。
これらのモードは、<acronym class="acronym">MVCC</acronym>では必要な動作を得られない場合、アプリケーション制御のロックに使用することができます。
また、ほとんどの<span class="productname">PostgreSQL</span>コマンドでは、参照されるテーブルがそのコマンドの実行中に別の方法で削除もしくは変更されていないことを確実にするために、適切なモードのロックを自動的に獲得します。
（例えば、<code class="command">TRUNCATE</code>コマンドは、同じテーブルに対する他の操作と同時に安全に実行することはできないので、それを確実に実行するため、そのテーブルの排他ロックを獲得します。）
   </p><p>
<span class="original">
    To examine a list of the currently outstanding locks in a database
    server, use the
    &lt;link linkend="view-pg-locks"&gt;&lt;structname&gt;pg_locks&lt;/structname&gt;&lt;/link&gt;
    system view. For more information on monitoring the status of the lock
    manager subsystem, refer to &lt;xref linkend="monitoring"/&gt;.
</span>
現在のデータベースサーバに残っているロックの一覧を確認するには、<a class="link" href="view-pg-locks.html" title="52.73. pg_locks"><code class="structname">pg_locks</code></a>システムビューを使用してください。
ロック管理サブシステムの状況監視についての詳細は<a class="xref" href="monitoring.html" title="第28章 データベース活動状況の監視">第28章</a>を参照してください。
   </p><div class="sect2" id="LOCKING-TABLES"><div class="titlepage"><div><div><h3 class="title">13.3.1. テーブルレベルロック</h3></div></div></div><span class="original">
   &lt;title&gt;Table-level Locks&lt;/title&gt;
</span><a id="id-1.5.12.6.5.2" class="indexterm"></a><p>
<span class="original">
    The list below shows the available lock modes and the contexts in
    which they are used automatically by
    &lt;productname&gt;PostgreSQL&lt;/productname&gt;.  You can also acquire any
    of these locks explicitly with the command &lt;xref
    linkend="sql-lock"/&gt;.
    Remember that all of these lock modes are table-level locks,
    even if the name contains the word
    &lt;quote&gt;row&lt;/quote&gt;; the names of the lock modes are historical.
    To some extent the names reflect the typical usage of each lock
    mode &amp;mdash; but the semantics are all the same.  The only real difference
    between one lock mode and another is the set of lock modes with
    which each conflicts (see &lt;xref linkend="table-lock-compatibility"/&gt;).
    Two transactions cannot hold locks of conflicting
    modes on the same table at the same time.  (However, a transaction
    never conflicts with itself.  For example, it might acquire
    &lt;literal&gt;ACCESS EXCLUSIVE&lt;/literal&gt; lock and later acquire
    &lt;literal&gt;ACCESS SHARE&lt;/literal&gt; lock on the same table.)  Non-conflicting
    lock modes can be held concurrently by many transactions.  Notice in
    particular that some lock modes are self-conflicting (for example,
    an &lt;literal&gt;ACCESS EXCLUSIVE&lt;/literal&gt; lock cannot be held by more than one
    transaction at a time) while others are not self-conflicting (for example,
    an &lt;literal&gt;ACCESS SHARE&lt;/literal&gt; lock can be held by multiple transactions).
</span>
以下のリストに、使用可能なロックモードとそれらが<span class="productname">PostgreSQL</span>で自動的に使用される文脈を示します。
また、<a class="xref" href="sql-lock.html" title="LOCK"><span class="refentrytitle">LOCK</span></a>コマンドを使用して、こうしたロックを明示的に獲得することもできます。
これらのロックモードは、たとえその名前に<span class="quote">「<span class="quote">row（行）</span>」</span>という言葉が付いていても、全てテーブルレベルのロックであることに注意してください。
ロックモードの名前は歴史的なものです。
これらの名前は、各ロックモードの代表的な使用方法をある程度表しています。
しかし、意味的には全て同じです。
ロックモード間における唯一の実質的な差異は、どのモードがどのモードと競合するかというロックモードの組み合わせです(<a class="xref" href="explicit-locking.html#TABLE-LOCK-COMPATIBILITY" title="表13.2 ロックモードの競合">表 13.2</a>を参照してください)。
2つのトランザクションで、競合するモードのロックを同時に同一テーブル上に保持することはできません
（しかし、トランザクションは自分自身とは決して競合しません。
例えば、<code class="literal">ACCESS EXCLUSIVE</code>ロックを獲得し、その後同じテーブルに<code class="literal">ACCESS SHARE</code>ロックを獲得できる可能性があります）。
競合しないロックモードは、多くのトランザクションで同時に保持することが可能です。
特に、ロックモードには、自己競合するもの（例えば、<code class="literal">ACCESS EXCLUSIVE</code>は同時に複数のトランザクションで保持することは不可能）と、自己競合しないもの（例えば、<code class="literal">ACCESS SHARE</code>は複数のトランザクションで保持可能）があることに注意してください。
   </p><div class="variablelist"><p class="title"><strong>テーブルレベルロックモード</strong></p><span class="original">
      &lt;title&gt;Table-level Lock Modes&lt;/title&gt;
</span><dl class="variablelist"><dt><span class="term">
        <code class="literal">ACCESS SHARE</code>
       </span></dt><dd><p>
<span class="original">
         Conflicts with the &lt;literal&gt;ACCESS EXCLUSIVE&lt;/literal&gt; lock
         mode only.
</span>
         <code class="literal">ACCESS EXCLUSIVE</code>ロックモードとのみ競合します。
        </p><p>
<span class="original">
         The &lt;command&gt;SELECT&lt;/command&gt; command acquires a lock of this mode on
         referenced tables.  In general, any query that only &lt;emphasis&gt;reads&lt;/emphasis&gt; a table
         and does not modify it will acquire this lock mode.
</span>
<code class="command">SELECT</code>コマンドにより、参照されるテーブルに対してこのモードのロックが獲得されます。
通常、テーブルの<span class="emphasis"><em>読み取り</em></span>のみで変更を行わない問い合わせであれば全て、このロックモードを獲得します。
        </p></dd><dt><span class="term">
        <code class="literal">ROW SHARE</code>
       </span></dt><dd><p>
<span class="original">
         Conflicts with the &lt;literal&gt;EXCLUSIVE&lt;/literal&gt; and
         &lt;literal&gt;ACCESS EXCLUSIVE&lt;/literal&gt; lock modes.
</span>
<code class="literal">EXCLUSIVE</code>および<code class="literal">ACCESS EXCLUSIVE</code>ロックモードと競合します。
        </p><p>
<span class="original">
         The &lt;command&gt;SELECT FOR UPDATE&lt;/command&gt; and
         &lt;command&gt;SELECT FOR SHARE&lt;/command&gt; commands acquire a
         lock of this mode on the target table(s) (in addition to
         &lt;literal&gt;ACCESS SHARE&lt;/literal&gt; locks on any other tables
         that are referenced but not selected
         &lt;option&gt;FOR UPDATE/FOR SHARE&lt;/option&gt;).
</span>
<code class="command">SELECT FOR UPDATE</code>および<code class="command">SELECT FOR SHARE</code>コマンドは、（参照はされているが、<code class="option">FOR UPDATE/FOR SHARE</code>として選択はされていない他のテーブルに対する<code class="literal">ACCESS SHARE</code>ロックに加えて）対象となるテーブル上にこのモードのロックを獲得します。
        </p></dd><dt><span class="term">
        <code class="literal">ROW EXCLUSIVE</code>
       </span></dt><dd><p>
<span class="original">
         Conflicts with the &lt;literal&gt;SHARE&lt;/literal&gt;, &lt;literal&gt;SHARE ROW
         EXCLUSIVE&lt;/literal&gt;, &lt;literal&gt;EXCLUSIVE&lt;/literal&gt;, and
         &lt;literal&gt;ACCESS EXCLUSIVE&lt;/literal&gt; lock modes.
</span>
<code class="literal">SHARE</code>、<code class="literal">SHARE ROW EXCLUSIVE</code>、<code class="literal">EXCLUSIVE</code>、および<code class="literal">ACCESS EXCLUSIVE</code>ロックモードと競合します。
        </p><p>
<span class="original">
         The commands &lt;command&gt;UPDATE&lt;/command&gt;,
         &lt;command&gt;DELETE&lt;/command&gt;, and &lt;command&gt;INSERT&lt;/command&gt;
         acquire this lock mode on the target table (in addition to
         &lt;literal&gt;ACCESS SHARE&lt;/literal&gt; locks on any other referenced
         tables).  In general, this lock mode will be acquired by any
         command that &lt;emphasis&gt;modifies data&lt;/emphasis&gt; in a table.
</span>
<code class="command">UPDATE</code>、<code class="command">DELETE</code>、および<code class="command">INSERT</code>コマンドは、（参照される他の全てのテーブルに対する<code class="literal">ACCESS SHARE</code>ロックに加えて）対象となるテーブル上にこのモードのロックを獲得します。
通常、このロックモードは、テーブルの<span class="emphasis"><em>データを変更する</em></span>問い合わせにより獲得されます。
        </p></dd><dt><span class="term">
        <code class="literal">SHARE UPDATE EXCLUSIVE</code>
       </span></dt><dd><p>
<span class="original">
         Conflicts with the &lt;literal&gt;SHARE UPDATE EXCLUSIVE&lt;/literal&gt;,
         &lt;literal&gt;SHARE&lt;/literal&gt;, &lt;literal&gt;SHARE ROW
         EXCLUSIVE&lt;/literal&gt;, &lt;literal&gt;EXCLUSIVE&lt;/literal&gt;, and
         &lt;literal&gt;ACCESS EXCLUSIVE&lt;/literal&gt; lock modes.
         This mode protects a table against
         concurrent schema changes and &lt;command&gt;VACUUM&lt;/command&gt; runs.
</span>
<code class="literal">SHARE UPDATE EXCLUSIVE</code>、<code class="literal">SHARE</code>、<code class="literal">SHARE ROW EXCLUSIVE</code>、<code class="literal">EXCLUSIVE</code>、および<code class="literal">ACCESS EXCLUSIVE</code>ロックモードと競合します。
このモードにより、同時実行されるスキーマの変更および<code class="command">VACUUM</code>コマンドの実行から、テーブルを保護します。
        </p><p>
<span class="original">
         Acquired by &lt;command&gt;VACUUM&lt;/command&gt; (without &lt;option&gt;FULL&lt;/option&gt;),
         &lt;command&gt;ANALYZE&lt;/command&gt;, &lt;command&gt;CREATE INDEX CONCURRENTLY&lt;/command&gt;,
         &lt;command&gt;CREATE STATISTICS&lt;/command&gt; and
         &lt;command&gt;ALTER TABLE VALIDATE&lt;/command&gt; and other
         &lt;command&gt;ALTER TABLE&lt;/command&gt; variants (for full details see
         &lt;xref linkend="sql-altertable"/&gt;).
</span>
（<code class="option">FULL</code>なしの）<code class="command">VACUUM</code>、<code class="command">ANALYZE</code>、<code class="command">CREATE INDEX CONCURRENTLY</code>、<code class="command">CREATE STATISTICS</code>、<code class="command">ALTER TABLE VALIDATE</code>、および、その他の<code class="command">ALTER TABLE</code>の亜種(詳細は<a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>を参照してください)によって獲得されます。
        </p></dd><dt><span class="term">
        <code class="literal">SHARE</code>
       </span></dt><dd><p>
<span class="original">
         Conflicts with the &lt;literal&gt;ROW EXCLUSIVE&lt;/literal&gt;,
         &lt;literal&gt;SHARE UPDATE EXCLUSIVE&lt;/literal&gt;, &lt;literal&gt;SHARE ROW
         EXCLUSIVE&lt;/literal&gt;, &lt;literal&gt;EXCLUSIVE&lt;/literal&gt;, and
         &lt;literal&gt;ACCESS EXCLUSIVE&lt;/literal&gt; lock modes.
         This mode protects a table against concurrent data changes.
</span>
<code class="literal">ROW EXCLUSIVE</code>、<code class="literal">SHARE UPDATE EXCLUSIVE</code>、<code class="literal">SHARE ROW EXCLUSIVE</code>、<code class="literal">EXCLUSIVE</code>、および<code class="literal">ACCESS EXCLUSIVE</code>ロックモードと競合します。
このモードは、同時実行されるデータ変更からテーブルを保護します。
        </p><p>
<span class="original">
         Acquired by &lt;command&gt;CREATE INDEX&lt;/command&gt;
         (without &lt;option&gt;CONCURRENTLY&lt;/option&gt;).
</span>
（<code class="option">CONCURRENTLY</code>なしの）<code class="command">CREATE INDEX</code>によって獲得されます。
        </p></dd><dt><span class="term">
        <code class="literal">SHARE ROW EXCLUSIVE</code>
       </span></dt><dd><p>
<span class="original">
         Conflicts with the &lt;literal&gt;ROW EXCLUSIVE&lt;/literal&gt;,
         &lt;literal&gt;SHARE UPDATE EXCLUSIVE&lt;/literal&gt;,
         &lt;literal&gt;SHARE&lt;/literal&gt;, &lt;literal&gt;SHARE ROW
         EXCLUSIVE&lt;/literal&gt;, &lt;literal&gt;EXCLUSIVE&lt;/literal&gt;, and
         &lt;literal&gt;ACCESS EXCLUSIVE&lt;/literal&gt; lock modes.
         This mode protects a table against concurrent data changes, and
         is self-exclusive so that only one session can hold it at a time.
</span>
<code class="literal">ROW EXCLUSIVE</code>、<code class="literal">SHARE UPDATE EXCLUSIVE</code>、
<code class="literal">SHARE</code>、<code class="literal">SHARE ROW EXCLUSIVE</code>、<code class="literal">EXCLUSIVE</code>、および<code class="literal">ACCESS EXCLUSIVE</code>ロックモードと競合します。
このモードは、1つのセッションだけが一度にそれを保持することができるよう、自己排他的に同時のデータ変更からテーブルを保護します。
        </p><p>
<span class="original">
         Acquired by &lt;command&gt;CREATE COLLATION&lt;/command&gt;,
         &lt;command&gt;CREATE TRIGGER&lt;/command&gt;, and many forms of
         &lt;command&gt;ALTER TABLE&lt;/command&gt; (see &lt;xref linkend="sql-altertable"/&gt;).
</span>
<code class="command">CREATE COLLATION</code>、<code class="command">CREATE TRIGGER</code>および<code class="command">ALTER TABLE</code>（<a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>参照）の多くの形式により獲得されます。
        </p></dd><dt><span class="term">
        <code class="literal">EXCLUSIVE</code>
       </span></dt><dd><p>
<span class="original">
         Conflicts with the &lt;literal&gt;ROW SHARE&lt;/literal&gt;, &lt;literal&gt;ROW
         EXCLUSIVE&lt;/literal&gt;, &lt;literal&gt;SHARE UPDATE
         EXCLUSIVE&lt;/literal&gt;, &lt;literal&gt;SHARE&lt;/literal&gt;, &lt;literal&gt;SHARE
         ROW EXCLUSIVE&lt;/literal&gt;, &lt;literal&gt;EXCLUSIVE&lt;/literal&gt;, and
         &lt;literal&gt;ACCESS EXCLUSIVE&lt;/literal&gt; lock modes.
         This mode allows only concurrent &lt;literal&gt;ACCESS SHARE&lt;/literal&gt; locks,
         i.e., only reads from the table can proceed in parallel with a
         transaction holding this lock mode.
</span>
<code class="literal">ROW SHARE</code>、<code class="literal">ROW EXCLUSIVE</code>、
<code class="literal">SHARE UPDATE EXCLUSIVE</code>、<code class="literal">SHARE</code>、
<code class="literal">SHARE ROW EXCLUSIVE</code>、<code class="literal">EXCLUSIVE</code>、および<code class="literal">ACCESS EXCLUSIVE</code>ロックモードと競合します。
このモードは、同時実行される<code class="literal">ACCESS SHARE</code>のみを許可します。
つまり、このロックモードを保持するトランザクションと並行して実行できる処理は、テーブルの読み取りだけです。
        </p><p>
<span class="original">
         Acquired by &lt;command&gt;REFRESH MATERIALIZED VIEW CONCURRENTLY&lt;/command&gt;.
</span>
<code class="command">REFRESH MATERIALIZED VIEW CONCURRENTLY</code>により獲得されます。
        </p></dd><dt><span class="term">
        <code class="literal">ACCESS EXCLUSIVE</code>
       </span></dt><dd><p>
<span class="original">
         Conflicts with locks of all modes (&lt;literal&gt;ACCESS
         SHARE&lt;/literal&gt;, &lt;literal&gt;ROW SHARE&lt;/literal&gt;, &lt;literal&gt;ROW
         EXCLUSIVE&lt;/literal&gt;, &lt;literal&gt;SHARE UPDATE
         EXCLUSIVE&lt;/literal&gt;, &lt;literal&gt;SHARE&lt;/literal&gt;, &lt;literal&gt;SHARE
         ROW EXCLUSIVE&lt;/literal&gt;, &lt;literal&gt;EXCLUSIVE&lt;/literal&gt;, and
         &lt;literal&gt;ACCESS EXCLUSIVE&lt;/literal&gt;).
         This mode guarantees that the
         holder is the only transaction accessing the table in any way.
</span>
全てのモードのロック（<code class="literal">ACCESS
         SHARE</code>、<code class="literal">ROW SHARE</code>、<code class="literal">ROW
         EXCLUSIVE</code>、<code class="literal">SHARE UPDATE
         EXCLUSIVE</code>、<code class="literal">SHARE</code>、<code class="literal">SHARE
         ROW EXCLUSIVE</code>、<code class="literal">EXCLUSIVE</code>、および
         <code class="literal">ACCESS EXCLUSIVE</code>）と競合します。
このモードにより、その保持者以外にテーブルにアクセスするトランザクションがないことが保証されます。
        </p><p>
<span class="original">
         Acquired by the &lt;command&gt;DROP TABLE&lt;/command&gt;,
         &lt;command&gt;TRUNCATE&lt;/command&gt;, &lt;command&gt;REINDEX&lt;/command&gt;,
         &lt;command&gt;CLUSTER&lt;/command&gt;, &lt;command&gt;VACUUM FULL&lt;/command&gt;,
         and &lt;command&gt;REFRESH MATERIALIZED VIEW&lt;/command&gt; (without
         &lt;option&gt;CONCURRENTLY&lt;/option&gt;)
         commands. Many forms of &lt;command&gt;ALTER TABLE&lt;/command&gt; also acquire
         a lock at this level. This is also the default lock mode for
         &lt;command&gt;LOCK TABLE&lt;/command&gt; statements that do not specify
         a mode explicitly.
</span>
<code class="command">DROP TABLE</code>、<code class="command">TRUNCATE</code>、<code class="command">REINDEX</code>、<code class="command">CLUSTER</code>、<code class="command">VACUUM FULL</code>、（<code class="option">CONCURRENTLY</code>なしの）<code class="command">REFRESH MATERIALIZED VIEW</code>コマンドによって獲得されます。
<code class="command">ALTER TABLE</code>の多くの形式もこのレベルでロックを獲得します。
これはまた、明示的にモードを指定しない<code class="command">LOCK TABLE</code>文のデフォルトのロックモードです。
        </p></dd></dl></div><div class="tip"><h3 class="title">ヒント</h3><p>
<span class="original">
       Only an &lt;literal&gt;ACCESS EXCLUSIVE&lt;/literal&gt; lock blocks a
       &lt;command&gt;SELECT&lt;/command&gt; (without &lt;option&gt;FOR UPDATE/SHARE&lt;/option&gt;)
       statement.
</span>
<code class="literal">ACCESS EXCLUSIVE</code>ロックのみが、<code class="command">SELECT</code>（<code class="option">FOR UPDATE/SHARE</code>なし）文をブロックします。
      </p></div><p>
<span class="original">
    Once acquired, a lock is normally held till end of transaction.  But if a
    lock is acquired after establishing a savepoint, the lock is released
    immediately if the savepoint is rolled back to.  This is consistent with
    the principle that &lt;command&gt;ROLLBACK&lt;/command&gt; cancels all effects of the
    commands since the savepoint.  The same holds for locks acquired within a
    &lt;application&gt;PL/pgSQL&lt;/application&gt; exception block: an error escape from the block
    releases locks acquired within it.
</span>
通常ロックは獲得した後、トランザクションの終わりまで保持されます。
しかし、ロックがセーブポイントの確立後に獲得された場合、セーブポイントがロールバックされると、ロックは即座に解放されます。
これは、<code class="command">ROLLBACK</code>がセーブポイント以降に行われたすべてのコマンドの効果を取消すという原則と整合性が取れています。
<span class="application">PL/pgSQL</span>例外ブロック内で獲得されたロックに対しても同様です。
そのブロックからエラーで抜けた後、獲得されたロックは解放されます。
   </p><div class="table" id="TABLE-LOCK-COMPATIBILITY"><p class="title"><strong>表13.2  ロックモードの競合</strong></p><div class="table-contents"><span class="original">
     &lt;title&gt; Conflicting Lock Modes&lt;/title&gt;
</span><table class="table" summary=" ロックモードの競合" border="1"><colgroup><col /><col class="lockst" /><col /><col /><col /><col /><col /><col /><col class="lockend" /></colgroup><thead><tr><th rowspan="2">要求するロックモード</th><th colspan="8">現在のロックモード</th></tr><tr><th>ACCESS SHARE</th><th>ROW SHARE</th><th>ROW EXCLUSIVE</th><th>SHARE UPDATE EXCLUSIVE</th><th>SHARE</th><th>SHARE ROW EXCLUSIVE</th><th>EXCLUSIVE</th><th>ACCESS EXCLUSIVE</th></tr></thead><tbody><tr><td>ACCESS SHARE</td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center">X</td></tr><tr><td>ROW SHARE</td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td></tr><tr><td>ROW EXCLUSIVE</td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td>SHARE UPDATE EXCLUSIVE</td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td>SHARE</td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td>SHARE ROW EXCLUSIVE</td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td>EXCLUSIVE</td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td>ACCESS EXCLUSIVE</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="LOCKING-ROWS"><div class="titlepage"><div><div><h3 class="title">13.3.2. 行レベルロック</h3></div></div></div><span class="original">
    &lt;title&gt;Row-level Locks&lt;/title&gt;
</span><p>
<span class="original">
     In addition to table-level locks, there are row-level locks, which
     are listed as below with the contexts in which they are used
     automatically by &lt;productname&gt;PostgreSQL&lt;/productname&gt;.  See
     &lt;xref linkend="row-lock-compatibility"/&gt; for a complete table of
     row-level lock conflicts.  Note that a transaction can hold
     conflicting locks on the same row, even in different subtransactions;
     but other than that, two transactions can never hold conflicting locks
     on the same row.  Row-level locks do not affect data querying; they
     block only &lt;emphasis&gt;writers and lockers&lt;/emphasis&gt; to the same row.
</span>
テーブルレベルロックに加えて、行レベルロックがあります。<span class="productname">PostgreSQL</span>が自動的に使う文脈付きで以下に行レベルロックの一覧があります。
行レベルロックの競合の完全な表については<a class="xref" href="explicit-locking.html#ROW-LOCK-COMPATIBILITY" title="表13.3 行レベルロックの競合">表 13.3</a>を参照してください。
トランザクションは異なる副トランザクション内であっても、同じ行に対して競合するロックを保持できることに注意してください。
しかし、それ以外では、二つのトランザクションは同じ行に対して競合するロックを決して保持できません。
行レベルロックは、データの問い合わせには影響を与えません。
行レベルロックは、<span class="emphasis"><em>同じ行に対する書き込みとロック</em></span>だけをブロックします。
    </p><div class="variablelist"><p class="title"><strong>行レベルロックモード</strong></p><span class="original">
      &lt;title&gt;Row-level Lock Modes&lt;/title&gt;
</span><dl class="variablelist"><dt><span class="term">
        <code class="literal">FOR UPDATE</code>
       </span></dt><dd><p>
<span class="original">
         &lt;literal&gt;FOR UPDATE&lt;/literal&gt; causes the rows retrieved by the
         &lt;command&gt;SELECT&lt;/command&gt; statement to be locked as though for
         update.  This prevents them from being locked, modified or deleted by
         other transactions until the current transaction ends.  That is,
         other transactions that attempt &lt;command&gt;UPDATE&lt;/command&gt;,
         &lt;command&gt;DELETE&lt;/command&gt;,
         &lt;command&gt;SELECT FOR UPDATE&lt;/command&gt;,
         &lt;command&gt;SELECT FOR NO KEY UPDATE&lt;/command&gt;,
         &lt;command&gt;SELECT FOR SHARE&lt;/command&gt; or
         &lt;command&gt;SELECT FOR KEY SHARE&lt;/command&gt;
         of these rows will be blocked until the current transaction ends;
         conversely, &lt;command&gt;SELECT FOR UPDATE&lt;/command&gt; will wait for a
         concurrent transaction that has run any of those commands on the
         same row,
         and will then lock and return the updated row (or no row, if the
         row was deleted).  Within a &lt;literal&gt;REPEATABLE READ&lt;/literal&gt; or
         &lt;literal&gt;SERIALIZABLE&lt;/literal&gt; transaction,
         however, an error will be thrown if a row to be locked has changed
         since the transaction started.  For further discussion see
         &lt;xref linkend="applevel-consistency"/&gt;.
</span>
<code class="literal">FOR UPDATE</code>により<code class="command">SELECT</code>文により取り出された行が更新用であるかのようにロックされます。
これにより、それらは現在のトランザクションが終わるまで、他のトランザクションがロック、変更、削除できなくなります。
すなわち、これらの行に対して<code class="command">UPDATE</code>、<code class="command">DELETE</code>、<code class="command">SELECT FOR UPDATE</code>、<code class="command">SELECT FOR NO KEY UPDATE</code>、<code class="command">SELECT FOR SHARE</code>、<code class="command">SELECT FOR KEY SHARE</code>をしようとする他のトランザクションは現在のトランザクションが終わるまでブロックされます。逆に言えば、<code class="command">SELECT FOR UPDATE</code>は同じ行に対して上記のコマンドを実行している同時実行トランザクションを待ち、それから更新された行をロックして返します(行が削除されていれば、行は返しません)。
しかし、<code class="literal">REPEATABLE READ</code>もしくは<code class="literal">SERIALIZABLE</code>トランザクション内では、ロックする行がトランザクションの開始した後に変更された場合にはエラーが返ります。
これ以上の議論は<a class="xref" href="applevel-consistency.html" title="13.4. アプリケーションレベルでのデータの一貫性チェック">13.4</a>を参照してください。
        </p><p>
<span class="original">
         The &lt;literal&gt;FOR UPDATE&lt;/literal&gt; lock mode
         is also acquired by any &lt;command&gt;DELETE&lt;/command&gt; on a row, and also by an
         &lt;command&gt;UPDATE&lt;/command&gt; that modifies the values on certain columns.  Currently,
         the set of columns considered for the &lt;command&gt;UPDATE&lt;/command&gt; case are those that
         have a unique index on them that can be used in a foreign key (so partial
         indexes and expressional indexes are not considered), but this may change
         in the future.
</span>
<code class="literal">FOR UPDATE</code>ロックモードは行に対する<code class="command">DELETE</code>でも、ある列の値を変更する<code class="command">UPDATE</code>でも獲得されます。
現時点では、<code class="command">UPDATE</code>の場合に考慮される列の集合は、外部キーとして使うことのできる一意のインデックス(つまり部分インデックスや式インデックスは考慮されません)があるものですが、これは将来変わるかもしれません。
        </p></dd><dt><span class="term">
        <code class="literal">FOR NO KEY UPDATE</code>
       </span></dt><dd><p>
<span class="original">
         Behaves similarly to &lt;literal&gt;FOR UPDATE&lt;/literal&gt;, except that the lock
         acquired is weaker: this lock will not block
         &lt;literal&gt;SELECT FOR KEY SHARE&lt;/literal&gt; commands that attempt to acquire
         a lock on the same rows. This lock mode is also acquired by any
         &lt;command&gt;UPDATE&lt;/command&gt; that does not acquire a &lt;literal&gt;FOR UPDATE&lt;/literal&gt; lock.
</span>
獲得するロックが弱い以外は<code class="literal">FOR UPDATE</code>と同じように振る舞います。このロックは同じ行のロックを獲得しようとする<code class="literal">SELECT FOR KEY SHARE</code>コマンドをブロックしません。
このロックモードは<code class="literal">FOR UPDATE</code>ロックを獲得しない<code class="command">UPDATE</code>によっても獲得されます。
        </p></dd><dt><span class="term">
        <code class="literal">FOR SHARE</code>
       </span></dt><dd><p>
<span class="original">
         Behaves similarly to &lt;literal&gt;FOR NO KEY UPDATE&lt;/literal&gt;, except that it
         acquires a shared lock rather than exclusive lock on each retrieved
         row.  A shared lock blocks other transactions from performing
         &lt;command&gt;UPDATE&lt;/command&gt;, &lt;command&gt;DELETE&lt;/command&gt;,
         &lt;command&gt;SELECT FOR UPDATE&lt;/command&gt; or
         &lt;command&gt;SELECT FOR NO KEY UPDATE&lt;/command&gt; on these rows, but it does not
         prevent them from performing &lt;command&gt;SELECT FOR SHARE&lt;/command&gt; or
         &lt;command&gt;SELECT FOR KEY SHARE&lt;/command&gt;.
</span>
取り出された各行に対して排他ロックではなく共有ロックを獲得する以外は、<code class="literal">FOR NO KEY UPDATE</code>と同じように振る舞います。
共有ロックは、他のトランザクションがこれらの行に対して<code class="command">UPDATE</code>、<code class="command">DELETE</code>、<code class="command">SELECT FOR UPDATE</code>、<code class="command">SELECT FOR NO KEY UPDATE</code>を実行するのをブロックしますが、<code class="command">SELECT FOR SHARE</code>や<code class="command">SELECT FOR KEY SHARE</code>を実行するのを阻害しません。
        </p></dd><dt><span class="term">
        <code class="literal">FOR KEY SHARE</code>
       </span></dt><dd><p>
<span class="original">
         Behaves similarly to &lt;literal&gt;FOR SHARE&lt;/literal&gt;, except that the
         lock is weaker: &lt;literal&gt;SELECT FOR UPDATE&lt;/literal&gt; is blocked, but not
         &lt;literal&gt;SELECT FOR NO KEY UPDATE&lt;/literal&gt;.  A key-shared lock blocks
         other transactions from performing &lt;command&gt;DELETE&lt;/command&gt; or
         any &lt;command&gt;UPDATE&lt;/command&gt; that changes the key values, but not
         other &lt;command&gt;UPDATE&lt;/command&gt;, and neither does it prevent
         &lt;command&gt;SELECT FOR NO KEY UPDATE&lt;/command&gt;, &lt;command&gt;SELECT FOR SHARE&lt;/command&gt;,
         or &lt;command&gt;SELECT FOR KEY SHARE&lt;/command&gt;.
</span>
獲得するロックが弱い以外は<code class="literal">FOR SHARE</code>と同じように振る舞います。<code class="literal">SELECT FOR UPDATE</code>はブロックされますが、<code class="literal">SELECT FOR NO KEY UPDATE</code>はブロックされません。
キー共有ロックは、他のトランザクションが<code class="command">DELETE</code>やキー値を変更する<code class="command">UPDATE</code>を実行するのをブロックしますが、それ以外の<code class="command">UPDATE</code>や、<code class="command">SELECT FOR NO KEY UPDATE</code>、<code class="command">SELECT FOR SHARE</code>、<code class="command">SELECT FOR KEY SHARE</code>を阻害しません。
        </p></dd></dl></div><p>
<span class="original">
     &lt;productname&gt;PostgreSQL&lt;/productname&gt; doesn't remember any
     information about modified rows in memory, so there is no limit on
     the number of rows locked at one time.  However, locking a row
     might cause a disk write, e.g., &lt;command&gt;SELECT FOR
     UPDATE&lt;/command&gt; modifies selected rows to mark them locked, and so
     will result in disk writes.
</span>
<span class="productname">PostgreSQL</span>では、メモリ上に変更された行の情報を記憶しないため、同時にロックできる行数の上限はありません。
しかし、行をロックする際に、ディスクに書き込む作業が発生するかもしれません。
例えば<code class="command">SELECT FOR UPDATE</code>は、選択された行をロックしたものと印を付けるために変更を行いますので、ディスクにその結果を書き込むことになります。
    </p><div class="table" id="ROW-LOCK-COMPATIBILITY"><p class="title"><strong>表13.3 行レベルロックの競合</strong></p><div class="table-contents"><span class="original">
     &lt;title&gt;Conflicting Row-level Locks&lt;/title&gt;
</span><table class="table" summary="行レベルロックの競合" border="1"><colgroup><col /><col class="lockst" /><col /><col /><col class="lockend" /></colgroup><thead><tr><th rowspan="2">要求するロックモード</th><th colspan="4">現在のロックモード</th></tr><tr><th>FOR KEY SHARE</th><th>FOR SHARE</th><th>FOR NO KEY UPDATE</th><th>FOR UPDATE</th></tr></thead><tbody><tr><td>FOR KEY SHARE</td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center">X</td></tr><tr><td>FOR SHARE</td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td></tr><tr><td>FOR NO KEY UPDATE</td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td>FOR UPDATE</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="LOCKING-PAGES"><div class="titlepage"><div><div><h3 class="title">13.3.3. ページレベルロック</h3></div></div></div><span class="original">
    &lt;title&gt;Page-level Locks&lt;/title&gt;
</span><p>
<span class="original">
     In addition to table and row locks, page-level share/exclusive locks are
     used to control read/write access to table pages in the shared buffer
     pool.  These locks are released immediately after a row is fetched or
     updated.  Application developers normally need not be concerned with
     page-level locks, but they are mentioned here for completeness.
</span>
テーブルと行ロックに加え、ページレベルの共有/排他ロックがあり、これらは共有バッファプールにあるテーブルページへの読み書きのアクセスを管理するために使用されます。
これらのロックは、行が取得された後や更新された後に即座に解除されます。
アプリケーション開発者は通常ページレベルロックを考慮する必要はありませんが、ロックについて全てを説明したかったためここで取り上げました。
    </p></div><div class="sect2" id="LOCKING-DEADLOCKS"><div class="titlepage"><div><div><h3 class="title">13.3.4. デッドロック</h3></div></div></div><span class="original">
    &lt;title&gt;Deadlocks&lt;/title&gt;
</span><a id="id-1.5.12.6.8.2" class="indexterm"></a><p>
<span class="original">
     The use of explicit locking can increase the likelihood of
     &lt;firstterm&gt;deadlocks&lt;/firstterm&gt;, wherein two (or more) transactions each
     hold locks that the other wants.  For example, if transaction 1
     acquires an exclusive lock on table A and then tries to acquire
     an exclusive lock on table B, while transaction 2 has already
     exclusive-locked table B and now wants an exclusive lock on table
     A, then neither one can proceed.
     &lt;productname&gt;PostgreSQL&lt;/productname&gt; automatically detects
     deadlock situations and resolves them by aborting one of the
     transactions involved, allowing the other(s) to complete.
     (Exactly which transaction will be aborted is difficult to
     predict and should not be relied upon.)
</span>
明示的なロックの使用は、<em class="firstterm">デッドロック</em>の原因となる可能性があります。
デッドロックとは、2つ（もしくはそれ以上）のトランザクションにおいて、それぞれが、他方のトランザクションが必要とするロックを所持してしまうことです。
例えば、トランザクション1がテーブルAに排他ロックを獲得していて、次にテーブルBに排他ロックを獲得しようとする際に、トランザクション2が既にテーブルBに排他ロックを獲得済みであって、今からテーブルAに排他ロックを獲得しようと試みる場合、どちらのトランザクションも処理を進められません。
<span class="productname">PostgreSQL</span>では、自動的にデッドロック状況を検知し、関係するトランザクションの一方をアボートすることにより、この状況を解決し、もう一方のトランザクションの処理を完了させます
（どちらのトランザクションをアボートするかを正確に予期するのは難しく、これに依存すべきではありません）。
    </p><p>
<span class="original">
     Note that deadlocks can also occur as the result of row-level
     locks (and thus, they can occur even if explicit locking is not
     used). Consider the case in which two concurrent
     transactions modify a table. The first transaction executes:
</span>
デッドロックは行レベルロックの結果として発生する可能性があります
（したがって、明示的なロック処理を使用していなくても発生する可能性があります）。
2つの同時実行トランザクションがあるテーブルを変更する状況を考えてみます。
1つ目のトランザクションは以下を実行します。

</p><pre class="screen">
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 11111;
</pre><p>

<span class="original">
     This acquires a row-level lock on the row with the specified
     account number. Then, the second transaction executes:
</span>
これは、指定した口座番号の行に対し行レベルロックを獲得します。
次に2番目のトランザクションが以下を実行します。

</p><pre class="screen">
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 22222;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 11111;
</pre><p>

<span class="original">
     The first &lt;command&gt;UPDATE&lt;/command&gt; statement successfully
     acquires a row-level lock on the specified row, so it succeeds in
     updating that row. However, the second &lt;command&gt;UPDATE&lt;/command&gt;
     statement finds that the row it is attempting to update has
     already been locked, so it waits for the transaction that
     acquired the lock to complete. Transaction two is now waiting on
     transaction one to complete before it continues execution. Now,
     transaction one executes:
</span>
1つ目の<code class="command">UPDATE</code>文は指定された行に対する行レベルロックの獲得に成功し、この行の更新に成功します。
しかし、2つ目の<code class="command">UPDATE</code>文は、更新対象の行がロックされていることを検知し、ロックを獲得したトランザクションが完了するまで待機します。
トランザクション2は、ここで、続きを実行する前にトランザクション1が完了するのを待機しています。
さて、トランザクション1がここで以下を実行します。

</p><pre class="screen">
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 22222;
</pre><p>

<span class="original">
     Transaction one attempts to acquire a row-level lock on the
     specified row, but it cannot: transaction two already holds such
     a lock. So it waits for transaction two to complete. Thus,
     transaction one is blocked on transaction two, and transaction
     two is blocked on transaction one: a deadlock
     condition. &lt;productname&gt;PostgreSQL&lt;/productname&gt; will detect this
     situation and abort one of the transactions.
</span>
トランザクション1は指定した行の行レベルロックを獲得しようとしますが、これは不可能です。
トランザクション2がそのロックを既に獲得しているからです。
そのため、トランザクション2が完了するのを待機することになります。
こうして、トランザクション1はトランザクション2でブロックされ、トランザクション2はトランザクション1でブロックされる、つまり、デッドロック状態です。
<span class="productname">PostgreSQL</span>はデッドロック状態を検知し、片方のトランザクションを中断させます。
    </p><p>
<span class="original">
     The best defense against deadlocks is generally to avoid them by
     being certain that all applications using a database acquire
     locks on multiple objects in a consistent order. In the example
     above, if both transactions
     had updated the rows in the same order, no deadlock would have
     occurred. One should also ensure that the first lock acquired on
     an object in a transaction is the most restrictive mode that will be
     needed for that object.  If it is not feasible to verify this in
     advance, then deadlocks can be handled on-the-fly by retrying
     transactions that abort due to deadlocks.
</span>
デッドロックを防ぐ最も良い方法は、データベースを使用する全てのアプリケーションが、整合性のある順序で複数のオブジェクトに対するロックを獲得することです。
前に示したデッドロックの例で、もし両方のトランザクションで同じ順序で行を更新していたらデッドロックは起こりません。
また、トランザクション内のオブジェクトに対して獲得した最初のロックが、そのオブジェクトが必要とする最も制限的なモードであることを確実に保証すべきです。
このことが事前に検証できない場合、デッドロックによりアボートするトランザクションを再試行すれば、デッドロックをデータベースを稼働させながらでも処理することができます。
    </p><p>
<span class="original">
     So long as no deadlock situation is detected, a transaction seeking
     either a table-level or row-level lock will wait indefinitely for
     conflicting locks to be released.  This means it is a bad idea for
     applications to hold transactions open for long periods of time
     (e.g., while waiting for user input).
</span>
デッドロック状況が検出されなければ、テーブルレベルロックもしくは行レベルロックを要求するトランザクションは、競合するロックが解放されるまで、無期限に待機します。
したがって、アプリケーションで長時間（例えば、ユーザの入力待ち）トランザクションを開いたまま保持しておくのは、推奨されません。
    </p></div><div class="sect2" id="ADVISORY-LOCKS"><div class="titlepage"><div><div><h3 class="title">13.3.5. 勧告的ロック</h3></div></div></div><span class="original">
    &lt;title&gt;Advisory Locks&lt;/title&gt;
</span><a id="id-1.5.12.6.9.2" class="indexterm"></a><a id="id-1.5.12.6.9.3" class="indexterm"></a><p>
<span class="original">
     &lt;productname&gt;PostgreSQL&lt;/productname&gt; provides a means for
     creating locks that have application-defined meanings.  These are
     called &lt;firstterm&gt;advisory locks&lt;/firstterm&gt;, because the system does not
     enforce their use &amp;mdash; it is up to the application to use them
     correctly.  Advisory locks can be useful for locking strategies
     that are an awkward fit for the MVCC model.
     For example, a common use of advisory locks is to emulate pessimistic
     locking strategies typical of so-called &lt;quote&gt;flat file&lt;/quote&gt; data
     management systems.
     While a flag stored in a table could be used for the same purpose,
     advisory locks are faster, avoid table bloat, and are automatically
     cleaned up by the server at the end of the session.
</span>
<span class="productname">PostgreSQL</span>は、アプリケーション独自の意味を持つロックを生成する手法を提供します。
これは、その使用に関してシステムによる制限がないこと、つまり、正しい使用に関してはアプリケーションが責任を持つことから<em class="firstterm">勧告的ロック</em>と呼ばれます。
勧告的ロックは、MVCC方式に合わせづらいロック戦略で有用に使用することができます。
例えば、勧告的ロックのよくある利用として、いわゆる<span class="quote">「<span class="quote">フラットファイル</span>」</span>データ管理システムで典型的な、悲観的なロック戦略を模擬することです。
この用途のためにテーブル内にフラグを格納することもできますが、勧告的ロックの方が高速で、テーブルの膨張を防ぐことができます。
また、セッション終了時にサーバによる自動整理を行うこともできるようになります。
    </p><p>
<span class="original">
     There are two ways to acquire an advisory lock in
     &lt;productname&gt;PostgreSQL&lt;/productname&gt;: at session level or at
     transaction level.
     Once acquired at session level, an advisory lock is held until
     explicitly released or the session ends.  Unlike standard lock requests,
     session-level advisory lock requests do not honor transaction semantics:
     a lock acquired during a transaction that is later rolled back will still
     be held following the rollback, and likewise an unlock is effective even
     if the calling transaction fails later.  A lock can be acquired multiple
     times by its owning process; for each completed lock request there must
     be a corresponding unlock request before the lock is actually released.
     Transaction-level lock requests, on the other hand, behave more like
     regular lock requests: they are automatically released at the end of the
     transaction, and there is no explicit unlock operation.  This behavior
     is often more convenient than the session-level behavior for short-term
     usage of an advisory lock.
     Session-level and transaction-level lock requests for the same advisory
     lock identifier will block each other in the expected way.
     If a session already holds a given advisory lock, additional requests by
     it will always succeed, even if other sessions are awaiting the lock; this
     statement is true regardless of whether the existing lock hold and new
     request are at session level or transaction level.
</span>
<span class="productname">PostgreSQL</span>には、セッションレベルとトランザクションレベルという２つの勧告的ロックの獲得方法があります。
セッションレベルで獲得すると、勧告的ロックは明示的に解放されるか、セッションが終了するまで保持されます。
標準のロック要求と異なり、セッションレベル勧告的ロックはトランザクションという意味には従いません。
ロックがトランザクション期間中に獲得され、そのトランザクションを後でロールバックしたとしても、ロールバック後も保持されます。
そして、呼び出し元のトランザクションが後で失敗したとしてもロック解除は有効です。
所有するプロセスの中で、同一のセッションレベルのロックを複数回獲得することもできます。
この場合、個々のロック要求に対して、ロックを実際に解放する前に対応するロック解除要求がなければなりません。
一方トランザクションレベルのロックはより通常のロックに似たように動作します。
それらは、処理の終わりに自動的に解放されますので、明示的なロック解放操作はありません。
短期間の勧告的ロックを利用する場合は、セッションレベルの動作よりもこの動作の方が便利なことが多くあります。
同じ勧告的ロック識別子に対するセッションレベルのロックとトランザクションレベルのロック要求は、想像通り互いをブロックします。
セッションがすでに指定された勧告的ロックを保持している場合、他のセッションがそのロックを待機していたとしても、追加の要求は常に成功します。
これは保持されているロックと新しい要求がセッションレベルかトランザクションレベルかどうかに関わらず、この文は当てはまります。
    </p><p>
<span class="original">
     Like all locks in
     &lt;productname&gt;PostgreSQL&lt;/productname&gt;, a complete list of advisory locks
     currently held by any session can be found in the &lt;link
     linkend="view-pg-locks"&gt;&lt;structname&gt;pg_locks&lt;/structname&gt;&lt;/link&gt; system
     view.
</span>
<span class="productname">PostgreSQL</span>におけるすべてのロックと同様に、現時点ですべてのセッションで保持されている勧告的ロックの全一覧は<a class="link" href="view-pg-locks.html" title="52.73. pg_locks"><code class="structname">pg_locks</code></a>システムビューにあります。
    </p><p>
<span class="original">
     Both advisory locks and regular locks are stored in a shared memory
     pool whose size is defined by the configuration variables
     &lt;xref linkend="guc-max-locks-per-transaction"/&gt; and
     &lt;xref linkend="guc-max-connections"/&gt;.
     Care must be taken not to exhaust this
     memory or the server will be unable to grant any locks at all.
     This imposes an upper limit on the number of advisory locks
     grantable by the server, typically in the tens to hundreds of thousands
     depending on how the server is configured.
</span>
勧告的ロックと通常のロックは共有メモリプールに割り当てられ、その容量は<a class="xref" href="runtime-config-locks.html#GUC-MAX-LOCKS-PER-TRANSACTION">max_locks_per_transaction</a>と<a class="xref" href="runtime-config-connection.html#GUC-MAX-CONNECTIONS">max_connections</a>設定変数により決定されます。
このメモリを浪費しないように注意が必要です。
さもないと、サーバはロック獲得をまったく許可することができなくなります。
これは、サーバで許可できる勧告的ロック数に上限があることを意味します。
サーバの設定によりますが、通常、1万から10万程度になります。
    </p><p>
<span class="original">
     In certain cases using advisory locking methods, especially in queries
     involving explicit ordering and &lt;literal&gt;LIMIT&lt;/literal&gt; clauses, care must be
     taken to control the locks acquired because of the order in which SQL
     expressions are evaluated.  For example:
</span>
特に明示的な順序付けと<code class="literal">LIMIT</code>句を持つ問い合わせでは、この勧告ロックモードを使用する幾つかの場合において、SQL式が評価される順序を考慮し獲得されたロックを制御することに気を配らなければなりません。
以下に例を示します。
</p><pre class="screen">
<span class="original">
SELECT pg_advisory_lock(id) FROM foo WHERE id = 12345; &amp;#045;&amp;#045; ok
SELECT pg_advisory_lock(id) FROM foo WHERE id &amp;gt; 12345 LIMIT 100; &amp;#045;&amp;#045; danger!
SELECT pg_advisory_lock(q.id) FROM
(
  SELECT id FROM foo WHERE id &amp;gt; 12345 LIMIT 100
) q; &amp;#045;&amp;#045; ok
</span>
SELECT pg_advisory_lock(id) FROM foo WHERE id = 12345; -- 問題なし
SELECT pg_advisory_lock(id) FROM foo WHERE id &gt; 12345 LIMIT 100; -- 危険！
SELECT pg_advisory_lock(q.id) FROM
(
  SELECT id FROM foo WHERE id &gt; 12345 LIMIT 100
) q; -- 問題なし
</pre><p>
<span class="original">
     In the above queries, the second form is dangerous because the
     &lt;literal&gt;LIMIT&lt;/literal&gt; is not guaranteed to be applied before the locking
     function is executed.  This might cause some locks to be acquired
     that the application was not expecting, and hence would fail to release
     (until it ends the session).
     From the point of view of the application, such locks
     would be dangling, although still viewable in
     &lt;structname&gt;pg_locks&lt;/structname&gt;.
</span>
上の例では、ロック獲得関数が実行される前に<code class="literal">LIMIT</code> が適用されることを保障できないため、2番目の形式は危険です。
これにより、アプリケーションが想定していないなんらかのロックが生成される可能性があります。
そのため、（セッションが終了するまで）解放に失敗することになります。
アプリケーションから見ると、こうしたロックはただの飾りですが、<code class="structname">pg_locks</code>からは参照され続けます。
    </p><p>
<span class="original">
     The functions provided to manipulate advisory locks are described in
     &lt;xref linkend="functions-advisory-locks"/&gt;.
</span>
勧告的ロックを扱うための関数については、<a class="xref" href="functions-admin.html#FUNCTIONS-ADVISORY-LOCKS" title="9.26.10. 勧告的ロック用関数">9.26.10</a>で説明します。
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="transaction-iso.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="mvcc.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="applevel-consistency.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">13.2. トランザクションの分離 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 13.4. アプリケーションレベルでのデータの一貫性チェック</td></tr></table></div></body></html>