<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE FUNCTION</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-createforeigntable.html" title="CREATE FOREIGN TABLE" /><link rel="next" href="sql-creategroup.html" title="CREATE GROUP" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 11.5文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="sql-commands.html" title="SQLコマンド">SQLコマンド</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 11.5 &#10;                      sql-createfunction.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createforeigntable.html" title="CREATE FOREIGN TABLE">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">上へ</a></td><td width="60%" align="center">CREATE FUNCTION</td><td width="20%" align="right"> <a accesskey="n" href="sql-creategroup.html" title="CREATE GROUP">次へ</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATEFUNCTION"><div class="titlepage"></div><a id="id-1.9.3.67.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE FUNCTION</span></h2><p>CREATE FUNCTION<span class="original">
  &lt;refpurpose&gt;define a new function&lt;/refpurpose&gt;
</span> — 新しい関数を定義する</p></div><div class="refsynopsisdiv"><h2>概要</h2><pre class="synopsis">
CREATE [ OR REPLACE ] FUNCTION
    <em class="replaceable"><code>name</code></em> ( [ [ <em class="replaceable"><code>argmode</code></em> ] [ <em class="replaceable"><code>argname</code></em> ] <em class="replaceable"><code>argtype</code></em> [ { DEFAULT | = } <em class="replaceable"><code>default_expr</code></em> ] [, ...] ] )
    [ RETURNS <em class="replaceable"><code>rettype</code></em>
      | RETURNS TABLE ( <em class="replaceable"><code>column_name</code></em> <em class="replaceable"><code>column_type</code></em> [, ...] ) ]
  { LANGUAGE <em class="replaceable"><code>lang_name</code></em>
    | TRANSFORM { FOR TYPE <em class="replaceable"><code>type_name</code></em> } [, ... ]
    | WINDOW
    | IMMUTABLE | STABLE | VOLATILE | [ NOT ] LEAKPROOF
    | CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
    | [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
    | PARALLEL { UNSAFE | RESTRICTED | SAFE }
    | COST <em class="replaceable"><code>execution_cost</code></em>
    | ROWS <em class="replaceable"><code>result_rows</code></em>
    | SET <em class="replaceable"><code>configuration_parameter</code></em> { TO <em class="replaceable"><code>value</code></em> | = <em class="replaceable"><code>value</code></em> | FROM CURRENT }
    | AS '<em class="replaceable"><code>definition</code></em>'
    | AS '<em class="replaceable"><code>obj_file</code></em>', '<em class="replaceable"><code>link_symbol</code></em>'
  } ...
</pre></div><div class="refsect1" id="SQL-CREATEFUNCTION-DESCRIPTION"><h2>説明</h2><span class="original">
  &lt;title&gt;Description&lt;/title&gt;
</span><p>
<span class="original">
   &lt;command&gt;CREATE FUNCTION&lt;/command&gt; defines a new function.
   &lt;command&gt;CREATE OR REPLACE FUNCTION&lt;/command&gt; will either create a
   new function, or replace an existing definition.
   To be able to define a function, the user must have the
   &lt;literal&gt;USAGE&lt;/literal&gt; privilege on the language.
</span>
<code class="command">CREATE FUNCTION</code>は新しい関数を定義します。
<code class="command">CREATE OR REPLACE FUNCTION</code>は、新しい関数の作成、または、既存定義の置換のどちらかを行います。
関数を定義するには、ユーザはその言語の<code class="literal">USAGE</code>権限が必要です。
  </p><p>
<span class="original">
   If a schema name is included, then the function is created in the
   specified schema.  Otherwise it is created in the current schema.
   The name of the new function must not match any existing function or procedure
   with the same input argument types in the same schema.  However,
   functions and procedures of different argument types can share a name (this is
   called &lt;firstterm&gt;overloading&lt;/firstterm&gt;).
</span>
スキーマ名が含まれている場合、関数は指定されたスキーマに作成されます。
スキーマ名がなければ、関数は現在のスキーマに作成されます。
同じスキーマ内の同じ入力引数データ型を持つ既存の関数またはプロシージャの名前は、新しい関数の名前として使用できません。
しかし、異なる引数データ型を持つ関数やプロシージャであれば、名前が重複しても構いません
（これを、<em class="firstterm">オーバーロード</em>と言います）。
  </p><p>
<span class="original">
   To replace the current definition of an existing function, use
   &lt;command&gt;CREATE OR REPLACE FUNCTION&lt;/command&gt;.  It is not possible
   to change the name or argument types of a function this way (if you
   tried, you would actually be creating a new, distinct function).
   Also, &lt;command&gt;CREATE OR REPLACE FUNCTION&lt;/command&gt; will not let
   you change the return type of an existing function.  To do that,
   you must drop and recreate the function.  (When using &lt;literal&gt;OUT&lt;/literal&gt;
   parameters, that means you cannot change the types of any
   &lt;literal&gt;OUT&lt;/literal&gt; parameters except by dropping the function.)
</span>
既存の関数定義を入れ替えるには、<code class="command">CREATE OR REPLACE FUNCTION</code>を使用してください。
この方法では関数の名前や引数の型を変更することはできません
（これを行った場合、新しく別の関数が作成されます）。
また、<code class="command">CREATE OR REPLACE FUNCTION</code>では、既存の関数の戻り値の型を変更することはできません。
戻り値の型を変更したい場合は、その関数を削除し、再度作成してください。
（これは、<code class="literal">OUT</code>パラメータを使用している場合、関数を削除しない限り<code class="literal">OUT</code>パラメータの型を変更できないことを意味します。）
  </p><p>
<span class="original">
   When &lt;command&gt;CREATE OR REPLACE FUNCTION&lt;/command&gt; is used to replace an
   existing function, the ownership and permissions of the function
   do not change.  All other function properties are assigned the
   values specified or implied in the command.  You must own the function
   to replace it (this includes being a member of the owning role).
</span>
<code class="command">CREATE OR REPLACE FUNCTION</code>を使用して既存の関数を置き換える場合、関数の所有者と権限は変わりません。
他の関数に関するすべての属性には、そのコマンドで指定された値、または暗黙的な値が設定されます。
関数を置き換えるためにはその関数を所有していなければなりません。
（これには所有するロールのメンバであることが含まれています。）
  </p><p>
<span class="original">
   If you drop and then recreate a function, the new function is not
   the same entity as the old; you will have to drop existing rules, views,
   triggers, etc. that refer to the old function.  Use
   &lt;command&gt;CREATE OR REPLACE FUNCTION&lt;/command&gt; to change a function
   definition without breaking objects that refer to the function.
   Also, &lt;command&gt;ALTER FUNCTION&lt;/command&gt; can be used to change most of the
   auxiliary properties of an existing function.
</span>
関数を削除し再作成した場合、新しい関数は古いものと同じ実体にはなりません。
古い関数を参照する、既存のルール、ビュー、トリガなどを削除しなければならないでしょう。
関数を参照するオブジェクトを破壊せずに関数定義を変更するには、<code class="command">CREATE OR REPLACE FUNCTION</code>を使用してください。
また、<code class="command">ALTER FUNCTION</code>を使用して、既存の関数の補助属性のほとんどを変更することができます。
  </p><p>
<span class="original">
   The user that creates the function becomes the owner of the function.
</span>
関数を作成したユーザが、その関数の所有者となります。
  </p><p>
<span class="original">
   To be able to create a function, you must have &lt;literal&gt;USAGE&lt;/literal&gt;
   privilege on the argument types and the return type.
</span>
関数を作成するためには、引数の型および戻り値の型に対する<code class="literal">USAGE</code>権限を持たなければなりません。
  </p></div><div class="refsect1" id="id-1.9.3.67.6"><h2>パラメータ</h2><span class="original">
  &lt;title&gt;Parameters&lt;/title&gt;
</span><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>name</code></em></span></dt><dd><p>
<span class="original">
       The name (optionally schema-qualified) of the function to create.
</span>
作成する関数の名前です（スキーマ修飾名も可）。
      </p></dd><dt><span class="term"><em class="replaceable"><code>argmode</code></em></span></dt><dd><p>
<span class="original">
       The mode of an argument: &lt;literal&gt;IN&lt;/literal&gt;, &lt;literal&gt;OUT&lt;/literal&gt;,
       &lt;literal&gt;INOUT&lt;/literal&gt;, or &lt;literal&gt;VARIADIC&lt;/literal&gt;.
       If omitted, the default is &lt;literal&gt;IN&lt;/literal&gt;.
       Only &lt;literal&gt;OUT&lt;/literal&gt; arguments can follow a &lt;literal&gt;VARIADIC&lt;/literal&gt; one.
       Also, &lt;literal&gt;OUT&lt;/literal&gt; and &lt;literal&gt;INOUT&lt;/literal&gt; arguments cannot be used
       together with the &lt;literal&gt;RETURNS TABLE&lt;/literal&gt; notation.
</span>
引数のモードで、<code class="literal">IN</code>、<code class="literal">OUT</code>、<code class="literal">INOUT</code>、<code class="literal">VARIADIC</code>のいずれかです。
省略時のデフォルトは<code class="literal">IN</code>です。
<code class="literal">OUT</code>引数のみが<code class="literal">VARIADIC</code>の後に続けることができます。
また、<code class="literal">RETURNS TABLE</code>記法では、<code class="literal">OUT</code>と<code class="literal">INOUT</code>引数の両方を使用することはできません。
      </p></dd><dt><span class="term"><em class="replaceable"><code>argname</code></em></span></dt><dd><p>
<span class="original">
       The name of an argument. Some languages (including SQL and PL/pgSQL)
       let you use the name in the function body.  For other languages the
       name of an input argument is just extra documentation, so far as
       the function itself is concerned; but you can use input argument names
       when calling a function to improve readability (see &lt;xref
       linkend="sql-syntax-calling-funcs"/&gt;).  In any case, the name
       of an output argument is significant, because it defines the column
       name in the result row type.  (If you omit the name for an output
       argument, the system will choose a default column name.)
</span>
引数の名前です。
（SQLおよびPL/pgSQLを含む）言語の中にはこの名前を関数本体で使用できるものもあります。
他の言語では、関数そのものに注目する限り、入力引数の名前は単なる追加ドキュメントとして扱われます。
しかし関数呼び出し時に入力引数の名前を使用することで可読性を高めることができます。
（<a class="xref" href="sql-syntax-calling-funcs.html" title="4.3. 関数呼び出し">4.3</a>参照）
どのような場合であっても、出力引数の名前は、結果の行型の列名となりますので重要です。
（出力引数の名前を省略した場合、システムはデフォルトの列名を付与します。）
      </p></dd><dt><span class="term"><em class="replaceable"><code>argtype</code></em></span></dt><dd><p>
<span class="original">
       The data type(s) of the function's arguments (optionally
       schema-qualified), if any. The argument types can be base, composite,
       or domain types, or can reference the type of a table column.
</span>
関数の引数のデータ型です（スキーマ修飾名も可）。
基本データ型、複合データ型、ドメイン型、または、テーブル列の型の参照を使用することができます。
      </p><p>
<span class="original">
       Depending on the implementation language it might also be allowed
       to specify &lt;quote&gt;pseudo-types&lt;/quote&gt; such as &lt;type&gt;cstring&lt;/type&gt;.
       Pseudo-types indicate that the actual argument type is either
       incompletely specified, or outside the set of ordinary SQL data types.
</span>
また、実装する言語に依存しますが、<code class="type">cstring</code>といった<span class="quote">「<span class="quote">疑似型</span>」</span>を指定できる場合もあります。
疑似型は、実引数の型の指定が不完全である、もしくは、通常のSQLデータ型の集合を越えていることを示します。
      </p><p>
<span class="original">
       The type of a column is referenced by writing
       &lt;literal&gt;&lt;replaceable
       class="parameter"&gt;table_name&lt;/replaceable&gt;.&lt;replaceable
       class="parameter"&gt;column_name&lt;/replaceable&gt;%TYPE&lt;/literal&gt;.
       Using this feature can sometimes help make a function independent of
       changes to the definition of a table.
</span>
列の型を参照するには、<code class="literal"><em class="replaceable"><code>table_name</code></em>.<em class="replaceable"><code>column_name</code></em>%TYPE</code>と記述します。
これを使用すると、テーブル定義が変更されても関数が影響を受けないようにするのに役に立つことがあります。
      </p></dd><dt><span class="term"><em class="replaceable"><code>default_expr</code></em></span></dt><dd><p>
<span class="original">
       An expression to be used as default value if the parameter is
       not specified.  The expression has to be coercible to the
       argument type of the parameter.
       Only input (including &lt;literal&gt;INOUT&lt;/literal&gt;) parameters can have a default
        value.  All input parameters following a
       parameter with a default value must have default values as well.
</span>
パラメータが指定されなかった場合のデフォルト値として使用される式です。
この式はパラメータの引数型と変換可能でなければなりません。
入力パラメータ（<code class="literal">INOUT</code>を含みます）のみがデフォルト値を持つことができます。
デフォルト値を持つパラメータの後ろにあるパラメータはすべて、同様にデフォルト値を持たなければなりません。
      </p></dd><dt><span class="term"><em class="replaceable"><code>rettype</code></em></span></dt><dd><p>
<span class="original">
       The return data type (optionally schema-qualified). The return type
       can be a base, composite, or domain type,
       or can reference the type of a table column.
       Depending on the implementation language it might also be allowed
       to specify &lt;quote&gt;pseudo-types&lt;/quote&gt; such as &lt;type&gt;cstring&lt;/type&gt;.
       If the function is not supposed to return a value, specify
       &lt;type&gt;void&lt;/type&gt; as the return type.
</span>
関数が返すデータの型です（スキーマ修飾名も可）。
基本型、複合型、ドメイン型、または、テーブル列の型の参照を設定することができます。
また、実装している言語によりますが、<code class="type">cstring</code>のような<span class="quote">「<span class="quote">疑似型</span>」</span>も指定することが可能です。
その関数が値を返すことを想定していない場合は、戻り値として<code class="type">void</code>を指定してください。
      </p><p>
<span class="original">
       When there are &lt;literal&gt;OUT&lt;/literal&gt; or &lt;literal&gt;INOUT&lt;/literal&gt; parameters,
       the &lt;literal&gt;RETURNS&lt;/literal&gt; clause can be omitted.  If present, it
       must agree with the result type implied by the output parameters:
       &lt;literal&gt;RECORD&lt;/literal&gt; if there are multiple output parameters, or
       the same type as the single output parameter.
</span>
<code class="literal">OUT</code>もしくは<code class="literal">INOUT</code>パラメータが存在する場合、<code class="literal">RETURNS</code>句を省略することができます。
省略しない場合は、出力用パラメータが意味する結果型に従ったもの、つまり、複数の出力用パラメータがあれば<code class="literal">RECORD</code>、単一の出力用パラメータであればそれと同じ型、でなければなりません。
      </p><p>
<span class="original">
       The &lt;literal&gt;SETOF&lt;/literal&gt;
       modifier indicates that the function will return a set of
       items, rather than a single item.
</span>
<code class="literal">SETOF</code>修飾子は、その関数が、1つではなく複数のアイテムの集合を返すことを示します。
      </p><p>
<span class="original">
       The type of a column is referenced by writing
       &lt;literal&gt;&lt;replaceable
       class="parameter"&gt;table_name&lt;/replaceable&gt;.&lt;replaceable
       class="parameter"&gt;column_name&lt;/replaceable&gt;%TYPE&lt;/literal&gt;.
</span>
列の型は、<code class="literal"><em class="replaceable"><code>table_name</code></em>.<em class="replaceable"><code>column_name</code></em>%TYPE</code>と記述することで参照されます。
      </p></dd><dt><span class="term"><em class="replaceable"><code>column_name</code></em></span></dt><dd><p>
<span class="original">
       The name of an output column in the &lt;literal&gt;RETURNS TABLE&lt;/literal&gt;
       syntax.  This is effectively another way of declaring a named
       &lt;literal&gt;OUT&lt;/literal&gt; parameter, except that &lt;literal&gt;RETURNS TABLE&lt;/literal&gt;
       also implies &lt;literal&gt;RETURNS SETOF&lt;/literal&gt;.
</span>
<code class="literal">RETURNS TABLE</code>構文における出力列の名前です。
これは実際名前付けされた<code class="literal">OUT</code>パラメータを宣言する別の方法ですが、<code class="literal">RETURNS TABLE</code>が<code class="literal">RETURNS SETOF</code>をも意味する点が異なります。
      </p></dd><dt><span class="term"><em class="replaceable"><code>column_type</code></em></span></dt><dd><p>
<span class="original">
       The data type of an output column in the &lt;literal&gt;RETURNS TABLE&lt;/literal&gt;
       syntax.
</span>
<code class="literal">RETURNS TABLE</code>構文における出力列のデータ型です。
      </p></dd><dt><span class="term"><em class="replaceable"><code>lang_name</code></em></span></dt><dd><p>
<span class="original">
       The name of the language that the function is implemented in.
       It can be &lt;literal&gt;sql&lt;/literal&gt;, &lt;literal&gt;c&lt;/literal&gt;,
       &lt;literal&gt;internal&lt;/literal&gt;, or the name of a user-defined
       procedural language, e.g. &lt;literal&gt;plpgsql&lt;/literal&gt;.  Enclosing the
       name in single quotes is deprecated and requires matching case.
</span>
関数を実装している言語の名前です。
このパラメータには、<code class="literal">sql</code>、<code class="literal">c</code>、<code class="literal">internal</code>、もしくはユーザ定義手続き言語(例：<code class="literal">plpgsql</code>)の名前を指定可能です。
名前を単一引用符で囲むのは廃止予定で、大文字小文字の一致が必要になります。
      </p></dd><dt><span class="term"><code class="literal">TRANSFORM { FOR TYPE <em class="replaceable"><code>type_name</code></em> } [, ... ] }</code></span></dt><dd><p>
<span class="original">
       Lists which transforms a call to the function should apply.  Transforms
       convert between SQL types and language-specific data types;
       see &lt;xref linkend="sql-createtransform"/&gt;.  Procedural language
       implementations usually have hardcoded knowledge of the built-in types,
       so those don't need to be listed here.  If a procedural language
       implementation does not know how to handle a type and no transform is
       supplied, it will fall back to a default behavior for converting data
       types, but this depends on the implementation.
</span>
関数呼び出しにどの変換を適用すべきかのリストです。
変換はSQLの型と言語独自のデータ型の間の変換を行います（<a class="xref" href="sql-createtransform.html" title="CREATE TRANSFORM"><span class="refentrytitle">CREATE TRANSFORM</span></a>を参照）。
手続言語の実装では、通常、ビルトインの型についてハードコードされた知識があるので、それらをこのリストに含める必要はありません。
手続言語の実装が型の処理について定めておらず、変換が提供されない場合は、データ型変換のデフォルトの動作によることになりますが、これは実装に依存します。
      </p></dd><dt><span class="term"><code class="literal">WINDOW</code></span></dt><dd><span class="original">
      &lt;para&gt;&lt;literal&gt;WINDOW&lt;/literal&gt; indicates that the function is a
       &lt;firstterm&gt;window function&lt;/firstterm&gt; rather than a plain function.
       This is currently only useful for functions written in C.
       The &lt;literal&gt;WINDOW&lt;/literal&gt; attribute cannot be changed when
       replacing an existing function definition.
</span><p><code class="literal">WINDOW</code>は、この関数が普通の関数ではなく<em class="firstterm">ウィンドウ関数</em>であることを示します。
現在これはC言語で作成した関数のみに使用することができます。
既存の関数定義を置き換える場合、<code class="literal">WINDOW</code>属性を変更することはできません。
      </p></dd><dt><span class="term"><code class="literal">IMMUTABLE</code><br /></span><span class="term"><code class="literal">STABLE</code><br /></span><span class="term"><code class="literal">VOLATILE</code></span></dt><dd><p>
<span class="original">
       These attributes inform the query optimizer about the behavior
       of the function.  At most one choice
       can be specified.  If none of these appear,
       &lt;literal&gt;VOLATILE&lt;/literal&gt; is the default assumption.
</span>
これらの属性は、関数の動作に関する情報を問い合わせオプティマイザに提供します。
いずれか1つのキーワードのみ指定できます。
指定がない場合は、デフォルトで<code class="literal">VOLATILE</code>と解釈されます。
      </p><span class="original">
      &lt;para&gt;&lt;literal&gt;IMMUTABLE&lt;/literal&gt; indicates that the function
       cannot modify the database and always
       returns the same result when given the same argument values; that
       is, it does not do database lookups or otherwise use information not
       directly present in its argument list.  If this option is given,
       any call of the function with all-constant arguments can be
       immediately replaced with the function value.
</span><p><code class="literal">IMMUTABLE</code>は、関数がデータベースに対する変更を行わないこと、および、その関数に同じ引数値を与えた場合に常に同じ結果を返すことを示します。
つまり、データベースを検索したり、引数リスト中に直接存在しない情報を使用したりしないということです。
このオプションが指定された場合、引数が全て定数である関数呼び出しは、即座に関数値と置き換えることができます。
      </p><span class="original">
      &lt;para&gt;&lt;literal&gt;STABLE&lt;/literal&gt; indicates that the function
       cannot modify the database,
       and that within a single table scan it will consistently
       return the same result for the same argument values, but that its
       result could change across SQL statements.  This is the appropriate
       selection for functions whose results depend on database lookups,
       parameter variables (such as the current time zone), etc.  (It is
       inappropriate for &lt;literal&gt;AFTER&lt;/literal&gt; triggers that wish to
       query rows modified by the current command.)  Also note
       that the &lt;function&gt;current_timestamp&lt;/function&gt; family of functions qualify
       as stable, since their values do not change within a transaction.
</span><p><code class="literal">STABLE</code>は、関数がデータベースに対する変更を行わないこと、および、その関数に同じ引数値を与えた場合、常に同じ結果を返すが、SQL文が異なると結果が変わってしまう可能性があることを示します。
これは、データベース検索や（現在の時間帯のような）パラメータ変数などに結果が依存する関数に適します。
(これは現在のコマンドで変更された行を問い合わせたい<code class="literal">AFTER</code>トリガには不適切です。)
また、<code class="function">current_timestamp</code>系の関数は、1つのトランザクション内では値が変化しないため、STABLEであることに注意してください。
      </p><span class="original">
      &lt;para&gt;&lt;literal&gt;VOLATILE&lt;/literal&gt; indicates that the function value can
       change even within a single table scan, so no optimizations can be
       made.  Relatively few database functions are volatile in this sense;
       some examples are &lt;literal&gt;random()&lt;/literal&gt;, &lt;literal&gt;currval()&lt;/literal&gt;,
       &lt;literal&gt;timeofday()&lt;/literal&gt;.  But note that any function that has
       side-effects must be classified volatile, even if its result is quite
       predictable, to prevent calls from being optimized away; an example is
       &lt;literal&gt;setval()&lt;/literal&gt;.
</span><p><code class="literal">VOLATILE</code>は、1つのテーブルスキャン内でも関数の値が変化する可能性があるため、最適化できないことを示します。
このような意味で変動的（volatile）なデータベース関数は、比較的少数です。
例えば、<code class="literal">random()</code>、<code class="literal">currval()</code>、<code class="literal">timeofday()</code>などは変動的な関数です。
しかし、例えば<code class="literal">setval()</code>などの副作用がある関数は、その結果を完全に予測できるとしても、呼び出しを最適化しないよう、<code class="literal">VOLATILE</code>（変動的）に分類する必要があることに注意してください。
      </p><p>
<span class="original">
       For additional details see &lt;xref linkend="xfunc-volatility"/&gt;.
</span>
詳細は<a class="xref" href="xfunc-volatility.html" title="38.7. 関数の変動性分類">38.7</a>を参照してください。
      </p></dd><dt><span class="term"><code class="literal">LEAKPROOF</code></span></dt><dd><p>
<span class="original">
       &lt;literal&gt;LEAKPROOF&lt;/literal&gt; indicates that the function has no side
       effects.  It reveals no information about its arguments other than by
       its return value.  For example, a function which throws an error message
       for some argument values but not others, or which includes the argument
       values in any error message, is not leakproof.  This affects how the
       system executes queries against views created with the
       &lt;literal&gt;security_barrier&lt;/literal&gt; option or tables with row level
       security enabled.  The system will enforce conditions from security
       policies and security barrier views before any user-supplied conditions
       from the query itself that contain non-leakproof functions, in order to
       prevent the inadvertent exposure of data.  Functions and operators
       marked as leakproof are assumed to be trustworthy, and may be executed
       before conditions from security policies and security barrier views.
       In addition, functions which do not take arguments or which are not
       passed any arguments from the security barrier view or table do not have
       to be marked as leakproof to be executed before security conditions.  See
       &lt;xref linkend="sql-createview"/&gt; and &lt;xref linkend="rules-privileges"/&gt;.
       This option can only be set by the superuser.
</span>
<code class="literal">LEAKPROOF</code>は、関数が副作用を持たないことを示します。
その引数に関する情報を戻り値以外で漏らしません。
例えば、一部の引数値に対してのみエラーメッセージを返す関数や何らかのエラーメッセージの中に引数の値を含める関数は漏洩防止(leakproof)とはいえません。
これは<code class="literal">security_barrier</code>オプション付きで作成されたビュー、あるいは行単位セキュリティが有効にされたテーブルに対して、システムが問い合わせを実行する方法に影響します。
データが偶然に露見することを防ぐため、システムは、漏洩防止でない関数を含む問い合わせのユーザが提供した条件より前に、セキュリティポリシーおよびセキュリティバリアビューの条件を強制します。
漏洩防止であるとされた関数および演算子は信頼できると見なされ、セキュリティポリシーおよびセキュリティバリアビューによる条件より先に実行されることがあります。
なお、引数を取らない、あるいはセキュリティバリアビューやテーブルから引数を渡されない関数は、セキュリティ条件より前に実行するために漏洩防止とする必要はありません。
<a class="xref" href="sql-createview.html" title="CREATE VIEW"><span class="refentrytitle">CREATE VIEW</span></a>および<a class="xref" href="rules-privileges.html" title="41.5. ルールと権限">41.5</a>を参照してください。
このオプションはスーパーユーザによってのみ設定することができます。
      </p></dd><dt><span class="term"><code class="literal">CALLED ON NULL INPUT</code><br /></span><span class="term"><code class="literal">RETURNS NULL ON NULL INPUT</code><br /></span><span class="term"><code class="literal">STRICT</code></span></dt><dd><span class="original">
      &lt;para&gt;&lt;literal&gt;CALLED ON NULL INPUT&lt;/literal&gt; (the default) indicates
       that the function will be called normally when some of its
       arguments are null.  It is then the function author's
       responsibility to check for null values if necessary and respond
       appropriately.
</span><p><code class="literal">CALLED ON NULL INPUT</code>（デフォルト）を指定すると、引数にNULLが含まれていても、関数が通常通り呼び出されます。
その場合は、必要に応じてNULL値を確認し、適切な対応をすることは関数作成者の責任です。
      </p><span class="original">
      &lt;para&gt;&lt;literal&gt;RETURNS NULL ON NULL INPUT&lt;/literal&gt; or
       &lt;literal&gt;STRICT&lt;/literal&gt; indicates that the function always
       returns null whenever any of its arguments are null.  If this
       parameter is specified, the function is not executed when there
       are null arguments; instead a null result is assumed
       automatically.
</span><p><code class="literal">RETURNS NULL ON NULL INPUT</code>もしくは<code class="literal">STRICT</code>を指定すると、関数の引数に1つでもNULLがある場合、常にNULLを返します。
このパラメータが指定されると、NULL引数がある場合、関数は実行されません。
代わりに、NULLという結果が自動的に与えられます。
      </p></dd><dt><span class="term"><code class="literal">[<span class="optional">EXTERNAL</span>] SECURITY INVOKER</code><br /></span><span class="term"><code class="literal">[<span class="optional">EXTERNAL</span>] SECURITY DEFINER</code></span></dt><dd><span class="original">
     &lt;para&gt;&lt;literal&gt;SECURITY INVOKER&lt;/literal&gt; indicates that the function
      is to be executed with the privileges of the user that calls it.
      That is the default.  &lt;literal&gt;SECURITY DEFINER&lt;/literal&gt;
      specifies that the function is to be executed with the
      privileges of the user that owns it.
</span><p><code class="literal">SECURITY INVOKER</code>を指定すると、関数を呼び出したユーザの権限で、その関数が実行されます。
これがデフォルトです。
<code class="literal">SECURITY DEFINER</code>を指定すると、関数を所有するユーザの権限で、その関数が実行されます。
     </p><p>
<span class="original">
      The key word &lt;literal&gt;EXTERNAL&lt;/literal&gt; is allowed for SQL
      conformance, but it is optional since, unlike in SQL, this feature
      applies to all functions not only external ones.
</span>
<code class="literal">EXTERNAL</code>キーワードは、SQLとの互換性を保つために許されています。
しかし、SQLとは異なり、この機能は外部関数だけではなくすべての関数に適用されるため、このキーワードは省略可能です。
     </p></dd><dt><span class="term"><code class="literal">PARALLEL</code></span></dt><dd><span class="original">
     &lt;para&gt;&lt;literal&gt;PARALLEL UNSAFE&lt;/literal&gt; indicates that the function
      can't be executed in parallel mode and the presence of such a
      function in an SQL statement forces a serial execution plan.  This is
      the default.  &lt;literal&gt;PARALLEL RESTRICTED&lt;/literal&gt; indicates that
      the function can be executed in parallel mode, but the execution is
      restricted to parallel group leader.  &lt;literal&gt;PARALLEL SAFE&lt;/literal&gt;
      indicates that the function is safe to run in parallel mode without
      restriction.
</span><p>
<code class="literal">PARALLEL UNSAFE</code>は、その関数が並列モードでは実行できないこと、そしてそのような関数がSQL文の中にある場合は順次の実行プランが強制されることを意味します。
これがデフォルトです。
<code class="literal">PARALLEL RESTRICTED</code>はその関数が並列モードで実行できますが、その実行は並列グループのリーダーに制限されることを意味します。
<code class="literal">PARALLEL SAFE</code>はその関数が並列モードで制限なく実行することについて安全であることを意味します。
     </p><p>
<span class="original">
      Functions should be labeled parallel unsafe if they modify any database
      state, or if they make changes to the transaction such as using
      sub-transactions, or if they access sequences or attempt to make
      persistent changes to settings (e.g. &lt;literal&gt;setval&lt;/literal&gt;).  They should
      be labeled as parallel restricted if they access temporary tables,
      client connection state, cursors, prepared statements, or miscellaneous
      backend-local state which the system cannot synchronize in parallel mode
      (e.g.  &lt;literal&gt;setseed&lt;/literal&gt; cannot be executed other than by the group
      leader because a change made by another process would not be reflected
      in the leader).  In general, if a function is labeled as being safe when
      it is restricted or unsafe, or if it is labeled as being restricted when
      it is in fact unsafe, it may throw errors or produce wrong answers
      when used in a parallel query.  C-language functions could in theory
      exhibit totally undefined behavior if mislabeled, since there is no way
      for the system to protect itself against arbitrary C code, but in most
      likely cases the result will be no worse than for any other function.
      If in doubt, functions should be labeled as &lt;literal&gt;UNSAFE&lt;/literal&gt;, which is
      the default.
</span>
関数がデータベースの状態に何らかの変更を行う、サブトランザクションを使うなどトランザクションを変更する、シーケンスにアクセスするか設定に恒久的な変更をする（例えば<code class="literal">setval</code>）という場合はparallel unsafe（並列は安全でない）という印をつけるべきです。
一時テーブル、クライアントの接続状態、カーソル、プリペアド文、その他並列モードでシステムが同期できない様々なバックエンド独自の状態に関数がアクセスする場合、parallel restricted（並列は制限される）という印をつけるべきです（例えば、<code class="literal">setseed</code>はグループのリーダー以外では実行できません。なぜなら他のプロセスでなされた変更がリーダーに反映されないからです）。
一般的に、restrictedあるいはunsafeな関数がsafeとラベル付けされた場合、あるいはunsafeな関数がrestrictedとラベル付けされた場合、それがパラレルクエリ内で使用されると、エラーが発生したり、誤った結果が生成されたりします。
C言語の関数は、ラベルが間違っていると、理論的には全く予想できない動作をすることがあります。
これは任意のCプログラムに対してシステムが自分を保護する手段がないからですが、多くの場合、その結果は他の関数と同程度の悪さでしょう。
よくわからない場合は、デフォルトの<code class="literal">UNSAFE</code>で関数にラベル付けしてください。
     </p></dd><dt><span class="term"><code class="literal">COST</code> <em class="replaceable"><code>execution_cost</code></em></span></dt><dd><p>
<span class="original">
       A positive number giving the estimated execution cost for the function,
       in units of &lt;xref linkend="guc-cpu-operator-cost"/&gt;.  If the function
       returns a set, this is the cost per returned row.  If the cost is
       not specified, 1 unit is assumed for C-language and internal functions,
       and 100 units for functions in all other languages.  Larger values
       cause the planner to try to avoid evaluating the function more often
       than necessary.
</span>
この関数の推定実行コストを表す正数で、単位は<a class="xref" href="runtime-config-query.html#GUC-CPU-OPERATOR-COST">cpu_operator_cost</a>です。
関数が集合を返す場合、これは1行当たりのコストとなります。
このコストが指定されない場合、C言語および内部関数では1、他のすべての言語では100となります。
値をより大きくすると、プランナは必要以上に頻繁に関数を評価しないようになります。
      </p></dd><dt><span class="term"><code class="literal">ROWS</code> <em class="replaceable"><code>result_rows</code></em></span></dt><dd><p>
<span class="original">
       A positive number giving the estimated number of rows that the planner
       should expect the function to return.  This is only allowed when the
       function is declared to return a set.  The default assumption is
       1000 rows.
</span>
プランナが想定する、この関数が返す行数の推定値を表す正数です。
これは、関数が集合を返すものと宣言された場合のみ使用可能です。
デフォルト推定値は1000行です。
      </p></dd><dt><span class="term"><em class="replaceable"><code>configuration_parameter</code></em><br /></span><span class="term"><em class="replaceable"><code>value</code></em></span></dt><dd><p>
<span class="original">
       The &lt;literal&gt;SET&lt;/literal&gt; clause causes the specified configuration
       parameter to be set to the specified value when the function is
       entered, and then restored to its prior value when the function exits.
       &lt;literal&gt;SET FROM CURRENT&lt;/literal&gt; saves the value of the parameter that
       is current when &lt;command&gt;CREATE FUNCTION&lt;/command&gt; is executed as the value
       to be applied when the function is entered.
</span>
<code class="literal">SET</code>句により、関数が始まった時に指定した設定パラメータを指定した値に設定し、関数の終了時にそれを以前の値に戻すことができます。
<code class="literal">SET FROM CURRENT</code>は、<code class="command">CREATE FUNCTION</code>の実行時点でのパラメータ値を、関数に入る時に適用する値として保管します。
      </p><p>
<span class="original">
       If a &lt;literal&gt;SET&lt;/literal&gt; clause is attached to a function, then
       the effects of a &lt;command&gt;SET LOCAL&lt;/command&gt; command executed inside the
       function for the same variable are restricted to the function: the
       configuration parameter's prior value is still restored at function exit.
       However, an ordinary
       &lt;command&gt;SET&lt;/command&gt; command (without &lt;literal&gt;LOCAL&lt;/literal&gt;) overrides the
       &lt;literal&gt;SET&lt;/literal&gt; clause, much as it would do for a previous &lt;command&gt;SET
       LOCAL&lt;/command&gt; command: the effects of such a command will persist after
       function exit, unless the current transaction is rolled back.
</span>
関数に<code class="literal">SET</code>句が付いている場合、関数内部で実行される<code class="command">SET LOCAL</code>コマンドの同一変数に対する効果はその関数に制限されます。
つまり、設定パラメータの前の値は関数が終了する時に元に戻ります。
しかし、通常の（<code class="literal">LOCAL</code>がない）<code class="command">SET</code>コマンドは<code class="literal">SET</code>句を上書きします。
これは過去に行われた<code class="command">SET LOCAL</code>コマンドに対してもほぼ同じです。
つまり、このコマンドの効果は、現在のトランザクションがロールバックされない限り、関数が終了した後も永続化されます。
      </p><p>
<span class="original">
       See &lt;xref linkend="sql-set"/&gt; and
       &lt;xref linkend="runtime-config"/&gt;
       for more information about allowed parameter names and values.
</span>
使用可能なパラメータと値については、<a class="xref" href="sql-set.html" title="SET"><span class="refentrytitle">SET</span></a>および<a class="xref" href="runtime-config.html" title="第19章 サーバの設定">第19章</a>を参照してください。
      </p></dd><dt><span class="term"><em class="replaceable"><code>definition</code></em></span></dt><dd><p>
<span class="original">
       A string constant defining the function; the meaning depends on the
       language.  It can be an internal function name, the path to an
       object file, an SQL command, or text in a procedural language.
</span>
関数を定義する文字列定数です。
このパラメータの意味は言語に依存します。
内部的な関数名、オブジェクトファイルへのパス、SQLコマンド、手続き言語で記述されたテキストなどを指定できます。
      </p><p>
<span class="original">
       It is often helpful to use dollar quoting (see &lt;xref
       linkend="sql-syntax-dollar-quoting"/&gt;) to write the function definition
       string, rather than the normal single quote syntax.  Without dollar
       quoting, any single quotes or backslashes in the function definition must
       be escaped by doubling them.
</span>
関数を定義する文字列を記述する際に、通常の単一引用符ではなく、ドル引用符（<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING" title="4.1.2.4. ドル記号で引用符付けされた文字列定数">4.1.2.4</a>参照）を使用すると便利なことが多くあります。
ドル引用符を使用しなければ、関数定義内の単一引用符やバックスラッシュは必ず二重にしてエスケープしなければなりません。
      </p></dd><dt><span class="term"><code class="literal"><em class="replaceable"><code>obj_file</code></em>, <em class="replaceable"><code>link_symbol</code></em></code></span></dt><dd><p>
<span class="original">
       This form of the &lt;literal&gt;AS&lt;/literal&gt; clause is used for
       dynamically loadable C language functions when the function name
       in the C language source code is not the same as the name of
       the SQL function. The string &lt;replaceable
       class="parameter"&gt;obj_file&lt;/replaceable&gt; is the name of the shared
       library file containing the compiled C function, and is interpreted
       as for the &lt;xref linkend="sql-load"/&gt; command.  The string
       &lt;replaceable class="parameter"&gt;link_symbol&lt;/replaceable&gt; is the
       function's link symbol, that is, the name of the function in the C
       language source code.  If the link symbol is omitted, it is assumed to
       be the same as the name of the SQL function being defined.  The C names
       of all functions must be different, so you must give overloaded C
       functions different C names (for example, use the argument types as
       part of the C names).
</span>
この構文の<code class="literal">AS</code>句は、動的にロードされるC言語関数において、C言語のソースコード中の関数名がSQL関数の名前と同じでない場合に使われます。
<em class="replaceable"><code>obj_file</code></em>という文字列はコンパイルされたC関数を含む共有ライブラリファイルの名前で、<a class="xref" href="sql-load.html" title="LOAD"><span class="refentrytitle">LOAD</span></a>コマンドの場合と同じように解釈されます。
文字列<em class="replaceable"><code>link_symbol</code></em>はその関数のリンクシンボル、つまり、C言語ソースコード中の関数の名前です。
リンクシンボルが省略された場合、定義されるSQL関数の名前と同じものであるとみなされます。
全ての関数について、C言語における名前は、重複してはいけません。したがって、オーバーロードするC言語関数には、異なるC言語の名前を与える必要があります(例えば、C言語における名前の一部に引数の型を使用してください)。
      </p><p>
<span class="original">
       When repeated &lt;command&gt;CREATE FUNCTION&lt;/command&gt; calls refer to
       the same object file, the file is only loaded once per session.
       To unload and
       reload the file (perhaps during development), start a new session.
</span>
同一オブジェクトファイルを参照する、<code class="command">CREATE FUNCTION</code>呼び出しが繰り返された場合、そのファイルはセッション毎に一度だけロードされます。
（おそらく開発段階で）ファイルをアンロードし再ロードするには、新しいセッションを開始してください。
      </p></dd></dl></div><p>
<span class="original">
    Refer to &lt;xref linkend="xfunc"/&gt; for further information on writing
    functions.
</span>
さらに詳しい関数の作成方法については<a class="xref" href="xfunc.html" title="38.3. ユーザ定義関数">38.3</a>を参照してください。
   </p></div><div class="refsect1" id="SQL-CREATEFUNCTION-OVERLOADING"><h2>オーバーロード</h2><span class="original">
  &lt;title&gt;Overloading&lt;/title&gt;
</span><p>
<span class="original">
    &lt;productname&gt;PostgreSQL&lt;/productname&gt; allows function
    &lt;firstterm&gt;overloading&lt;/firstterm&gt;; that is, the same name can be
    used for several different functions so long as they have distinct
    input argument types.  Whether or not you use it, this capability entails
    security precautions when calling functions in databases where some users
    mistrust other users; see &lt;xref linkend="typeconv-func"/&gt;.
</span>
<span class="productname">PostgreSQL</span>では関数の<em class="firstterm">オーバーロード</em>が可能です。
つまり、入力引数の型が異なっていれば、複数の関数に同じ名前を使用することができます。
使うかどうかに関わりなく、この能力は、あるユーザが他のユーザを信用しないデータベースで関数を呼び出す時に、セキュリティの事前の対策を必要とします。<a class="xref" href="typeconv-func.html" title="10.3. 関数">10.3</a>を参照してください。
   </p><p>
<span class="original">
    Two functions are considered the same if they have the same names and
    &lt;emphasis&gt;input&lt;/emphasis&gt; argument types, ignoring any &lt;literal&gt;OUT&lt;/literal&gt;
    parameters.  Thus for example these declarations conflict:
</span>
同じ名前、同じ<span class="emphasis"><em>入力用</em></span>パラメータ型を持つ場合、2つの関数は同一であるとみなされます。
<code class="literal">OUT</code>パラメータは無視されます。
したがって、例えば以下の宣言は競合しています。
</p><pre class="programlisting">
CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, out text) ...
</pre><p>
   </p><p>
<span class="original">
    Functions that have different argument type lists will not be considered
    to conflict at creation time, but if defaults are provided they might
    conflict in use.  For example, consider
</span>
異なる引数型のリストを持つ関数は、作成時に競合するとはみなされませんが、デフォルト値が指定された場合使用時に競合する可能性があります。
例えば以下を考えてみましょう。
</p><pre class="programlisting">
CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, int default 42) ...
</pre><p>
<span class="original">
    A call &lt;literal&gt;foo(10)&lt;/literal&gt; will fail due to the ambiguity about which
    function should be called.
</span>
<code class="literal">foo(10)</code>という呼び出しは、どちらの関数を呼び出すべきかに関して曖昧さがあるために失敗します。
   </p></div><div class="refsect1" id="SQL-CREATEFUNCTION-NOTES"><h2>注釈</h2><span class="original">
  &lt;title&gt;Notes&lt;/title&gt;
</span><p>
<span class="original">
    The full &lt;acronym&gt;SQL&lt;/acronym&gt; type syntax is allowed for
    declaring a function's arguments and return value.  However,
    parenthesized type modifiers (e.g., the precision field for
    type &lt;type&gt;numeric&lt;/type&gt;) are discarded by &lt;command&gt;CREATE FUNCTION&lt;/command&gt;.
    Thus for example
    &lt;literal&gt;CREATE FUNCTION foo (varchar(10)) ...&lt;/literal&gt;
    is exactly the same as
    &lt;literal&gt;CREATE FUNCTION foo (varchar) ...&lt;/literal&gt;.
</span>
関数の引数と戻り値の宣言において、完全な<acronym class="acronym">SQL</acronym>型の構文が使用できます。
しかし、括弧付けされた型修飾子（例えば<code class="type">numeric</code>型の精度フィールド）は、<code class="command">CREATE FUNCTION</code>により破棄されます。
従って、<code class="literal">CREATE FUNCTION foo (varchar(10)) ...</code>は<code class="literal">CREATE FUNCTION foo (varchar) ...</code>とまったく同じになります。
   </p><p>
<span class="original">
    When replacing an existing function with &lt;command&gt;CREATE OR REPLACE
    FUNCTION&lt;/command&gt;, there are restrictions on changing parameter names.
    You cannot change the name already assigned to any input parameter
    (although you can add names to parameters that had none before).
    If there is more than one output parameter, you cannot change the
    names of the output parameters, because that would change the
    column names of the anonymous composite type that describes the
    function's result.  These restrictions are made to ensure that
    existing calls of the function do not stop working when it is replaced.
</span>
既存の関数を<code class="command">CREATE OR REPLACE FUNCTION</code>を使って置き換える場合、パラメータ名の変更に関して制限があります。
すでに何らかの入力パラメータに割り当てられた名前を変更することはできません。
（しかし、これまで名前を持たなかったパラメータに名前を追加することは可能です。）
複数の出力パラメータが存在する場合、関数の結果を表わす無名複合型の列名を変更することになるため、出力パラメータの名前を変更することはできません。
既存の関数呼び出しが置き換わった時に動作しなくなることを確実に防ぐために、これらの制限がなされています。
   </p><p>
<span class="original">
    If a function is declared &lt;literal&gt;STRICT&lt;/literal&gt; with a &lt;literal&gt;VARIADIC&lt;/literal&gt;
    argument, the strictness check tests that the variadic array &lt;emphasis&gt;as
    a whole&lt;/emphasis&gt; is non-null.  The function will still be called if the
    array has null elements.
</span>
関数が<code class="literal">VARIADIC</code>引数を持つ<code class="literal">STRICT</code>と宣言された場合、その厳密性検査では、variadic配列<span class="emphasis"><em>全体</em></span>が非NULLかどうかを検査します。
配列がNULL要素を持っていたとしても関数は呼び出されます。
   </p></div><div class="refsect1" id="SQL-CREATEFUNCTION-EXAMPLES"><h2>例</h2><span class="original">
  &lt;title&gt;Examples&lt;/title&gt;
</span><p>
<span class="original">
   Here are some trivial examples to help you get started.  For more
   information and examples, see &lt;xref linkend="xfunc"/&gt;.
</span>
ここでは、初心者向けの簡単な例をいくつか示します。
<a class="xref" href="xfunc.html" title="38.3. ユーザ定義関数">38.3</a>には、より多くの情報と例が記載されています。
</p><pre class="programlisting">
CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
</pre><p>
  </p><p>
<span class="original">
   Increment an integer, making use of an argument name, in
   &lt;application&gt;PL/pgSQL&lt;/application&gt;:
</span>
<span class="application">PL/pgSQL</span>で、引数名を使用して、整数を1増やします。
</p><pre class="programlisting">
CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS $$
        BEGIN
                RETURN i + 1;
        END;
$$ LANGUAGE plpgsql;
</pre><p>
  </p><p>
<span class="original">
   Return a record containing multiple output parameters:
</span>
複数の出力用パラメータを持つレコードを返します。
</p><pre class="programlisting">
CREATE FUNCTION dup(in int, out f1 int, out f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</pre><p>
<span class="original">
   You can do the same thing more verbosely with an explicitly named
   composite type:
</span>
上と同じことを、明示的な名前が付いた複合型を使用して、より冗長に行うことができます。
</p><pre class="programlisting">
CREATE TYPE dup_result AS (f1 int, f2 text);

CREATE FUNCTION dup(int) RETURNS dup_result
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</pre><p>
<span class="original">
   Another way to return multiple columns is to use a &lt;literal&gt;TABLE&lt;/literal&gt;
   function:
</span>
複数列を返す別の方法は、<code class="literal">TABLE</code>関数を使用することです。
</p><pre class="programlisting">
CREATE FUNCTION dup(int) RETURNS TABLE(f1 int, f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</pre><p>
<span class="original">
   However, a &lt;literal&gt;TABLE&lt;/literal&gt; function is different from the
   preceding examples, because it actually returns a &lt;emphasis&gt;set&lt;/emphasis&gt;
   of records, not just one record.
</span>
しかし、これは実際には、1つのレコードではなく、レコードの<span class="emphasis"><em>集合</em></span>を返しますので、<code class="literal">TABLE</code>関数は上の例とは異なります。
  </p></div><div class="refsect1" id="SQL-CREATEFUNCTION-SECURITY"><h2><code class="literal">SECURITY DEFINER</code>関数の安全な作成</h2><span class="original">
  &lt;title&gt;Writing &lt;literal&gt;SECURITY DEFINER&lt;/literal&gt; Functions Safely&lt;/title&gt;
</span><a id="id-1.9.3.67.10.2" class="indexterm"></a><p>
<span class="original">
    Because a &lt;literal&gt;SECURITY DEFINER&lt;/literal&gt; function is executed
    with the privileges of the user that owns it, care is needed to
    ensure that the function cannot be misused.  For security,
    &lt;xref linkend="guc-search-path"/&gt; should be set to exclude any schemas
    writable by untrusted users.  This prevents
    malicious users from creating objects (e.g., tables, functions, and
    operators) that mask objects intended to be used by the function.
    Particularly important in this regard is the
    temporary-table schema, which is searched first by default, and
    is normally writable by anyone.  A secure arrangement can be obtained
    by forcing the temporary schema to be searched last.  To do this,
    write &lt;literal&gt;pg_temp&lt;/literal&gt;&lt;indexterm&gt;&lt;primary&gt;pg_temp&lt;/primary&gt;&lt;secondary&gt;securing functions&lt;/secondary&gt;&lt;/indexterm&gt; as the last entry in &lt;varname&gt;search_path&lt;/varname&gt;.
    This function illustrates safe usage:
</span>
<code class="literal">SECURITY DEFINER</code>関数は関数を所有するユーザの権限で実行されますので、その関数を間違って使用できないことを確実にしなければなりません。
安全上、<a class="xref" href="runtime-config-client.html#GUC-SEARCH-PATH">search_path</a>は、信頼できないユーザが書き込み可能なスキーマを除去した形で設定すべきです。
これは、悪意のあるユーザがその関数で使用されるオブジェクトを隠すようなオブジェクト（例えば、テーブル、関数、演算子など）を作成することを防ぎます。
ここで特に重要なことは、一時テーブルスキーマです。
このスキーマはデフォルトで最初に検索され、そして、通常誰でも書き込み可能です。
一時スキーマの検索を強制的に最後にすることで、セキュリティを調整できます。
このためには、<code class="literal">pg_temp</code>を<code class="varname">search_path</code>の最後の項目として記載してください。
<a id="id-1.9.3.67.10.3.5" class="indexterm"></a>
安全な使用方法を以下の関数で示します。

</p><pre class="programlisting">
CREATE FUNCTION check_password(uname TEXT, pass TEXT)
RETURNS BOOLEAN AS $$
DECLARE passed BOOLEAN;
BEGIN
        SELECT  (pwd = $2) INTO passed
        FROM    pwds
        WHERE   username = $1;

        RETURN passed;
END;
$$  LANGUAGE plpgsql
    SECURITY DEFINER
<span class="original">
    &amp;#045;&amp;#045; Set a secure search_path: trusted schema(s), then 'pg_temp'.
</span>
    -- 信頼できるスキーマ、その後にpg_tempという順でsearch_pathを安全に設定します。
    SET search_path = admin, pg_temp;
</pre><p>

<span class="original">
    This function's intention is to access a table &lt;literal&gt;admin.pwds&lt;/literal&gt;.
    But without the &lt;literal&gt;SET&lt;/literal&gt; clause, or with a &lt;literal&gt;SET&lt;/literal&gt; clause
    mentioning only &lt;literal&gt;admin&lt;/literal&gt;, the function could be subverted by
    creating a temporary table named &lt;literal&gt;pwds&lt;/literal&gt;.
</span>
この関数の意図は、テーブル<code class="literal">admin.pwds</code>にアクセスすることです。
しかし<code class="literal">SET</code>句がなければ、あるいは<code class="literal">SET</code>句が<code class="literal">admin</code>だけしか記述していなければ、<code class="literal">pwds</code>という名前の一時テーブルを作成することで、この関数は無意味になってしまいます。
   </p><p>
<span class="original">
    Before &lt;productname&gt;PostgreSQL&lt;/productname&gt; version 8.3, the
    &lt;literal&gt;SET&lt;/literal&gt; clause was not available, and so older functions may
    contain rather complicated logic to save, set, and restore
    &lt;varname&gt;search_path&lt;/varname&gt;.  The &lt;literal&gt;SET&lt;/literal&gt; clause is far easier
    to use for this purpose.
</span>
<span class="productname">PostgreSQL</span>バージョン8.3より前では、<code class="literal">SET</code>句は利用できません。
このため古い関数には、<code class="varname">search_path</code>を保管し、設定、そして元に戻すという、多少複雑なロジックが含まれているかもしれません。
こうした目的に<code class="literal">SET</code>句を使用すると、かなり簡単になります。
   </p><p>
<span class="original">
    Another point to keep in mind is that by default, execute privilege
    is granted to &lt;literal&gt;PUBLIC&lt;/literal&gt; for newly created functions
    (see &lt;xref linkend="sql-grant"/&gt; for more
    information).  Frequently you will wish to restrict use of a security
    definer function to only some users.  To do that, you must revoke
    the default &lt;literal&gt;PUBLIC&lt;/literal&gt; privileges and then grant execute
    privilege selectively.  To avoid having a window where the new function
    is accessible to all, create it and set the privileges within a single
    transaction.  For example:
</span>
この他に注意すべき点として、新しく作成された関数ではデフォルトで実行権限が<code class="literal">PUBLIC</code>に付与されていることがあります。
（詳細は<a class="xref" href="sql-grant.html" title="GRANT"><span class="refentrytitle">GRANT</span></a>を参照してください。）
SECURITY DEFINER関数の使用を一部のユーザのみに制限したいことはよくあります。
このためには、デフォルトの<code class="literal">PUBLIC</code>権限を取り消し、そして、実行権限の付与を選択して行ってください。
新しい関数がすべてのユーザに実行可能となる隙間が存在することを防ぐためには、単一トランザクション内で作成と権限設定を行ってください。
以下に例を示します。
   </p><pre class="programlisting">
BEGIN;
CREATE FUNCTION check_password(uname TEXT, pass TEXT) ... SECURITY DEFINER;
REVOKE ALL ON FUNCTION check_password(uname TEXT, pass TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION check_password(uname TEXT, pass TEXT) TO admins;
COMMIT;
</pre></div><div class="refsect1" id="SQL-CREATEFUNCTION-COMPAT"><h2>互換性</h2><span class="original">
  &lt;title&gt;Compatibility&lt;/title&gt;
</span><p>
<span class="original">
   A &lt;command&gt;CREATE FUNCTION&lt;/command&gt; command is defined in the SQL standard.
   The &lt;productname&gt;PostgreSQL&lt;/productname&gt; version is similar but
   not fully compatible.  The attributes are not portable, neither are the
   different available languages.
</span>
<code class="command">CREATE FUNCTION</code>コマンドは標準SQLで定義されています。
<span class="application">PostgreSQL</span>における<code class="command">CREATE FUNCTION</code>も類似の機能を持ちますが、完全な互換性はありません。
属性には移植性がありません。また、使用可能な言語も異なります。
  </p><p>
<span class="original">
   For compatibility with some other database systems,
   &lt;replaceable class="parameter"&gt;argmode&lt;/replaceable&gt; can be written
   either before or after &lt;replaceable class="parameter"&gt;argname&lt;/replaceable&gt;.
   But only the first way is standard-compliant.
</span>
他のデータベースシステムとの互換性のために、<em class="replaceable"><code>argmode</code></em>は<em class="replaceable"><code>argname</code></em>の前に書くことも後に書くこともできます。
しかし、1つ目の方法が標準に従っています。
  </p><p>
<span class="original">
   For parameter defaults, the SQL standard specifies only the syntax with
   the &lt;literal&gt;DEFAULT&lt;/literal&gt; key word.  The syntax
   with &lt;literal&gt;=&lt;/literal&gt; is used in T-SQL and Firebird.
</span>
パラメータのデフォルトに関しては、標準SQLでは<code class="literal">DEFAULT</code>キーワードの構文のみを規定します。
<code class="literal">=</code>を持つ構文はT-SQLおよびFirebirdで使用されています。
  </p></div><div class="refsect1" id="id-1.9.3.67.12"><h2>関連項目</h2><span class="original">
  &lt;title&gt;See Also&lt;/title&gt;
</span><span class="simplelist"><a class="xref" href="sql-alterfunction.html" title="ALTER FUNCTION"><span class="refentrytitle">ALTER FUNCTION</span></a>, <a class="xref" href="sql-dropfunction.html" title="DROP FUNCTION"><span class="refentrytitle">DROP FUNCTION</span></a>, <a class="xref" href="sql-grant.html" title="GRANT"><span class="refentrytitle">GRANT</span></a>, <a class="xref" href="sql-load.html" title="LOAD"><span class="refentrytitle">LOAD</span></a>, <a class="xref" href="sql-revoke.html" title="REVOKE"><span class="refentrytitle">REVOKE</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createforeigntable.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-creategroup.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE FOREIGN TABLE </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> CREATE GROUP</td></tr></table></div></body></html>