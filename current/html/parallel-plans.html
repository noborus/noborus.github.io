<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>15.3. パラレルプラン</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="when-can-parallel-query-be-used.html" title="15.2. どのような時にパラレルクエリは使用できるのか？" /><link rel="next" href="parallel-safety.html" title="15.4. パラレル安全" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 11.3文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="parallel-query.html" title="第15章 パラレルクエリ">第15章 パラレルクエリ</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 11.3 &#10;                      parallel-plans.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="when-can-parallel-query-be-used.html" title="15.2. どのような時にパラレルクエリは使用できるのか？">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="parallel-query.html" title="第15章 パラレルクエリ">上へ</a></td><td width="60%" align="center">15.3. パラレルプラン</td><td width="20%" align="right"> <a accesskey="n" href="parallel-safety.html" title="15.4. パラレル安全">次へ</a></td></tr></table><hr /></div><div class="sect1" id="PARALLEL-PLANS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">15.3. パラレルプラン</h2></div></div></div><span class="original">
  &lt;title&gt;Parallel Plans&lt;/title&gt;
</span><p>
<span class="original">
    Because each worker executes the parallel portion of the plan to
    completion, it is not possible to simply take an ordinary query plan
    and run it using multiple workers.  Each worker would produce a full
    copy of the output result set, so the query would not run any faster
    than normal but would produce incorrect results.  Instead, the parallel
    portion of the plan must be what is known internally to the query
    optimizer as a &lt;firstterm&gt;partial plan&lt;/firstterm&gt;; that is, it must be constructed
    so that each process which executes the plan will generate only a
    subset of the output rows in such a way that each required output row
    is guaranteed to be generated by exactly one of the cooperating processes.
    Generally, this means that the scan on the driving table of the query
    must be a parallel-aware scan.
</span>
各々のワーカーは完了すべきプランのパラレル部分を実行するので、単に通常のクエリプランを適用し、複数のワーカーを使って実行することはできません。
それぞれのワーカーが結果セットの全体のコピーを生成するので、クエリは通常よりも決して速くなりませんし、不正な結果を生成してしまいます。
そうではなくて、プランのパラレル部分は、クエリオプティマイザの内部で<em class="firstterm">部分プラン</em>として知られているものでなくてはなりません。
すなわち、プランを実行する各プロセスが、要求される個々の出力行が、協調動作するプロセスの正確に１個だけによって生成されることが保証されているような方法で、出力行の一部だけを生成します。
一般に、これはクエリの処理対象のテーブルに対するスキャンは、パラレル対応のスキャンでなければならないことを意味します。
  </p><div class="sect2" id="PARALLEL-SCANS"><div class="titlepage"><div><div><h3 class="title">15.3.1. パラレルスキャン</h3></div></div></div><span class="original">
  &lt;title&gt;Parallel Scans&lt;/title&gt;
</span><p>
<span class="original">
    The following types of parallel-aware table scans are currently supported.
</span>
今のところ、次に示すパラレル対応のテーブルスキャンがサポートされています。

  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
        In a &lt;emphasis&gt;parallel sequential scan&lt;/emphasis&gt;, the table's blocks will
        be divided among the cooperating processes.  Blocks are handed out one
        at a time, so that access to the table remains sequential.
</span>
<span class="emphasis"><em>パラレルシーケンシャルスキャン</em></span>では、テーブルのブロックは、協調するプロセスに分割して割り当てられます。
ブロックは一度に１個ずつ処理され、テーブルへのアクセスは逐次のままです。
      </p></li><li class="listitem"><p>
<span class="original">
        In a &lt;emphasis&gt;parallel bitmap heap scan&lt;/emphasis&gt;, one process is chosen
        as the leader.  That process performs a scan of one or more indexes
        and builds a bitmap indicating which table blocks need to be visited.
        These blocks are then divided among the cooperating processes as in
        a parallel sequential scan.  In other words, the heap scan is performed
        in parallel, but the underlying index scan is not.
</span>
<span class="emphasis"><em>パラレルビットマップヒープスキャン</em></span>では、一つのプロセスがリーダーに選ばれます。
そのプロセスは、一つ以上のインデックスをスキャンし、アクセスする必要のあるブロックを示すビットマップを作成します。
次にこれらのブロックは、パラレルシーケンシャルスキャン同様、協調するプロセスに割り当てられます。
つまり、ヒープスキャンは並列であるものの、対応するインデックスのスキャンは並列ではありません。
      </p></li><li class="listitem"><p>
<span class="original">
        In a &lt;emphasis&gt;parallel index scan&lt;/emphasis&gt; or &lt;emphasis&gt;parallel index-only
        scan&lt;/emphasis&gt;, the cooperating processes take turns reading data from the
        index.  Currently, parallel index scans are supported only for
        btree indexes.  Each process will claim a single index block and will
        scan and return all tuples referenced by that block; other process can
        at the same time be returning tuples from a different index block.
        The results of a parallel btree scan are returned in sorted order
        within each worker process.
</span>
<span class="emphasis"><em>パラレルインデックススキャン</em></span>あるいは<span class="emphasis"><em>パラレルインデックスオンリースキャン</em></span>では、協調するプロセスは、交代でインデックスからデータを読み込みます。
今のところ、パラレルインデックススキャンは、btreeインデックスのみでサポートされています。
個々のプロセスは単一のインデックスブロックを要求し、スキャンしてそのブロックから参照されているすべてのタプルを返却します。
他のプロセスは同時に他のインデックスからタプルを返却することができます。
並列btreeスキャンの結果は、ワーカー内におけるソート順の結果で返却されます。
      </p></li></ul></div><p>

<span class="original">
    Other scan types, such as scans of non-btree indexes, may support
    parallel scans in the future.
</span>
btree以外のインデックススキャンのような他のスキャンタイプは、将来パラレルスキャンをサポートするかもしれません。
  </p></div><div class="sect2" id="PARALLEL-JOINS"><div class="titlepage"><div><div><h3 class="title">15.3.2. パラレルジョイン</h3></div></div></div><span class="original">
  &lt;title&gt;Parallel Joins&lt;/title&gt;
</span><p>
<span class="original">
    Just as in a non-parallel plan, the driving table may be joined to one or
    more other tables using a nested loop, hash join, or merge join.  The
    inner side of the join may be any kind of non-parallel plan that is
    otherwise supported by the planner provided that it is safe to run within
    a parallel worker.  Depending on the join type, the inner side may also be
    a parallel plan.
</span>
非パラレルプランと同様、処理対象のテーブルは、1個以上の他のテーブルとネステッドループ、ハッシュ結合、マージ結合で結合することができます。
結合の内側は、パラレルワーカー中で実行しても安全だという条件下で、プランナがサポートするどのような非パラレルプランであっても構いません。
結合タイプによっては内側がパラレルプランであってもよいです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
        In a &lt;emphasis&gt;nested loop join&lt;/emphasis&gt;, the inner side is always
        non-parallel.  Although it is executed in full, this is efficient if
        the inner side is an index scan, because the outer tuples and thus
        the loops that look up values in the index are divided over the
        cooperating processes.
</span>
<span class="emphasis"><em>ネステッドループ結合</em></span>では、内側は常に非パラレルです。
外側タプルとこのようなインデックスで値を探すループは共同するプロセス間で分割されるので、全体で実行されても内側がインデックススキャンであるなら、これは効率的です。
      </p></li><li class="listitem"><p>
<span class="original">
        In a &lt;emphasis&gt;merge join&lt;/emphasis&gt;, the inner side is always
        a non-parallel plan and therefore executed in full.  This may be
        inefficient, especially if a sort must be performed, because the work
        and resulting data are duplicated in every cooperating process.
</span>
<span class="emphasis"><em>マージ結合</em></span>では、内側は常に非パラレルプランで、それゆえに全体で実行されます。
特にソート実行を要する場合、全ての共同プロセスで処理と結果データが重複するので、これは非効率的と考えられます。
      </p></li><li class="listitem"><p>
<span class="original">
        In a &lt;emphasis&gt;hash join&lt;/emphasis&gt; (without the "parallel" prefix),
        the inner side is executed in full by every cooperating process
        to build identical copies of the hash table.  This may be inefficient
        if the hash table is large or the plan is expensive.  In a
        &lt;emphasis&gt;parallel hash join&lt;/emphasis&gt;, the inner side is a
        &lt;emphasis&gt;parallel hash&lt;/emphasis&gt; that divides the work of building
        a shared hash table over the cooperating processes.
</span>
（parallelが付かない）<span class="emphasis"><em>ハッシュ結合</em></span>では、内側は全ての共同プロセスがハッシュテーブルの同じコピーを作ることで、全体で実行されます。
ハッシュテーブルが大きかったり、そのプランが高価である場合、これは非効率的と考えられます。
<span class="emphasis"><em>パラレルハッシュ結合</em></span>では、内側は共有ハッシュテーブルの構築処理を共同プロセス間で分割する<span class="emphasis"><em>パラレルハッシュ</em></span>です。
      </p></li></ul></div></div><div class="sect2" id="PARALLEL-AGGREGATION"><div class="titlepage"><div><div><h3 class="title">15.3.3. パラレル集約</h3></div></div></div><span class="original">
  &lt;title&gt;Parallel Aggregation&lt;/title&gt;
</span><p>
<span class="original">
    &lt;productname&gt;PostgreSQL&lt;/productname&gt; supports parallel aggregation by aggregating in
    two stages.  First, each process participating in the parallel portion of
    the query performs an aggregation step, producing a partial result for
    each group of which that process is aware.  This is reflected in the plan
    as a &lt;literal&gt;Partial Aggregate&lt;/literal&gt; node.  Second, the partial results are
    transferred to the leader via &lt;literal&gt;Gather&lt;/literal&gt; or &lt;literal&gt;Gather
    Merge&lt;/literal&gt;.  Finally, the leader re-aggregates the results across all
    workers in order to produce the final result.  This is reflected in the
    plan as a &lt;literal&gt;Finalize Aggregate&lt;/literal&gt; node.
</span>
<span class="productname">PostgreSQL</span>は、ふたつのステージで集約処理を行うことによってパラレル集約処理をサポートします。
まず、クエリのパラレル部分に参加している個々のプロセスが集約ステップを実行し、それぞれのプロセスが認識しているグループに対する部分的な結果を生成します。
これは<code class="literal">Partial Aggregate</code>ノードとしてプラン中に反映されています。
次に、<code class="literal">Gather</code>または<code class="literal">Gather Merge</code>ノードを通じて部分的な結果がリーダーに転送されます。
最後に、リーダーは、すべてのワーカーにまたがる結果を再集約して、最終的な結果を生成します。
これは、<code class="literal">Finalize Aggregate</code>ノードとしてプラン中に反映されています。
  </p><p>
<span class="original">
    Because the &lt;literal&gt;Finalize Aggregate&lt;/literal&gt; node runs on the leader
    process, queries which produce a relatively large number of groups in
    comparison to the number of input rows will appear less favorable to the
    query planner. For example, in the worst-case scenario the number of
    groups seen by the &lt;literal&gt;Finalize Aggregate&lt;/literal&gt; node could be as many as
    the number of input rows which were seen by all worker processes in the
    &lt;literal&gt;Partial Aggregate&lt;/literal&gt; stage. For such cases, there is clearly
    going to be no performance benefit to using parallel aggregation. The
    query planner takes this into account during the planning process and is
    unlikely to choose parallel aggregate in this scenario.
</span>
<code class="literal">Finalize Aggregate</code>ノードはリーダープロセスで実行されるので、入力行数の割には、比較的多数のグループを生成するクエリは、クエリプランナはあまり好ましくないものとして認識します。
たとえば最悪の場合、<code class="literal">Finalize Aggregate</code>ノードが認識するグループ数は、<code class="literal">Partial Aggregate</code>ですべてのワーカープロセスが認識する入力行数と同じだけの数になります。
こうした場合には、明らかにパラレル集約を利用する性能上の利点がないことになります。
クエリプランナはプラン処理中にこれを考慮するので、このシナリオでパラレル集約を採用することはまずありません。
  </p><p>
<span class="original">
    Parallel aggregation is not supported in all situations.  Each aggregate
    must be &lt;link linkend="parallel-safety"&gt;safe&lt;/link&gt; for parallelism and must
    have a combine function.  If the aggregate has a transition state of type
    &lt;literal&gt;internal&lt;/literal&gt;, it must have serialization and deserialization
    functions.  See &lt;xref linkend="sql-createaggregate"/&gt; for more details.
    Parallel aggregation is not supported if any aggregate function call
    contains &lt;literal&gt;DISTINCT&lt;/literal&gt; or &lt;literal&gt;ORDER BY&lt;/literal&gt; clause and is also
    not supported for ordered set aggregates or when  the query involves
    &lt;literal&gt;GROUPING SETS&lt;/literal&gt;.  It can only be used when all joins involved in
    the query are also part of the parallel portion of the plan.
</span>
どんな状況でもパラレル集約がサポートされているわけではありません。
個々の集約は並列処理<a class="link" href="parallel-safety.html" title="15.4. パラレル安全">安全</a>で、結合関数(combine function)を持っていなければなりません。
その集約が<code class="literal">internal</code>型の遷移状態を持っているならば、シリアライズ関数とデシリアライズ関数を持っていなければなりません。
更なる詳細は<a class="xref" href="sql-createaggregate.html" title="CREATE AGGREGATE"><span class="refentrytitle">CREATE AGGREGATE</span></a>をご覧ください。
パラレル集約は、集約関数呼び出しが<code class="literal">DISTINCT</code>あるいは<code class="literal">ORDER BY</code>句を含む場合、また 順序集合集約、あるいはクエリが<code class="literal">GROUPING SETS</code>を実行する場合にはサポートされません。
パラレル集約は、クエリの中で実行されるすべての結合が、プラン中の並列実行部分の一部であるときにのみ利用できます。
  </p></div><div class="sect2" id="PARALLEL-APPEND"><div class="titlepage"><div><div><h3 class="title">15.3.4. パラレルアペンド</h3></div></div></div><span class="original">
  &lt;title&gt;Parallel Append&lt;/title&gt;
</span><p>
<span class="original">
    Whenever &lt;productname&gt;PostgreSQL&lt;/productname&gt; needs to combine rows
    from multiple sources into a single result set, it uses an
    &lt;literal&gt;Append&lt;/literal&gt; or &lt;literal&gt;MergeAppend&lt;/literal&gt; plan node.
    This commonly happens when implementing &lt;literal&gt;UNION ALL&lt;/literal&gt; or
    when scanning a partitioned table.  Such nodes can be used in parallel
    plans just as they can in any other plan.  However, in a parallel plan,
    the planner may instead use a &lt;literal&gt;Parallel Append&lt;/literal&gt; node.
</span>
<span class="productname">PostgreSQL</span>が複数のソースから一つの結果セットへの行の連結を必要とするときはいつでも、<code class="literal">Append</code>または<code class="literal">MergeAppend</code>プランノードが使われます。
これは一般に<code class="literal">UNION ALL</code>を実施するときや、パーティションテーブルをスキャンするときに発生します。
他のプランと同様にこのようなノードをパラレルプランで使うことができます。
しかしながら、パラレルプランではプランナは代わりに<code class="literal">Parallel Append</code>ノードを使ってもよいです。
  </p><p>
<span class="original">
    When an &lt;literal&gt;Append&lt;/literal&gt; node is used in a parallel plan, each
    process will execute the child plans in the order in which they appear,
    so that all participating processes cooperate to execute the first child
    plan until it is complete and then move to the second plan at around the
    same time.  When a &lt;literal&gt;Parallel Append&lt;/literal&gt; is used instead, the
    executor will instead spread out the participating processes as evenly as
    possible across its child plans, so that multiple child plans are executed
    simultaneously.  This avoids contention, and also avoids paying the startup
    cost of a child plan in those processes that never execute it.
</span>
<code class="literal">Append</code>ノードがパラレルプランで使われるとき、各プロセスは子プランをそれらの出現順に実行します。そのため、全ての参加しているプロセスは共同して最初の子プランを完了するまで実行して、その後、一斉に次プランに移ります。
代わりに<code class="literal">Parallel Append</code>が使われるときには、エグゼキュータは逆に参加しているプロセスを各子プランにできるだけ均等に分散させます。そのため、複数の子プランは同時並行に実行されます。
これは競合を回避し、また、プランを実行することのないプロセスで子プランの開始コストが生じることも回避します。
  </p><p>
<span class="original">
    Also, unlike a regular &lt;literal&gt;Append&lt;/literal&gt; node, which can only have
    partial children when used within a parallel plan, a &lt;literal&gt;Parallel
    Append&lt;/literal&gt; node can have both partial and non-partial child plans.
    Non-partial children will be scanned by only a single process, since
    scanning them more than once would produce duplicate results.  Plans that
    involve appending multiple results sets can therefore achieve
    coarse-grained parallelism even when efficient partial plans are not
    available.  For example, consider a query against a partitioned table
    which can be only be implemented efficiently by using an index that does
    not support parallel scans.  The planner might choose a &lt;literal&gt;Parallel
    Append&lt;/literal&gt; of regular &lt;literal&gt;Index Scan&lt;/literal&gt; plans; each
    individual index scan would have to be executed to completion by a single
    process, but different scans could be performed at the same time by
    different processes.
</span>
また、パラレルプランの中で使われるときだけ部分的な子プランを持てる、通常の<code class="literal">Append</code>ノードと違い、<code class="literal">Parallel Append</code>ノードは部分的、非部分的のどちらの子プランも持つことができます。
複数回のスキャンは重複した結果をもたらすため、非部分的な子プランは単一プロセスのみからスキャンされます。
複数の結果セットの連結に関わるプランは、効率的なパラレルプランが不可能なときでも、それゆえ粗い並列性を実現できます。
例えば、パラレルスキャンをサポートしないインデックスを使うことでのみ効率的に実行できるパーティションテーブルに対する問い合わせを考えてください。
プランナは通常の<code class="literal">Index Scan</code>プランの<code class="literal">Parallel Append</code>を選ぶことができます。
個々のインデックススキャンは単一プロセスで最後まで実行しなければなりませんが、別のスキャンは同時に別プロセスで実行することができます。
  </p><p>
<span class="original">
    &lt;xref linkend="guc-enable-parallel-append" /&gt; can be used to disable
    this feature.
</span>
本機能を無効にするために<a class="xref" href="runtime-config-query.html#GUC-ENABLE-PARALLEL-APPEND">enable_parallel_append</a>を使用できます。
  </p></div><div class="sect2" id="PARALLEL-PLAN-TIPS"><div class="titlepage"><div><div><h3 class="title">15.3.5. パラレルプランに関するヒント</h3></div></div></div><span class="original">
  &lt;title&gt;Parallel Plan Tips&lt;/title&gt;
</span><p>
<span class="original">
    If a query that is expected to do so does not produce a parallel plan,
    you can try reducing &lt;xref linkend="guc-parallel-setup-cost"/&gt; or
    &lt;xref linkend="guc-parallel-tuple-cost"/&gt;.  Of course, this plan may turn
    out to be slower than the serial plan which the planner preferred, but
    this will not always be the case.  If you don't get a parallel
    plan even with very small values of these settings (e.g. after setting
    them both to zero), there may be some reason why the query planner is
    unable to generate a parallel plan for your query.  See
    &lt;xref linkend="when-can-parallel-query-be-used"/&gt; and
    &lt;xref linkend="parallel-safety"/&gt; for information on why this may be
    the case.
</span>
パラレルプランを生成すると期待していたクエリがそうならない場合には、<a class="xref" href="runtime-config-query.html#GUC-PARALLEL-SETUP-COST">parallel_setup_cost</a>または<a class="xref" href="runtime-config-query.html#GUC-PARALLEL-TUPLE-COST">parallel_tuple_cost</a>を減らしてみてください。
もちろん、このプランは結局のところ、プランナが選択した順次実行プランよりも遅いということもあり得ますが、いつもそうだとは限りません。
これらの設定値を非常に小さく（つまり両方とも0に）したにも関わらずパラレルプランを得られない場合、あなたのクエリのためにクエリプランナがパラレルプランを生成できない何か理由があるのかもしれません。
そうしたケースに該当しているかどうかを、<a class="xref" href="when-can-parallel-query-be-used.html" title="15.2. どのような時にパラレルクエリは使用できるのか？">15.2</a>と<a class="xref" href="parallel-safety.html" title="15.4. パラレル安全">15.4</a>を参照して確認してください。
  </p><p>
<span class="original">
    When executing a parallel plan, you can use &lt;literal&gt;EXPLAIN (ANALYZE,
    VERBOSE)&lt;/literal&gt; to display per-worker statistics for each plan node.
    This may be useful in determining whether the work is being evenly
    distributed between all plan nodes and more generally in understanding the
    performance characteristics of the plan.
</span>
パラレルプランを実行する際には、<code class="literal">EXPLAIN (ANALYZE, VERBOSE)</code>を使って個々のプランノードに対するワーカーごとの状態を表示することができます。
これは、すべてのプランノードに均等に仕事が分散されているかどうかを確認すること、そしてもっと一般的には、プランの性能特性を理解するのに役に立つかもしれません。
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="when-can-parallel-query-be-used.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="parallel-query.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="parallel-safety.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">15.2. どのような時にパラレルクエリは使用できるのか？ </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 15.4. パラレル安全</td></tr></table></div></body></html>