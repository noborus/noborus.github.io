<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>26.2. ログシッピングスタンバイサーバ</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="different-replication-solutions.html" title="26.1. 様々な解法の比較" /><link rel="next" href="warm-standby-failover.html" title="26.3. フェイルオーバー" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 11.5文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="high-availability.html" title="第26章 高可用性、負荷分散およびレプリケーション">第26章 高可用性、負荷分散およびレプリケーション</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 11.5 &#10;                      warm-standby.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="different-replication-solutions.html" title="26.1. 様々な解法の比較">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="high-availability.html" title="第26章 高可用性、負荷分散およびレプリケーション">上へ</a></td><td width="60%" align="center">26.2. ログシッピングスタンバイサーバ</td><td width="20%" align="right"> <a accesskey="n" href="warm-standby-failover.html" title="26.3. フェイルオーバー">次へ</a></td></tr></table><hr /></div><div class="sect1" id="WARM-STANDBY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">26.2. ログシッピングスタンバイサーバ</h2></div></div></div><span class="original">
 &lt;title&gt;Log-Shipping Standby Servers&lt;/title&gt;
</span><p>
<span class="original">
   Continuous archiving can be used to create a &lt;firstterm&gt;high
   availability&lt;/firstterm&gt; (HA) cluster configuration with one or more
   &lt;firstterm&gt;standby servers&lt;/firstterm&gt; ready to take over operations if the
   primary server fails. This capability is widely referred to as
   &lt;firstterm&gt;warm standby&lt;/firstterm&gt; or &lt;firstterm&gt;log shipping&lt;/firstterm&gt;.
</span>
継続的なアーカイブ処理を使用して、プライマリサーバが失敗した場合に操作を引き継ぐ準備がなされた、1つ以上の<em class="firstterm">スタンバイサーバ</em>を持つ<em class="firstterm">高可用性</em>(HA)クラスタ構成を作成することができます。
この機能は<em class="firstterm">ウォームスタンバイ</em>または<em class="firstterm">ログシッピング</em>として広く知られています。
  </p><p>
<span class="original">
   The primary and standby server work together to provide this capability,
   though the servers are only loosely coupled. The primary server operates
   in continuous archiving mode, while each standby server operates in
   continuous recovery mode, reading the WAL files from the primary. No
   changes to the database tables are required to enable this capability,
   so it offers low administration overhead compared to some other
   replication solutions. This configuration also has relatively low
   performance impact on the primary server.
</span>
プライマリサーバとスタンバイサーバは、この機能を提供するために共同して稼動しますが、サーバとサーバはゆるく結合しています。
プライマリサーバは継続的アーカイブモードで動作し、各スタンバイサーバはプライマリからWALファイルを読み取る、継続的リカバリモードで動作します。
この機能を可能にするために、データベースのテーブル変更は不要です。
したがって、他のレプリケーションの解法に比べて、管理にかかるオーバーヘッドが減少します。
この構成はプライマリサーバの性能への影響も相対的に減少させます。
  </p><p>
<span class="original">
   Directly moving WAL records from one database server to another
   is typically described as log shipping. &lt;productname&gt;PostgreSQL&lt;/productname&gt;
   implements file-based log shipping by transferring WAL records
   one file (WAL segment) at a time. WAL files (16MB) can be
   shipped easily and cheaply over any distance, whether it be to an
   adjacent system, another system at the same site, or another system on
   the far side of the globe. The bandwidth required for this technique
   varies according to the transaction rate of the primary server.
   Record-based log shipping is more granular and streams WAL changes
   incrementally over a network connection (see &lt;xref
   linkend="streaming-replication"/&gt;).
</span>
あるデータベースサーバから他へ直接WALレコードを移動することは通常、ログシッピングと説明されます。
<span class="productname">PostgreSQL</span>はファイルベースのログシッピングを実装します。
つまりWALレコードはある時点で1つのファイル(WALセグメント)として送信されることを意味します。
WALファイル(16MB)は隣り合うシステム、同じサイトの別システム、地球の裏側のシステムなど距離に関わらず、簡単かつ安価に送付することができます。
この技法に必要な帯域幅はプライマリサーバのトランザクションの頻度に応じて変動します。
レコードベースのログシッピングはより粒度を細かくしたもので、ネットワーク接続を介してWALの変更を増分的に流します（<a class="xref" href="warm-standby.html#STREAMING-REPLICATION" title="26.2.5. ストリーミングレプリケーション">26.2.5</a>参照）。
  </p><p>
<span class="original">
   It should be noted that log shipping is asynchronous, i.e., the WAL
   records are shipped after transaction commit. As a result, there is a
   window for data loss should the primary server suffer a catastrophic
   failure; transactions not yet shipped will be lost.  The size of the
   data loss window in file-based log shipping can be limited by use of the
   &lt;varname&gt;archive_timeout&lt;/varname&gt; parameter, which can be set as low
   as a few seconds.  However such a low setting will
   substantially increase the bandwidth required for file shipping.
   Streaming replication (see &lt;xref linkend="streaming-replication"/&gt;)
   allows a much smaller window of data loss.
</span>
ログシッピングが非同期であることに注意しなければなりません。
つまり、WALレコードはトランザクションがコミットした後に転送されます。
結果として、プライマリサーバが災害などの致命的な失敗をうけた場合、送信されていないトランザクションが失われますので、データを損失する空白期間があります。
ファイルベースのログシッピングにおけるデータ損失の空白期間量を<code class="varname">archive_timeout</code>パラメータを用いて制限することができます。
これは数秒程度まで小さく設定することができます。
しかし、低く設定するとファイル転送に必要な帯域幅が増大します。
ストリーミングレプリケーション（<a class="xref" href="warm-standby.html#STREAMING-REPLICATION" title="26.2.5. ストリーミングレプリケーション">26.2.5</a>参照）により、データを損失する期間を非常に小さくすることができます。
  </p><p>
<span class="original">
   Recovery performance is sufficiently good that the standby will
   typically be only moments away from full
   availability once it has been activated. As a result, this is called
   a warm standby configuration which offers high
   availability. Restoring a server from an archived base backup and
   rollforward will take considerably longer, so that technique only
   offers a solution for disaster recovery, not high availability.
   A standby server can also be used for read-only queries, in which case
   it is called a Hot Standby server. See &lt;xref linkend="hot-standby"/&gt; for
   more information.
</span>
リカバリ処理の性能は十分よく、一度実施されれば、スタンバイサーバが完全な状態から逸脱するのは一時的にしかすぎません。
結果としてこれは、高可用性を提供するウォームスタンバイ構成と呼ばれます。
保管されたベースバックアップからサーバをリストアし、ロールフォワードを行うことはおそらく長時間かかりますので、これは高可用性のための解法とはいえず、災害からのリカバリのための解法です。
スタンバイサーバは読み取り専用の問い合わせに使用することもできます。
この場合ホットスタンバイサーバと呼ばれます。
詳細については<a class="xref" href="hot-standby.html" title="26.5. ホットスタンバイ">26.5</a>を参照してください。
  </p><a id="id-1.6.13.16.7" class="indexterm"></a><a id="id-1.6.13.16.8" class="indexterm"></a><a id="id-1.6.13.16.9" class="indexterm"></a><a id="id-1.6.13.16.10" class="indexterm"></a><a id="id-1.6.13.16.11" class="indexterm"></a><a id="id-1.6.13.16.12" class="indexterm"></a><div class="sect2" id="STANDBY-PLANNING"><div class="titlepage"><div><div><h3 class="title">26.2.1. 計画</h3></div></div></div><span class="original">
   &lt;title&gt;Planning&lt;/title&gt;
</span><p>
<span class="original">
    It is usually wise to create the primary and standby servers
    so that they are as similar as possible, at least from the
    perspective of the database server.  In particular, the path names
    associated with tablespaces will be passed across unmodified, so both
    primary and standby servers must have the same mount paths for
    tablespaces if that feature is used.  Keep in mind that if
    &lt;xref linkend="sql-createtablespace"/&gt;
    is executed on the primary, any new mount point needed for it must
    be created on the primary and all standby servers before the command
    is executed. Hardware need not be exactly the same, but experience shows
    that maintaining two identical systems is easier than maintaining two
    dissimilar ones over the lifetime of the application and system.
    In any case the hardware architecture must be the same &amp;mdash; shipping
    from, say, a 32-bit to a 64-bit system will not work.
</span>
プライマリサーバとスタンバイサーバを、少なくともデータベースサーバという見地でできる限り同じになるように作成することを通常勧めます。
具体的には、テーブル空間に関連するパス名はそのまま渡されますので、テーブル空間機能を使用する場合には、プライマリとスタンバイサーバの両方でテーブル空間用のマウントパスを同じにしておかなければなりません。
<a class="xref" href="sql-createtablespace.html" title="CREATE TABLESPACE"><span class="refentrytitle">CREATE TABLESPACE</span></a>をプライマリで実行する場合、そのコマンドを実行する前に必要な新しいマウントポイントをプライマリとすべてのスタンバイサーバで作成しなければならないことに注意してください。
ハードウェアをまったく同じにする必要はありませんが、経験上アプリケーションとシステムの運用期間に渡って2つの同じシステムを管理する方が、異なる2つのシステムを管理するよりも簡単です。
いずれにしてもハードウェアアーキテクチャは必ず同じでなければなりません。
例えば32ビットシステムから64ビットシステムへのシッピングは動作しません。
   </p><p>
<span class="original">
    In general, log shipping between servers running different major
    &lt;productname&gt;PostgreSQL&lt;/productname&gt; release
    levels is not possible. It is the policy of the PostgreSQL Global
    Development Group not to make changes to disk formats during minor release
    upgrades, so it is likely that running different minor release levels
    on primary and standby servers will work successfully. However, no
    formal support for that is offered and you are advised to keep primary
    and standby servers at the same release level as much as possible.
    When updating to a new minor release, the safest policy is to update
    the standby servers first &amp;mdash; a new minor release is more likely
    to be able to read WAL files from a previous minor release than vice
    versa.
</span>
マイナーリリースの更新ではディスク書式を変更しないというのがPostgreSQLグローバル開発グループの方針ですので、プライマリサーバとスタンバイサーバとの間でマイナーリリースレベルの違いがあってもうまく動作するはずです。
しかし、この場合、公的なサポートは提供されません。
できる限りプライマリサーバとスタンバイサーバとで同じリリースレベルを使用してください。
新しいマイナーリリースに更新する場合、もっとも安全な方針はスタンバイサーバを先に更新することです。
新しいマイナーリリースは以前のマイナーリリースのWALファイルを読み込むことはできますが、逆はできないかもしれません。
   </p></div><div class="sect2" id="STANDBY-SERVER-OPERATION"><div class="titlepage"><div><div><h3 class="title">26.2.2. スタンバイサーバの動作</h3></div></div></div><span class="original">
   &lt;title&gt;Standby Server Operation&lt;/title&gt;
</span><p>
<span class="original">
    In standby mode, the server continuously applies WAL received from the
    master server. The standby server can read WAL from a WAL archive
    (see &lt;xref linkend="restore-command"/&gt;) or directly from the master
    over a TCP connection (streaming replication). The standby server will
    also attempt to restore any WAL found in the standby cluster's
    &lt;filename&gt;pg_wal&lt;/filename&gt; directory. That typically happens after a server
    restart, when the standby replays again WAL that was streamed from the
    master before the restart, but you can also manually copy files to
    &lt;filename&gt;pg_wal&lt;/filename&gt; at any time to have them replayed.
</span>
スタンバイモードでは、サーバは継続的にマスタサーバから受け取ったWALを適用します。
スタンバイサーバはWALアーカイブ(<a class="xref" href="archive-recovery-settings.html#RESTORE-COMMAND">restore_command</a>参照)から、または直接TCP接続(ストリーミングレプリケーション)を介してマスタサーバから、WALを読み取ることができます。
またスタンバイサーバはスタンバイクラスタの<code class="filename">pg_wal</code>ディレクトリにあるすべてのWALをリストアしようと試みます。
これはよくサーバの再起動後、スタンバイが再起動前にマスタから流れ込んだWALを再生する時に発生します。
しかしまたファイルを再生する任意の時点で、手作業で<code class="filename">pg_wal</code>にコピーすることもできます。
   </p><p>
<span class="original">
    At startup, the standby begins by restoring all WAL available in the
    archive location, calling &lt;varname&gt;restore_command&lt;/varname&gt;. Once it
    reaches the end of WAL available there and &lt;varname&gt;restore_command&lt;/varname&gt;
    fails, it tries to restore any WAL available in the &lt;filename&gt;pg_wal&lt;/filename&gt; directory.
    If that fails, and streaming replication has been configured, the
    standby tries to connect to the primary server and start streaming WAL
    from the last valid record found in archive or &lt;filename&gt;pg_wal&lt;/filename&gt;. If that fails
    or streaming replication is not configured, or if the connection is
    later disconnected, the standby goes back to step 1 and tries to
    restore the file from the archive again. This loop of retries from the
    archive, &lt;filename&gt;pg_wal&lt;/filename&gt;, and via streaming replication goes on until the server
    is stopped or failover is triggered by a trigger file.
</span>
起動時、スタンバイサーバは<code class="varname">restore_command</code>を呼び出して、アーカイブ場所にある利用可能なすべてのWALをリストアすることから始めます。
そこで利用可能なWALの終端に達し、<code class="varname">restore_command</code>が失敗すると、<code class="filename">pg_wal</code>ディレクトリにある利用可能な任意のWALのリストアを試みます。
ストリーミングレプリケーションが設定されている場合、これに失敗すると、スタンバイはプライマリサーバへの接続を試み、アーカイブまたは<code class="filename">pg_wal</code>内に存在した最終の有効レコードからWALのストリーミングを開始します。
ストリーミングレプリケーションが未設定時にこれに失敗する場合、または、接続が後で切断される場合、スタンバイは最初に戻り、アーカイブからのファイルのリストアを繰り返し行います。
このアーカイブ、<code class="filename">pg_wal</code>、ストリーミングレプリケーションからという再試行の繰り返しはサーバが停止する、あるいはトリガファイルによるフェイルオーバーが発行されるまで続きます。
   </p><p>
<span class="original">
    Standby mode is exited and the server switches to normal operation
    when &lt;command&gt;pg_ctl promote&lt;/command&gt; is run or a trigger file is found
    (&lt;varname&gt;trigger_file&lt;/varname&gt;). Before failover,
    any WAL immediately available in the archive or in &lt;filename&gt;pg_wal&lt;/filename&gt; will be
    restored, but no attempt is made to connect to the master.
</span>
<code class="command">pg_ctl promote</code>が実行された時またはトリガファイル(<code class="varname">trigger_file</code>)が存在する時、スタンバイモードは終了し、サーバは通常の動作に切り替わります。
フェイルオーバーの前に、アーカイブまたは<code class="filename">pg_wal</code>内の即座に利用可能なWALをすべてリストアします。
しかし、マスタへの接続を行おうとはしません。
   </p></div><div class="sect2" id="PREPARING-MASTER-FOR-STANDBY"><div class="titlepage"><div><div><h3 class="title">26.2.3. スタンバイサーバのためのマスタの準備</h3></div></div></div><span class="original">
   &lt;title&gt;Preparing the Master for Standby Servers&lt;/title&gt;
</span><p>
<span class="original">
    Set up continuous archiving on the primary to an archive directory
    accessible from the standby, as described
    in &lt;xref linkend="continuous-archiving"/&gt;. The archive location should be
    accessible from the standby even when the master is down, i.e. it should
    reside on the standby server itself or another trusted server, not on
    the master server.
</span>
<a class="xref" href="continuous-archiving.html" title="25.3. 継続的アーカイブとポイントインタイムリカバリ（PITR）">25.3</a>で説明したように、スタンバイからアクセス可能なアーカイブディレクトリに対してプライマリで継続的なアーカイブを設定してください。
このアーカイブ場所はマスタが停止した時であってもスタンバイからアクセス可能でなければなりません。
つまり、マスタサーバ上ではなく、スタンバイサーバ自身上に存在するか、または他の高信頼性サーバ上に存在しなければなりません。
   </p><p>
<span class="original">
    If you want to use streaming replication, set up authentication on the
    primary server to allow replication connections from the standby
    server(s); that is, create a role and provide a suitable entry or
    entries in &lt;filename&gt;pg_hba.conf&lt;/filename&gt; with the database field set to
    &lt;literal&gt;replication&lt;/literal&gt;.  Also ensure &lt;varname&gt;max_wal_senders&lt;/varname&gt; is set
    to a sufficiently large value in the configuration file of the primary
    server. If replication slots will be used,
    ensure that &lt;varname&gt;max_replication_slots&lt;/varname&gt; is set sufficiently
    high as well.
</span>
ストリーミングレプリケーションを使用したい場合、スタンバイサーバ(複数可)からのレプリケーション接続を受け付けるようにプライマリサーバで認証を設定してください。
つまり、ロールを作成し適切な項目を提供、あるいは、そのデータベースフィールドとして<code class="literal">replication</code>を持つ項目を<code class="filename">pg_hba.conf</code>内に設定してください。
また、プライマリサーバの設定ファイルにおいて<code class="varname">max_wal_senders</code>が十分大きな値に設定されていることを確認してください。
レプリケーションスロットを使用している場合は、<code class="varname">max_replication_slots</code>も十分に設定されているか確認してください。
   </p><p>
<span class="original">
    Take a base backup as described in &lt;xref linkend="backup-base-backup"/&gt;
    to bootstrap the standby server.
</span>
<a class="xref" href="continuous-archiving.html#BACKUP-BASE-BACKUP" title="25.3.2. ベースバックアップの作成">25.3.2</a>に記述したように、スタンバイサーバの再起動のために、ベースバックアップを取得してください。
   </p></div><div class="sect2" id="STANDBY-SERVER-SETUP"><div class="titlepage"><div><div><h3 class="title">26.2.4. スタンバイサーバの設定</h3></div></div></div><span class="original">
   &lt;title&gt;Setting Up a Standby Server&lt;/title&gt;
</span><p>
<span class="original">
    To set up the standby server, restore the base backup taken from primary
    server (see &lt;xref linkend="backup-pitr-recovery"/&gt;). Create a recovery
    command file &lt;filename&gt;recovery.conf&lt;/filename&gt; in the standby's cluster data
    directory, and turn on &lt;varname&gt;standby_mode&lt;/varname&gt;. Set
    &lt;varname&gt;restore_command&lt;/varname&gt; to a simple command to copy files from
    the WAL archive. If you plan to have multiple standby servers for high
    availability purposes, set &lt;varname&gt;recovery_target_timeline&lt;/varname&gt; to
    &lt;literal&gt;latest&lt;/literal&gt;, to make the standby server follow the timeline change
    that occurs at failover to another standby.
</span>
スタンバイサーバを設定するためには、プライマリサーバから取得したベースバックアップをリストアしてください(<a class="xref" href="continuous-archiving.html#BACKUP-PITR-RECOVERY" title="25.3.4. 継続的アーカイブによるバックアップを使用した復旧">25.3.4</a>参照)。
スタンバイのクラスタデータディレクトリ内に<code class="filename">recovery.conf</code>リカバリコマンドファイルを作成し、<code class="varname">standby_mode</code>を有効にしてください。
WALアーカイブからファイルをコピーする簡単なコマンドを<code class="varname">restore_command</code>に設定してください。
高可用性のために複数のスタンバイサーバを持たせようとしている場合、<code class="varname">recovery_target_timeline</code>を<code class="literal">latest</code>に設定し、スタンバイサーバが他のスタンバイにフェイルオーバーする時に発生するタイムラインの変更に従うようにします。
   </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
     Do not use pg_standby or similar tools with the built-in standby mode
     described here. &lt;varname&gt;restore_command&lt;/varname&gt; should return immediately
     if the file does not exist; the server will retry the command again if
     necessary. See &lt;xref linkend="log-shipping-alternative"/&gt;
     for using tools like pg_standby.
</span>
ここで説明した組み込みのスタンバイモードといっしょにpg_standbyや類似ツールを使用しないでください。
<code class="varname">restore_command</code>はファイルが存在しない場合に即座に終了しなければなりません。
サーバが必要に応じてそのコマンドを再度実行します。
pg_standbyのようなツールを使用するためには<a class="xref" href="log-shipping-alternative.html" title="26.4. この他のログシッピングの方法">26.4</a>を参照してください。
    </p></div><p>
<span class="original">
     If you want to use streaming replication, fill in
     &lt;varname&gt;primary_conninfo&lt;/varname&gt; with a libpq connection string, including
     the host name (or IP address) and any additional details needed to
     connect to the primary server. If the primary needs a password for
     authentication, the password needs to be specified in
     &lt;varname&gt;primary_conninfo&lt;/varname&gt; as well.
</span>
ストリーミングレプリケーションを使用したい場合には、ホスト名(またはIPアドレス)とプライマリサーバとの接続に必要な追加情報を含む、libpq接続文字列で<code class="varname">primary_conninfo</code>を記述してください。
プライマリで認証用のパスワードが必要な場合は<code class="varname">primary_conninfo</code>にそのパスワードも指定する必要があります。
   </p><p>
<span class="original">
    If you're setting up the standby server for high availability purposes,
    set up WAL archiving, connections and authentication like the primary
    server, because the standby server will work as a primary server after
    failover.
</span>
スタンバイサーバを高可用性を目的に設定しているのであれば、スタンバイサーバはフェイルオーバーの後プライマリサーバとして動作しますので、プライマリサーバと同様にWALアーカイブ処理、接続、認証を設定してください。
   </p><p>
<span class="original">
    If you're using a WAL archive, its size can be minimized using the &lt;xref
    linkend="archive-cleanup-command"/&gt; parameter to remove files that are no
    longer required by the standby server.
    The &lt;application&gt;pg_archivecleanup&lt;/application&gt; utility is designed specifically to
    be used with &lt;varname&gt;archive_cleanup_command&lt;/varname&gt; in typical single-standby
    configurations, see &lt;xref linkend="pgarchivecleanup"/&gt;.
    Note however, that if you're using the archive for backup purposes, you
    need to retain files needed to recover from at least the latest base
    backup, even if they're no longer needed by the standby.
</span>
WALアーカイブを使用している場合、<a class="xref" href="archive-recovery-settings.html#ARCHIVE-CLEANUP-COMMAND">archive_cleanup_command</a>パラメータを使用してスタンバイサーバで不要となったファイルを削除することで、その容量を最小化することができます。
特に<span class="application">pg_archivecleanup</span>ユーティリティは、典型的な単一スタンバイ構成（<a class="xref" href="pgarchivecleanup.html" title="pg_archivecleanup"><span class="refentrytitle"><span class="application">pg_archivecleanup</span></span></a>参照）における<code class="varname">archive_cleanup_command</code>と共に使用されるように設計されています。
しかし、バックアップを目的にアーカイブを使用している場合には、スタンバイから必要とされなくなったファイルであっても、最新のベースバックアップの時点からリカバリするために必要なファイルを保持しなければならないことに注意してください。
   </p><p>
<span class="original">
    A simple example of a &lt;filename&gt;recovery.conf&lt;/filename&gt; is:
</span>
<code class="filename">recovery.conf</code>の簡単な例を以下に示します。
</p><pre class="programlisting">
standby_mode = 'on'
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
restore_command = 'cp /path/to/archive/%f %p'
archive_cleanup_command = 'pg_archivecleanup /path/to/archive %r'
</pre><p>
   </p><p>
<span class="original">
    You can have any number of standby servers, but if you use streaming
    replication, make sure you set &lt;varname&gt;max_wal_senders&lt;/varname&gt; high enough in
    the primary to allow them to be connected simultaneously.
</span>
スタンバイサーバの台数に制限はありませんが、ストリーミングレプリケーションを使用するなら、プライマリサーバに同時に接続できるように<code class="varname">max_wal_senders</code>を十分な数に設定してください。
   </p></div><div class="sect2" id="STREAMING-REPLICATION"><div class="titlepage"><div><div><h3 class="title">26.2.5. ストリーミングレプリケーション</h3></div></div></div><span class="original">
   &lt;title&gt;Streaming Replication&lt;/title&gt;
</span><a id="id-1.6.13.16.17.2" class="indexterm"></a><p>
<span class="original">
    Streaming replication allows a standby server to stay more up-to-date
    than is possible with file-based log shipping. The standby connects
    to the primary, which streams WAL records to the standby as they're
    generated, without waiting for the WAL file to be filled.
</span>
ストリーミングレプリケーションによりスタンバイサーバはファイルベースのログシッピングよりもより最近の状態を維持できるようになります。
スタンバイは、WALレコードが生成された時にWALファイルがいっぱいになるまで待機せずにWALレコードをスタンバイに流し出すプライマリと接続します。
   </p><p>
<span class="original">
    Streaming replication is asynchronous by default
    (see &lt;xref linkend="synchronous-replication"/&gt;), in which case there is
    a small delay between committing a transaction in the primary and the
    changes becoming visible in the standby. This delay is however much
    smaller than with file-based log shipping, typically under one second
    assuming the standby is powerful enough to keep up with the load. With
    streaming replication, &lt;varname&gt;archive_timeout&lt;/varname&gt; is not required to
    reduce the data loss window.
</span>
ストリーミングレプリケーションはデフォルトで非同期で、(<a class="xref" href="warm-standby.html#SYNCHRONOUS-REPLICATION" title="26.2.8. 同期レプリケーション">26.2.8</a>参照)
この場合、プライマリでトランザクションがコミットされてから、その変更がスタンバイ側で参照可能になるまでの間にわずかな遅延がまだあります。
しかし、この遅延はファイルベースのログシッピングよりも非常に小さなもので、負荷に追随できる程度の能力があるスタンバイであれば通常は1秒以下です。
ストリーミングレプリケーションでは、データ損失期間を減らすための<code class="varname">archive_timeout</code>を必要としません。
   </p><p>
<span class="original">
    If you use streaming replication without file-based continuous
    archiving, the server might recycle old WAL segments before the standby
    has received them.  If this occurs, the standby will need to be
    reinitialized from a new base backup.  You can avoid this by setting
    &lt;varname&gt;wal_keep_segments&lt;/varname&gt; to a value large enough to ensure that
    WAL segments are not recycled too early, or by configuring a replication
    slot for the standby.  If you set up a WAL archive that's accessible from
    the standby, these solutions are not required, since the standby can
    always use the archive to catch up provided it retains enough segments.
</span>
ファイルベースの継続的アーカイブのないストリーミングレプリケーションを使用している場合、スタンバイが受け取る前に古いWALセグメントを再利用するかもしれません。
もし、そうなった場合はスタンバイは新しいベースバックアップから再作成しなければならなくなります。
<code class="varname">wal_keep_segments</code>を十分に大きくしたり、レプリケーションスロットにスタンバイを設定することでWALセグメントがすぐに再利用されることを防ぎ、これを防ぐことができます。WALアーカイブをスタンバイからアクセスできる位置に設定する場合は、スタンバイが常にWALセグメントを追随することができるため、これらの解決策は要求されません。
   </p><p>
<span class="original">
    To use streaming replication, set up a file-based log-shipping standby
    server as described in &lt;xref linkend="warm-standby"/&gt;. The step that
    turns a file-based log-shipping standby into streaming replication
    standby is setting &lt;varname&gt;primary_conninfo&lt;/varname&gt; setting in the
    &lt;filename&gt;recovery.conf&lt;/filename&gt; file to point to the primary server. Set
    &lt;xref linkend="guc-listen-addresses"/&gt; and authentication options
    (see &lt;filename&gt;pg_hba.conf&lt;/filename&gt;) on the primary so that the standby server
    can connect to the &lt;literal&gt;replication&lt;/literal&gt; pseudo-database on the primary
    server (see &lt;xref linkend="streaming-replication-authentication"/&gt;).
</span>
ストリーミングレプリケーションを使用するためには、<a class="xref" href="warm-standby.html" title="26.2. ログシッピングスタンバイサーバ">26.2</a>の説明のようにファイルベースのログシッピングを行うスタンバイサーバを設定してください。
ファイルベースのログシッピングを行うスタンバイをストリーミングレプリケーションを行うスタンバイに切り替える手順は、<code class="filename">recovery.conf</code>内の<code class="varname">primary_conninfo</code>設定をプライマリサーバを指し示すように設定することです。
スタンバイサーバがプライマリサーバ上の<code class="literal">replication</code>疑似データベースに接続できる(<a class="xref" href="warm-standby.html#STREAMING-REPLICATION-AUTHENTICATION" title="26.2.5.1. 認証">26.2.5.1</a>参照)ように、プライマリで<a class="xref" href="runtime-config-connection.html#GUC-LISTEN-ADDRESSES">listen_addresses</a>と認証オプション(<code class="filename">pg_hba.conf</code>参照)を設定してください。
   </p><p>
<span class="original">
    On systems that support the keepalive socket option, setting
    &lt;xref linkend="guc-tcp-keepalives-idle"/&gt;,
    &lt;xref linkend="guc-tcp-keepalives-interval"/&gt; and
    &lt;xref linkend="guc-tcp-keepalives-count"/&gt; helps the primary promptly
    notice a broken connection.
</span>
キープアライブソケットオプションをサポートするシステムでは、<a class="xref" href="runtime-config-connection.html#GUC-TCP-KEEPALIVES-IDLE">tcp_keepalives_idle</a>、<a class="xref" href="runtime-config-connection.html#GUC-TCP-KEEPALIVES-INTERVAL">tcp_keepalives_interval</a>および<a class="xref" href="runtime-config-connection.html#GUC-TCP-KEEPALIVES-COUNT">tcp_keepalives_count</a>を設定することで、プライマリの接続切断の即時検知に有用です。
   </p><p>
<span class="original">
    Set the maximum number of concurrent connections from the standby servers
    (see &lt;xref linkend="guc-max-wal-senders"/&gt; for details).
</span>
スタンバイサーバからの同時接続数の最大値を設定してください（詳細は<a class="xref" href="runtime-config-replication.html#GUC-MAX-WAL-SENDERS">max_wal_senders</a>を参照）。
   </p><p>
<span class="original">
    When the standby is started and &lt;varname&gt;primary_conninfo&lt;/varname&gt; is set
    correctly, the standby will connect to the primary after replaying all
    WAL files available in the archive. If the connection is established
    successfully, you will see a walreceiver process in the standby, and
    a corresponding walsender process in the primary.
</span>
スタンバイが起動し、<code class="varname">primary_conninfo</code>が正しく設定されると、スタンバイはアーカイブ内で利用可能なWALファイルをすべて再生した後にプライマリと接続します。
接続の確立に成功すると、スタンバイでWAL受信プロセスが存在し、プライマリで対応するWAL送信プロセスが存在します。
   </p><div class="sect3" id="STREAMING-REPLICATION-AUTHENTICATION"><div class="titlepage"><div><div><h4 class="title">26.2.5.1. 認証</h4></div></div></div><span class="original">
    &lt;title&gt;Authentication&lt;/title&gt;
</span><p>
<span class="original">
     It is very important that the access privileges for replication be set up
     so that only trusted users can read the WAL stream, because it is
     easy to extract privileged information from it.  Standby servers must
     authenticate to the primary as a superuser or an account that has the
     &lt;literal&gt;REPLICATION&lt;/literal&gt; privilege. It is recommended to create a
     dedicated user account with &lt;literal&gt;REPLICATION&lt;/literal&gt; and &lt;literal&gt;LOGIN&lt;/literal&gt;
     privileges for replication. While &lt;literal&gt;REPLICATION&lt;/literal&gt; privilege gives
     very high permissions, it does not allow the user to modify any data on
     the primary system, which the &lt;literal&gt;SUPERUSER&lt;/literal&gt; privilege does.
</span>
信頼できるユーザのみがWALストリームを読み取ることができるように、レプリケーション用のアクセス権限を設定することは非常に重要です。
WALから機密情報を取り出すことは簡単だからです。
スタンバイサーバはプライマリに対してプライマリのスーパーユーザか<code class="literal">REPLICATION</code>権限を持つアカウントとして認証されなければなりません。
レプリケーションのための<code class="literal">REPLICATION</code>権限 と <code class="literal">LOGIN</code>権限を持つ専用のユーザを作成することをお勧めします。
<code class="literal">REPLICATION</code>権限は非常に強力な権限なので、<code class="literal">SUPERUSER</code>のようにプライマリのデータを変更することを許可されていません。
    </p><p>
<span class="original">
     Client authentication for replication is controlled by a
     &lt;filename&gt;pg_hba.conf&lt;/filename&gt; record specifying &lt;literal&gt;replication&lt;/literal&gt; in the
     &lt;replaceable&gt;database&lt;/replaceable&gt; field. For example, if the standby is running on
     host IP &lt;literal&gt;192.168.1.100&lt;/literal&gt; and the account name for replication
     is &lt;literal&gt;foo&lt;/literal&gt;, the administrator can add the following line to the
     &lt;filename&gt;pg_hba.conf&lt;/filename&gt; file on the primary:
</span>
レプリケーション用のクライアント認証は<code class="filename">pg_hba.conf</code>内でその<em class="replaceable"><code>database</code></em>フィールドに<code class="literal">replication</code>を指定したレコードで制御されます。
例えば、スタンバイがIPアドレス<code class="literal">192.168.1.100</code>のホストで稼動し、レプリケーション用のアカウントの名前が<code class="literal">foo</code>である場合、管理者はプライマリ上の<code class="filename">pg_hba.conf</code>に以下の行を追加することができます。

</p><pre class="programlisting">
<span class="original">
# Allow the user "foo" from host 192.168.1.100 to connect to the primary
# as a replication standby if the user's password is correctly supplied.
</span>
# 利用者 foo のホスト 192.168.1.100 からプライマリサーバへのレプリケーションスタンバイとしての接続を
# 利用者のパスワードが正しく入力されたならば許可する
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    replication     foo             192.168.1.100/32        md5
</pre><p>
    </p><p>
<span class="original">
     The host name and port number of the primary, connection user name,
     and password are specified in the &lt;filename&gt;recovery.conf&lt;/filename&gt; file.
     The password can also be set in the &lt;filename&gt;~/.pgpass&lt;/filename&gt; file on the
     standby (specify &lt;literal&gt;replication&lt;/literal&gt; in the &lt;replaceable&gt;database&lt;/replaceable&gt;
     field).
     For example, if the primary is running on host IP &lt;literal&gt;192.168.1.50&lt;/literal&gt;,
     port &lt;literal&gt;5432&lt;/literal&gt;, the account name for replication is
     &lt;literal&gt;foo&lt;/literal&gt;, and the password is &lt;literal&gt;foopass&lt;/literal&gt;, the administrator
     can add the following line to the &lt;filename&gt;recovery.conf&lt;/filename&gt; file on the
     standby:
</span>
プライマリサーバのホスト名とポート番号、接続する利用者名およびパスワードは、<code class="filename">recovery.conf</code>ファイルで指定します。
パスワードはスタンバイサーバの<code class="filename">~/.pgpass</code>ファイルでも設定できます（<em class="replaceable"><code>database</code></em>フィールドの<code class="literal">replication</code>を指定します）。
例えば、プライマリサーバが稼動するホストの IP アドレスが<code class="literal">192.168.1.50</code>でポート番号が<code class="literal">5432</code>であり、レプリケーションのアカウント名が<code class="literal">foo</code>であり、パスワードが<code class="literal">foopass</code>である場合、管理者はスタンバイサーバの<code class="filename">recovery.conf</code>ファイルに次行を追加できます。

</p><pre class="programlisting">
<span class="original">
# The standby connects to the primary that is running on host 192.168.1.50
# and port 5432 as the user "foo" whose password is "foopass".
</span>
# プライマリサーバが 192.168.1.50 のホストの 5432ポートで稼動し
# 利用者名が foo でパスワードが foopass とする
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
</pre><p>
    </p></div><div class="sect3" id="STREAMING-REPLICATION-MONITORING"><div class="titlepage"><div><div><h4 class="title">26.2.5.2. 監視</h4></div></div></div><span class="original">
    &lt;title&gt;Monitoring&lt;/title&gt;
</span><p>
<span class="original">
     An important health indicator of streaming replication is the amount
     of WAL records generated in the primary, but not yet applied in the
     standby. You can calculate this lag by comparing the current WAL write
     location on the primary with the last WAL location received by the
     standby. These locations can be retrieved using
     &lt;function&gt;pg_current_wal_lsn&lt;/function&gt; on the primary and
     &lt;function&gt;pg_last_wal_receive_lsn&lt;/function&gt; on the standby,
     respectively (see &lt;xref linkend="functions-admin-backup-table"/&gt; and
     &lt;xref linkend="functions-recovery-info-table"/&gt; for details).
     The last WAL receive location in the standby is also displayed in the
     process status of the WAL receiver process, displayed using the
     &lt;command&gt;ps&lt;/command&gt; command (see &lt;xref linkend="monitoring-ps"/&gt; for details).
</span>
ストリーミングレプリケーションの重要な健全性尺度は、プライマリサーバで生成されたがスタンバイサーバではまだ適用されていないWALレコードの量です。
プライマリサーバの現在のWAL書き込み位置とスタンバイサーバの受理したWALの最終位置を比較すれば、この遅延を計算できます。
これらの位置は、プライマリサーバでは<code class="function">pg_current_wal_lsn</code>を、スタンバイサーバでは<code class="function">pg_last_wal_receive_lsn</code>を使用すれば検索できます（詳細は<a class="xref" href="functions-admin.html#FUNCTIONS-ADMIN-BACKUP-TABLE" title="表9.79 バックアップ制御関数">表 9.79</a>および<a class="xref" href="functions-admin.html#FUNCTIONS-RECOVERY-INFO-TABLE" title="表9.80 リカバリ情報関数">表 9.80</a>を参照）。
スタンバイサーバの最終位置は、<code class="command">ps</code>コマンドを使用して WAL受信プロセスの状態としても表示できます（詳細は<a class="xref" href="monitoring-ps.html" title="28.1. 標準的なUnixツール">28.1</a>を参照）。
    </p><p>
<span class="original">
     You can retrieve a list of WAL sender processes via the
     &lt;xref linkend="pg-stat-replication-view"/&gt; view. Large differences between
     &lt;function&gt;pg_current_wal_lsn&lt;/function&gt; and the view's &lt;literal&gt;sent_lsn&lt;/literal&gt; field
     might indicate that the master server is under heavy load, while
     differences between &lt;literal&gt;sent_lsn&lt;/literal&gt; and
     &lt;function&gt;pg_last_wal_receive_lsn&lt;/function&gt; on the standby might indicate
     network delay, or that the standby is under heavy load.
</span>
<a class="xref" href="monitoring-stats.html#PG-STAT-REPLICATION-VIEW" title="表28.5 pg_stat_replicationビュー">pg_stat_replication</a>ビューを介してWAL送信処理プロセスのリストを入手することができます。
<code class="function">pg_current_wal_lsn</code>とビューの<code class="literal">sent_lsn</code>フィールドとの違いが大きい場合、マスタサーバが高負荷状態であることを示している可能性があります。
一方でスタンバイサーバ上の<code class="literal">sent_lsn</code>と<code class="function">pg_last_wal_receive_lsn</code>の値の差異は、ネットワーク遅延、またはスタンバイが高負荷状態であることを示す可能性があります。
    </p><p>
<span class="original">
     On a hot standby, the status of the WAL receiver process can be retrieved
     via the &lt;xref linkend="pg-stat-wal-receiver-view"/&gt; view.  A large
     difference between &lt;function&gt;pg_last_wal_replay_lsn&lt;/function&gt; and the
     view's &lt;literal&gt;received_lsn&lt;/literal&gt; indicates that WAL is being
     received faster than it can be replayed.
</span>
ホットスタンバイ上では、WAL受信プロセスの状態は、<a class="xref" href="monitoring-stats.html#PG-STAT-WAL-RECEIVER-VIEW" title="表28.6 pg_stat_wal_receiverビュー">pg_stat_wal_receiver</a>ビューを通じて入手することができます。
<code class="function">pg_last_wal_replay_lsn</code>とビューの<code class="literal">received_lsn</code>との違いが大きい場合、WALのリプレイを上回る速さでWALが受信されていることを示しています。
    </p></div></div><div class="sect2" id="STREAMING-REPLICATION-SLOTS"><div class="titlepage"><div><div><h3 class="title">26.2.6. レプリケーションスロット</h3></div></div></div><span class="original">
   &lt;title&gt;Replication Slots&lt;/title&gt;
</span><a id="id-1.6.13.16.18.2" class="indexterm"></a><p>
<span class="original">
    Replication slots provide an automated way to ensure that the master does
    not remove WAL segments until they have been received by all standbys,
    and that the master does not remove rows which could cause a
    &lt;link linkend="hot-standby-conflict"&gt;recovery conflict&lt;/link&gt; even when the
    standby is disconnected.
</span>
レプリケーションスロットは、以下のことを保証する自動的な方法を提供します。
全てのスタンバイがWALセグメントを受け取るまでは、マスターがWALセグメントを削除しないこと、また、スタンバイが接続していない際にも、<a class="link" href="hot-standby.html#HOT-STANDBY-CONFLICT" title="26.5.2. 問い合わせコンフリクトの処理">リカバリの競合</a>が発生する可能性がある行をマスターが削除しないこと、です。
   </p><p>
<span class="original">
    In lieu of using replication slots, it is possible to prevent the removal
    of old WAL segments using &lt;xref linkend="guc-wal-keep-segments"/&gt;, or by
    storing the segments in an archive using
    &lt;xref linkend="guc-archive-command"/&gt;.
    However, these methods often result in retaining more WAL segments than
    required, whereas replication slots retain only the number of segments
    known to be needed.  An advantage of these methods is that they bound
    the space requirement for &lt;literal&gt;pg_wal&lt;/literal&gt;; there is currently no way
    to do this using replication slots.
</span>
レプリケーションスロットを使う代わりに、<a class="xref" href="runtime-config-replication.html#GUC-WAL-KEEP-SEGMENTS">wal_keep_segments</a>を使う、あるいは<a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-COMMAND">archive_command</a>を使用してセグメントをアーカイブに保存することによっても、古いWALセグメントの削除を防ぐことができます。
しかし、これらの方法はしばしば要求される以上のWALセグメントを残すことになってしまうのに対し、レプリケーションスロットは必要と判断されたセグメントのみを残します。
これらの方法のメリットの一つは<code class="literal">pg_wal</code>が要求する領域を制限できることです。現時点でレプリケーションスロットを使って同じことをする方法はありません。
   </p><p>
<span class="original">
    Similarly, &lt;xref linkend="guc-hot-standby-feedback"/&gt;
    and &lt;xref linkend="guc-vacuum-defer-cleanup-age"/&gt; provide protection against
    relevant rows being removed by vacuum, but the former provides no
    protection during any time period when the standby is not connected,
    and the latter often needs to be set to a high value to provide adequate
    protection.  Replication slots overcome these disadvantages.
</span>
同様に、<a class="xref" href="runtime-config-replication.html#GUC-HOT-STANDBY-FEEDBACK">hot_standby_feedback</a>と<a class="xref" href="runtime-config-replication.html#GUC-VACUUM-DEFER-CLEANUP-AGE">vacuum_defer_cleanup_age</a>は必要な行をvacuumが削除するのを防ぐ機能を提供しますが、前者はスタンバイが接続されていない間は行の保護を提供しませんし、後者は適切な保護を提供するために高い値を設定せざるを得ないことがしばしばあります。
レプリケーションスロットはこのような短所を克服しています。
   </p><div class="sect3" id="STREAMING-REPLICATION-SLOTS-MANIPULATION"><div class="titlepage"><div><div><h4 class="title">26.2.6.1. レプリケーションスロットへの問い合わせと操作</h4></div></div></div><span class="original">
    &lt;title&gt;Querying and manipulating replication slots&lt;/title&gt;
</span><p>
<span class="original">
     Each replication slot has a name, which can contain lower-case letters,
     numbers, and the underscore character.
</span>
いずれのレプリケーションスロットにも小文字、数字、アンダースコアを含む名前があります。
    </p><p>
<span class="original">
     Existing replication slots and their state can be seen in the
     &lt;link linkend="view-pg-replication-slots"&gt;&lt;structname&gt;pg_replication_slots&lt;/structname&gt;&lt;/link&gt;
     view.
</span>
レプリケーションスロットとその状態は<a class="link" href="view-pg-replication-slots.html" title="52.80. pg_replication_slots"><code class="structname">pg_replication_slots</code></a>
ビューより確認できます。
    </p><p>
<span class="original">
     Slots can be created and dropped either via the streaming replication
     protocol (see &lt;xref linkend="protocol-replication"/&gt;) or via SQL
     functions (see &lt;xref linkend="functions-replication"/&gt;).
</span>
レプリケーションスロットはストリーミングレプリケーションプロトコル( <a class="xref" href="protocol-replication.html" title="53.4. ストリーミングレプリケーションプロトコル">53.4</a>参照)もしくはSQL関数(<a class="xref" href="functions-admin.html#FUNCTIONS-REPLICATION" title="9.26.6. レプリケーション関数">9.26.6</a>参照)を使用し、作成や削除ができます。
    </p></div><div class="sect3" id="STREAMING-REPLICATION-SLOTS-CONFIG"><div class="titlepage"><div><div><h4 class="title">26.2.6.2. 設定の例</h4></div></div></div><span class="original">
    &lt;title&gt;Configuration Example&lt;/title&gt;
</span><p>
<span class="original">
     You can create a replication slot like this:
</span>
以下のような方法でレプリケーションスロットを作成できます。
</p><pre class="programlisting">
postgres=# SELECT * FROM pg_create_physical_replication_slot('node_a_slot');
  slot_name  | lsn
-------------+-----
 node_a_slot |

postgres=# SELECT slot_name, slot_type, active FROM pg_replication_slots;
  slot_name  | slot_type | active 
-------------+-----------+--------
 node_a_slot | physical  | f
(1 row)
</pre><p>
<span class="original">
     To configure the standby to use this slot, &lt;varname&gt;primary_slot_name&lt;/varname&gt;
     should be configured in the standby's &lt;filename&gt;recovery.conf&lt;/filename&gt;.
     Here is a simple example:
</span>
スタンバイのレプリケーションスロットを使用できるように設定するためには、<code class="varname">primary_slot_name</code>をスタンバイ側の<code class="filename">recovery.conf</code>に設定します。
以下は設定例です。：
</p><pre class="programlisting">
standby_mode = 'on'
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
primary_slot_name = 'node_a_slot'
</pre><p>
    </p></div></div><div class="sect2" id="CASCADING-REPLICATION"><div class="titlepage"><div><div><h3 class="title">26.2.7. カスケードレプリケーション</h3></div></div></div><span class="original">
   &lt;title&gt;Cascading Replication&lt;/title&gt;
</span><a id="id-1.6.13.16.19.2" class="indexterm"></a><p>
<span class="original">
    The cascading replication feature allows a standby server to accept replication
    connections and stream WAL records to other standbys, acting as a relay.
    This can be used to reduce the number of direct connections to the master
    and also to minimize inter-site bandwidth overheads.
</span>
カスケードレプリケーションは、リレーのような振る舞い、つまり、スタンバイサーバから他のスタンバイにレプリケーション接続し、WALレコードを送信することができます。
マスターサーバへ直接の接続を減らしたり、サイト相互の帯域オーバヘッドを最小化するために使用することができます。
   </p><p>
<span class="original">
    A standby acting as both a receiver and a sender is known as a cascading
    standby.  Standbys that are more directly connected to the master are known
    as upstream servers, while those standby servers further away are downstream
    servers.  Cascading replication does not place limits on the number or
    arrangement of downstream servers, though each standby connects to only
    one upstream server which eventually links to a single master/primary
    server.
</span>
カスケードスタンバイとして知られているとおり、スタンバイは受け取り手としても送り手としても振る舞うことができます。
よりマスターサーバに近いスタンバイサーバは上流サーバと呼ばれるのに対し、より遠いスタンバイサーバは下流サーバと呼ばれます。
カスケードレプリケーションには下流サーバの数に制限は設定されていません。しかし、どのスタンバイサーバも最終的には1つのマスター/プライマリサーバに繋がる1つの上流サーバに接続します。
   </p><p>
<span class="original">
    A cascading standby sends not only WAL records received from the
    master but also those restored from the archive. So even if the replication
    connection in some upstream connection is terminated, streaming replication
    continues downstream for as long as new WAL records are available.
</span>
カスケードスタンバイはマスターから受け取ったWALレコードだけでなく、アーカイブからリストアしたWALレコードも送信します。
このため、レプリケーション接続が上流サーバで切断しても、ストリーミングレプリケーションは下流サーバへ新しいWAL
レコードがある限り継続します。
   </p><p>
<span class="original">
    Cascading replication is currently asynchronous. Synchronous replication
    (see &lt;xref linkend="synchronous-replication"/&gt;) settings have no effect on
    cascading replication at present.
</span>
カスケードレプリケーションは現時点では非同期です。同期レプリケーション（参照<a class="xref" href="warm-standby.html#SYNCHRONOUS-REPLICATION" title="26.2.8. 同期レプリケーション">26.2.8</a>）の設定は現時点でカスケードレプリケーションへは影響を与えません。
   </p><p>
<span class="original">
    Hot Standby feedback propagates upstream, whatever the cascaded arrangement.
</span>
ホットスタンバイがどの様に配置されていても、ホットスタンバイフィードバックは上流に伝播します。
   </p><p>
<span class="original">
    If an upstream standby server is promoted to become new master, downstream
    servers will continue to stream from the new master if
    &lt;varname&gt;recovery_target_timeline&lt;/varname&gt; is set to &lt;literal&gt;'latest'&lt;/literal&gt;.
</span>
上流スタンバイサーバが昇格し、新しいマスターサーバになった場合、<code class="varname">recovery_target_timeline</code>が<code class="literal">'latest'</code>に設定されていれば、下流サーバは新マスターサーバからのストリーミングレプリケーションを継続します。
   </p><p>
<span class="original">
    To use cascading replication, set up the cascading standby so that it can
    accept replication connections (that is, set
    &lt;xref linkend="guc-max-wal-senders"/&gt; and &lt;xref linkend="guc-hot-standby"/&gt;,
    and configure
    &lt;link linkend="auth-pg-hba-conf"&gt;host-based authentication&lt;/link&gt;).
    You will also need to set &lt;varname&gt;primary_conninfo&lt;/varname&gt; in the downstream
    standby to point to the cascading standby.
</span>
カスケードレプリケーションを使うためには、カスケードスタンバイをセットアップ、つまり、レプリケーション接続を許可してください。(<a class="xref" href="runtime-config-replication.html#GUC-MAX-WAL-SENDERS">max_wal_senders</a>と<a class="xref" href="runtime-config-replication.html#GUC-HOT-STANDBY">hot_standby</a>および、 <a class="link" href="auth-pg-hba-conf.html" title="20.1. pg_hba.confファイル">クライアント認証</a>を設定してください)
また、下流スタンバイがカスケードスタンバイに接続できるために、下流スタンバイでは<code class="varname">primary_conninfo</code>を設定する必要があります。
   </p></div><div class="sect2" id="SYNCHRONOUS-REPLICATION"><div class="titlepage"><div><div><h3 class="title">26.2.8. 同期レプリケーション</h3></div></div></div><span class="original">
   &lt;title&gt;Synchronous Replication&lt;/title&gt;
</span><a id="id-1.6.13.16.20.2" class="indexterm"></a><p>
<span class="original">
    &lt;productname&gt;PostgreSQL&lt;/productname&gt; streaming replication is asynchronous by
    default. If the primary server
    crashes then some transactions that were committed may not have been
    replicated to the standby server, causing data loss. The amount
    of data loss is proportional to the replication delay at the time of
    failover.
</span>
<span class="productname">PostgreSQL</span>のストリーミングレプリケーションはデフォルトで非同期です。
プライマリサーバがクラッシュした場合、コミットされた一部のトランザクションがスタンバイサーバに複製されず、データ損失を引き起こす可能性があります。
データ損失量はフェイルオーバー時点のレプリケーション遅延に比例します。
   </p><p>
<span class="original">
    Synchronous replication offers the ability to confirm that all changes
    made by a transaction have been transferred to one or more synchronous
    standby servers. This extends that standard level of durability
    offered by a transaction commit. This level of protection is referred
    to as 2-safe replication in computer science theory, and group-1-safe
    (group-safe and 1-safe) when &lt;varname&gt;synchronous_commit&lt;/varname&gt; is set to
    &lt;literal&gt;remote_write&lt;/literal&gt;.
</span>
同期レプリケーションは、あるトランザクションでなされた変更はすべて、１つ以上の同期スタンバイサーバに転送されていることを確実にする機能を提供します。
これはトランザクションコミットで提供される永続性の標準レベルを拡張します。
この保護レベルはコンピュータ科学理論では、2-safeレプリケーション、そして<code class="varname">synchronous_commit</code>が<code class="literal">remote_write</code>に設定されている場合にはgroup-1-safe (group-safeと1-safe) と呼ばれます。
   </p><p>
<span class="original">
    When requesting synchronous replication, each commit of a
    write transaction will wait until confirmation is
    received that the commit has been written to the write-ahead log on disk
    of both the primary and standby server. The only possibility that data
    can be lost is if both the primary and the standby suffer crashes at the
    same time. This can provide a much higher level of durability, though only
    if the sysadmin is cautious about the placement and management of the two
    servers.  Waiting for confirmation increases the user's confidence that the
    changes will not be lost in the event of server crashes but it also
    necessarily increases the response time for the requesting transaction.
    The minimum wait time is the round-trip time between primary to standby.
</span>
同期レプリケーションを要求する時、書き込みトランザクションのコミットはそれぞれ、そのコミットがプライマリサーバおよびスタンバイサーバの両方で、ディスク上の書き込み先行ログに書き込まれたという確認を受けとるまで待機します。
データ損失が起こる可能性は、プライマリサーバとスタンバイサーバが同時にクラッシュしてしまった場合のみです。
これは非常に高い永続性を提供することができますが、それはシステム管理者が２つのサーバの設置と管理に関して注意を払っている場合のみです。
確認のための待機は、サーバがクラッシュした場合でも変更が失われないということでユーザからの信頼性が大きくなりますが、同時に要求するトランザクションの応答時間も必ず大きくなります。
最小待機時間はプライマリとスタンバイの間の往復遅延時間です。
   </p><p>
<span class="original">
    Read only transactions and transaction rollbacks need not wait for
    replies from standby servers. Subtransaction commits do not wait for
    responses from standby servers, only top-level commits. Long
    running actions such as data loading or index building do not wait
    until the very final commit message. All two-phase commit actions
    require commit waits, including both prepare and commit.
</span>
読み取り専用のトランザクションおよびトランザクションのロールバックはスタンバイサーバからの応答を待つ必要はありません。
副トランザクションのコミットもスタンバイサーバからの応答を待つことはなく、最上位レベルのコミットのみ待機します。
データロード処理やインデックス構築など長時間実行される操作は、最終コミットメッセージまで待機しません。
準備およびコミットの両方を含め、二相コミット動作はすべてコミット待機を必要とします。
   </p><p>
<span class="original">
    A synchronous standby can be a physical replication standby or a logical
    replication subscriber.  It can also be any other physical or logical WAL
    replication stream consumer that knows how to send the appropriate
    feedback messages.  Besides the built-in physical and logical replication
    systems, this includes special programs such
    as &lt;command&gt;pg_receivewal&lt;/command&gt; and &lt;command&gt;pg_recvlogical&lt;/command&gt;
    as well as some third-party replication systems and custom programs.
    Check the respective documentation for details on synchronous replication
    support.
</span>
同期スタンバイは、物理レプリケーションのスタンバイでも、論理レプリケーションのサブスクライバーのどちらでも構いません。
また同期スタンバイは、適切なフィードバックメッセージを送信する方法を知っている、物理あるいは論理WALレプリケーションストリームの消費者であっても構いません。
組み込みの物理あるいは論理レプリケーションシステムを別にすると、<code class="command">pg_receivewal</code>と<code class="command">pg_recvlogical</code>、それにサードパーティーのレプリケーションシステムとカスタムプログラムが該当します。
対応する同期レプリケーションのサポートの詳細に関するドキュメントを参照してください。
   </p><div class="sect3" id="SYNCHRONOUS-REPLICATION-CONFIG"><div class="titlepage"><div><div><h4 class="title">26.2.8.1. 基本設定</h4></div></div></div><span class="original">
    &lt;title&gt;Basic Configuration&lt;/title&gt;
</span><p>
<span class="original">
    Once streaming replication has been configured, configuring synchronous
    replication requires only one additional configuration step:
    &lt;xref linkend="guc-synchronous-standby-names"/&gt; must be set to
    a non-empty value.  &lt;varname&gt;synchronous_commit&lt;/varname&gt; must also be set to
    &lt;literal&gt;on&lt;/literal&gt;, but since this is the default value, typically no change is
    required.  (See &lt;xref linkend="runtime-config-wal-settings"/&gt; and
    &lt;xref linkend="runtime-config-replication-master"/&gt;.)
    This configuration will cause each commit to wait for
    confirmation that the standby has written the commit record to durable
    storage.
    &lt;varname&gt;synchronous_commit&lt;/varname&gt; can be set by individual
    users, so it can be configured in the configuration file, for particular
    users or databases, or dynamically by applications, in order to control
    the durability guarantee on a per-transaction basis.
</span>
一度、ストリーミングレプリケーションが設定されている場合、同期レプリケーションの設定には必要な追加設定は１つだけ：<a class="xref" href="runtime-config-replication.html#GUC-SYNCHRONOUS-STANDBY-NAMES">synchronous_standby_names</a>を空でない値に設定することです。
また<code class="varname">synchronous_commit</code>は<code class="literal">on</code>に設定されていなければなりませんが、これはデフォルト値ですので、通常は変更する必要はありません。(<a class="xref" href="runtime-config-wal.html#RUNTIME-CONFIG-WAL-SETTINGS" title="19.5.1. 諸設定">19.5.1</a> および<a class="xref" href="runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-MASTER" title="19.6.2. マスターサーバ">19.6.2</a>を参照してください)
この設定によりスタンバイがそのコミットレコードを信頼できるストレージに書き込んだことが確認できるまで、各コミットが待たされるようになります。
<code class="varname">synchronous_commit</code>は個々のユーザによって設定することができます。
このため、トランザクション単位を基準とした永続性の保証を制御するために、設定ファイルの中で特定のユーザまたはデータベースについて設定することも、アプリケーションによって動的に設定することもできます。
   </p><p>
<span class="original">
    After a commit record has been written to disk on the primary, the
    WAL record is then sent to the standby. The standby sends reply
    messages each time a new batch of WAL data is written to disk, unless
    &lt;varname&gt;wal_receiver_status_interval&lt;/varname&gt; is set to zero on the standby.
    In the case that &lt;varname&gt;synchronous_commit&lt;/varname&gt; is set to
    &lt;literal&gt;remote_apply&lt;/literal&gt;, the standby sends reply messages when the commit
    record is replayed, making the transaction visible.
    If the standby is chosen as a synchronous standby, according to the setting
    of &lt;varname&gt;synchronous_standby_names&lt;/varname&gt; on the primary, the reply
    messages from that standby will be considered along with those from other
    synchronous standbys to decide when to release transactions waiting for
    confirmation that the commit record has been received. These parameters
    allow the administrator to specify which standby servers should be
    synchronous standbys. Note that the configuration of synchronous
    replication is mainly on the master. Named standbys must be directly
    connected to the master; the master knows nothing about downstream
    standby servers using cascaded replication.
</span>
コミットレコードがプライマリ上のディスクに書き出された後、WALレコードがスタンバイに送信されます。
スタンバイにて<code class="varname">wal_receiver_status_interval</code>がゼロに設定されていない限り、スタンバイは新しいWALデータの塊がディスクに書き出される度に応答メッセージを返します。
<code class="varname">synchronous_commit</code>が<code class="literal">remote_apply</code>に設定されている場合には、コミットレコードが再生され、そのトランザクションが可視化されたときに応答メッセージを返します。
スタンバイが、プライマリ上の<code class="varname">synchronous_standby_names</code>にしたがって、同期スタンバイとして選ばれた時は、コミットレコードの受領の確認のために待機しているトランザクションをいつ解放すべきかを決めるために、他の同期スタンバイとともにそれらスタンバイからの応答メッセージが考慮されます。
これらのパラメータにより、管理者はどのスタンバイサーバを同期スタンバイとすべきかを指定することができます。
同期レプリケーションの設定は主にマスタでなされることに注意してください。
指名されたスタンバイは直接マスターサーバに接続される必要があります。
つまり、カスケードレプリケーションを使用している下流スタンバイサーバについて、マスターサーバは何も知りません。
   </p><p>
<span class="original">
    Setting &lt;varname&gt;synchronous_commit&lt;/varname&gt; to &lt;literal&gt;remote_write&lt;/literal&gt; will
    cause each commit to wait for confirmation that the standby has received
    the commit record and written it out to its own operating system, but not
    for the data to be flushed to disk on the standby.  This
    setting provides a weaker guarantee of durability than &lt;literal&gt;on&lt;/literal&gt;
    does: the standby could lose the data in the event of an operating system
    crash, though not a &lt;productname&gt;PostgreSQL&lt;/productname&gt; crash.
    However, it's a useful setting in practice
    because it can decrease the response time for the transaction.
    Data loss could only occur if both the primary and the standby crash and
    the database of the primary gets corrupted at the same time.
</span>
<code class="varname">synchronous_commit</code>を<code class="literal">remote_write</code>に設定することで、個々のコミットは、スタンバイサーバがコミットされたレコードを受け取り、オペレーティングシステムに書きだしたことが確認できるまで待ちますが、スタンバイ上のディスクに吐き出すまでは待ちません。
これは、<code class="literal">on</code>と設定するより、提供される永続性は弱くなります。
具体的には、スタンバイサーバはオペレーティングシステムがクラッシュした場合にデータを失う可能性がありますが、<span class="productname">PostgreSQL</span>がクラッシュした場合にはデータを失いません。
しかし、実用的にはこの設定はトランザクションの応答時間を短くすることができるので有用です。
データの損失は、プライマリサーバとスタンバイサーバが同時にクラッシュし、かつ、プライマリのデータベースが同時に壊れた場合にのみ発生します。
   </p><p>
<span class="original">
    Setting &lt;varname&gt;synchronous_commit&lt;/varname&gt; to &lt;literal&gt;remote_apply&lt;/literal&gt; will
    cause each commit to wait until the current synchronous standbys report
    that they have replayed the transaction, making it visible to user
    queries.  In simple cases, this allows for load balancing with causal
    consistency.
</span>
<code class="varname">synchronous_commit</code>を<code class="literal">remote_apply</code>に設定することで、現在の同期スタンバイがトランザクションを再生し、ユーザから見えるようにしたと報告するまでは各々のコミットは待たされます。
単純なケースでは、因果一貫性を保つ負荷分散を可能にします。
   </p><p>
<span class="original">
    Users will stop waiting if a fast shutdown is requested.  However, as
    when using asynchronous replication, the server will not fully
    shutdown until all outstanding WAL records are transferred to the currently
    connected standby servers.
</span>
高速シャットダウンが要求された場合、ユーザは待ち状態ではなくなります。
しかし非同期レプリケーションを使用している時と同じく、送信中のWALレコードが現在接続しているスタンバイサーバに転送されるまで、サーバは完全に停止しません。
   </p></div><div class="sect3" id="SYNCHRONOUS-REPLICATION-MULTIPLE-STANDBYS"><div class="titlepage"><div><div><h4 class="title">26.2.8.2. 複数の同期スタンバイ</h4></div></div></div><span class="original">
    &lt;title&gt;Multiple Synchronous Standbys&lt;/title&gt;
</span><p>
<span class="original">
    Synchronous replication supports one or more synchronous standby servers;
    transactions will wait until all the standby servers which are considered
    as synchronous confirm receipt of their data. The number of synchronous
    standbys that transactions must wait for replies from is specified in
    &lt;varname&gt;synchronous_standby_names&lt;/varname&gt;. This parameter also specifies
    a list of standby names and the method (&lt;literal&gt;FIRST&lt;/literal&gt; and
    &lt;literal&gt;ANY&lt;/literal&gt;) to choose synchronous standbys from the listed ones.
</span>
同期レプリケーションは、一つ以上の同期スタンバイサーバをサポートします。
同期と見なされるすべてのスタンバイサーバがデータの受領を確認するまで、トランザクションは待機します。
トランザクションが応答を待たなければならない同期スタンバイの数は、<code class="varname">synchronous_standby_names</code>で指定されます。
また、このパラメータには、スタンバイの名前のリストと、リストされたものから同期スタンバイを選ぶ方法（<code class="literal">FIRST</code>と<code class="literal">ANY</code>）を指定します。
   </p><p>
<span class="original">
    The method &lt;literal&gt;FIRST&lt;/literal&gt; specifies a priority-based synchronous
    replication and makes transaction commits wait until their WAL records are
    replicated to the requested number of synchronous standbys chosen based on
    their priorities. The standbys whose names appear earlier in the list are
    given higher priority and will be considered as synchronous. Other standby
    servers appearing later in this list represent potential synchronous
    standbys. If any of the current synchronous standbys disconnects for
    whatever reason, it will be replaced immediately with the
    next-highest-priority standby.
</span>
方法<code class="literal">FIRST</code>は優先度に基づく同期レプリケーションを指定し、優先度に応じて選択された同期スタンバイにWALレコードがレプリケーションされるまで、トランザクションのコミットは待機します。
リストの前の方に名前が書いてあるスタンバイにはより高い優先度が与えられ、同期とみなされます。
リストの後ろの方に書いてあるスタンバイは、潜在的な同期スタンバイであることを示します。
どんな理由であれ、現在のスタンバイのどれかの接続が切断されると、次に優先度が高いスタンバイがとって代わります。
   </p><p>
<span class="original">
    An example of &lt;varname&gt;synchronous_standby_names&lt;/varname&gt; for
    a priority-based multiple synchronous standbys is:
</span>
優先度に基づく複数同期スタンバイのための<code class="varname">synchronous_standby_names</code>の例を示します。
   </p><pre class="programlisting">
synchronous_standby_names = 'FIRST 2 (s1, s2, s3)'
</pre><p>
<span class="original">
    In this example, if four standby servers &lt;literal&gt;s1&lt;/literal&gt;, &lt;literal&gt;s2&lt;/literal&gt;,
    &lt;literal&gt;s3&lt;/literal&gt; and &lt;literal&gt;s4&lt;/literal&gt; are running, the two standbys
    &lt;literal&gt;s1&lt;/literal&gt; and &lt;literal&gt;s2&lt;/literal&gt; will be chosen as synchronous standbys
    because their names appear early in the list of standby names.
    &lt;literal&gt;s3&lt;/literal&gt; is a potential synchronous standby and will take over
    the role of synchronous standby when either of &lt;literal&gt;s1&lt;/literal&gt; or
    &lt;literal&gt;s2&lt;/literal&gt; fails. &lt;literal&gt;s4&lt;/literal&gt; is an asynchronous standby since
    its name is not in the list.
</span>
この例では、もし4つのスタンバイサーバ<code class="literal">s1</code>、<code class="literal">s2</code>、<code class="literal">s3</code>、<code class="literal">s4</code>が稼働中なら、<code class="literal">s1</code>と<code class="literal">s2</code>が同期スタンバイに選ばれます。
それらの名前がスタンバイ名のリストの最初の方にあるからです。
<code class="literal">s3</code>は潜在的な同期スタンバイで、<code class="literal">s1</code>あるいは<code class="literal">s2</code>が故障した時に同期スタンバイの役割を取って代わります。
このリストに名前が載っていないので、<code class="literal">s4</code>は非同期スタンバイです。
   </p><p>
<span class="original">
    The method &lt;literal&gt;ANY&lt;/literal&gt; specifies a quorum-based synchronous
    replication and makes transaction commits wait until their WAL records
    are replicated to &lt;emphasis&gt;at least&lt;/emphasis&gt; the requested number of
    synchronous standbys in the list.
</span>
方法<code class="literal">ANY</code>はクォーラムに基づく同期レプリケーションを指定し、<span class="emphasis"><em>少なくとも</em></span>リスト中で指定された数の同期スタンバイにWALレコードがレプリケーションされるまで、トランザクションのコミットを待たせます
   </p><p>
<span class="original">
    An example of &lt;varname&gt;synchronous_standby_names&lt;/varname&gt; for
    a quorum-based multiple synchronous standbys is:
</span>
クォーラムに基づく同期スタンバイのための<code class="varname">synchronous_standby_names</code>の例を示します。
</p><pre class="programlisting">
synchronous_standby_names = 'ANY 2 (s1, s2, s3)'
</pre><p>
<span class="original">
    In this example, if four standby servers &lt;literal&gt;s1&lt;/literal&gt;, &lt;literal&gt;s2&lt;/literal&gt;,
    &lt;literal&gt;s3&lt;/literal&gt; and &lt;literal&gt;s4&lt;/literal&gt; are running, transaction commits will
    wait for replies from at least any two standbys of &lt;literal&gt;s1&lt;/literal&gt;,
    &lt;literal&gt;s2&lt;/literal&gt; and &lt;literal&gt;s3&lt;/literal&gt;. &lt;literal&gt;s4&lt;/literal&gt; is an asynchronous
    standby since its name is not in the list.
</span>
この例では、もし4つのスタンバイサーバ<code class="literal">s1</code>、<code class="literal">s2</code>、<code class="literal">s3</code>、<code class="literal">s4</code>が稼働中なら、トランザクションのコミットは、<code class="literal">s1</code>、<code class="literal">s2</code>、<code class="literal">s3</code>のどれか二つのスタンバイから応答があるまで待たされます。
このリストに名前が載っていないので、<code class="literal">s4</code>は非同期スタンバイです。
   </p><p>
<span class="original">
    The synchronous states of standby servers can be viewed using
    the &lt;structname&gt;pg_stat_replication&lt;/structname&gt; view.
</span>
<code class="structname">pg_stat_replication</code>ビューを使って、スタンバイサーバの同期状態を見ることができます。
   </p></div><div class="sect3" id="SYNCHRONOUS-REPLICATION-PERFORMANCE"><div class="titlepage"><div><div><h4 class="title">26.2.8.3. 性能に関する考慮</h4></div></div></div><span class="original">
    &lt;title&gt;Planning for Performance&lt;/title&gt;
</span><p>
<span class="original">
    Synchronous replication usually requires carefully planned and placed
    standby servers to ensure applications perform acceptably. Waiting
    doesn't utilize system resources, but transaction locks continue to be
    held until the transfer is confirmed. As a result, incautious use of
    synchronous replication will reduce performance for database
    applications because of increased response times and higher contention.
</span>
通常、同期レプリケーションは、アプリケーションが満足できる程度に実行されることを確実にするために、注意深くスタンバイサーバを計画し設置しなければなりません。
待機のためにシステムリソースを使用することはありませんが、トランザクションロックは転送が確認されるまで継続して保持されます。
結果として同期レプリケーションを注意せずに使用すると、応答時間が増加する、および競合がより高くなるため、データベースアプリケーションの性能は低下します。
   </p><p>
<span class="original">
    &lt;productname&gt;PostgreSQL&lt;/productname&gt; allows the application developer
    to specify the durability level required via replication. This can be
    specified for the system overall, though it can also be specified for
    specific users or connections, or even individual transactions.
</span>
<span class="productname">PostgreSQL</span>ではアプリケーション開発者がレプリケーション経由で必要とする永続性レベルを指定することができます。
これをシステム全体に対して指定することができますし、特定のユーザ、接続、個々のトランザクションに対してさえ指定することもできます。
   </p><p>
<span class="original">
    For example, an application workload might consist of:
    10% of changes are important customer details, while
    90% of changes are less important data that the business can more
    easily survive if it is lost, such as chat messages between users.
</span>
例えばアプリケーションの作業量が、重要な顧客詳細の変更が10%、ユーザ間のチャットメッセージなど、あまり重要ではなく、失ったとしても業務をより簡単に戻すことができるようなデータの変更が90% という構成を考えてみます。
   </p><p>
<span class="original">
    With synchronous replication options specified at the application level
    (on the primary) we can offer synchronous replication for the most
    important changes, without slowing down the bulk of the total workload.
    Application level options are an important and practical tool for allowing
    the benefits of synchronous replication for high performance applications.
</span>
（プライマリ上で）アプリケーションレベルで指定する同期レプリケーションオプションを使用して、作業全体を低速化させることなく、最も重要な変更に対して同期レプリケーションを企てることができます。
アプリケーションレベルのオプションは、高い性能が求められるアプリケーションで同期レプリケーションの利点が得られる、重要かつ現実的な手段です。
   </p><p>
<span class="original">
    You should consider that the network bandwidth must be higher than
    the rate of generation of WAL data.
</span>
生成されるWALデータの割合よりネットワーク帯域幅が大きくなければならないことを考慮しなければなりません。
   </p></div><div class="sect3" id="SYNCHRONOUS-REPLICATION-HA"><div class="titlepage"><div><div><h4 class="title">26.2.8.4. 高可用性に関する検討</h4></div></div></div><span class="original">
    &lt;title&gt;Planning for High Availability&lt;/title&gt;
</span><p>
<span class="original">
    &lt;varname&gt;synchronous_standby_names&lt;/varname&gt; specifies the number and
    names of synchronous standbys that transaction commits made when
    &lt;varname&gt;synchronous_commit&lt;/varname&gt; is set to &lt;literal&gt;on&lt;/literal&gt;,
    &lt;literal&gt;remote_apply&lt;/literal&gt; or &lt;literal&gt;remote_write&lt;/literal&gt; will wait for
    responses from. Such transaction commits may never be completed
    if any one of synchronous standbys should crash.
</span>
<code class="varname">synchronous_commit</code>が、<code class="literal">on</code>、<code class="literal">remote_apply</code>、<code class="literal">remote_write</code>のいずれかに設定されている場合、<code class="varname">synchronous_standby_names</code>には、コミットされたトランザクションが応答を待つ同期スタンバイの数と名前を指定します。
そのようなトランザクションのコミットは、同期スタンバイのどれかがクラッシュすると決して完了しないかもしれません。
   </p><p>
<span class="original">
    The best solution for high availability is to ensure you keep as many
    synchronous standbys as requested. This can be achieved by naming multiple
    potential synchronous standbys using &lt;varname&gt;synchronous_standby_names&lt;/varname&gt;.
</span>
高可用性のもっとも良い解決方法は、想定したのと同じ数の同期スタンバイを確実に確保することです。
これは、<code class="varname">synchronous_standby_names</code>を使って同期スタンバイ候補を複数指定することによって実現できます。
そのリストの最初の方に名前が上がっているスタンバイは、同期スタンバイとして使用されます。
その後の方に名前が上がっているスタンバイは、同期スタンバイのどれかが故障した時に、その役割を取って代わります。
   </p><p>
<span class="original">
    In a priority-based synchronous replication, the standbys whose names
    appear earlier in the list will be used as synchronous standbys.
    Standbys listed after these will take over the role of synchronous standby
    if one of current ones should fail.
</span>
優先度に基づく同期レプリケーションでは、リストの前の方に名前が現れるスタンバイが同期スタンバイになります。
現在の同期スタンバイのどれかが故障した際には、リストの後の方にあるスタンバイが同期スタンバイの役割を引き継ぎます。
   </p><p>
<span class="original">
    In a quorum-based synchronous replication, all the standbys appearing
    in the list will be used as candidates for synchronous standbys.
    Even if one of them should fail, the other standbys will keep performing
    the role of candidates of synchronous standby.
</span>
クォーラムに基づく同期レプリケーションでは、リストに現れたすべてのスタンバイが同期スタンバイの候補となります。
そのどれかが故障した場合でも、他のスタンバイは引き続き同期スタンバイの候補としての役割を担い続けます。
   </p><p>
<span class="original">
    When a standby first attaches to the primary, it will not yet be properly
    synchronized. This is described as &lt;literal&gt;catchup&lt;/literal&gt; mode. Once
    the lag between standby and primary reaches zero for the first time
    we move to real-time &lt;literal&gt;streaming&lt;/literal&gt; state.
    The catch-up duration may be long immediately after the standby has
    been created. If the standby is shut down, then the catch-up period
    will increase according to the length of time the standby has been down.
    The standby is only able to become a synchronous standby
    once it has reached &lt;literal&gt;streaming&lt;/literal&gt; state.
    This state can be viewed using
    the &lt;structname&gt;pg_stat_replication&lt;/structname&gt; view.
</span>
スタンバイが最初にプライマリに接続された時、それはまだ適切に同期されていません。
これは<code class="literal">catchup</code>モードと呼ばれます。
一旦スタンバイとプライマリ間の遅延がゼロになると、実時間<code class="literal">streaming</code>状態に移ります。
追従（catchup）期間はスタンバイが作成された直後は長くなるかもしれません。
スタンバイが停止している場合、追従期間はスタンバイの停止期間にしたがって長くなります。
スタンバイは、<code class="literal">streaming</code>状態に達した後でのみ、同期スタンバイになることができます。
この状態は、<code class="structname">pg_stat_replication</code>ビューで見ることができます。
   </p><p>
<span class="original">
    If primary restarts while commits are waiting for acknowledgement, those
    waiting transactions will be marked fully committed once the primary
    database recovers.
    There is no way to be certain that all standbys have received all
    outstanding WAL data at time of the crash of the primary. Some
    transactions may not show as committed on the standby, even though
    they show as committed on the primary. The guarantee we offer is that
    the application will not receive explicit acknowledgement of the
    successful commit of a transaction until the WAL data is known to be
    safely received by all the synchronous standbys.
</span>
コミットが受領通知を待機している間にプライマリが再起動した場合、プライマリデータベースが復旧した後、待機中のトランザクションは完全にコミットされたものと記録されます。
すべてのスタンバイがプライマリのクラッシュ時点で送信中のWALデータのすべてを受信したかどうかを確認する方法はありません。
トランザクションの一部は、プライマリではコミットされたものと表示されていたとしても、スタンバイではコミットされていないと表示されるかもしれません。
PostgreSQLは、WALデータをすべてのスタンバイが安全に受信したことが分かるまで、アプリケーションは明示的なトランザクションコミットの成功に関する受領通知を受けとらないことを保証しています。
   </p><p>
<span class="original">
    If you really cannot keep as many synchronous standbys as requested
    then you should decrease the number of synchronous standbys that
    transaction commits must wait for responses from
    in &lt;varname&gt;synchronous_standby_names&lt;/varname&gt; (or disable it) and
    reload the configuration file on the primary server.
</span>
要求していた数の同期スタンバイを本当に確保できないときは、トランザクションが応答を待たなければならない同期スタンバイの数を、<code class="varname">synchronous_standby_names</code>から減らしてください（もしくは無効にします）。
そして、プライマリサーバの設定ファイルを再読み込みしてください。
   </p><p>
<span class="original">
    If the primary is isolated from remaining standby servers you should
    fail over to the best candidate of those other remaining standby servers.
</span>
プライマリが既存のスタンバイサーバから切り離された場合は、スタンバイサーバの中から最善と思われる候補にフェイルオーバーしてください。
   </p><p>
<span class="original">
    If you need to re-create a standby server while transactions are
    waiting, make sure that the commands pg_start_backup() and
    pg_stop_backup() are run in a session with
    &lt;varname&gt;synchronous_commit&lt;/varname&gt; = &lt;literal&gt;off&lt;/literal&gt;, otherwise those
    requests will wait forever for the standby to appear.
</span>
トランザクションの待機中にスタンバイサーバを再作成する必要がある場合、pg_start_backup()およびpg_stop_backup()を実行するコマンドを<code class="varname">synchronous_commit</code> = <code class="literal">off</code>であるセッション内で確実に実行してください。
さもないとこれらの要求はスタンバイに現れるまで永遠に待機します。
   </p></div></div><div class="sect2" id="CONTINUOUS-ARCHIVING-IN-STANDBY"><div class="titlepage"><div><div><h3 class="title">26.2.9. スタンバイにおける継続的アーカイビング</h3></div></div></div><span class="original">
   &lt;title&gt;Continuous archiving in standby&lt;/title&gt;
</span><a id="id-1.6.13.16.21.2" class="indexterm"></a><p>
<span class="original">
     When continuous WAL archiving is used in a standby, there are two
     different scenarios: the WAL archive can be shared between the primary
     and the standby, or the standby can have its own WAL archive. When
     the standby has its own WAL archive, set &lt;varname&gt;archive_mode&lt;/varname&gt;
     to &lt;literal&gt;always&lt;/literal&gt;, and the standby will call the archive
     command for every WAL segment it receives, whether it's by restoring
     from the archive or by streaming replication. The shared archive can
     be handled similarly, but the &lt;varname&gt;archive_command&lt;/varname&gt; must
     test if the file being archived exists already, and if the existing file
     has identical contents. This requires more care in the
     &lt;varname&gt;archive_command&lt;/varname&gt;, as it must
     be careful to not overwrite an existing file with different contents,
     but return success if the exactly same file is archived twice. And
     all that must be done free of race conditions, if two servers attempt
     to archive the same file at the same time.
</span>
スタンバイにおいてWALの継続的アーカイビングが行われる場合、2つのシナリオが考えられます。
WALアーカイブがプライマリとスタンバイで共有されるケースと、スタンバイが自分のWALアーカイブを持つケースです。
スタンバイが自分のWALアーカイブを持つケースでは、<code class="varname">archive_mode</code>を<code class="literal">always</code>に設定しておくことにより、アーカイブからリストアされたWALセグメントであろうと、ストリーミングレプリケーション由来のWALセグメントであろうと、WALセグメントを受信する度にスタンバイはアーカイブコマンドを呼び出します。
共有アーカイブのケースも同じように扱えますが、<code class="varname">archive_command</code>はアーカイブしようとしているファイルがすでに存在していて、それが同一内容かどうかのチェックを行う必要があります。
このため、<code class="varname">archive_command</code>はより工夫が必要です。
というのも、<code class="varname">archive_command</code>は既存のファイルを異なる内容で置き換えてはいけませんし、またまったく同じ内容のファイルを置き換えた場合には成功したと報告しなければならないからです。
更に、2つのサーバが同時に同じファイルをアーカイブしようとした時に、競合状態が起きないようにしなければなりません。
   </p><p>
<span class="original">
     If &lt;varname&gt;archive_mode&lt;/varname&gt; is set to &lt;literal&gt;on&lt;/literal&gt;, the
     archiver is not enabled during recovery or standby mode. If the standby
     server is promoted, it will start archiving after the promotion, but
     will not archive any WAL it did not generate itself. To get a complete
     series of WAL files in the archive, you must ensure that all WAL is
     archived, before it reaches the standby. This is inherently true with
     file-based log shipping, as the standby can only restore files that
     are found in the archive, but not if streaming replication is enabled.
     When a server is not in recovery mode, there is no difference between
     &lt;literal&gt;on&lt;/literal&gt; and &lt;literal&gt;always&lt;/literal&gt; modes.
</span>
<code class="varname">archive_mode</code>が<code class="literal">on</code>の場合には、リカバリモードあるいはスタンバイモードではアーカイブは有効になりません。
スタンバイサーバが昇格すると、昇格後にスタンバイサーバはアーカイブを開始します。
しかし、自分が生成しなかったWALは一切アーカイブしません。
完全な一連のWALファイルをアーカイブから取り出すためには、WALがスタンバイに到着する前に、すべてのWALがアーカイブされていることを保証しなければなりません。
ファイルベースのログシッピングにおいても本質的にはこの通りです。
というのも、スタンバイはアーカイブにあるファイルだけをリストアできるからです。
ストリーミングレプリケーションが有効ならば、この限りではありません。
サーバがリカバリモードでない場合には、<code class="literal">on</code>と<code class="literal">always</code>のモードの間には違いはありません。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="different-replication-solutions.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="high-availability.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="warm-standby-failover.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">26.1. 様々な解法の比較 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 26.3. フェイルオーバー</td></tr></table></div></body></html>