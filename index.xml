<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Top on Noboru Saito's page</title><link>https://noborus.github.io/</link><description>Recent content in Top on Noboru Saito's page</description><generator>Hugo -- gohugo.io</generator><language>ja</language><copyright>&amp;copy;Noboru Saito 2019</copyright><lastBuildDate>Fri, 13 Dec 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://noborus.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>trdsql 目次</title><link>https://noborus.github.io/trdsql/</link><pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/trdsql/</guid><description>CSV,LTSV,JSON,TBLNファイルにSQLを実行できるツールのtrdsqlのドキュメントです。 trdsql Advent Calendar 2019として書かれています。 目次 インストール 変換 簡単なSQL 簡単なSQLその2 集計 集計計算 グループ集計 ログ集計 ワイルドカード、圧縮ファイル 標準入力 処理の概要 Postgr</description></item><item><title>About</title><link>https://noborus.github.io/about/</link><pubDate>Fri, 13 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/about/</guid><description>斉藤 登のページです。 noborus Links GitHub: https://github.com/noborus Twitter: https://twitter.com/noborus Qiita: https://qiita.com/noborus</description></item><item><title>tcellについて</title><link>https://noborus.github.io/blog/tcell_01/</link><pubDate>Wed, 13 May 2020 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/tcell_01/</guid><description>SetContent() goのTUIについてで書いたようにtcellのSetContent()は1文字設置していくのでASCIIの範囲内だと簡単ですが、Unicodeの世界では注意すべき点があります。 まず日本語などの全角幅の文字と半角幅の文字が混在すると全角幅のときには、次の文字は1つとばして設置する</description></item><item><title>goのTUIについて</title><link>https://noborus.github.io/blog/go_tui/</link><pubDate>Tue, 12 May 2020 23:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/go_tui/</guid><description>概要 goでTUI(text user interface)を作成する場合にライブラリを使用するのが一般的です。 goのTUIライブラリはだいたい以下に分類されます。 termbox-go系 tcell系 その他 TUIライブラリを謳っている場合は、だいたい上記2つを元に実装されている場合が多いです。</description></item><item><title>ov v0.1.3</title><link>https://noborus.github.io/blog/ov_013/</link><pubDate>Mon, 11 May 2020 10:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/ov_013/</guid><description>ov v0.1.3をリリースしました。 行番号モードを追加しました -nオプションをつけての起動又はGキー（トグル）により行番号モードになります。 交互の背景色の仕様を少し変更しました 交互の背景色を付けるモードでは、画面の端から端まで色を付けるように変更しました。 これにより空行でも背景色が</description></item><item><title>Oviewer</title><link>https://noborus.github.io/blog/oviewer_en/</link><pubDate>Sat, 25 Apr 2020 16:50:00 +0900</pubDate><guid>https://noborus.github.io/blog/oviewer_en/</guid><description>Introduction to OV - Oviewer.
Install You can also download binaries from the ov release, but for now it is still recommended to go get and download the latest version.
go get -u github.com/noborus/ov cd ov make install Features oviewer is a terminal pager like less or more.
Compressed (gzip, bzip2, zstd, lz4, xz) files can be displayed as they are. Better Unicode support. Can also display combined characters that can be displayed in the terminal (if fonts are available). Better wide (full-width) character support. Can be fixed by specifying the number of rows in the header. Ability to switch between wrapping and non-wrapping lines. Background color can be added to every 1 lines. Supports display from psql and mysql. The contents of the current screen can be exported at the end. The goal is to use the PAGER environment variable without problems.</description></item><item><title>Oviewer</title><link>https://noborus.github.io/blog/oviewer/</link><pubDate>Tue, 21 Apr 2020 14:50:00 +0900</pubDate><guid>https://noborus.github.io/blog/oviewer/</guid><description>私が作成中のov - Oviewerの紹介です。 最初Oviewerというレポジトリ名でしたが、コマンド名に合わせるようにovに変更しました。 インストール ov のリリースからバイナリもダウンロードできますが、今はまだgo getで最新をダウンロードして使うことをオススメします。 ※ 2020/5</description></item><item><title>GoのTUIで表示が崩れる場合</title><link>https://noborus.github.io/blog/runewidth/</link><pubDate>Mon, 06 Apr 2020 16:10:00 +0900</pubDate><guid>https://noborus.github.io/blog/runewidth/</guid><description>結論 gnome-terminalを使用している場合は、設定の「曖昧幅の文字(W)」と環境変数RUNEWIDTH_EASTASIANを一致させよう。 Ambiguous width(曖昧幅) ターミナル上のアプリケーション(TUI)では、GUIと違って文字単位で描画されます。 そして1文字の幅は固定されて</description></item><item><title>trdsql 0.7.5</title><link>https://noborus.github.io/blog/trdsql_075/</link><pubDate>Sat, 07 Mar 2020 10:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/trdsql_075/</guid><description>trdsql 0.7.5をリリースしました。 リリースのページから各バイナリがダウンロードできます。 圧縮ファイルへの対応を強化 trdsql 圧縮ファイルに書いたように圧縮ファイルのサポートを増やしました。 また、圧縮しての出力をできるようにしました。 ファイルへの出力 trdsql outputに書いたように出力ファイルを</description></item><item><title>trdsql output</title><link>https://noborus.github.io/blog/34_output/</link><pubDate>Mon, 02 Mar 2020 18:45:00 +0900</pubDate><guid>https://noborus.github.io/blog/34_output/</guid><description>今までは標準出力にのみ出力していましたが、-out ファイル名により、出力ファイルを指定できるようにしました。 -out ファイル名では出力ファイル名からファイル形式、圧縮形式を推測するモードをデフォルトで有効にしてあります。 出力ファイル名の拡張子が[.csv,.ltsv,json,json</description></item><item><title>trdsql 圧縮ファイル</title><link>https://noborus.github.io/blog/33_compression/</link><pubDate>Mon, 02 Mar 2020 17:52:00 +0900</pubDate><guid>https://noborus.github.io/blog/33_compression/</guid><description>圧縮ファイルに実行 0.7.4までは gzip(.gz)の圧縮形式のみの対応でしたが、最新のmaster(0.7.5以降の予定)では、gzip(gz)、bzip2(bz2)、zstd(zst)、lz4、xzの圧縮形式に対応しました。 従来は.gzの拡張子をみて判断していましたが、今回か</description></item><item><title>MySQL の LOAD DATA INFILE (go)</title><link>https://noborus.github.io/blog/mysql-load/</link><pubDate>Mon, 10 Feb 2020 15:09:00 +0900</pubDate><guid>https://noborus.github.io/blog/mysql-load/</guid><description>前提 LOAD DATA INFILEはMySQLサーバーがファイルを読み取ってデータベースのテーブルにインポートする構文ですが、LOAD DATA LOCAL INFILEはクライアント側のファイル（の内容）をサーバー側に送信してインポートします。 このLOCAL指定ですが、セキュリティ上の問題を抱えているため、最近</description></item><item><title>trdsql 0.7.4</title><link>https://noborus.github.io/blog/trdsql_074/</link><pubDate>Wed, 05 Feb 2020 10:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/trdsql_074/</guid><description>trdsql 0.7.4をリリースしました。 リリースのページから各バイナリがダウンロードできます。 全ての項目を二重引用符（”）で囲うオプション(-oaq)を追加 今回は、CSV出力に全ての項目を二重引用符（”）で囲うオプション(-oaq)を追加しました。 goのencoding/csvはRFC 4</description></item><item><title>trdsql CASE式</title><link>https://noborus.github.io/blog/32_case/</link><pubDate>Tue, 07 Jan 2020 10:18:00 +0900</pubDate><guid>https://noborus.github.io/blog/32_case/</guid><description>CASE式は、プログラム言語のif文やswitch文のような条件に分岐した処理をおこないます。単純な1を&amp;rsquo;A&amp;rsquo;に変換するような場合は、一時的なテーブルとJOINさせたり文字列の書き換えで可能ですが、 範囲を指定してグループ化したい場合はCASE式を使うと便利</description></item><item><title>trdsql 合計を行に追加する</title><link>https://noborus.github.io/blog/31_rollup/</link><pubDate>Sat, 04 Jan 2020 13:38:00 +0900</pubDate><guid>https://noborus.github.io/blog/31_rollup/</guid><description>Window関数により元のファイルの内容に列を追加して、集計結果を出せました。 ただ、人が確認する場合は、集計の結果行が最後に出るほうが確認しやすくなります。 通常のSQLでも元の内容と集計結果を別々に出してUNIONを使うことで、一つの結果として出すことが出来ますが、一回で済むなら</description></item><item><title>trdsql convert log</title><link>https://noborus.github.io/blog/30_convert_log/</link><pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/30_convert_log/</guid><description>既存のログをLTSVに変換する 既存のログをLTSVに変換にしてみます。 mingrammer/flog を使用するとフェイクのログが簡単に出力できるので、 これで出力されるログをLTSV形式に変換する方法を紹介します。 Apache common log 以下のコマンドにより apache_common形式のログをaccess.common.lo</description></item><item><title>trdsql generate_series</title><link>https://noborus.github.io/blog/29_generate_series/</link><pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/29_generate_series/</guid><description>generate_series PostgreSQLにはgenerate_series()という便利な関数があります。 これはUnixのseqコマンドと同じような働きをする関数です。またgenerate_series()は、タイムスタンプ型にも使用できる拡張があります。 使い方は簡単で「開始値」、「終了値」、「刻</description></item><item><title>trdsql CROSS JOIN</title><link>https://noborus.github.io/blog/28_cross_join/</link><pubDate>Sat, 28 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/28_cross_join/</guid><description>CROSS JOINは、総当りを簡単に作り出せる方法です。 a.csv aa ab ac b.csv ba bb bc の２つのCSVをCROSS JOINすると 3×3で全ての組み合わせを出力できます。 trdsql &amp;#34;SELECT * FROM a.csv CROSS JOIN b.csv&amp;#34; aa,ba aa,bb aa,bc ab,ba ab,bb ab,bc ac,ba ac,bb ac,bc また一つのファイルに対して自己結合をすることもできます。 例えば、ホーム＆アウェーの総当り表を作成してみ</description></item><item><title>trdsql config</title><link>https://noborus.github.io/blog/27_config/</link><pubDate>Fri, 27 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/27_config/</guid><description>trdsqlは設定ファイルが無くても動作しますが、設定ファイルによりデフォルトのデータベースのエンジンを変更できます。 configファイルの場所 -configオプションで、直接ファイルの場所を指定できます。 -configオプションを使用しないデフォルトの場所は以下です。 Linux</description></item><item><title>trdsql SQLファイル指定</title><link>https://noborus.github.io/blog/26_file_sql/</link><pubDate>Thu, 26 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/26_file_sql/</guid><description>SQLファイル名指定オプション「-q」 trdsql &amp;ldquo;SQLコマンド&amp;quot;の形式だと、長いSQLを書くのが難しいですし、シェルに対してエスケープしなければならない文字があって見た目もわかりにくい場合があります。 trdsqlではファイルにSQLを書いておき、そのファイルのSQ</description></item><item><title>trdsql ライブラリ使用</title><link>https://noborus.github.io/blog/25_library/</link><pubDate>Wed, 25 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/25_library/</guid><description>trdsqlは初期の頃は、main packageで構成されていましたが、現在はtrdsql packageをmainから呼び出す構成になっていて、trdsql packageをライブラリとして使用できます。 trdsqlのパッケージは、以下の構成になっていて、それぞれ呼び出し可能です。</description></item><item><title>trdsql グラフ</title><link>https://noborus.github.io/blog/24_graph/</link><pubDate>Tue, 24 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/24_graph/</guid><description>trdsqlは、グラフ作成機能は持っていないためグラフを作成したいときには別のツールを使用して作成することになります。 ExcelやLibreOfficeで描画するのが定番でしょうが、ここではmarianogappa/chartでグラフを描画する方法を紹介します。 marianoga</description></item><item><title>trdsql 差分、比較</title><link>https://noborus.github.io/blog/23_except/</link><pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/23_except/</guid><description>CSV同士やCSVとテーブルなどで、値の比較をしたい場合があります。 同じ形式で一部が違うCSVファイルであれば、diffを取る方法もありますが、trdsqlのSQLを使用して比較すると形式が違う場合の比較にも使用できます。 差分の出力 SQLで比較して、差分を出すには、EXCEPTを</description></item><item><title>trdsql JSON出力</title><link>https://noborus.github.io/blog/22_json_output/</link><pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/22_json_output/</guid><description>CSVやLTSVなどのフラットな形式のデータは、JSONにしたいときには（-ojsonによる）JSON出力をすれば良いですが、JSONは本来より深い階層も表現できるフォーマットです。 そのようなJSONは、データベースのJSON関数を使用することにより作成できます。 以下のCSVから</description></item><item><title>trdsql JSON解析</title><link>https://noborus.github.io/blog/21_json_parse/</link><pubDate>Sat, 21 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/21_json_parse/</guid><description>これまでtrdsqlでは、JSONの入力が可能と書きましたが、例として書いたのは基本的にフラットな構造のJSONでした。 ただ、２階層以上の階層構造が含まれるJSONはエラーになる訳ではなく、そのまま文字列として扱われます。 以下のようなJSONがあるとします。 sample.json [ { &amp;#34;color&amp;#34;: &amp;#34;white&amp;#34;, &amp;#34;category&amp;#34;: &amp;#34;value&amp;#34;, &amp;#34;code&amp;#34;: { &amp;#34;rgba&amp;#34;: [0,</description></item><item><title>trdsql 日付・時刻処理</title><link>https://noborus.github.io/blog/20_date/</link><pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/20_date/</guid><description>ファイル内に入っている日付、時刻をそのまま扱う場合は良いですが、変換等の処理をしたい場合があります。 その場合は、一旦日付や時刻と解釈させてから扱う方が扱いやすくなります。 SQLite3の日付、時刻処理 デフォルトのSQLite3の日付、時刻処理では、以下のフォーマットであれば、日付</description></item><item><title>trdsql Window関数</title><link>https://noborus.github.io/blog/19_window/</link><pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/19_window/</guid><description>これまでグループ集計による集計を紹介していますが、グループ集計は元の行とはまったく別にグループ毎の行を出力していました。 つまり、元のファイルとは別に集計の結果を出力していた訳です。 そうではなくて、元のファイルの情報にプラスして集計結果を出して欲しい場合があります。 例えば、点数の列</description></item><item><title>trdsql 列の編集</title><link>https://noborus.github.io/blog/18_edit_columns/</link><pubDate>Wed, 18 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/18_edit_columns/</guid><description>これまで列の並べ替えはしてきましたが、列の内容はそのままでした。 SQLでは、文字列の書き換えが得意分野とは言えませんが、SQLの関数を使うことにより、それなりできる機能は揃っています。 列の連結 「||」を使って、列名をつなげば、２つ以上の列を連結して一つの列になります。 trdsql -ih -oh \ &amp;#34;SELECT id,name||id</description></item><item><title>trdsql ファイルとテーブルのJOIN</title><link>https://noborus.github.io/blog/17_file_table/</link><pubDate>Tue, 17 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/17_file_table/</guid><description>既にテーブルが存在するデータベースに接続することにより、ファイルとテーブルをJOINすることもできます。 例えば、データベース内にfruitsというテーブルがあった場合に、前回のabc.csvとJOINできます。 trdsql -driver postgres -dsn &amp;#34;dbname=trdsql_test&amp;#34; \ &amp;#34;SELECT a.c1, a.c2, f.name FROM abc.csv AS a &amp;#34;\ &amp;#34;LEFT JOIN fruits AS f ON (CAST(a.c1 AS int) = f.id)&amp;#34; 1,AAA,Orange 2,BBB,Melon 3,CCC,Apple 例えば、デー</description></item><item><title>trdsql JOIN</title><link>https://noborus.github.io/blog/16_join/</link><pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/16_join/</guid><description>これまで一つのファイルにSQLを実行してきましたが、複数のファイルをJOINするSQLも実行できます。 以下の2つのCSVファイルがあったとして、 abc.csv 1,AAA 2,BBB 3,CCC price.csv 1,100 2,500 3,50 以下のように連結するのが、JOINです。 1,AAA,100 2,BBB,500 3,CCC,50 trdsqlではテーブルの代わりにファイル名を使用すれば、そのままSQLの</description></item><item><title>trdsql DBインポート</title><link>https://noborus.github.io/blog/15_import/</link><pubDate>Sun, 15 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/15_import/</guid><description>trdsqlにはデータベースにインポートするオプションはありません。 しかしながら、SELECT以外のSQLの実行も可能なので、SQLによるインポートが可能です。 以下は、メモリデータベースにインポートしても終了すると消えてしまうので、メモリデータベース以外のデータベースに接続して実</description></item><item><title>trdsql SQLite3エンジンの使用</title><link>https://noborus.github.io/blog/14_sqlite3/</link><pubDate>Sat, 14 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/14_sqlite3/</guid><description>SQLite3への接続方法を説明します。 SQLite3に接続 そもそもtrdsqlのデフォルトはSQLite3のメモリデータベースに接続していますが、メモリデータベース以外にも接続できます。 オプションの -driver に sqlite3 を指定し、-dsn にサーバーへの接続情報を指定します。 dsnはsqlite</description></item><item><title>trdsql MySQLエンジンの使用</title><link>https://noborus.github.io/blog/13_mysql/</link><pubDate>Fri, 13 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/13_mysql/</guid><description>前回はPostgreSQL接続の話でしたが、今度はMySQLに接続して使用する方法を説明します。 MySQLに接続 MySQLに接続するには動作しているMySQLサーバーが必要です。接続できテーブルが作成できる権限があるデータベースを作成しておきます。 オプションの -driver に mysql を指定し、-d</description></item><item><title>trdsql PostgreSQLエンジンの使用</title><link>https://noborus.github.io/blog/12_postgres/</link><pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/12_postgres/</guid><description>trdsqlは組込みのSQLite3を利用してSQLを実行していますが、データベースの処理を別のデータベースに変更出来ます。 ここではPostgreSQLを使用する方法を説明します。 PostgreSQLに接続 SQLite3と違いPostgreSQLは動作しているPostgreSQL</description></item><item><title>trdsql 処理の概要</title><link>https://noborus.github.io/blog/11_summary/</link><pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/11_summary/</guid><description>ここでtrdsqlの内部処理の概要を簡単に説明します。 trdsqlの内部処理は、以下のようになっています。 オプションやSQLコマンドの解釈 SQLコマンド内のファイル名をデータベースにインポート SQLの実行 指定された出力フォーマットで実行結果を出力 SQLの実行は実際のRDBMSを使</description></item><item><title>trdsql 標準入力</title><link>https://noborus.github.io/blog/10_stdin/</link><pubDate>Tue, 10 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/10_stdin/</guid><description>標準入力 trdsqlは他のUNIXツールのように標準入力からデータを受け取ることができます。ただSQLの文法上テーブル名を指定する必要があります。標準入力を使用するときは、「-」か「stdin」を使用します。 cat test.csv|trdsql -icsv &amp;#34;SELECT * FROM -&amp;#34; apple,100 orange,50 potato,30 （ここで注意が必要なのが、trdsqlは標準入力から</description></item><item><title>trdsql ワイルドカード、圧縮ファイル</title><link>https://noborus.github.io/blog/09_wildcard/</link><pubDate>Mon, 09 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/09_wildcard/</guid><description>Wildcard ここまでは一つのファイルを対象としてきましたが、ログファイル等はローテートされて複数のファイルになっている場合があります。 同じ列で構成されている対象ファイルであれば、ワイルドカードを使用して、複数のファイルを一つのテーブルとして扱うことができます。 ls test*.csv test1.csv test2.csv test3.csv trdsql -icsv &amp;#34;SELECT COUNT(*) FROM test*.csv&amp;#34; 15 圧縮フ</description></item><item><title>trdsql Log集計</title><link>https://noborus.github.io/blog/08_log/</link><pubDate>Sun, 08 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/08_log/</guid><description>Log集計 ApacheやnginxなどのLogをLTSVフォーマットで出力する方法も定着してきました。 そのようなLogをtrdsqlで解析する例です。 出力する側は、apacheのLogFormatの設定を以下のようにカスタマイズフォーマットにします。 LogFormat &amp;quot;host:%h\tident:%l\tuser:%u\ttime:%t\treq:%r\tstatus:%&amp;gt;s\tsize:%b\treferer:\%{Referer}i\tua:%{User-Agent}i&amp;quot; combined_ltsv host,ident,u</description></item><item><title>trdsql GROUP集計</title><link>https://noborus.github.io/blog/07_group/</link><pubDate>Sat, 07 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/07_group/</guid><description>GROUP集計 全体の合計を計算することもありますが、グループ毎の合計をまとめて出力したい場合もあります。 そこで使うのがGROUP BYです。 前回の例をもう一度使用します。 name,price apple,100 orange,50 melon,500 apple,90 apple,90 orange,40 orange,40 ここでappleやorange毎の合計を出したい場合は、以下のように検索条件で絞れば計算できます</description></item><item><title>trdsql 集計計算</title><link>https://noborus.github.io/blog/06_calculation/</link><pubDate>Fri, 06 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/06_calculation/</guid><description>集計計算 集計には、COUNT()だけでなく集計計算することも当然できます。SQLには数値に対して計算をおこなう集計関数があらかじめ揃っています。 ここでは以下のようなCSVファイルを例に説明します。 name,price apple,100 orange,50 melon,500 apple,90 apple,90 orange,40 orange,40 SUM 合計を計算します。price列をすべて足します。 trdsql -ih &amp;#34;SELECT SUM(price) FROM sample.csv&amp;#34; 910 前に</description></item><item><title>trdsql 集計</title><link>https://noborus.github.io/blog/05_aggregate/</link><pubDate>Thu, 05 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/05_aggregate/</guid><description>COUNT(*) 最初はCOUNT(*)です。全体の件数を数えることが出来ます。 集計関数を使用すると元の行と列のデータは出力されず、そこから集計された結果が出力されます。 以下の例は結果が１行なので、CSVの様に見えませんが、1行1列(ヘッダー付き)のCSVとして出力されています。 単純に件数を数え</description></item><item><title>trdsql 簡単なSQL その２</title><link>https://noborus.github.io/blog/04_sql2/</link><pubDate>Wed, 04 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/04_sql2/</guid><description>検索条件 前回、列の並べ替え、抽出、行の並べ替えをしたので、今回は行の抽出です。 行を抽出するには、WHEREを付けて、検索条件を書きます。 前回と同じ例のファイルを使います。 trdsql -ih \ &amp;#34;SELECT id, \`name\` FROM header.csv WHERE id=1&amp;#34; 1,Orange SQLのメインな機能ですね。検索条件を書くだけで、該当する行を出力できます。 AND, OR AND や OR や</description></item><item><title>trdsql 簡単なSQL</title><link>https://noborus.github.io/blog/03_sql/</link><pubDate>Tue, 03 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/03_sql/</guid><description>trdsqlと簡単なSQLを使用することで、他のUNIXツールを組み合わせて出来るようなことが一発で出来るようになります。 ファイル解析 SELECT * FROMから進んで簡単なSQLを実行する場合、あらかじめ列名を把握しておく必要があります。 trdsql に -aオプションにファイル名を付けて実行するとファ</description></item><item><title>trdsql ファイルフォーマット変換</title><link>https://noborus.github.io/blog/02_convert/</link><pubDate>Mon, 02 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/02_convert/</guid><description>trdsqlはCSV等のファイルをSQLで処理するツールとして説明していますが、単純にファイル形式を変換するツールとしても使用できます。 その場合、SQLは以下の定型句さえ覚えておけば、十分です。 ファイル内のすべての行と列を出力します。 SELECT * FROM ファイル名 後は、オプションとして入力形式</description></item><item><title>trdsql インストール</title><link>https://noborus.github.io/blog/01_install/</link><pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/01_install/</guid><description>概要 trdsqlはテーブル（表）形式のテキストに対してSQLを実行するCLIツールです。 テーブル形式とは、行と列で構成される以下のようなデータです。 1列 2列 1行 a1 a2 2行 b1 b2 結果をざまざまなフォーマットに出力できるので、テーブル形式データのフォーマット変換にも使用できます。 インスト</description></item></channel></rss>