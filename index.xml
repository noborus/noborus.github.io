<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Top on Noboru Saito&#39;s page</title><link>https://noborus.github.io/</link><description>Recent content in Top on Noboru Saito&#39;s page</description><generator>Hugo -- gohugo.io</generator><language>ja</language><copyright>&amp;copy;Noboru Saito 2019</copyright><lastBuildDate>Sat, 04 Jan 2020 13:38:00 +0900</lastBuildDate><atom:link href="https://noborus.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>trdsql 目次</title><link>https://noborus.github.io/trdsql/</link><pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/trdsql/</guid><description>CSV,LTSV,JSON,TBLNファイルにSQLを実行できるツールのtrdsqlのドキュメントです。 trdsql Advent Calendar 2019として書かれています。 目次 インストール 変換 簡単なSQL 簡単なSQLその2 集計 集計計算 グループ集計 ログ集計 ワイルドカード、圧縮ファイル 標準入力 処理の概要 Postgr</description></item><item><title>About</title><link>https://noborus.github.io/about/</link><pubDate>Fri, 13 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/about/</guid><description>斉藤 登のページです。 noborus Links GitHub: https://github.com/noborus Twitter: https://twitter.com/noborus Qiita: https://qiita.com/noborus</description></item><item><title>trdsql 合計を行に追加する</title><link>https://noborus.github.io/blog/31_rollup/</link><pubDate>Sat, 04 Jan 2020 13:38:00 +0900</pubDate><guid>https://noborus.github.io/blog/31_rollup/</guid><description>Window関数により元のファイルの内容に列を追加して、集計結果を出せました。 ただ、人が確認する場合は、集計の結果行が最後に出るほうが確認しやすくなります。 通常のSQLでも元の内容と集計結果を別々に出してUNIONを使うことで、一つの結果として出すことが出来ますが、一回で済むなら</description></item><item><title>trdsql convert log</title><link>https://noborus.github.io/blog/30_convert_log/</link><pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/30_convert_log/</guid><description>既存のログをLTSVに変換する 既存のログをLTSVに変換にしてみます。 mingrammer/flog を使用するとフェイクのログが簡単に出力できるので、 これで出力されるログをLTSV形式に変換する方法を紹介します。 Apache common log 以下のコマンドにより apache_common形式のログをaccess.common.lo</description></item><item><title>trdsql generate_series</title><link>https://noborus.github.io/blog/29_generate_series/</link><pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/29_generate_series/</guid><description>generate_series PostgreSQLにはgenerate_series()という便利な関数があります。 これはUnixのseqコマンドと同じような働きをする関数です。またgenerate_series()は、タイムスタンプ型にも使用できる拡張があります。 使い方は簡単で「開始値」、「終了値」、「刻</description></item><item><title>trdsql CROSS JOIN</title><link>https://noborus.github.io/blog/28_cross_join/</link><pubDate>Sat, 28 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/28_cross_join/</guid><description>CROSS JOINは、総当りを簡単に作り出せる方法です。 a.csv aa ab ac b.csv ba bb bc の２つのCSVをCROSS JOINすると 3×3で全ての組み合わせを出力できます。 trdsql &amp;#34;SELECT * FROM a.csv CROSS JOIN b.csv&amp;#34; aa,ba aa,bb aa,bc ab,ba ab,bb ab,bc ac,ba ac,bb ac,bc また一つのファイルに対して自己結合をすることもできます。 例えば、ホーム＆アウェーの総当り表を作成してみ</description></item><item><title>trdsql config</title><link>https://noborus.github.io/blog/27_config/</link><pubDate>Fri, 27 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/27_config/</guid><description>trdsqlは設定ファイルが無くても動作しますが、設定ファイルによりデフォルトのデータベースのエンジンを変更できます。 configファイルの場所 -configオプションで、直接ファイルの場所を指定できます。 -configオプションを使用しないデフォルトの場所は以下です。 Linux</description></item><item><title>trdsql SQLファイル指定</title><link>https://noborus.github.io/blog/26_file_sql/</link><pubDate>Thu, 26 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/26_file_sql/</guid><description>SQLファイル名指定オプション「-q」 trdsql &amp;ldquo;SQLコマンド&amp;rdquo;の形式だと、長いSQLを書くのが難しいですし、シェルに対してエスケープしなければならない文字があって見た目もわかりにくい場合があります。 trdsqlではファイルにSQLを書いておき、そのファイルのS</description></item><item><title>trdsql ライブラリ使用</title><link>https://noborus.github.io/blog/25_library/</link><pubDate>Wed, 25 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/25_library/</guid><description>trdsqlは初期の頃は、main packageで構成されていましたが、現在はtrdsql packageをmainから呼び出す構成になっていて、trdsql packageをライブラリとして使用できます。 trdsqlのパッケージは、以下の構成になっていて、それぞれ呼び出し可能です。</description></item><item><title>trdsql グラフ</title><link>https://noborus.github.io/blog/24_graph/</link><pubDate>Tue, 24 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/24_graph/</guid><description>trdsqlは、グラフ作成機能は持っていないためグラフを作成したいときには別のツールを使用して作成することになります。 ExcelやLibreOfficeで描画するのが定番でしょうが、ここではmarianogappa/chartでグラフを描画する方法を紹介します。 marianoga</description></item><item><title>trdsql 差分、比較</title><link>https://noborus.github.io/blog/23_except/</link><pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/23_except/</guid><description>CSV同士やCSVとテーブルなどで、値の比較をしたい場合があります。 同じ形式で一部が違うCSVファイルであれば、diffを取る方法もありますが、trdsqlのSQLを使用して比較すると形式が違う場合の比較にも使用できます。 差分の出力 SQLで比較して、差分を出すには、EXCEPTを</description></item><item><title>trdsql JSON出力</title><link>https://noborus.github.io/blog/22_json_output/</link><pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/22_json_output/</guid><description>CSVやLTSVなどのフラットな形式のデータは、JSONにしたいときには（-ojsonによる）JSON出力をすれば良いですが、JSONは本来より深い階層も表現できるフォーマットです。 そのようなJSONは、データベースのJSON関数を使用することにより作成できます。 以下のCSVから</description></item><item><title>trdsql JSON解析</title><link>https://noborus.github.io/blog/21_json_parse/</link><pubDate>Sat, 21 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/21_json_parse/</guid><description>これまでtrdsqlでは、JSONの入力が可能と書きましたが、例として書いたのは基本的にフラットな構造のJSONでした。 ただ、２階層以上の階層構造が含まれるJSONはエラーになる訳ではなく、そのまま文字列として扱われます。 以下のようなJSONがあるとします。 sample.json [ { &amp;#34;color&amp;#34;: &amp;#34;white&amp;#34;, &amp;#34;category&amp;#34;: &amp;#34;value&amp;#34;, &amp;#34;code&amp;#34;: { &amp;#34;rgba&amp;#34;: [0,</description></item><item><title>trdsql 日付・時刻処理</title><link>https://noborus.github.io/blog/20_date/</link><pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/20_date/</guid><description>ファイル内に入っている日付、時刻をそのまま扱う場合は良いですが、変換等の処理をしたい場合があります。 その場合は、一旦日付や時刻と解釈させてから扱う方が扱いやすくなります。 SQLite3の日付、時刻処理 デフォルトのSQLite3の日付、時刻処理では、以下のフォーマットであれば、日付</description></item><item><title>trdsql Window関数</title><link>https://noborus.github.io/blog/19_window/</link><pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/19_window/</guid><description>これまでグループ集計による集計を紹介していますが、グループ集計は元の行とはまったく別にグループ毎の行を出力していました。 つまり、元のファイルとは別に集計の結果を出力していた訳です。 そうではなくて、元のファイルの情報にプラスして集計結果を出して欲しい場合があります。 例えば、点数の列</description></item><item><title>trdsql 列の編集</title><link>https://noborus.github.io/blog/18_edit_columns/</link><pubDate>Wed, 18 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/18_edit_columns/</guid><description>これまで列の並べ替えはしてきましたが、列の内容はそのままでした。 SQLでは、文字列の書き換えが得意分野とは言えませんが、SQLの関数を使うことにより、それなりできる機能は揃っています。 列の連結 「||」を使って、列名をつなげば、２つ以上の列を連結して一つの列になります。 trdsql -ih -oh \ &amp;#34;SELECT id,name||id</description></item><item><title>trdsql ファイルとテーブルのJOIN</title><link>https://noborus.github.io/blog/17_file_table/</link><pubDate>Tue, 17 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/17_file_table/</guid><description>既にテーブルが存在するデータベースに接続することにより、ファイルとテーブルをJOINすることもできます。 例えば、データベース内にfruitsというテーブルがあった場合に、前回のabc.csvとJOINできます。 trdsql -driver postgres -dsn &amp;#34;dbname=trdsql_test&amp;#34; \ &amp;#34;SELECT a.c1, a.c2, f.name FROM abc.csv AS a &amp;#34;\ &amp;#34;LEFT JOIN fruits AS f ON (CAST(a.c1 AS int) = f.id)&amp;#34; 1,AAA,Orange 2,BBB,Melon 3,CCC,Apple 例えば、デー</description></item><item><title>trdsql JOIN</title><link>https://noborus.github.io/blog/16_join/</link><pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/16_join/</guid><description>これまで一つのファイルにSQLを実行してきましたが、複数のファイルをJOINするSQLも実行できます。 以下の2つのCSVファイルがあったとして、 abc.csv 1,AAA 2,BBB 3,CCC price.csv 1,100 2,500 3,50 以下のように連結するのが、JOINです。 1,AAA,100 2,BBB,500 3,CCC,50 trdsqlではテーブルの代わりにファイル名を使用すれば、そのままSQLの</description></item><item><title>trdsql DBインポート</title><link>https://noborus.github.io/blog/15_import/</link><pubDate>Sun, 15 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/15_import/</guid><description>trdsqlにはデータベースにインポートするオプションはありません。 しかしながら、SELECT以外のSQLの実行も可能なので、SQLによるインポートが可能です。 以下は、メモリデータベースにインポートしても終了すると消えてしまうので、メモリデータベース以外のデータベースに接続して実</description></item><item><title>trdsql SQLite3エンジンの使用</title><link>https://noborus.github.io/blog/14_sqlite3/</link><pubDate>Sat, 14 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/14_sqlite3/</guid><description>SQLite3への接続方法を説明します。 SQLite3に接続 そもそもtrdsqlのデフォルトはSQLite3のメモリデータベースに接続していますが、メモリデータベース以外にも接続できます。 オプションの -driver に sqlite3 を指定し、-dsn にサーバーへの接続情報を指定します。 dsnはsqlite</description></item><item><title>trdsql MySQLエンジンの使用</title><link>https://noborus.github.io/blog/13_mysql/</link><pubDate>Fri, 13 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/13_mysql/</guid><description>前回はPostgreSQL接続の話でしたが、今度はMySQLに接続して使用する方法を説明します。 MySQLに接続 MySQLに接続するには動作しているMySQLサーバーが必要です。接続できテーブルが作成できる権限があるデータベースを作成しておきます。 オプションの -driver に mysql を指定し、-d</description></item><item><title>trdsql PostgreSQLエンジンの使用</title><link>https://noborus.github.io/blog/12_postgres/</link><pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/12_postgres/</guid><description>trdsqlは組込みのSQLite3を利用してSQLを実行していますが、データベースの処理を別のデータベースに変更出来ます。 ここではPostgreSQLを使用する方法を説明します。 PostgreSQLに接続 SQLite3と違いPostgreSQLは動作しているPostgreSQL</description></item><item><title>trdsql 処理の概要</title><link>https://noborus.github.io/blog/11_summary/</link><pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/11_summary/</guid><description>ここでtrdsqlの内部処理の概要を簡単に説明します。 trdsqlの内部処理は、以下のようになっています。 オプションやSQLコマンドの解釈 SQLコマンド内のファイル名をインポート SQLの実行 指定された出力フォーマットでエクスポート SQLの実行は実際のRDBMSを使用して実行されま</description></item><item><title>trdsql 標準入力</title><link>https://noborus.github.io/blog/10_stdin/</link><pubDate>Tue, 10 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/10_stdin/</guid><description>標準入力 trdsqlは他のUNIXツールのように標準入力からデータを受け取ることができます。ただSQLの文法上テーブル名を指定する必要があります。標準入力を使用するときは、「-」か「stdin」を使用します。 cat test.csv|trdsql -icsv &amp;#34;SELECT * FROM -&amp;#34; apple,100 orange,50 potato,30 （ここで注意が必要なのが、trdsqlは標準入力から</description></item><item><title>trdsql ワイルドカード、圧縮ファイル</title><link>https://noborus.github.io/blog/09_wildcard/</link><pubDate>Mon, 09 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/09_wildcard/</guid><description>Wildcard ここまでは一つのファイルを対象としてきましたが、ログファイル等はローテートされて複数のファイルになっている場合があります。 同じ列で構成されている対象ファイルであれば、ワイルドカードを使用して、一つのテーブルとして扱うことができます。 ls test*.csv test1.csv test2.csv test3.csvtrdsql -icsv &amp;#34;SELECT COUNT(*) FROM test*.csv&amp;#34; 15 gzip圧縮 また古いログ</description></item><item><title>trdsql Log集計</title><link>https://noborus.github.io/blog/08_log/</link><pubDate>Sun, 08 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/08_log/</guid><description>Log集計 ApacheやnginxなどのLogをLTSVフォーマットで出力する方法も定着してきました。 そのようなLogをtrdsqlで解析する例です。 出力する側は、apacheのLogFormatの設定を以下のようにカスタマイズフォーマットにします。 LogFormat &amp;quot;host:%h\tident:%l\tuser:%u\ttime:%t\treq:%r\tstatus:%&amp;gt;s\tsize:%b\treferer:\%{Referer}i\tua:%{User-Agent}i&amp;quot; combined_ltsv host,ident,u</description></item><item><title>trdsql GROUP集計</title><link>https://noborus.github.io/blog/07_group/</link><pubDate>Sat, 07 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/07_group/</guid><description>GROUP集計 全体の合計を計算することもありますが、グループ毎の合計をまとめて出力したい場合もあります。 そこで使うのがGROUP BYです。 前回の例をもう一度使用します。 name,price apple,100 orange,50 melon,500 apple,90 apple,90 orange,40 orange,40 ここでappleやorange毎の合計を出したい場合は、以下のように検索条件で絞れば計算できます</description></item><item><title>trdsql 集計計算</title><link>https://noborus.github.io/blog/06_calculation/</link><pubDate>Fri, 06 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/06_calculation/</guid><description>集計計算 集計には、COUNT()だけでなく集計計算することも当然できます。SQLには数値に対して計算をおこなう集計関数があらかじめ揃っています。 ここでは以下のようなCSVファイルを例に説明します。 name,price apple,100 orange,50 melon,500 apple,90 apple,90 orange,40 orange,40 SUM 合計を計算します。price列をすべて足します。 trdsql -ih &amp;#34;SELECT SUM(price) FROM sample.csv&amp;#34; 910 前に</description></item><item><title>trdsql 集計</title><link>https://noborus.github.io/blog/05_aggregate/</link><pubDate>Thu, 05 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/05_aggregate/</guid><description>集計 COUNT(*) 最初はCOUNT(*)です。全体の件数を数えることが出来ます。 集計関数を使用すると元の行と列のデータは出力されず、そこから集計された結果が出力されます。 以下の例は結果が１行なので、CSVの様に見えませんが、1行1列(ヘッダー付き)のCSVとして出力されています。 単純に件数を</description></item><item><title>trdsql 簡単なSQL その２</title><link>https://noborus.github.io/blog/04_sql2/</link><pubDate>Wed, 04 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/04_sql2/</guid><description>検索条件 前回、列の並べ替え、抽出、行の並べ替えをしたので、今回は行の抽出です。 行を抽出するには、WHEREを付けて、検索条件を書きます。 前回と同じ例のファイルを使います。 trdsql -ih \ &amp;#34;SELECT id, \`name\` FROM header.csv WHERE id=1&amp;#34; 1,Orange SQLのメインな機能ですね。検索条件を書くだけで、該当する行を出力できます。 AND, OR AND や OR や</description></item><item><title>trdsql 簡単なSQL</title><link>https://noborus.github.io/blog/03_sql/</link><pubDate>Tue, 03 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/03_sql/</guid><description>trdsqlと簡単なSQLを使用することで、他のUNIXツールを組み合わせて出来るようなことが一発で出来るようになります。 ファイル解析 SELECT * FROMから進んで簡単なSQLを実行する場合、あらかじめ列名を把握しておく必要があります。 trdsql に -aオプションにファイル名を付けて実行するとファ</description></item><item><title>trdsql ファイルフォーマット変換</title><link>https://noborus.github.io/blog/02_convert/</link><pubDate>Mon, 02 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/02_convert/</guid><description>trdsqlはCSV等のファイルをSQLで処理するツールとして説明していますが、単純にファイル形式を変換するツールとしても使用できます。 その場合、SQLは以下の定型句さえ覚えておけば、十分です。 ファイル内のすべての行と列を出力します。 SELECT * FROM ファイル名 後は、オプションとして入力形式</description></item><item><title>trdsql インストール</title><link>https://noborus.github.io/blog/01_install/</link><pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/01_install/</guid><description>概要 trdsqlはテーブル（表）形式のテキストに対してSQLを実行するCLIツールです。 テーブル形式とは、行と列で構成される以下のようなデータです。 1列 2列 1行 a1 a2 2行 b1 b2 結果をざまざまなフォーマットに出力できるので、テーブル形式データのフォーマット変換にも使用できます。 インスト</description></item></channel></rss>