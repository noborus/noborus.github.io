<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE TABLE</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-createsubscription.html" title="CREATE SUBSCRIPTION" /><link rel="next" href="sql-createtableas.html" title="CREATE TABLE AS" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 11.4文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="sql-commands.html" title="SQLコマンド">SQLコマンド</a></td><td width="20%" align="right"></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createsubscription.html" title="CREATE SUBSCRIPTION">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">上へ</a></td><td width="60%" align="center">CREATE TABLE</td><td width="20%" align="right"> <a accesskey="n" href="sql-createtableas.html" title="CREATE TABLE AS">次へ</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATETABLE"><div class="titlepage"></div><a id="id-1.9.3.85.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE TABLE</span></h2><p>CREATE TABLE<!--
  <refpurpose>define a new table</refpurpose>
--> — 新しいテーブルを定義する</p></div><div class="refsynopsisdiv"><h2>概要</h2><pre class="synopsis">
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <em class="replaceable"><code>table_name</code></em> ( [
  { <em class="replaceable"><code>column_name</code></em> <em class="replaceable"><code>data_type</code></em> [ COLLATE <em class="replaceable"><code>collation</code></em> ] [ <em class="replaceable"><code>column_constraint</code></em> [ ... ] ]
    | <em class="replaceable"><code>table_constraint</code></em>
    | LIKE <em class="replaceable"><code>source_table</code></em> [ <em class="replaceable"><code>like_option</code></em> ... ] }
    [, ... ]
] )
[ INHERITS ( <em class="replaceable"><code>parent_table</code></em> [, ... ] ) ]
[ PARTITION BY { RANGE | LIST | HASH } ( { <em class="replaceable"><code>column_name</code></em> | ( <em class="replaceable"><code>expression</code></em> ) } [ COLLATE <em class="replaceable"><code>collation</code></em> ] [ <em class="replaceable"><code>opclass</code></em> ] [, ... ] ) ]
[ WITH ( <em class="replaceable"><code>storage_parameter</code></em> [= <em class="replaceable"><code>value</code></em>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <em class="replaceable"><code>table_name</code></em>
    OF <em class="replaceable"><code>type_name</code></em> [ (
  { <em class="replaceable"><code>column_name</code></em> [ WITH OPTIONS ] [ <em class="replaceable"><code>column_constraint</code></em> [ ... ] ]
    | <em class="replaceable"><code>table_constraint</code></em> }
    [, ... ]
) ]
[ PARTITION BY { RANGE | LIST | HASH } ( { <em class="replaceable"><code>column_name</code></em> | ( <em class="replaceable"><code>expression</code></em> ) } [ COLLATE <em class="replaceable"><code>collation</code></em> ] [ <em class="replaceable"><code>opclass</code></em> ] [, ... ] ) ]
[ WITH ( <em class="replaceable"><code>storage_parameter</code></em> [= <em class="replaceable"><code>value</code></em>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <em class="replaceable"><code>table_name</code></em>
    PARTITION OF <em class="replaceable"><code>parent_table</code></em> [ (
  { <em class="replaceable"><code>column_name</code></em> [ WITH OPTIONS ] [ <em class="replaceable"><code>column_constraint</code></em> [ ... ] ]
    | <em class="replaceable"><code>table_constraint</code></em> }
    [, ... ]
) ] { FOR VALUES <em class="replaceable"><code>partition_bound_spec</code></em> | DEFAULT }
[ PARTITION BY { RANGE | LIST | HASH } ( { <em class="replaceable"><code>column_name</code></em> | ( <em class="replaceable"><code>expression</code></em> ) } [ COLLATE <em class="replaceable"><code>collation</code></em> ] [ <em class="replaceable"><code>opclass</code></em> ] [, ... ] ) ]
[ WITH ( <em class="replaceable"><code>storage_parameter</code></em> [= <em class="replaceable"><code>value</code></em>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> ]

<!--
<phrase>where <replaceable class="parameter">column_constraint</replaceable> is:</phrase>
-->
<span class="phrase">ここで<em class="replaceable"><code>column_constraint</code></em>には、次の構文が入ります。</span>

[ CONSTRAINT <em class="replaceable"><code>constraint_name</code></em> ]
{ NOT NULL |
  NULL |
  CHECK ( <em class="replaceable"><code>expression</code></em> ) [ NO INHERIT ] |
  DEFAULT <em class="replaceable"><code>default_expr</code></em> |
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <em class="replaceable"><code>sequence_options</code></em> ) ] |
  UNIQUE <em class="replaceable"><code>index_parameters</code></em> |
  PRIMARY KEY <em class="replaceable"><code>index_parameters</code></em> |
  REFERENCES <em class="replaceable"><code>reftable</code></em> [ ( <em class="replaceable"><code>refcolumn</code></em> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <em class="replaceable"><code>action</code></em> ] [ ON UPDATE <em class="replaceable"><code>action</code></em> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<!--
<phrase>and <replaceable class="parameter">table_constraint</replaceable> is:</phrase>
-->
<span class="phrase">また、<em class="replaceable"><code>table_constraint</code></em>には、次の構文が入ります。</span>

[ CONSTRAINT <em class="replaceable"><code>constraint_name</code></em> ]
{ CHECK ( <em class="replaceable"><code>expression</code></em> ) [ NO INHERIT ] |
  UNIQUE ( <em class="replaceable"><code>column_name</code></em> [, ... ] ) <em class="replaceable"><code>index_parameters</code></em> |
  PRIMARY KEY ( <em class="replaceable"><code>column_name</code></em> [, ... ] ) <em class="replaceable"><code>index_parameters</code></em> |
  EXCLUDE [ USING <em class="replaceable"><code>index_method</code></em> ] ( <em class="replaceable"><code>exclude_element</code></em> WITH <em class="replaceable"><code>operator</code></em> [, ... ] ) <em class="replaceable"><code>index_parameters</code></em> [ WHERE ( <em class="replaceable"><code>predicate</code></em> ) ] |
  FOREIGN KEY ( <em class="replaceable"><code>column_name</code></em> [, ... ] ) REFERENCES <em class="replaceable"><code>reftable</code></em> [ ( <em class="replaceable"><code>refcolumn</code></em> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <em class="replaceable"><code>action</code></em> ] [ ON UPDATE <em class="replaceable"><code>action</code></em> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<!--
<phrase>and <replaceable class="parameter">like_option</replaceable> is:</phrase>
-->
<span class="phrase">また<em class="replaceable"><code>like_option</code></em>は、以下の通りです。</span>

{ INCLUDING | EXCLUDING } { COMMENTS | CONSTRAINTS | DEFAULTS | IDENTITY | INDEXES | STATISTICS | STORAGE | ALL }

<!--
<phrase>and <replaceable class="parameter">partition_bound_spec</replaceable> is:</phrase>
-->
<span class="phrase">また<em class="replaceable"><code>partition_bound_spec</code></em>は、以下の通りです。</span>

IN ( { <em class="replaceable"><code>numeric_literal</code></em> | <em class="replaceable"><code>string_literal</code></em> | TRUE | FALSE | NULL } [, ...] ) |
FROM ( { <em class="replaceable"><code>numeric_literal</code></em> | <em class="replaceable"><code>string_literal</code></em> | TRUE | FALSE | MINVALUE | MAXVALUE } [, ...] )
  TO ( { <em class="replaceable"><code>numeric_literal</code></em> | <em class="replaceable"><code>string_literal</code></em> | TRUE | FALSE | MINVALUE | MAXVALUE } [, ...] ) |
WITH ( MODULUS <em class="replaceable"><code>numeric_literal</code></em>, REMAINDER <em class="replaceable"><code>numeric_literal</code></em> )

<!--
<phrase><replaceable class="parameter">index_parameters</replaceable> in <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, and <literal>EXCLUDE</literal> constraints are:</phrase>
-->
<span class="phrase"><code class="literal">UNIQUE</code>、<code class="literal">PRIMARY KEY</code>および<code class="literal">EXCLUDE</code>制約内の<em class="replaceable"><code>index_parameters</code></em>は以下の通りです。</span>

[ INCLUDE ( <em class="replaceable"><code>column_name</code></em> [, ... ] ) ]
[ WITH ( <em class="replaceable"><code>storage_parameter</code></em> [= <em class="replaceable"><code>value</code></em>] [, ... ] ) ]
[ USING INDEX TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> ]

<!--
<phrase><replaceable class="parameter">exclude_element</replaceable> in an <literal>EXCLUDE</literal> constraint is:</phrase>
-->
<span class="phrase"><code class="literal">EXCLUDE</code>制約内の<em class="replaceable"><code>exclude_element</code></em>は以下の通りです。</span>

{ <em class="replaceable"><code>column_name</code></em> | ( <em class="replaceable"><code>expression</code></em> ) } [ <em class="replaceable"><code>opclass</code></em> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]
</pre></div><div class="refsect1" id="SQL-CREATETABLE-DESCRIPTION"><h2>説明</h2><!--
  <title>Description</title>
--><p>
<!--
   <command>CREATE TABLE</command> will create a new, initially empty table
   in the current database. The table will be owned by the user issuing the
   command.
-->
<code class="command">CREATE TABLE</code>は、現在のデータベースに新しい空のテーブルを作成します。
作成したテーブルはこのコマンドを実行したユーザが所有します。
  </p><p>
<!--
   If a schema name is given (for example, <literal>CREATE TABLE
   myschema.mytable ...</literal>) then the table is created in the specified
   schema.  Otherwise it is created in the current schema.  Temporary
   tables exist in a special schema, so a schema name cannot be given
   when creating a temporary table.  The name of the table must be
   distinct from the name of any other table, sequence, index, view,
   or foreign table in the same schema.
-->
スキーマ名が付けられている場合（例えば、<code class="literal">CREATE TABLE myschema.mytable ...</code>）、テーブルは指定されたスキーマに作成されます。
スキーマ名がなければ、テーブルは現在のスキーマに作成されます。
また、一時テーブルは特別なスキーマに存在するため、一時テーブルの作成時にスキーマ名を与えることはできません。
テーブル名は、同じスキーマ内の他のテーブル、シーケンス、インデックス、ビュー、外部テーブルとは異なる名前にする必要があります。
  </p><p>
<!--
   <command>CREATE TABLE</command> also automatically creates a data
   type that represents the composite type corresponding
   to one row of the table.  Therefore, tables cannot have the same
   name as any existing data type in the same schema.
-->
さらに、<code class="command">CREATE TABLE</code>は、作成するテーブルの1行に対応する複合型のデータ型を作成します。
したがって、テーブルは、同じスキーマ内の既存のデータ型と同じ名前を持つことができません。

  </p><p>
<!--
   The optional constraint clauses specify constraints (tests) that
   new or updated rows must satisfy for an insert or update operation
   to succeed.  A constraint is an SQL object that helps define the
   set of valid values in the table in various ways.
-->
制約句には、挿入、更新操作を行うときに、新しい行、または更新する行が満たさなければならない制約（検査項目）を指定します。制約句は省略可能です。
制約は、テーブル内で有効な値の集合を様々な方法で定義できるSQLオブジェクトです。
  </p><p>
<!--
   There are two ways to define constraints: table constraints and
   column constraints.  A column constraint is defined as part of a
   column definition.  A table constraint definition is not tied to a
   particular column, and it can encompass more than one column.
   Every column constraint can also be written as a table constraint;
   a column constraint is only a notational convenience for use when the
   constraint only affects one column.
-->
制約の定義にはテーブル制約と列制約という2種類があります。
列制約は列定義の一部として定義されます。
テーブル制約定義は、特定の列とは結びつけられておらず、複数の列を含有することができます。
また、全ての列制約はテーブル制約として記述することができます。
列制約は、1つの列にのみ影響する制約のための、簡便な記述方法に過ぎません。
  </p><p>
<!--
   To be able to create a table, you must have <literal>USAGE</literal>
   privilege on all column types or the type in the <literal>OF</literal>
   clause, respectively.
-->
テーブルを作成するためには、すべての列の型または<code class="literal">OF</code>句中の型に対する<code class="literal">USAGE</code>権限を持たなければなりません。
  </p></div><div class="refsect1" id="id-1.9.3.85.6"><h2>パラメータ</h2><!--
  <title>Parameters</title>
--><div class="variablelist"><dl class="variablelist"><dt id="SQL-CREATETABLE-TEMPORARY"><span class="term"><code class="literal">TEMPORARY</code>または<code class="literal">TEMP</code></span></dt><dd><p>
<!--
      If specified, the table is created as a temporary table.
      Temporary tables are automatically dropped at the end of a
      session, or optionally at the end of the current transaction
      (see <literal>ON COMMIT</literal> below).  Existing permanent
      tables with the same name are not visible to the current session
      while the temporary table exists, unless they are referenced
      with schema-qualified names. Any indexes created on a temporary
      table are automatically temporary as well.
-->
このパラメータが指定された場合、テーブルは一時テーブルとして作成されます。
一時テーブルは、そのセッションの終わり、場合によっては、現在のトランザクションの終わり（後述の<code class="literal">ON COMMIT</code>を参照）に自動的に削除されます。
一時テーブルが存在する場合、同じ名前を持つ既存の永続テーブルは、スキーマ修飾名で参照されていない限り、現在のセッションでは非可視になります。
一時テーブルに作られるインデックスも、全て自動的に一時的なものとなります。
     </p><p>
<!--
      The <link linkend="autovacuum">autovacuum daemon</link> cannot
      access and therefore cannot vacuum or analyze temporary tables.
      For this reason, appropriate vacuum and analyze operations should be
      performed via session SQL commands.  For example, if a temporary
      table is going to be used in complex queries, it is wise to run
      <command>ANALYZE</command> on the temporary table after it is populated.
-->
<a class="link" href="routine-vacuuming.html#AUTOVACUUM" title="24.1.6. 自動バキュームデーモン">自動バキュームデーモン</a>は一時テーブルにアクセスできないため、一時テーブルのバキュームや解析を行うことはできません。
このためセッションのSQLコマンドを用いて適切なバキュームと解析を実行しなければなりません。
例えば、一時テーブルが複雑な問い合わせで使用される場合、一時テーブルにデータを投入した後にそれに対し<code class="command">ANALYZE</code>を実行することを勧めます。
     </p><p>
<!--
      Optionally, <literal>GLOBAL</literal> or <literal>LOCAL</literal>
      can be written before <literal>TEMPORARY</literal> or <literal>TEMP</literal>.
      This presently makes no difference in <productname>PostgreSQL</productname>
      and is deprecated; see
      <xref linkend="sql-createtable-compatibility"
      endterm="sql-createtable-compatibility-title"/>.
-->
オプションで、<code class="literal">GLOBAL</code>または<code class="literal">LOCAL</code>を<code class="literal">TEMPORARY</code>や<code class="literal">TEMP</code>の前に記述することができます。
<span class="productname">PostgreSQL</span>では、現在違いがなく、廃止予定です。
<a class="xref" href="sql-createtable.html#SQL-CREATETABLE-COMPATIBILITY" title="互換性">互換性</a>を参照してください。
     </p></dd><dt id="SQL-CREATETABLE-UNLOGGED"><span class="term"><code class="literal">UNLOGGED</code></span></dt><dd><p>
<!--
      If specified, the table is created as an unlogged table.  Data written
      to unlogged tables is not written to the write-ahead log (see <xref
      linkend="wal"/>), which makes them considerably faster than ordinary
      tables.  However, they are not crash-safe: an unlogged table is
      automatically truncated after a crash or unclean shutdown.  The contents
      of an unlogged table are also not replicated to standby servers.
      Any indexes created on an unlogged table are automatically unlogged as
      well.
-->
指定された場合、テーブルはログを取らないテーブルとして作成されます。
ログを取らないテーブルに書き出されたデータは先行書き込みログ（<a class="xref" href="wal.html" title="第30章 信頼性とログ先行書き込み">第30章</a>参照）には書き出されません。
このため通常のテーブルより相当高速になります。
しかしこれらはクラッシュ時に安全ではありません。
クラッシュまたは異常停止の後、ログを取らないテーブルは自動的に切り詰められます。
またログを取らないテーブルの内容はスタンバイサーバに複製されません。
ログを取らないテーブル上に作成されたインデックスはすべて同様に、ログを取らないようになります。
     </p></dd><dt><span class="term"><code class="literal">IF NOT EXISTS</code></span></dt><dd><p>
<!--
      Do not throw an error if a relation with the same name already exists.
      A notice is issued in this case.  Note that there is no guarantee that
      the existing relation is anything like the one that would have been
      created.
-->
同じ名前のリレーションがすでに存在していてもエラーとしません。
この場合注意が発せられます。
既存のリレーションが作成しようとしたものと何かしら似たものであることは保証されません。
     </p></dd><dt><span class="term"><em class="replaceable"><code>table_name</code></em></span></dt><dd><p>
<!--
      The name (optionally schema-qualified) of the table to be created.
-->
作成するテーブルの名前です（スキーマ修飾名でも可）。
     </p></dd><dt><span class="term"><code class="literal">OF <em class="replaceable"><code>type_name</code></em></code></span></dt><dd><p>
<!--
      Creates a <firstterm>typed table</firstterm>, which takes its
      structure from the specified composite type (name optionally
      schema-qualified).  A typed table is tied to its type; for
      example the table will be dropped if the type is dropped
      (with <literal>DROP TYPE ... CASCADE</literal>).
-->
指定した複合型(スキーマ修飾可能)から構造を取り出した<em class="firstterm">型付きテーブル</em>を作成します。
型付きテーブルはその型に束縛されます。
例えば、型が(<code class="literal">DROP TYPE ... CASCADE</code>で)削除されるとそのテーブルは削除されます。
     </p><p>
<!--
      When a typed table is created, then the data types of the
      columns are determined by the underlying composite type and are
      not specified by the <literal>CREATE TABLE</literal> command.
      But the <literal>CREATE TABLE</literal> command can add defaults
      and constraints to the table and can specify storage parameters.
-->
型付きテーブルが作成されると、その列のデータ型は背後の複合型により決定され、<code class="literal">CREATE TABLE</code>コマンドでは指定されません。
しかし<code class="literal">CREATE TABLE</code>コマンドではテーブルにデフォルトと制約を追加できます。
また、格納パラメータの指定も可能です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>column_name</code></em></span></dt><dd><p>
<!--
      The name of a column to be created in the new table.
-->
新しいテーブルで作成される列の名前です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>data_type</code></em></span></dt><dd><p>
<!--
      The data type of the column. This can include array
      specifiers. For more information on the data types supported by
      <productname>PostgreSQL</productname>, refer to <xref
      linkend="datatype"/>.
-->
列のデータ型です。
これには、配列指定子を含めることができます。
<span class="productname">PostgreSQL</span>でサポートされるデータ型の情報に関する詳細は<a class="xref" href="datatype.html" title="第8章 データ型">第8章</a>を参照してください。
     </p></dd><dt><span class="term"><code class="literal">COLLATE <em class="replaceable"><code>collation</code></em></code></span></dt><dd><p>
<!--
      The <literal>COLLATE</literal> clause assigns a collation to
      the column (which must be of a collatable data type).
      If not specified, the column data type's default collation is used.
-->
<code class="literal">COLLATE</code>句は列（照合順の設定が可能なデータ型でなければなりません）に照合順を割り当てます。
指定がなければ、列のデータ型のデフォルトの照合順が使用されます。
     </p></dd><dt><span class="term"><code class="literal">INHERITS ( <em class="replaceable"><code>parent_table</code></em> [, ... ] )</code></span></dt><dd><p>
<!--
      The optional <literal>INHERITS</literal> clause specifies a list of
      tables from which the new table automatically inherits all
      columns.  Parent tables can be plain tables or foreign tables.
-->
オプションの<code class="literal">INHERITS</code>句でテーブルの一覧を指定すると、新しいテーブルは指定されたテーブルの全ての列を自動的に継承します。
親テーブルには通常のテーブルまたは外部テーブルを指定できます。
     </p><p>
<!--
      Use of <literal>INHERITS</literal> creates a persistent relationship
      between the new child table and its parent table(s).  Schema
      modifications to the parent(s) normally propagate to children
      as well, and by default the data of the child table is included in
      scans of the parent(s).
-->
<code class="literal">INHERITS</code>を使用すると、新しい子テーブルとその親テーブル（複数可）との間に永続的な関連が作成されます。
通常、親へのスキーマ変更は子にも伝播します。また、デフォルトでは、親テーブルの走査結果には子テーブルのデータが含まれます。
     </p><p>
<!--
      If the same column name exists in more than one parent
      table, an error is reported unless the data types of the columns
      match in each of the parent tables.  If there is no conflict,
      then the duplicate columns are merged to form a single column in
      the new table.  If the column name list of the new table
      contains a column name that is also inherited, the data type must
      likewise match the inherited column(s), and the column
      definitions are merged into one.  If the
      new table explicitly specifies a default value for the column,
      this default overrides any defaults from inherited declarations
      of the column.  Otherwise, any parents that specify default
      values for the column must all specify the same default, or an
      error will be reported.
-->
複数の親テーブルに同一名の列が存在する場合、それらのデータ型が一致していなければ、エラーとして報告されます。
競合がなければ、これらの重複した列は新しいテーブルで1つの列の形に融合されます。
新しいテーブルの列名の一覧に継承する列の名前が含まれる場合も、そのデータ型は継承する列のデータ型と一致していなければなりません。さらに、その列定義は1つに融合されます。
新しいテーブルで明示的に列のデフォルト値を指定した場合、継承した列宣言における全てのデフォルト値は上書きされます。
デフォルト値を指定しなかった場合、親側でデフォルト値が指定されている時は、それらのデフォルト値が全て同じ値でなければなりません。
値が違う場合はエラーになります。
     </p><p>
<!--
      <literal>CHECK</literal> constraints are merged in essentially the same way as
      columns: if multiple parent tables and/or the new table definition
      contain identically-named <literal>CHECK</literal> constraints, these
      constraints must all have the same check expression, or an error will be
      reported.  Constraints having the same name and expression will
      be merged into one copy.  A constraint marked <literal>NO INHERIT</literal> in a
      parent will not be considered.  Notice that an unnamed <literal>CHECK</literal>
      constraint in the new table will never be merged, since a unique name
      will always be chosen for it.
-->
<code class="literal">CHECK</code>制約は、基本的には列と同様の方法でマージされます。
複数の親テーブル、新しいテーブル、またはその両方の定義に同じ名前の<code class="literal">CHECK</code>制約が存在した場合、これらの制約はすべて同じ検査式を持たなければなりません。
さもなくば、エラーが報告されます。
同じ名前と式を持つ制約は１つのコピーにまとめられます。
親テーブルで<code class="literal">NO INHERIT</code>と印が付いた制約は考慮されません。
新しいテーブル内の無名の<code class="literal">CHECK</code>制約は、一意な名前が必ず作られるため、マージされないことに注意してください。
     </p><p>
<!--
      Column <literal>STORAGE</literal> settings are also copied from parent tables.
-->
列の<code class="literal">STORAGE</code>設定もまた親テーブルからコピーされます。
     </p><p>
<!--
      If a column in the parent table is an identity column, that property is
      not inherited.  A column in the child table can be declared identity
      column if desired.
-->
親テーブルのある列がIDENTITY列の場合、その属性は継承されません。
望むなら子テーブルの列をIDENTY列と宣言することができます。
     </p></dd><dt><span class="term"><code class="literal">PARTITION BY { RANGE | LIST | HASH } ( { <em class="replaceable"><code>column_name</code></em> | ( <em class="replaceable"><code>expression</code></em> ) } [ <em class="replaceable"><code>opclass</code></em> ] [, ...] ) </code></span></dt><dd><p>
<!--
      The optional <literal>PARTITION BY</literal> clause specifies a strategy
      of partitioning the table.  The table thus created is called a
      <firstterm>partitioned</firstterm> table.  The parenthesized list of
      columns or expressions forms the <firstterm>partition key</firstterm>
      for the table.  When using range or hash partitioning, the partition key
      can include multiple columns or expressions (up to 32, but this limit can
      be altered when building <productname>PostgreSQL</productname>), but for
      list partitioning, the partition key must consist of a single column or
      expression.
-->
オプションの<code class="literal">PARTITION BY</code>句により、テーブルのパーティショニングの戦略を指定できます。
このようにして作られたテーブルを<em class="firstterm">パーティション</em>テーブルと呼びます。
括弧に囲まれた列や式のリストはテーブルの<em class="firstterm">パーティションキー</em>を構成します。
範囲パーティションを使うときは、パーティションキーは複数の列または式にまたがることができます（最大で32ですが、この制限は<span class="productname">PostgreSQL</span>をビルドする時に変更できます）が、リストパーティションでは、パーティションキーは1つだけの列または式で構成されなければなりません。
パーティションテーブルの作成時にBツリー演算子クラスを指定しない場合は、そのデータ型のデフォルトのBツリー演算子クラスが使用されます。
Bツリー演算子クラスがない場合はエラーが報告されます。
     </p><p>
      Range and list partitioning require a btree operator class, while hash
      partitioning requires a hash operator class.  If no operator class is
      specified explicitly, the default operator class of the appropriate
      type will be used; if no default operator class exists, an error will
      be raised.  When hash partitioning is used, the operator class used
      must implement support function 2 (see <a class="xref" href="xindex.html#XINDEX-SUPPORT" title="38.15.3. インデックスメソッドのサポートルーチン">38.15.3</a>
      for details).
     </p><p>
<!--
      A partitioned table is divided into sub-tables (called partitions),
      which are created using separate <literal>CREATE TABLE</literal> commands.
      The partitioned table is itself empty.  A data row inserted into the
      table is routed to a partition based on the value of columns or
      expressions in the partition key.  If no existing partition matches
      the values in the new row, an error will be reported.
-->
パーティションテーブルは（パーティションと呼ばれる）副テーブルに分割され、それらは別の<code class="literal">CREATE TABLE</code>コマンドにより作成されます。
パーティションテーブルそれ自体は空になります。
テーブルに挿入されるデータ行は、パーティションキーの列あるいは式の値に基づいて、1つのパーティションに回されます。
新しい行の値に適合するパーティションが存在しないときは、エラーが報告されます。
     </p><p>
<!--
      Partitioned tables do not support <literal>EXCLUDE</literal> constraints;
      however, you can define these constraints on individual partitions.
      Also, while it's possible to define <literal>PRIMARY KEY</literal>
      constraints on partitioned tables, creating foreign keys that
      reference a partitioned table is not yet supported.
-->
パーティションテーブルは<code class="literal">UNIQUE</code>、<code class="literal">PRIMARY KEY</code>、<code class="literal">EXCLUDE</code>、<code class="literal">FOREIGN KEY</code>の各制約をサポートしませんが、個々のパーティションでこれらの制約を定義することはできます。
     </p><p>
<!--
      See <xref linkend="ddl-partitioning"/> for more discussion on table
      partitioning.
-->
テーブルパーティショニングの更なる議論は<a class="xref" href="ddl-partitioning.html" title="5.10. テーブルのパーティショニング">5.10</a>を参照してください。
     </p></dd><dt id="SQL-CREATETABLE-PARTITION"><span class="term"><code class="literal">PARTITION OF <em class="replaceable"><code>parent_table</code></em> { FOR VALUES <em class="replaceable"><code>partition_bound_spec</code></em> | DEFAULT }</code></span></dt><dd><p>
<!--
      Creates the table as a <firstterm>partition</firstterm> of the specified
      parent table. The table can be created either as a partition for specific
      values using <literal>FOR VALUES</literal> or as a default partition
      using <literal>DEFAULT</literal>.  This option is not available for
      hash-partitioned tables.
-->
指定した親テーブルの<em class="firstterm">パーティション</em>としてテーブルを作成します。
<code class="literal">FOR VALUES</code>を用いて特定の値のパーティションとして、あるいは、<code class="literal">DEFAULT</code>を用いてデフォルトパーティションとしてテーブルを作成できます。
本オプションはハッシュパーティションされたテーブルには使用できません。
     </p><p>
<!--
      The <replaceable class="parameter">partition_bound_spec</replaceable>
      must correspond to the partitioning method and partition key of the
      parent table, and must not overlap with any existing partition of that
      parent.  The form with <literal>IN</literal> is used for list partitioning,
      the form with <literal>FROM</literal> and <literal>TO</literal> is used
      for range partitioning, and the form with <literal>WITH</literal> is used
      for hash partitioning.
-->
<em class="replaceable"><code>partition_bound_spec</code></em>は親テーブルのパーティショニング方法とパーティションキーに対応していなければならず、またそのテーブルのどの既存のパーティションとも重なり合ってはいけません。
<code class="literal">IN</code>の構文はリストパーティショニングで、<code class="literal">FROM</code>と<code class="literal">TO</code>の構文は範囲パーティショニングで、<code class="literal">WITH</code>の構文はハッシュパーティショニングで、使用されます。
     </p><p>
<!--
      Each of the values specified in
      the <replaceable class="parameter">partition_bound_spec</replaceable> is
      a literal, <literal>NULL</literal>, <literal>MINVALUE</literal>, or
      <literal>MAXVALUE</literal>.  Each literal value must be either a
      numeric constant that is coercible to the corresponding partition key
      column's type, or a string literal that is valid input for that type.
-->
<em class="replaceable"><code>partition_bound_spec</code></em>で指定される各値はリテラル、<code class="literal">NULL</code>、<code class="literal">MINVALUE</code>あるいは<code class="literal">MAXVALUE</code>です。
各リテラル値はパーティションキー列の型に変換可能な数値定数か、その列の型として有効な入力である文字列リテラルのいずれかです。
     </p><p>
<!--
      When creating a list partition, <literal>NULL</literal> can be
      specified to signify that the partition allows the partition key
      column to be null.  However, there cannot be more than one such
      list partition for a given parent table.  <literal>NULL</literal>
      cannot be specified for range partitions.
-->
リストパーティションを作るときは、<code class="literal">NULL</code>を指定することができて、それはそのパーティションではパーティションキーの列をNULLにすることができるということを意味します。
しかし、1つの親テーブルで2つ以上、そのようなリストパーティションを作ることはできません。
範囲パーティションでは<code class="literal">NULL</code>を指定することはできません。
     </p><p>
<!--
      When creating a range partition, the lower bound specified with
      <literal>FROM</literal> is an inclusive bound, whereas the upper
      bound specified with <literal>TO</literal> is an exclusive bound.
      That is, the values specified in the <literal>FROM</literal> list
      are valid values of the corresponding partition key columns for this
      partition, whereas those in the <literal>TO</literal> list are
      not.  Note that this statement must be understood according to the
      rules of row-wise comparison (<xref linkend="row-wise-comparison"/>).
      For example, given <literal>PARTITION BY RANGE (x,y)</literal>, a partition
      bound <literal>FROM (1, 2) TO (3, 4)</literal>
      allows <literal>x=1</literal> with any <literal>y&gt;=2</literal>,
      <literal>x=2</literal> with any non-null <literal>y</literal>,
      and <literal>x=3</literal> with any <literal>y&lt;4</literal>.
-->
範囲パーティションを作るとき、<code class="literal">FROM</code>で指定する下限はそれを含む境界、<code class="literal">TO</code>で指定する上限はそれを含まない境界になります。
つまり、<code class="literal">FROM</code>リストで指定される値は、そのパーティションの対応するパーティションキー列において有効な値ですが、<code class="literal">TO</code>リストで指定される値はそうではない、ということです。
この文の意味は行単位の比較の規則（<a class="xref" href="functions-comparisons.html#ROW-WISE-COMPARISON" title="9.23.5. 行コンストラクタの比較">9.23.5</a>）に従って理解しなければならないことに注意してください。
例えば、<code class="literal">PARTITION BY RANGE (x,y)</code>について、パーティション境界<code class="literal">FROM (1, 2) TO (3, 4)</code>には、<code class="literal">x=1</code>で<code class="literal">y&gt;=2</code>の任意の値のもの、<code class="literal">x=2</code>でNULLでない任意の<code class="literal">y</code>のもの、<code class="literal">x=3</code>で<code class="literal">y&lt;4</code>の任意の値のものが入ります。
     </p><p>
<!--
      The special values <literal>MINVALUE</literal> and <literal>MAXVALUE</literal>
      may be used when creating a range partition to indicate that there
      is no lower or upper bound on the column's value. For example, a
      partition defined using <literal>FROM (MINVALUE) TO (10)</literal> allows
      any values less than 10, and a partition defined using
      <literal>FROM (10) TO (MAXVALUE)</literal> allows any values greater than
      or equal to 10.
-->
範囲パーティションを作るとき、<code class="literal">MINVALUE</code>および<code class="literal">MAXVALUE</code>という特別な値を使用することができて、これらはそれぞれ列の値に下限と上限がないことを示します。
例えば、<code class="literal">FROM (MINVALUE) TO (10)</code>で定義されたパーティションには10より小さいすべての値が入り、<code class="literal">FROM (10) TO (MAXVALUE)</code>で定義されたパーティションには10以上のすべての値が入ります。
     </p><p>
<!--
      When creating a range partition involving more than one column, it
      can also make sense to use <literal>MAXVALUE</literal> as part of the lower
      bound, and <literal>MINVALUE</literal> as part of the upper bound. For
      example, a partition defined using
      <literal>FROM (0, MAXVALUE) TO (10, MAXVALUE)</literal> allows any rows
      where the first partition key column is greater than 0 and less than
      or equal to 10. Similarly, a partition defined using
      <literal>FROM ('a', MINVALUE) TO ('b', MINVALUE)</literal> allows any rows
      where the first partition key column starts with "a".
-->
2つ以上の列を含む範囲パーティションを作るとき、<code class="literal">MAXVALUE</code>を下限の一部として使うことや、<code class="literal">MINVALUE</code>を上限の一部として使うことも意味を持ちえます。
例えば、<code class="literal">FROM (0, MAXVALUE) TO (10, MAXVALUE)</code>で定義されたパーティションには、パーティションキーの第1列が0より大きく、かつ10以下であるものが入ります。
同様に、<code class="literal">FROM ('a', MINVALUE) TO ('b', MINVALUE)</code>で定義されたパーティションには、パーティションキーの第1列が"a"で始まるすべての行が入ります。
     </p><p>
<!--
      Note that if <literal>MINVALUE</literal> or <literal>MAXVALUE</literal> is used for
      one column of a partitioning bound, the same value must be used for all
      subsequent columns.  For example, <literal>(10, MINVALUE, 0)</literal> is not
      a valid bound; you should write <literal>(10, MINVALUE, MINVALUE)</literal>.
-->
<code class="literal">MINVALUE</code>または<code class="literal">MAXVALUE</code>をパーティション境界の1つの列で使用する場合、それより後の列では同じ値を使用しなければならないことに注意してください。
例えば、<code class="literal">(10, MINVALUE, 0)</code>は有効な境界ではありません。
<code class="literal">(10, MINVALUE, MINVALUE)</code>とします。
     </p><p>
<!--
      Also note that some element types, such as <literal>timestamp</literal>,
      have a notion of "infinity", which is just another value that can
      be stored. This is different from <literal>MINVALUE</literal> and
      <literal>MAXVALUE</literal>, which are not real values that can be stored,
      but rather they are ways of saying that the value is unbounded.
      <literal>MAXVALUE</literal> can be thought of as being greater than any
      other value, including "infinity" and <literal>MINVALUE</literal> as being
      less than any other value, including "minus infinity". Thus the range
      <literal>FROM ('infinity') TO (MAXVALUE)</literal> is not an empty range; it
      allows precisely one value to be stored &mdash; "infinity".
-->
<code class="literal">timestamp</code>,など一部の要素型では、"infinity"（無限）の概念があり、それも保存できる値であることにも注意してください。
<code class="literal">MINVALUE</code>と<code class="literal">MAXVALUE</code>は保存できる真の値ではなく、値に境界がないということを表現するための方法に過ぎないため、これとは違います。
<code class="literal">MAXVALUE</code>は"infinity"も含め、他のすべての値より大きいものと考えることができ、また<code class="literal">MINVALUE</code>は"minus infinity"も含め、他のすべての値より小さいものと考えることができます。
従って、境界<code class="literal">FROM ('infinity') TO (MAXVALUE)</code>は空の範囲ではなく、たった1つの値、つまり"infinity"だけを保存します。
     </p><p>
<!--
      If <literal>DEFAULT</literal> is specified, the table will be
      created as a default partition of the parent table. The parent can
      either be a list or range partitioned table. A partition key value
      not fitting into any other partition of the given parent will be
      routed to the default partition. There can be only one default
      partition for a given parent table.
-->
<code class="literal">DEFAULT</code>が指定された場合、テーブルは親テーブルのデフォルトパーティションとして作成されます。
親はリストパーティションテーブルか範囲パーティションテーブルのいずれかがありえます。
親の他のどのパーティションにも当てはまらないパーティションキー値はデフォルトパーティションに送られます。
ある親テーブルに対してデフォルトパーティションは一つだけ存在できます。
     </p><p>
<!--
      When a table has an existing <literal>DEFAULT</literal> partition and
      a new partition is added to it, the existing default partition must
      be scanned to verify that it does not contain any rows which properly
      belong in the new partition.  If the default partition contains a
      large number of rows, this may be slow.  The scan will be skipped if
      the default partition is a foreign table or if it has a constraint which
      proves that it cannot contain rows which should be placed in the new
      partition.
-->
テーブルが既存の<code class="literal">DEFAULT</code>パーティションを持っていて、新たなパーティションが追加された場合、既存のデフォルトパーティションは、新たなパーティションに属すのがふさわしい行が含まれていないことを確かめるために、検査されなければなりません。
デフォルトパーティションに多数の行が含まれている場合、これは時間を要すかもしれません。
デフォルトパーティションが、外部テーブルであるか、新パーティションに置くべき行を含むことができないことを証明する制約を持つ場合、この検査は省略されます。
     </p><p>
<!--
      When creating a hash partition, a modulus and remainder must be specified.
      The modulus must be a positive integer, and the remainder must be a
      non-negative integer less than the modulus.  Typically, when initially
      setting up a hash-partitioned table, you should choose a modulus equal to
      the number of partitions and assign every table the same modulus and a
      different remainder (see examples, below).   However, it is not required
      that every partition have the same modulus, only that every modulus which
      occurs among the partitions of a hash-partitioned table is a factor of the
      next larger modulus.  This allows the number of partitions to be increased
      incrementally without needing to move all the data at once.  For example,
      suppose you have a hash-partitioned table with 8 partitions, each of which
      has modulus 8, but find it necessary to increase the number of partitions
      to 16.  You can detach one of the modulus-8 partitions, create two new
      modulus-16 partitions covering the same portion of the key space (one with
      a remainder equal to the remainder of the detached partition, and the
      other with a remainder equal to that value plus 8), and repopulate them
      with data.  You can then repeat this -&#045;perhaps at a later time &#045;- for
      each modulus-8 partition until none remain.  While this may still involve
      a large amount of data movement at each step, it is still better than
      having to create a whole new table and move all the data at once.
-->
ハッシュパーティションを作るときには法と残余を指定しなければなりません。
法は正の整数でなければならず、残余は法よりも小さい非負整数でなければなりません。
典型的にはハッシュパーティションテーブル初期設定をするとき、パーティションの数と等しい法を選び、全てのテーブルに同じ法と異なる残余を割り当てます（後述の例を参照）。
しかしながら、全てのパーティションが同じ法を持つ必要はなく、あるハッシュパーティションテーブルのパーティションに存在する全ての法が次に大きい法の因子であることだけ必要です。
このことは、全データを一度に移すことなくパーティション数を徐々に増やすことを可能にします。
例えば、各々の法が8である8パーティションのハッシュパーティションテーブルがあるとして、パーティション数を16に増やさなければならなくなったとします。
私たちは8を法とするパーティションの一つをデタッチして、新たに16を法とするキー空間の同じ部分（一つはデタッチしたパーティションと等しい残余を持ち、一つはその値に8を加えたのと等しい残余を持つ）を対象とする二つのパーティションを追加して、データを再配置することができます。
これを（おそらくはより後に）8を法とする各パーティションがなくなるまで、繰り返すことができます。
これは依然として各ステップで大きなデータ移動を伴いますが、全体の新テーブルを作って全データを一度に移さなければならないというよりは、まだ良いです。
     </p><p>
<!--
      A partition must have the same column names and types as the partitioned
      table to which it belongs.  If the parent is specified <literal>WITH
      OIDS</literal> then all partitions must have OIDs; the parent's OID
      column will be inherited by all partitions just like any other column.
      Modifications to the column names or types of a partitioned table, or
      the addition or removal of an OID column, will automatically propagate
      to all partitions.  <literal>CHECK</literal> constraints will be inherited
      automatically by every partition, but an individual partition may specify
      additional <literal>CHECK</literal> constraints; additional constraints with
      the same name and condition as in the parent will be merged with the
      parent constraint.  Defaults may be specified separately for each
      partition.
-->
パーティションは、それが属するパーティションテーブルと同じ列名および型を持っていなければなりません。
親が<code class="literal">WITH OIDS</code>を指定している場合は、すべてのパーティションがOIDを持っていなければならず、親のOIDは他の列と同様にすべてのパーティションに継承されます。
パーティションテーブルの列名や型の変更や、OID列の追加や削除は自動的にすべてのパーティションに反映されます。
<code class="literal">CHECK</code>制約はすべてのパーティションで自動的に継承されますが、個々のパーティションで追加の<code class="literal">CHECK</code>制約を指定することができます。
親の制約と同じ名前と条件を持つ追加制約は親の制約と統合されます。
デフォルト制約は各パーティションで別々に指定できます。
     </p><p>
<!--
      Rows inserted into a partitioned table will be automatically routed to
      the correct partition.  If no suitable partition exists, an error will
      occur.
-->
パーティションテーブルに挿入された行は、自動的に正しいパーティションに回されます。
適当なパーティションが存在しないときは、エラーが発生します。
     </p><p>
<!--
      Operations such as TRUNCATE which normally affect a table and all of its
      inheritance children will cascade to all partitions, but may also be
      performed on an individual partition.  Note that dropping a partition
      with <literal>DROP TABLE</literal> requires taking an <literal>ACCESS
      EXCLUSIVE</literal> lock on the parent table.
-->
TRUNCATEのように通常はテーブルとそれを継承するすべての子テーブルに影響を及ぼす操作は、すべてのパーティションに対しても適用されますが、個別のパーティションに対して操作することも可能です。
<code class="literal">DROP TABLE</code>でパーティションを削除するには、親テーブルについて<code class="literal">ACCESS EXCLUSIVE</code>のロックを取得する必要があることに注意してください。
     </p></dd><dt><span class="term"><code class="literal">LIKE <em class="replaceable"><code>source_table</code></em> [ <em class="replaceable"><code>like_option</code></em> ... ]</code></span></dt><dd><p>
<!--
      The <literal>LIKE</literal> clause specifies a table from which
      the new table automatically copies all column names, their data types,
      and their not-null constraints.
-->
<code class="literal">LIKE</code>句にテーブルを指定すると、自動的にそのテーブルの全ての列名、そのデータ型、非NULL制約が新しいテーブルにコピーされます。
     </p><p>
<!--
      Unlike <literal>INHERITS</literal>, the new table and original table
      are completely decoupled after creation is complete.  Changes to the
      original table will not be applied to the new table, and it is not
      possible to include data of the new table in scans of the original
      table.
-->
<code class="literal">INHERITS</code>とは違い、作成した後、新しいテーブルと元のテーブルが完全に分離されます。
元のテーブルへの変更は新しいテーブルには適用されません。また、元のテーブルを走査しても新しいテーブルのデータは見つかりません。
     </p><p>
<!--
      Default expressions for the copied column definitions will be copied
      only if <literal>INCLUDING DEFAULTS</literal> is specified.  The
      default behavior is to exclude default expressions, resulting in the
      copied columns in the new table having null defaults.
      Note that copying defaults that call database-modification functions,
      such as <function>nextval</function>, may create a functional linkage between
      the original and new tables.
-->
コピーする列のデフォルト式は、<code class="literal">INCLUDING DEFAULTS</code>が指定された場合にのみコピーされます。
デフォルトの動作では、デフォルト式がコピーされないため、新しいテーブルのコピーされた列はデフォルト値としてNULLを持つことになります。
<code class="function">nextval</code>のようにデータベースを変更する関数を呼び出すデフォルトをコピーすると、元のテーブルと新しいテーブルの間に関数的なリンクが作成される場合があることに注意してください。
     </p><p>
<!--
      Any identity specifications of copied column definitions will only be
      copied if <literal>INCLUDING IDENTITY</literal> is specified.  A new
      sequence is created for each identity column of the new table, separate
      from the sequences associated with the old table.
-->
コピーされる列定義のIDENTITYの指定は、<code class="literal">INCLUDING IDENTITY</code>が指定された場合にのみコピーされます。
新しいテーブルの各IDENTITY列には新しいシーケンスが作られ、古いテーブルに紐付けられたシーケンスとは別になります。
     </p><p>
<!--
      Not-null constraints are always copied to the new table.
      <literal>CHECK</literal> constraints will be copied only if
      <literal>INCLUDING CONSTRAINTS</literal> is specified.
      No distinction is made between column constraints and table
      constraints.
-->
非NULL制約は常に新しいテーブルにコピーされます。
<code class="literal">CHECK</code>制約は、<code class="literal">INCLUDING CONSTRAINTS</code>が指定された場合にのみコピーされます。
列制約とテーブル制約は区別されません。
     </p><p>
<!--
      Extended statistics are copied to the new table if
      <literal>INCLUDING STATISTICS</literal> is specified.
-->
拡張統計情報は<code class="literal">INCLUDING STATISTICS</code>が指定された場合にのみコピーされます。
     </p><p>
<!--
      Indexes, <literal>PRIMARY KEY</literal>, <literal>UNIQUE</literal>,
      and <literal>EXCLUDE</literal> constraints on the original table will be
      created on the new table only if <literal>INCLUDING INDEXES</literal>
      is specified.  Names for the new indexes and constraints are
      chosen according to the default rules, regardless of how the originals
      were named.  (This behavior avoids possible duplicate-name failures for
      the new indexes.)
-->
元のテーブルのインデックス、および<code class="literal">PRIMARY KEY</code>、<code class="literal">UNIQUE</code>、<code class="literal">EXCLUDE</code>の制約は<code class="literal">INCLUDING INDEXES</code>が指定された場合のみ、新しいテーブル上で作成されます。
新しいインデックスと制約の名前は、元の名前とは関係なく、デフォルトの規則に従って付けられます。
（この動作により、新しいインデックスが名前の重複によりエラーになる可能性を回避しています。）
     </p><p>
<!--
      <literal>STORAGE</literal> settings for the copied column definitions will be
      copied only if <literal>INCLUDING STORAGE</literal> is specified.  The
      default behavior is to exclude <literal>STORAGE</literal> settings, resulting
      in the copied columns in the new table having type-specific default
      settings.  For more on <literal>STORAGE</literal> settings, see
      <xref linkend="storage-toast"/>.
-->
複製された列定義に関する<code class="literal">STORAGE</code>設定は、<code class="literal">INCLUDING STORAGE</code>が指定された場合のみコピーされます。
このデフォルトの動作では、<code class="literal">STORAGE</code>設定は除外され、新しいテーブルにおけるコピーされた列は型固有のデフォルトの設定を持つようになります。
<code class="literal">STORAGE</code>の詳細については<a class="xref" href="storage-toast.html" title="68.2. TOAST">68.2</a>を参照してください。
     </p><p>
<!--
      Comments for the copied columns, constraints, and indexes
      will be copied only if <literal>INCLUDING COMMENTS</literal>
      is specified. The default behavior is to exclude comments, resulting in
      the copied columns and constraints in the new table having no comments.
-->
コピーされた列、制約、インデックスについてのコメントは<code class="literal">INCLUDING COMMENTS</code>が指定された場合のみコピーされます。
このデフォルトの動作では、コメントは除外され、新しいテーブルにおけるコピーされた列や制約はコメントを持ちません。
     </p><p>
<!--
      <literal>INCLUDING ALL</literal> is an abbreviated form of
      <literal>INCLUDING COMMENTS INCLUDING CONSTRAINTS INCLUDING DEFAULTS INCLUDING IDENTITY INCLUDING INDEXES INCLUDING STATISTICS INCLUDING STORAGE</literal>.
-->
<code class="literal">INCLUDING ALL</code>は<code class="literal">INCLUDING COMMENTS INCLUDING CONSTRAINTS INCLUDING DEFAULTS INCLUDING IDENTITY INCLUDING INDEXES INCLUDING STATISTICS INCLUDING STORAGE</code>の省略形です。
     </p><p>
<!--
      Note that unlike <literal>INHERITS</literal>, columns and
      constraints copied by <literal>LIKE</literal> are not merged with similarly
      named columns and constraints.
      If the same name is specified explicitly or in another
      <literal>LIKE</literal> clause, an error is signaled.
-->
<code class="literal">INHERITS</code>と異なり、<code class="literal">LIKE</code>によりコピーされた列や制約は類似の名前の列や制約にまとめられません。
同じ名前が明示的に、あるいは他の<code class="literal">LIKE</code>句で指定された場合、エラーが通知されます。
     </p><p>
<!--
      The <literal>LIKE</literal> clause can also be used to copy column
      definitions from views, foreign tables, or composite types.
      Inapplicable options (e.g., <literal>INCLUDING INDEXES</literal> from
      a view) are ignored.
-->
また<code class="literal">LIKE</code>句をビュー、外部テーブル、複合型から列の定義をコピーするために使用することができます。
適用できないオプション（ビューからの<code class="literal">INCLUDING INDEXES</code>など）は無視されます。
     </p></dd><dt><span class="term"><code class="literal">CONSTRAINT <em class="replaceable"><code>constraint_name</code></em></code></span></dt><dd><p>
<!--
      An optional name for a column or table constraint.  If the
      constraint is violated, the constraint name is present in error messages,
      so constraint names like <literal>col must be positive</literal> can be used
      to communicate helpful constraint information to client applications.
      (Double-quotes are needed to specify constraint names that contain spaces.)
      If a constraint name is not specified, the system generates a name.
-->
列制約、テーブル制約の名前(省略可能)です。
制約に違反すると、制約名がエラーメッセージに含まれます。
ですので、<code class="literal">col must be positive(正数でなければならない)</code>といった名前の制約名を付与することで、クライアントアプリケーションへ有用な制約情報を渡すことができます。
（空白を含む制約名を指定する場合、二重引用符が必要です。）
指定されなければ、システムが名前を生成します。
     </p></dd><dt><span class="term"><code class="literal">NOT NULL</code></span></dt><dd><p>
<!--
      The column is not allowed to contain null values.
-->
その列がNULL値を持てないことを指定します。
     </p></dd><dt><span class="term"><code class="literal">NULL</code></span></dt><dd><p>
<!--
      The column is allowed to contain null values. This is the default.
-->
その列がNULL値を持てることを指定します。
これがデフォルトです。
     </p><p>
<!--
      This clause is only provided for compatibility with
      non-standard SQL databases.  Its use is discouraged in new
      applications.
-->
この句は非標準的なSQLデータベースとの互換性のためだけに提供されています。
新しいアプリケーションでこれを使用するのはお勧めしません。
     </p></dd><dt><span class="term"><code class="literal">CHECK ( <em class="replaceable"><code>expression</code></em> ) [ NO INHERIT ] </code></span></dt><dd><p>
<!--
      The <literal>CHECK</literal> clause specifies an expression producing a
      Boolean result which new or updated rows must satisfy for an
      insert or update operation to succeed.  Expressions evaluating
      to TRUE or UNKNOWN succeed.  Should any row of an insert or
      update operation produce a FALSE result, an error exception is
      raised and the insert or update does not alter the database.  A
      check constraint specified as a column constraint should
      reference that column's value only, while an expression
      appearing in a table constraint can reference multiple columns.
-->
<code class="literal">CHECK</code>句は、論理型の結果を生成する、新しい行または更新される行が挿入または更新処理を成功させるために満足しなければならない式を指定します。
TRUEまたはUNKNOWNと評価される式は成功します。
挿入または更新処理の行がFALSEという結果をもたらす場合はエラー例外が発生し、その挿入または更新によるデータベースの変更は行われません。
列制約として指定された検査制約は列の値のみを参照しなければなりません。
テーブル制約内の式は複数の列を参照できます。
     </p><p>
<!--
      Currently, <literal>CHECK</literal> expressions cannot contain
      subqueries nor refer to variables other than columns of the
      current row.  The system column <literal>tableoid</literal>
      may be referenced, but not any other system column.
-->
現時点では、<code class="literal">CHECK</code>式には副問い合わせも現在の行の列以外の変数も含めることはできません。
システム列<code class="literal">tableoid</code>を参照することはできますが、他のシステム列は参照できません。
     </p><p>
<!--
      A constraint marked with <literal>NO INHERIT</literal> will not propagate to
      child tables.
-->
<code class="literal">NO INHERIT</code>と印が付いた制約は子テーブルには伝搬しません。
     </p><p>
<!--
      When a table has multiple <literal>CHECK</literal> constraints,
      they will be tested for each row in alphabetical order by name,
      after checking <literal>NOT NULL</literal> constraints.
      (<productname>PostgreSQL</productname> versions before 9.5 did not honor any
      particular firing order for <literal>CHECK</literal> constraints.)
-->
テーブルに複数の<code class="literal">CHECK</code>制約がある場合、それらは<code class="literal">NOT NULL</code>制約について検証した後で、各行について名前のアルファベット順に検証されます。
（<span class="productname">PostgreSQL</span>の9.5より前のバージョンでは、<code class="literal">CHECK</code>制約の実行について特定の順序はありませんでした。）
     </p></dd><dt><span class="term"><code class="literal">DEFAULT
    <em class="replaceable"><code>default_expr</code></em></code></span></dt><dd><p>
<!--
      The <literal>DEFAULT</literal> clause assigns a default data value for
      the column whose column definition it appears within.  The value
      is any variable-free expression (subqueries and cross-references
      to other columns in the current table are not allowed).  The
      data type of the default expression must match the data type of the
      column.
-->
<code class="literal">DEFAULT</code>句を列定義に付けると、その列にデフォルトデータ値が割り当てられます。
値として指定するのは、任意の無変数式です（副問い合わせや現在のテーブル内の他の列へ交差参照はできません）。
デフォルト式のデータ型はその列のデータ型と一致する必要があります。
     </p><p>
<!--
      The default expression will be used in any insert operation that
      does not specify a value for the column.  If there is no default
      for a column, then the default is null.
-->
デフォルト式は、全ての挿入操作において、その列に値が指定されていない場合に使用されます。
列にデフォルト値がない場合、デフォルト値はNULLになります。
     </p></dd><dt><span class="term"><code class="literal">GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <em class="replaceable"><code>sequence_options</code></em> ) ]</code></span></dt><dd><p>
<!--
      This clause creates the column as an <firstterm>identity
      column</firstterm>.  It will have an implicit sequence attached to it
      and the column in new rows will automatically have values from the
      sequence assigned to it.
-->
この句は列を<em class="firstterm">IDENTITY列</em>として作成します。
それには暗示的なシーケンスが紐付けられ、新しい行のその列には紐付けられたシーケンスから取られた値が自動的に入ります。
     </p><p>
<!--
      The clauses <literal>ALWAYS</literal> and <literal>BY DEFAULT</literal>
      determine how the sequence value is given precedence over a
      user-specified value in an <command>INSERT</command> statement.
      If <literal>ALWAYS</literal> is specified, a user-specified value is
      only accepted if the <command>INSERT</command> statement
      specifies <literal>OVERRIDING SYSTEM VALUE</literal>.  If <literal>BY
      DEFAULT</literal> is specified, then the user-specified value takes
      precedence.  See <xref linkend="sql-insert"/> for details.  (In
      the <command>COPY</command> command, user-specified values are always
      used regardless of this setting.)
-->
<code class="literal">ALWAYS</code>と<code class="literal">BY DEFAULT</code>の句は、ユーザが<code class="command">INSERT</code>文で指定した値に対するシーケンスの値の優先度がどうなるかを決定します。
<code class="literal">ALWAYS</code>が指定された場合、ユーザが指定した値は<code class="command">INSERT</code>文で<code class="literal">OVERRIDING SYSTEM VALUE</code>を指定した場合にのみ受け付けられます。
<code class="literal">BY DEFAULT</code>が指定された場合は、ユーザが指定した値が優先します。
詳細は<a class="xref" href="sql-insert.html" title="INSERT"><span class="refentrytitle">INSERT</span></a>を参照してください。
（<code class="command">COPY</code>コマンドでは、この設定と関係なく、ユーザが指定した値が常に使用されます。）
     </p><p>
<!--
      The optional <replaceable>sequence_options</replaceable> clause can be
      used to override the options of the sequence.
      See <xref linkend="sql-createsequence"/> for details.
-->
オプションで<em class="replaceable"><code>sequence_options</code></em>句を指定することにより、シーケンスのオプションを変更できます。
詳しくは<a class="xref" href="sql-createsequence.html" title="CREATE SEQUENCE"><span class="refentrytitle">CREATE SEQUENCE</span></a>を参照してください。
     </p></dd><dt><span class="term"><code class="literal">UNIQUE</code> （列制約）<br /></span><span class="term"><code class="literal">UNIQUE ( <em class="replaceable"><code>column_name</code></em> [, ... ] )</code>
<!--
    <optional> INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ...]) </optional> (table constraint)</term>
-->
    [<span class="optional"> INCLUDE ( <em class="replaceable"><code>column_name</code></em> [, ...]) </span>] (表制約）</span></dt><dd><p>
<!--
      The <literal>UNIQUE</literal> constraint specifies that a
      group of one or more columns of a table can contain
      only unique values. The behavior of the unique table constraint
      is the same as that for column constraints, with the additional
      capability to span multiple columns.
-->
<code class="literal">UNIQUE</code>制約は、テーブルの1つまたは複数の列からなるグループが、一意な値のみを持つことができることを指定します。
一意性テーブル制約の動作は一意性列制約と同じですが、さらに複数列にまたがる機能を持ちます。
     </p><p>
<!--
      For the purpose of a unique constraint, null values are not
      considered equal.
-->
一意性制約では、NULL値同士は等しいとはみなされなせん。
     </p><p>
<!--
      Each unique table constraint must name a set of columns that is
      different from the set of columns named by any other unique or
      primary key constraint defined for the table.  (Otherwise it
      would just be the same constraint listed twice.)
-->
それぞれの一意性テーブル制約には、そのテーブルの他の一意性制約もしくは主キー制約によって指定された列の集合とは、異なる名前の列の集合を指定しなければなりません
（同じ名前を指定すると、同じ制約が2回現れるだけになります）。
     </p><p>
<!--
      When establishing a unique constraint for a multi-level partition
      hierarchy, all the columns in the partition key of the target
      partitioned table, as well as those of all its descendant partitioned
      tables, must be included in the constraint definition.
-->
複数レベルのパーティション階層に一意性制約を設定するとき、対象パーティションテーブル、および全ての子孫のパーティションテーブルの、パーティションキー内の全ての列が制約定義に含まれなくてはなりません。
     </p><p>
<!--
      Adding a unique constraint will automatically create a unique btree
      index on the column or group of columns used in the constraint.
      The optional clause <literal>INCLUDE</literal> adds to that index
      one or more columns on which the uniqueness is not enforced.
      Note that although the constraint is not enforced on the included columns,
      it still depends on them.  Consequently, some operations on these columns
      (e.g. <literal>DROP COLUMN</literal>) can cause cascaded constraint and
      index deletion.
-->
一意性制約を加えると、制約で使われている列や列のグループに一意性btreeインデックスが自動的に作られます。
省略可能な<code class="literal">INCLUDE</code>句はインデックスに一意性を強要されない列を1つまたは複数、追加します。
含めた（INCLUDEした）列に制約は強制されませんが、依存はしていることに注意してください。
このため、これらの列に対する一部の操作（例えば<code class="literal">DROP COLUMN</code>）は制約の連鎖とインデックスの削除をひき起こすことがあります。
     </p></dd><dt><span class="term"><code class="literal">PRIMARY KEY</code> （列制約）<br /></span><span class="term"><code class="literal">PRIMARY KEY ( <em class="replaceable"><code>column_name</code></em> [, ... ] )</code>
<!--
    <optional> INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ...]) </optional> (table constraint)</term>
-->
    [<span class="optional"> INCLUDE ( <em class="replaceable"><code>column_name</code></em> [, ...]) </span>] (表制約）</span></dt><dd><p>
<!--
      The <literal>PRIMARY KEY</literal> constraint specifies that a column or
      columns of a table can contain only unique (non-duplicate), nonnull
      values. Only one primary key can be specified for a table, whether as a
      column constraint or a table constraint.
-->
<code class="literal">PRIMARY KEY</code>制約はテーブルの一列または複数の列が一意（重複がない）で、非NULLの値のみを持つことを指定します。
列制約か表制約かに関わらず、１つのテーブルには主キーを１つだけ指定できます。
     </p><p>
<!--
      The primary key constraint should name a set of columns that is
      different from the set of columns named by any unique
      constraint defined for the same table.  (Otherwise, the unique
      constraint is redundant and will be discarded.)
-->
主キー制約では、同じテーブルに一意制約で指定した列の集合とは異なる列の集合を指定します。
（そうでなければ、一意制約は冗長となり、捨てられます。）
     </p><p>
<!--
      <literal>PRIMARY KEY</literal> enforces the same data constraints as
      a combination of <literal>UNIQUE</literal> and <literal>NOT NULL</literal>, but
      identifying a set of columns as the primary key also provides metadata
      about the design of the schema, since a primary key implies that other
      tables can rely on this set of columns as a unique identifier for rows.
-->
<code class="literal">PRIMARY KEY</code>は<code class="literal">UNIQUE</code>と<code class="literal">NOT NULL</code>の組み合わせと同じデータ制約を課しますが、列の集合を主キーと指定することは、スキーマの設計についてのメタデータを提供することにもなります。
なぜなら、主キーであることは、行を一意に特定するものとして、他のテーブルがその列の集合を当てにして良い、ということを意味するからです。
     </p><p>
<!--
      <literal>PRIMARY KEY</literal> constraints share the restrictions that
      <literal>UNIQUE</literal> constraints have when placed on partitioned
      tables.
-->
<code class="literal">PRIMARY KEY</code>制約は、パーティションテーブルに設定するときに<code class="literal">UNIQUE</code>制約が持つ制限を共有します。
     </p><p>
<!--
      Adding a <literal>PRIMARY KEY</literal> constraint will automatically
      create a unique btree index on the column or group of columns used in the
      constraint.  The optional <literal>INCLUDE</literal> clause allows a list
      of columns to be specified which will be included in the non-key portion
      of the index.  Although uniqueness is not enforced on the included columns,
      the constraint still depends on them. Consequently, some operations on the
      included columns (e.g. <literal>DROP COLUMN</literal>) can cause cascaded
      constraint and index deletion.
-->
<code class="literal">PRIMARY KEY</code>制約を追加すると、制約で使用する列や列のグループに一意性のbtreeインデックスが自動的に作られます。
省略可能な<code class="literal">INCLUDE</code>句はインデックスの非キー部分に含める列のリストを指定できます。
含めた列に一意性は強制されませんが、制約はこれらに依存はしています。
このため、これらの含められた列に対する一部の操作（例えば<code class="literal">DROP COLUMN</code>）は制約の連鎖とインデックスの削除をひき起こすことがあります。
     </p></dd><dt id="SQL-CREATETABLE-EXCLUDE"><span class="term"><code class="literal">EXCLUDE [ USING <em class="replaceable"><code>index_method</code></em> ] ( <em class="replaceable"><code>exclude_element</code></em> WITH <em class="replaceable"><code>operator</code></em> [, ... ] ) <em class="replaceable"><code>index_parameters</code></em> [ WHERE ( <em class="replaceable"><code>predicate</code></em> ) ]</code></span></dt><dd><p>
<!--
      The <literal>EXCLUDE</literal> clause defines an exclusion
      constraint, which guarantees that if
      any two rows are compared on the specified column(s) or
      expression(s) using the specified operator(s), not all of these
      comparisons will return <literal>TRUE</literal>.  If all of the
      specified operators test for equality, this is equivalent to a
      <literal>UNIQUE</literal> constraint, although an ordinary unique constraint
      will be faster.  However, exclusion constraints can specify
      constraints that are more general than simple equality.
      For example, you can specify a constraint that
      no two rows in the table contain overlapping circles
      (see <xref linkend="datatype-geometric"/>) by using the
      <literal>&amp;&amp;</literal> operator.
-->
<code class="literal">EXCLUDE</code>句は排他制約を定義し、任意の2行について指定した列(複数可)または式(複数可)を指定した演算子(複数可)を使用して比較した場合、比較結果のすべてが<code class="literal">TRUE</code>を返さないことを保証します。
指定した演算子のすべてが等価性を試験するものであれば、これは<code class="literal">UNIQUE</code>制約と同じですが、通常の一意性制約のほうが高速です。
しかし、排他制約では単純な等価性よりも一般的な制約を指定することができます。
例えば、テーブル内の2つの行が重複する円(<a class="xref" href="datatype-geometric.html" title="8.8. 幾何データ型">8.8</a>参照)を持たないといった制約を<code class="literal">&amp;&amp;</code>演算子を使用して指定することができます。
     </p><p>
<!--
      Exclusion constraints are implemented using
      an index, so each specified operator must be associated with an
      appropriate operator class
      (see <xref linkend="indexes-opclass"/>) for the index access
      method <replaceable>index_method</replaceable>.
      The operators are required to be commutative.
      Each <replaceable class="parameter">exclude_element</replaceable>
      can optionally specify an operator class and/or ordering options;
      these are described fully under
      <xref linkend="sql-createindex"/>.
-->
排他制約はインデックスを使用して実装されています。
このため指定した演算子はそれぞれ適切な演算子クラス(<a class="xref" href="indexes-opclass.html" title="11.10. 演算子クラスと演算子族">11.10</a>参照)で<em class="replaceable"><code>index_method</code></em>インデックスアクセスメソッドと関連付けされていなければなりません。
演算子は交換可能でなければなりません。
オプションで、各<em class="replaceable"><code>exclude_element</code></em>は演算子クラス、順序付けオプション、またはその両方を指定することができます。
これらについては<a class="xref" href="sql-createindex.html" title="CREATE INDEX"><span class="refentrytitle">CREATE INDEX</span></a>で説明します。
     </p><p>
<!--
      The access method must support <literal>amgettuple</literal> (see <xref
      linkend="indexam"/>); at present this means <acronym>GIN</acronym>
      cannot be used.  Although it's allowed, there is little point in using
      B-tree or hash indexes with an exclusion constraint, because this
      does nothing that an ordinary unique constraint doesn't do better.
      So in practice the access method will always be <acronym>GiST</acronym> or
      <acronym>SP-GiST</acronym>.
-->
アクセスメソッドは<code class="literal">amgettuple</code>をサポートしなければなりません(<a class="xref" href="indexam.html" title="第61章 インデックスアクセスメソッドのインタフェース定義">第61章</a>参照)。
現時点では、これは<acronym class="acronym">GIN</acronym>を使用できないことを意味します。
B-treeやHashインデックスを排他制約で使用することは許容されますが、そうすることにあまり意味はありません。
これが通常の一意性制約より良いことは何もないからです。
このため現実的にはアクセスメソッドは常に<acronym class="acronym">GiST</acronym>もしくは<acronym class="acronym">SP-GiST</acronym>となります。
     </p><p>
<!--
      The <replaceable class="parameter">predicate</replaceable> allows you to specify an
      exclusion constraint on a subset of the table; internally this creates a
      partial index. Note that parentheses are required around the predicate.
-->
<em class="replaceable"><code>predicate</code></em>により、排他制約をテーブルの部分集合に指定することができます。
内部的には、これは部分インデックスを作成します。
predicateの前後に括弧が必要であることに注意して下さい。
     </p></dd><dt><span class="term"><code class="literal">REFERENCES <em class="replaceable"><code>reftable</code></em> [ ( <em class="replaceable"><code>refcolumn</code></em> ) ] [ MATCH <em class="replaceable"><code>matchtype</code></em> ] [ ON DELETE <em class="replaceable"><code>action</code></em> ] [ ON UPDATE <em class="replaceable"><code>action</code></em> ]</code> （列制約）<br /></span><span class="term"><code class="literal">FOREIGN KEY ( <em class="replaceable"><code>column_name</code></em> [, ... ] )
    REFERENCES <em class="replaceable"><code>reftable</code></em> [ ( <em class="replaceable"><code>refcolumn</code></em> [, ... ] ) ]
    [ MATCH <em class="replaceable"><code>matchtype</code></em> ]
    [ ON DELETE <em class="replaceable"><code>action</code></em> ]
    [ ON UPDATE <em class="replaceable"><code>action</code></em> ]</code>
<!--
    (table constraint)</term>
-->
    （表制約）</span></dt><dd><p>
<!--
      These clauses specify a foreign key constraint, which requires
      that a group of one or more columns of the new table must only
      contain values that match values in the referenced
      column(s) of some row of the referenced table.  If the <replaceable
      class="parameter">refcolumn</replaceable> list is omitted, the
      primary key of the <replaceable class="parameter">reftable</replaceable>
      is used.  The referenced columns must be the columns of a non-deferrable
      unique or primary key constraint in the referenced table.  The user
      must have <literal>REFERENCES</literal> permission on the referenced table
      (either the whole table, or the specific referenced columns).  The
      addition of a foreign key constraint requires a
      <literal>SHARE ROW EXCLUSIVE</literal> lock on the referenced table.
      Note that foreign key constraints cannot be defined between temporary
      tables and permanent tables.  Also note that while it is possible to
      define a foreign key on a partitioned table, it is not possible to
      declare a foreign key that references a partitioned table.
-->
これらの句は、外部キー制約を指定します。
外部キー制約は、新しいテーブルの1つまたは複数の列の集合が、被参照テーブルの一部の行の被参照列に一致する値を持たなければならないことを指定するものです。
<em class="replaceable"><code>refcolumn</code></em>リストが省略された場合、<em class="replaceable"><code>reftable</code></em>の主キーが使用されます。
被参照列は、被参照テーブルにおいて遅延不可の一意性制約もしくは主キー制約を持った列でなければなりません。
ユーザは被参照テーブル（テーブル全体または特定の被参照列）について<code class="literal">REFERENCES</code>権限を持っていなければなりません。
外部キー制約の追加は被参照テーブルに<code class="literal">SHARE ROW EXCLUSIVE</code>ロックを必要とします。
一時テーブルと永続テーブルとの間で外部キー制約を定義できないことに注意してください。
パーティションテーブルに外部キーを定義できる一方、外部キーテーブルを参照する外部キーは定義できないことにも注意してください。
     </p><p>
<!--
      A value inserted into the referencing column(s) is matched against the
      values of the referenced table and referenced columns using the
      given match type.  There are three match types: <literal>MATCH
      FULL</literal>, <literal>MATCH PARTIAL</literal>, and <literal>MATCH
      SIMPLE</literal> (which is the default).  <literal>MATCH
      FULL</literal> will not allow one column of a multicolumn foreign key
      to be null unless all foreign key columns are null; if they are all
      null, the row is not required to have a match in the referenced table.
      <literal>MATCH SIMPLE</literal> allows any of the foreign key columns
      to be null; if any of them are null, the row is not required to have a
      match in the referenced table.
      <literal>MATCH PARTIAL</literal> is not yet implemented.
      (Of course, <literal>NOT NULL</literal> constraints can be applied to the
      referencing column(s) to prevent these cases from arising.)
-->
参照列に挿入された値は、被参照テーブルと被参照列の値に対して、指定した照合型で照会されます。
照合型には3種類があります。
<code class="literal">MATCH FULL</code>、<code class="literal">MATCH PARTIAL</code>、<code class="literal">MATCH SIMPLE</code>（これがデフォルト）照合型です。
<code class="literal">MATCH FULL</code>は全ての外部キー列がNULLとなる場合を除き、複数列外部キーのある列がNULLとなることを許可しません。
それらがすべてNULLであれば、その行は被参照テーブル内で一致があることは要求されません。
<code class="literal">MATCH SIMPLE</code>は、外部キーの一部がNULLであることを許可します。
それらの一部がNULLであれば、その行は被参照テーブル内で一致があることは要求されません。
<code class="literal">MATCH PARTIAL</code>はまだ実装されていません。
（当然ですが、<code class="literal">NOT NULL</code>制約を参照列に適用し、こうした状態が発生することを防止することができます。）
     </p><p>
<!--
      In addition, when the data in the referenced columns is changed,
      certain actions are performed on the data in this table's
      columns.  The <literal>ON DELETE</literal> clause specifies the
      action to perform when a referenced row in the referenced table is
      being deleted.  Likewise, the <literal>ON UPDATE</literal>
      clause specifies the action to perform when a referenced column
      in the referenced table is being updated to a new value. If the
      row is updated, but the referenced column is not actually
      changed, no action is done. Referential actions other than the
      <literal>NO ACTION</literal> check cannot be deferred, even if
      the constraint is declared deferrable. There are the following possible
      actions for each clause:
-->
さらに、被参照列のデータが変更された場合、このテーブルの列のデータに何らかの動作が発生します。
<code class="literal">ON DELETE</code>句は、被参照テーブルの被参照行が削除されようとした場合の動作を指定します。
同様に<code class="literal">ON UPDATE</code>句は、被参照テーブルの被参照列が新しい値に更新されようとした場合の動作を指定します。
行の更新があった場合でも、被参照列が実際に変更されない場合は、動作は実行されません。
制約が遅延可能と宣言されていても、<code class="literal">NO ACTION</code>検査以外の参照動作は遅延させられません。
各句について、以下の動作を指定可能です。

      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">NO ACTION</code></span></dt><dd><p>
<!--
          Produce an error indicating that the deletion or update
          would create a foreign key constraint violation.
          If the constraint is deferred, this
          error will be produced at constraint check time if there still
          exist any referencing rows.  This is the default action.
-->
削除もしくは更新により外部キー制約違反が起こることを示すエラーを発生します。
制約が遅延可能な場合、何らかの参照行が存在する限り、このエラーは制約の検査時点で発生します。
これはデフォルトの動作です。
         </p></dd><dt><span class="term"><code class="literal">RESTRICT</code></span></dt><dd><p>
<!--
          Produce an error indicating that the deletion or update
          would create a foreign key constraint violation.
          This is the same as <literal>NO ACTION</literal> except that
          the check is not deferrable.
-->
削除もしくは更新が外部キー制約違反となることを示すエラーを発生します。
検査が遅延できない点を除き、<code class="literal">NO ACTION</code>と同じです。
         </p></dd><dt><span class="term"><code class="literal">CASCADE</code></span></dt><dd><p>
<!--
          Delete any rows referencing the deleted row, or update the
          values of the referencing column(s) to the new values of the
          referenced columns, respectively.
-->
削除された行を参照している行は全て削除します。また、参照している列の値を、被参照列の新しい値にします。
         </p></dd><dt><span class="term"><code class="literal">SET NULL</code></span></dt><dd><p>
<!--
          Set the referencing column(s) to null.
-->
参照する列をNULLに設定します。
         </p></dd><dt><span class="term"><code class="literal">SET DEFAULT</code></span></dt><dd><p>
<!--
          Set the referencing column(s) to their default values.
          (There must be a row in the referenced table matching the default
          values, if they are not null, or the operation will fail.)
-->
参照する列をそのデフォルト値に設定します。
（デフォルト値がNULLでない場合は被参照テーブルの中にデフォルト値に一致する行が存在しなければなりません。さもないと操作が失敗します。）
         </p></dd></dl></div><p>
     </p><p>
<!--
      If the referenced column(s) are changed frequently, it might be wise to
      add an index to the referencing column(s) so that referential actions
      associated with the foreign key constraint can be performed more
      efficiently.
-->
被参照列が頻繁に更新される場合、参照列にインデックスを付け、その外部キー制約に関連する参照動作がより効率的に実行できるようにする方が良いでしょう。
     </p></dd><dt><span class="term"><code class="literal">DEFERRABLE</code><br /></span><span class="term"><code class="literal">NOT DEFERRABLE</code></span></dt><dd><p>
<!--
      This controls whether the constraint can be deferred.  A
      constraint that is not deferrable will be checked immediately
      after every command.  Checking of constraints that are
      deferrable can be postponed until the end of the transaction
      (using the <xref linkend="sql-set-constraints"/> command).
      <literal>NOT DEFERRABLE</literal> is the default.
      Currently, only <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>,
      <literal>EXCLUDE</literal>, and
      <literal>REFERENCES</literal> (foreign key) constraints accept this
      clause.  <literal>NOT NULL</literal> and <literal>CHECK</literal> constraints are not
      deferrable.  Note that deferrable constraints cannot be used as
      conflict arbitrators in an <command>INSERT</command> statement that
      includes an <literal>ON CONFLICT DO UPDATE</literal> clause.
-->
制約を遅延させることが可能かどうかを制御します。
遅延不可の制約は各コマンドの後すぐに検査されます。
遅延可能な制約の検査は、（<a class="xref" href="sql-set-constraints.html" title="SET CONSTRAINTS"><span class="refentrytitle">SET CONSTRAINTS</span></a>コマンドを使用して）トランザクションの終了時まで遅延させることができます。
<code class="literal">NOT DEFERRABLE</code>がデフォルトです。
現在、<code class="literal">UNIQUE</code>、<code class="literal">PRIMARY KEY</code>、<code class="literal">EXCLUDE</code>、<code class="literal">REFERENCES</code>（外部キー）制約のみがこの句を受け付けることができます。
<code class="literal">NOT NULL</code>および <code class="literal">CHECK</code>制約は遅延させることができません。
遅延可能な制約は<code class="literal">ON CONFLICT DO UPDATE</code>句を含む<code class="command">INSERT</code>文において、競合解決のために使うことはできないことに注意してください。
     </p></dd><dt><span class="term"><code class="literal">INITIALLY IMMEDIATE</code><br /></span><span class="term"><code class="literal">INITIALLY DEFERRED</code></span></dt><dd><p>
<!--
      If a constraint is deferrable, this clause specifies the default
      time to check the constraint.  If the constraint is
      <literal>INITIALLY IMMEDIATE</literal>, it is checked after each
      statement. This is the default.  If the constraint is
      <literal>INITIALLY DEFERRED</literal>, it is checked only at the
      end of the transaction.  The constraint check time can be
      altered with the <xref linkend="sql-set-constraints"/> command.
-->
制約が遅延可能な場合、この句は制約検査を行うデフォルトの時期を指定します。
制約が<code class="literal">INITIALLY IMMEDIATE</code>の場合、各文の実行後に検査されます。
これがデフォルトです。
制約が<code class="literal">INITIALLY DEFERRED</code>の場合、トランザクションの終了時にのみ検査されます。
制約検査の時期は<a class="xref" href="sql-set-constraints.html" title="SET CONSTRAINTS"><span class="refentrytitle">SET CONSTRAINTS</span></a>コマンドを使用して変更することができます。
     </p></dd><dt><span class="term"><code class="literal">WITH ( <em class="replaceable"><code>storage_parameter</code></em> [= <em class="replaceable"><code>value</code></em>] [, ... ] )</code></span></dt><dd><p>
<!--
      This clause specifies optional storage parameters for a table or index;
      see <xref linkend="sql-createtable-storage-parameters"
      endterm="sql-createtable-storage-parameters-title"/> for more
      information.  The <literal>WITH</literal> clause for a
      table can also include <literal>OIDS=TRUE</literal> (or just <literal>OIDS</literal>)
      to specify that rows of the new table
      should have OIDs (object identifiers) assigned to them, or
      <literal>OIDS=FALSE</literal> to specify that the rows should not have OIDs.
      If <literal>OIDS</literal> is not specified, the default setting depends upon
      the <xref linkend="guc-default-with-oids"/> configuration parameter.
      (If the new table inherits from any tables that have OIDs, then
      <literal>OIDS=TRUE</literal> is forced even if the command says
      <literal>OIDS=FALSE</literal>.)
-->
この句は、テーブルまたはインデックスに対して格納パラメータ(省略可能)を指定します。
詳細は<a class="xref" href="sql-createtable.html#SQL-CREATETABLE-STORAGE-PARAMETERS" title="格納パラメータ">格納パラメータ</a>を参照してください。
テーブルについての<code class="literal">WITH</code>には、<code class="literal">OIDS=TRUE</code>（もしくは単に<code class="literal">OIDS</code>）を含めて、新しいテーブルの行が行に割り当てられたOID（オブジェクト識別子）を持たなければならないことを指定することもできます。
また、<code class="literal">OIDS=FALSE</code>を含めて、OIDを持たないことを指定することもできます。
<code class="literal">OIDS</code>が指定されない場合、デフォルトの設定は設定パラメータ<a class="xref" href="runtime-config-compatible.html#GUC-DEFAULT-WITH-OIDS">default_with_oids</a>に依存します。
（新しいテーブルがOIDを持つテーブルから継承する場合、コマンドで<code class="literal">OIDS=FALSE</code>と指定しても強制的に<code class="literal">OIDS=TRUE</code> となります。）
     </p><p>
<!--
      If <literal>OIDS=FALSE</literal> is specified or implied, the new
      table does not store OIDs and no OID will be assigned for a row inserted
      into it. This is generally considered worthwhile, since it
      will reduce OID consumption and thereby postpone the wraparound
      of the 32-bit OID counter. Once the counter wraps around, OIDs
      can no longer be assumed to be unique, which makes them
      considerably less useful. In addition, excluding OIDs from a
      table reduces the space required to store the table on disk by
      4 bytes per row (on most machines), slightly improving performance.
-->
<code class="literal">OIDS=FALSE</code>が明示的または暗黙的に指定されている場合、新しいテーブルはOIDを格納しません。また、挿入される行にはOIDが割り当てられません。
このような動作は一般的に有益であると考えられます。それは、OIDの使用を抑え、32ビットのOIDカウンタの回転周期を延長できるためです。
カウンタが一周するとOIDの一意性を保証できなくなるので、その有用性を減少させることになります。
また、OIDをなくすことで、テーブル1行当たり（ほとんどのマシンで）4バイト分、テーブルをディスクに格納するための容量を軽減するので、多少性能が向上します。

     </p><p>
<!--
      To remove OIDs from a table after it has been created, use <xref
      linkend="sql-altertable"/>.
-->
テーブルの作成後にOIDを削除するには、<a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>を使用してください。
     </p></dd><dt><span class="term"><code class="literal">WITH OIDS</code><br /></span><span class="term"><code class="literal">WITHOUT OIDS</code></span></dt><dd><p>
<!--
      These are obsolescent syntaxes equivalent to <literal>WITH (OIDS)</literal>
      and <literal>WITH (OIDS=FALSE)</literal>, respectively.  If you wish to give
      both an <literal>OIDS</literal> setting and storage parameters, you must use
      the <literal>WITH ( ... )</literal> syntax; see above.
-->
これは古い構文で、それぞれ<code class="literal">WITH (OIDS)</code>および<code class="literal">WITH (OIDS=FALSE)</code>と同じです。
<code class="literal">OIDS</code>の設定と格納パラメータの設定の両方を指定したい場合は、上述の<code class="literal">WITH ( ... )</code>を使用しなければなりません。
     </p></dd><dt><span class="term"><code class="literal">ON COMMIT</code></span></dt><dd><p>
<!--
      The behavior of temporary tables at the end of a transaction
      block can be controlled using <literal>ON COMMIT</literal>.
      The three options are:
-->
<code class="literal">ON COMMIT</code>を使用して、トランザクションブロックの終了時点での一時テーブルの動作を制御することができます。
以下の3つのオプションがあります。

      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">PRESERVE ROWS</code></span></dt><dd><p>
<!--
          No special action is taken at the ends of transactions.
          This is the default behavior.
-->
トランザクションの終了時点で、特別な動作は行われません。
これがデフォルトの動作です。
         </p></dd><dt><span class="term"><code class="literal">DELETE ROWS</code></span></dt><dd><p>
<!--
          All rows in the temporary table will be deleted at the end
          of each transaction block.  Essentially, an automatic <xref
          linkend="sql-truncate"/> is done
          at each commit.  When used on a partitioned table, this
          is not cascaded to its partitions.
-->
一時テーブル内の全ての行は、各トランザクションブロックの終わりで削除されます。
実質的には、コミットの度に自動的に<a class="xref" href="sql-truncate.html" title="TRUNCATE"><span class="refentrytitle">TRUNCATE</span></a>が実行されます。
パーティションテーブルに使われた場合、そのパーティションに連鎖適用はされません。
         </p></dd><dt><span class="term"><code class="literal">DROP</code></span></dt><dd><p>
<!--
          The temporary table will be dropped at the end of the current
          transaction block.  When used on a partitioned table, this action
          drops its partitions and when used on tables with inheritance
          children, it drops the dependent children.
-->
一時テーブルは現在のトランザクションブロックの終わりで削除されます。
この動作は、パーティションテーブルに使われたときにそのパーティションを削除し、継承の子テーブルを伴うテーブルに使われたときに従属する子テーブルを削除します。
         </p></dd></dl></div></dd><dt><span class="term"><code class="literal">TABLESPACE <em class="replaceable"><code>tablespace_name</code></em></code></span></dt><dd><p>
<!--
      The <replaceable class="parameter">tablespace_name</replaceable> is the name
      of the tablespace in which the new table is to be created.
      If not specified,
      <xref linkend="guc-default-tablespace"/> is consulted, or
      <xref linkend="guc-temp-tablespaces"/> if the table is temporary.
-->
<em class="replaceable"><code>tablespace_name</code></em>は、新しいテーブルが作成されるテーブル空間名です。
指定されていない場合、<a class="xref" href="runtime-config-client.html#GUC-DEFAULT-TABLESPACE">default_tablespace</a>が、また一時テーブルの場合は<a class="xref" href="runtime-config-client.html#GUC-TEMP-TABLESPACES">temp_tablespaces</a>が考慮されます。
     </p></dd><dt><span class="term"><code class="literal">USING INDEX TABLESPACE <em class="replaceable"><code>tablespace_name</code></em></code></span></dt><dd><p>
<!--
      This clause allows selection of the tablespace in which the index
      associated with a <literal>UNIQUE</literal>, <literal>PRIMARY
      KEY</literal>, or <literal>EXCLUDE</literal> constraint will be created.
      If not specified,
      <xref linkend="guc-default-tablespace"/> is consulted, or
      <xref linkend="guc-temp-tablespaces"/> if the table is temporary.
-->
この句により、<code class="literal">UNIQUE</code>、<code class="literal">PRIMARY KEY</code>、または<code class="literal">EXCLUDE</code>制約に関連したインデックスを作成するテーブル空間を選択することができます。
指定されていない場合、<a class="xref" href="runtime-config-client.html#GUC-DEFAULT-TABLESPACE">default_tablespace</a>が、また一時テーブルであれば<a class="xref" href="runtime-config-client.html#GUC-TEMP-TABLESPACES">temp_tablespaces</a>が考慮されます。
     </p></dd></dl></div><div class="refsect2" id="SQL-CREATETABLE-STORAGE-PARAMETERS"><h3>格納パラメータ</h3><!--
   <title id="sql-createtable-storage-parameters-title">Storage Parameters</title>
--><a id="id-1.9.3.85.6.3.2" class="indexterm"></a><p>
<!--
    The <literal>WITH</literal> clause can specify <firstterm>storage parameters</firstterm>
    for tables, and for indexes associated with a <literal>UNIQUE</literal>,
    <literal>PRIMARY KEY</literal>, or <literal>EXCLUDE</literal> constraint.
    Storage parameters for
    indexes are documented in <xref linkend="sql-createindex"/>.
    The storage parameters currently
    available for tables are listed below.  For many of these parameters, as
    shown, there is an additional parameter with the same name prefixed with
    <literal>toast.</literal>, which controls the behavior of the
    table's secondary <acronym>TOAST</acronym> table, if any
    (see <xref linkend="storage-toast"/> for more information about TOAST).
    If a table parameter value is set and the
    equivalent <literal>toast.</literal> parameter is not, the TOAST table
    will use the table's parameter value.
    Specifying these parameters for partitioned tables is not supported,
    but you may specify them for individual leaf partitions.
-->
<code class="literal">WITH</code>句により、テーブルおよび<code class="literal">UNIQUE</code>、<code class="literal">PRIMARY KEY</code>、または<code class="literal">EXCLUDE</code>制約と関連づいたインデックスの<em class="firstterm">格納パラメータ</em>を指定することができます。
インデックスの格納パラメータについては<a class="xref" href="sql-createindex.html" title="CREATE INDEX"><span class="refentrytitle">CREATE INDEX</span></a>で説明します。
現在テーブルで設定可能な格納パラメータの一覧を以下に示します。
これらのパラメータの多くに対して、示した通り、さらに<code class="literal">toast</code>という接頭辞のついた、同一の名前のパラメータがあります。
これはもしあれば、テーブルの補助<acronym class="acronym">TOAST</acronym>テーブルの動作を制御します。
(TOASTに関する詳細については<a class="xref" href="storage-toast.html" title="68.2. TOAST">68.2</a>を参照してください。)
テーブルのパラメータ値が設定され、それと同等の<code class="literal">toast.</code>パラメータが設定されていない場合、TOASTテーブルはテーブルのパラメータ値を利用します。
これらのパラメータをパーティションテーブルについて指定することはサポートされませんが、個々の末端のパーティションについて指定することはできます。
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">fillfactor</code> (<code class="type">integer</code>)</span></dt><dd><p>
<!--
      The fillfactor for a table is a percentage between 10 and 100.
      100 (complete packing) is the default.  When a smaller fillfactor
      is specified, <command>INSERT</command> operations pack table pages only
      to the indicated percentage; the remaining space on each page is
      reserved for updating rows on that page.  This gives <command>UPDATE</command>
      a chance to place the updated copy of a row on the same page as the
      original, which is more efficient than placing it on a different page.
      For a table whose entries are never updated, complete packing is the
      best choice, but in heavily updated tables smaller fillfactors are
      appropriate.  This parameter cannot be set for TOAST tables.
-->
テーブルのフィルファクタ(fillfactor)は10から100までの間の割合（パーセント）です。
100（すべて使用）がデフォルトです。
より小さな値を指定すると、<code class="command">INSERT</code>操作は指定した割合までしかテーブルページを使用しません。
各ページの残りの部分は、そのページ内の行の更新用に予約されます。
これにより<code class="command">UPDATE</code>は、元の行と同じページ上に更新済みの行を格納することができるようになります。
これは別のページに更新済みの行を格納することよりも効率的です。
項目の更新がまったくないテーブルでは、すべてを使用することが最善の選択ですが、更新が非常に多いテーブルではより小さめのフィルファクタが適切です。
TOASTテーブルではこのパラメータを設定できません。
     </p></dd><dt><span class="term"><code class="literal">toast_tuple_target</code> (<code class="type">integer</code>)</span></dt><dd><p>
<!--
      The toast_tuple_target specifies the minimum tuple length required before
      we try to move long column values into TOAST tables, and is also the
      target length we try to reduce the length below once toasting begins.
      This only affects columns marked as either External or Extended
      and applies only to new tuples - there is no effect on existing rows.
      By default this parameter is set to allow at least 4 tuples per block,
      which with the default blocksize will be 2040 bytes. Valid values are
      between 128 bytes and the (blocksize - header), by default 8160 bytes.
      Changing this value may not be useful for very short or very long rows.
      Note that the default setting is often close to optimal, and
      it is possible that setting this parameter could have negative
      effects in some cases.
      This parameter cannot be set for TOAST tables.
-->
toast_tuple_targetは、長い列値をTOASTテーブルに移動する前に必要とされる最小タプル長を指定します。また、これはTOAST化を開始したときに長さをそれ未満に減らそうとする目標にもなります。
これはEXTERNALかEXTENDEDと印付けされた列にのみ影響があり、また、新たなタプルにのみ適用されます。既存の行には影響ありません。
デフォルトでは、このパラメータは1ブロックあたり少なくとも4タプルが可能であるように設定されます。これはデフォルトブロックサイズであれば2040バイトになります。
有効な値は128バイトから、ブロックサイズ - ヘッダ（デフォルトでは8160バイト）の間です。
非常に短いあるいは長い行に対して、この値を変更することはおそらく有用ではありません。
時にはデフォルト設定が最適に近く、本パラメータを設定することで場合によっては悪影響があるかもしれないことに注意してください。
     </p></dd><dt><span class="term"><code class="literal">parallel_workers</code> (<code class="type">integer</code>)</span></dt><dd><p>
<!--
      This sets the number of workers that should be used to assist a parallel
      scan of this table.  If not set, the system will determine a value based
      on the relation size.  The actual number of workers chosen by the planner
      or by utility statements that use parallel scans may be less, for example
      due to the setting of <xref linkend="guc-max-worker-processes"/>.
-->
このテーブルの並列スキャンを支援するために使用されるワーカの数を設定します。
設定されなければ、リレーションのサイズに基づいてシステムが値を決定します。
プランナやパラレルスキャンを使うユーティリティ文により選ばれるワーカの数は、例えば<a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a>の設定によって、より少なくなるかもしれません。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_enabled</code>, <code class="literal">toast.autovacuum_enabled</code> (<code class="type">boolean</code>)</span></dt><dd><p>
<!--
     Enables or disables the autovacuum daemon for a particular table.
     If true, the autovacuum daemon will perform automatic <command>VACUUM</command>
     and/or <command>ANALYZE</command> operations on this table following the rules
     discussed in <xref linkend="autovacuum"/>.
     If false, this table will not be autovacuumed, except to prevent
     transaction ID wraparound. See <xref linkend="vacuum-for-wraparound"/> for
     more about wraparound prevention.
     Note that the autovacuum daemon does not run at all (except to prevent
     transaction ID wraparound) if the <xref linkend="guc-autovacuum"/>
     parameter is false; setting individual tables' storage parameters does
     not override that.  Therefore there is seldom much point in explicitly
     setting this storage parameter to <literal>true</literal>, only
     to <literal>false</literal>.
-->
特定のテーブルに対する自動バキュームデーモンを有効または無効にします。
trueの場合、自動バキュームデーモンは、更新または削除されたタプル数が<code class="literal">autovacuum_vacuum_threshold</code>＋<code class="literal">autovacuum_vacuum_scale_factor</code>×リレーション内の推定有効タプル数を超えたときに、特定のテーブルに対する<code class="command">VACUUM</code>操作を始めます。
trueの場合、自動バキュームデーモンは、<a class="xref" href="routine-vacuuming.html#AUTOVACUUM" title="24.1.6. 自動バキュームデーモン">24.1.6</a>に記述されたルールに従って、このテーブルに対して自動的に<code class="command">VACUUM</code>あるいは<code class="command">ANALYZE</code>またはその両方の操作を行います。
falseの場合、トランザクションIDの周回問題を回避するためを除き自動バキュームは行われません。
周回問題の回避については<a class="xref" href="routine-vacuuming.html#VACUUM-FOR-WRAPAROUND" title="24.1.5. トランザクションIDの周回エラーの防止">24.1.5</a>を参照してください。
<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM">autovacuum</a>パラメータがfalseの場合、（トランザクションIDの周回問題を回避する場合を除き）自動バキュームデーモンはまったく実行されないことに注意して下さい。
個々のテーブルの格納パラメータを設定しても、それは優先されません。
従って、この格納パラメータを明示的に<code class="literal">true</code>に設定することにはほとんど意味はなく、<code class="literal">false</code>に設定することのみが意味を持ちます。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_vacuum_threshold</code>, <code class="literal">toast.autovacuum_vacuum_threshold</code> (<code class="type">integer</code>)</span></dt><dd><p>
<!--
      Per-table value for <xref linkend="guc-autovacuum-vacuum-threshold"/>
      parameter.
-->
<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-THRESHOLD">autovacuum_vacuum_threshold</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_vacuum_scale_factor</code>, <code class="literal">toast.autovacuum_vacuum_scale_factor</code> (<code class="type">float4</code>)</span></dt><dd><p>
<!--
      Per-table value for <xref linkend="guc-autovacuum-vacuum-scale-factor"/>
      parameter.
-->
<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR">autovacuum_vacuum_scale_factor</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_analyze_threshold</code> (<code class="type">integer</code>)</span></dt><dd><p>
<!--
      Per-table value for <xref linkend="guc-autovacuum-analyze-threshold"/>
      parameter.
-->
<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-ANALYZE-THRESHOLD">autovacuum_analyze_threshold</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_analyze_scale_factor</code> (<code class="type">float4</code>)</span></dt><dd><p>
<!--
      Per-table value for <xref linkend="guc-autovacuum-analyze-scale-factor"/>
      parameter.
-->
<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-ANALYZE-SCALE-FACTOR">autovacuum_analyze_scale_factor</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_vacuum_cost_delay</code>, <code class="literal">toast.autovacuum_vacuum_cost_delay</code> (<code class="type">integer</code>)</span></dt><dd><p>
<!--
      Per-table value for <xref linkend="guc-autovacuum-vacuum-cost-delay"/>
      parameter.
-->
<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-COST-DELAY">autovacuum_vacuum_cost_delay</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_vacuum_cost_limit</code>, <code class="literal">toast.autovacuum_vacuum_cost_limit</code> (<code class="type">integer</code>)</span></dt><dd><p>
<!--
      Per-table value for <xref linkend="guc-autovacuum-vacuum-cost-limit"/>
      parameter.
-->
<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-COST-LIMIT">autovacuum_vacuum_cost_limit</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_freeze_min_age</code>, <code class="literal">toast.autovacuum_freeze_min_age</code> (<code class="type">integer</code>)</span></dt><dd><p>
<!--
      Per-table value for <xref linkend="guc-vacuum-freeze-min-age"/>
      parameter.  Note that autovacuum will ignore
      per-table <literal>autovacuum_freeze_min_age</literal> parameters that are
      larger than half the
      system-wide <xref linkend="guc-autovacuum-freeze-max-age"/> setting.
-->
<a class="xref" href="runtime-config-client.html#GUC-VACUUM-FREEZE-MIN-AGE">vacuum_freeze_min_age</a>パラメータについて、テーブル毎に設定する値です。
テーブル単位の<code class="literal">autovacuum_freeze_min_age</code>パラメータをシステム全体の<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE">autovacuum_freeze_max_age</a>設定の1/2より大きく設定しても、自動バキュームが無視することに注意してください。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_freeze_max_age</code>, <code class="literal">toast.autovacuum_freeze_max_age</code> (<code class="type">integer</code>)</span></dt><dd><p>
<!--
      Per-table value for <xref linkend="guc-autovacuum-freeze-max-age"/>
      parameter.  Note that autovacuum will ignore
      per-table <literal>autovacuum_freeze_max_age</literal> parameters that are
      larger than the system-wide setting (it can only be set smaller).
-->
<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE">autovacuum_freeze_max_age</a>パラメータについて、テーブル毎に設定する値です。
テーブル単位の<code class="literal">autovacuum_freeze_max_age</code>パラメータをシステム全体に対する設定より大きく設定しても、自動バキュームが無視することに注意してください（より小さな値しか設定できません）。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_freeze_table_age</code>, <code class="literal">toast.autovacuum_freeze_table_age</code> (<code class="type">integer</code>)</span></dt><dd><p>
<!--
      Per-table value for <xref linkend="guc-vacuum-freeze-table-age"/>
      parameter.

-->
<a class="xref" href="runtime-config-client.html#GUC-VACUUM-FREEZE-TABLE-AGE">vacuum_freeze_table_age</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_multixact_freeze_min_age</code>, <code class="literal">toast.autovacuum_multixact_freeze_min_age</code> (<code class="type">integer</code>)</span></dt><dd><p>
<!--
      Per-table value for <xref linkend="guc-vacuum-multixact-freeze-min-age"/>
      parameter.  Note that autovacuum will ignore
      per-table <literal>autovacuum_multixact_freeze_min_age</literal> parameters
      that are larger than half the
      system-wide <xref linkend="guc-autovacuum-multixact-freeze-max-age"/>
      setting.
-->
<a class="xref" href="runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE">vacuum_multixact_freeze_min_age</a>パラメータについて、テーブル毎に設定する値です。
テーブル単位の<code class="literal">autovacuum_multixact_freeze_min_age</code>パラメータをシステム全体の<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE">autovacuum_multixact_freeze_max_age</a>の半分より大きく設定しても、自動バキュームが無視することに注意してください。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_multixact_freeze_max_age</code>, <code class="literal">toast.autovacuum_multixact_freeze_max_age</code> (<code class="type">integer</code>)</span></dt><dd><p>
<!--
      Per-table value
      for <xref linkend="guc-autovacuum-multixact-freeze-max-age"/> parameter.
      Note that autovacuum will ignore
      per-table <literal>autovacuum_multixact_freeze_max_age</literal> parameters
      that are larger than the system-wide setting (it can only be set
      smaller).
-->
<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE">autovacuum_multixact_freeze_max_age</a>パラメータについて、テーブル毎に設定する値です。
テーブル単位の<code class="literal">autovacuum_multixact_freeze_max_age</code>をシステム全体に対する設定より大きくしても、自動バキュームが無視することに注意してください（より小さな値しか設定できません）。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_multixact_freeze_table_age</code>, <code class="literal">toast.autovacuum_multixact_freeze_table_age</code> (<code class="type">integer</code>)</span></dt><dd><p>
<!--
      Per-table value
      for <xref linkend="guc-vacuum-multixact-freeze-table-age"/> parameter.
-->
<a class="xref" href="runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE">vacuum_multixact_freeze_table_age</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">log_autovacuum_min_duration</code>, <code class="literal">toast.log_autovacuum_min_duration</code> (<code class="type">integer</code>)</span></dt><dd><p>
<!--
      Per-table value for <xref linkend="guc-log-autovacuum-min-duration"/>
      parameter.
-->
<a class="xref" href="runtime-config-autovacuum.html#GUC-LOG-AUTOVACUUM-MIN-DURATION">log_autovacuum_min_duration</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">user_catalog_table</code> (<code class="type">boolean</code>)</span></dt><dd><p>
<!--
      Declare the table as an additional catalog table for purposes of
      logical replication. See
      <xref linkend="logicaldecoding-capabilities"/> for details.
      This parameter cannot be set for TOAST tables.
-->
テーブルを論理レプリケーションのための追加のカタログテーブルとして宣言します。
詳しくは<a class="xref" href="logicaldecoding-output-plugin.html#LOGICALDECODING-CAPABILITIES" title="49.6.2. 機能">49.6.2</a>を参照してください。
このパラメータはTOASTテーブルには設定できません。
     </p></dd></dl></div></div></div><div class="refsect1" id="SQL-CREATETABLE-NOTES"><h2>注釈</h2><!--
  <title>Notes</title>
--><p>
<!--
     Using OIDs in new applications is not recommended: where
     possible, using an identity column or other sequence
     generator as the table's primary key is preferred. However, if
     your application does make use of OIDs to identify specific
     rows of a table, it is recommended to create a unique constraint
     on the <structfield>oid</structfield> column of that table, to ensure that
     OIDs in the table will indeed uniquely identify rows even after
     counter wraparound.  Avoid assuming that OIDs are unique across
     tables; if you need a database-wide unique identifier, use the
     combination of <structfield>tableoid</structfield> and row OID for the
     purpose.
-->
新規のアプリケーションでOIDを使用するのはお勧めしません。
可能であれば、テーブルの主キーとしてIDENTITY列や他のシーケンスジェネレータを使用する方が望ましいです。
しかし、アプリケーションがテーブルの特定の行を識別するためにOIDを使用する場合は、そのテーブルの<code class="structfield">oid</code>列に一意性制約を作成することを推奨します。
これにより、カウンタが一周してしまった場合でも、テーブル内のOIDで一意に行を識別できることが保証されるからです。
OIDがテーブルをまたがって一意であると考えるのは止めてください。
データベース全体で一意な識別子が必要な場合は、<code class="structfield">tableoid</code>と行のOIDの組み合わせを使用してください。
    </p><div class="tip"><h3 class="title">ヒント</h3><p>
<!--
      The use of <literal>OIDS=FALSE</literal> is not recommended
      for tables with no primary key, since without either an OID or a
      unique data key, it is difficult to identify specific rows.
-->
<code class="literal">OIDS=FALSE</code>の使用は、主キーのないテーブルでは推奨されません。
OIDも一意なデータキーも存在しないと、特定行を識別することが難しくなるからです。
     </p></div><p>
<!--
     <productname>PostgreSQL</productname> automatically creates an
     index for each unique constraint and primary key constraint to
     enforce uniqueness.  Thus, it is not necessary to create an
     index explicitly for primary key columns.  (See <xref
     linkend="sql-createindex"/> for more information.)
-->
<span class="productname">PostgreSQL</span>は自動的に各一意性制約と主キー制約に対してインデックスを作成し、その一意性を確実なものにします。
したがって、主キーの列に明示的にインデックスを作成することは必要ありません
（詳細については<a class="xref" href="sql-createindex.html" title="CREATE INDEX"><span class="refentrytitle">CREATE INDEX</span></a>を参照してください）。
    </p><p>
<!--
     Unique constraints and primary keys are not inherited in the
     current implementation.  This makes the combination of
     inheritance and unique constraints rather dysfunctional.
-->
現在の実装では、一意性制約と主キーは継承されません。
これは、継承と一意性制約を組み合わせると障害が発生するからです。
    </p><p>
<!--
     A table cannot have more than 1600 columns.  (In practice, the
     effective limit is usually lower because of tuple-length constraints.)
-->
テーブルは1600列以上の列を持つことはできません
（タプル長の制限により実際の制限はもっと小さくなります）。
    </p></div><div class="refsect1" id="SQL-CREATETABLE-EXAMPLES"><h2>例</h2><!--
  <title>Examples</title>
--><p>
<!--
   Create table <structname>films</structname> and table
   <structname>distributors</structname>:
-->
<code class="structname">films</code>テーブルと<code class="structname">distributors</code>テーブルを作成します。

</p><pre class="programlisting">
CREATE TABLE films (
    code        char(5) CONSTRAINT firstkey PRIMARY KEY,
    title       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute
);

CREATE TABLE distributors (
     did    integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
     name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')
);
</pre><p>
  </p><p>
<!--
   Create a table with a 2-dimensional array:
-->
2次元配列を持つテーブルを作成します。

</p><pre class="programlisting">
CREATE TABLE array_int (
    vector  int[][]
);
</pre><p>
  </p><p>
<!--
   Define a unique table constraint for the table
   <literal>films</literal>.  Unique table constraints can be defined
   on one or more columns of the table:
-->
<code class="literal">films</code>テーブルに 一意性テーブル制約を定義します。
一意性テーブル制約はテーブルの1つ以上の列に定義することができます。

</p><pre class="programlisting">
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT production UNIQUE(date_prod)
);
</pre><p>
  </p><p>
<!--
   Define a check column constraint:
-->
検査列制約を定義します。

</p><pre class="programlisting">
CREATE TABLE distributors (
    did     integer CHECK (did &gt; 100),
    name    varchar(40)
);
</pre><p>
  </p><p>
<!--
   Define a check table constraint:
-->
検査テーブル制約を定義します。

</p><pre class="programlisting">
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    CONSTRAINT con1 CHECK (did &gt; 100 AND name &lt;&gt; '')
);
</pre><p>
  </p><p>
<!--
   Define a primary key table constraint for the table
   <structname>films</structname>:
-->
<code class="structname">films</code>テーブルに主キーテーブル制約を定義します。

</p><pre class="programlisting">
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT code_title PRIMARY KEY(code,title)
);
</pre><p>
  </p><p>
<!--
   Define a primary key constraint for table
   <structname>distributors</structname>.  The following two examples are
   equivalent, the first using the table constraint syntax, the second
   the column constraint syntax:
-->
<code class="structname">distributors</code>テーブルに主キー制約を定義します。
以下の2つの例は同等で、前者はテーブル制約構文を使用し、後者は列制約構文を使用します。

</p><pre class="programlisting">
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    PRIMARY KEY(did)
);

CREATE TABLE distributors (
    did     integer PRIMARY KEY,
    name    varchar(40)
);
</pre><p>
  </p><p>
<!--
   Assign a literal constant default value for the column
   <literal>name</literal>, arrange for the default value of column
   <literal>did</literal> to be generated by selecting the next value
   of a sequence object, and make the default value of
   <literal>modtime</literal> be the time at which the row is
   inserted:
-->
以下では、<code class="literal">name</code>列のデフォルト値にリテラル定数を割り当てています。また、<code class="literal">did</code>列のデフォルト値として、シーケンスオブジェクトの次の値が生成されるように調整しています。
<code class="literal">modtime</code>のデフォルト値は、その行が挿入された時刻となります。

</p><pre class="programlisting">
CREATE TABLE distributors (
    name      varchar(40) DEFAULT 'Luso Films',
    did       integer DEFAULT nextval('distributors_serial'),
    modtime   timestamp DEFAULT current_timestamp
);
</pre><p>
  </p><p>
<!--
   Define two <literal>NOT NULL</literal> column constraints on the table
   <classname>distributors</classname>, one of which is explicitly
   given a name:
-->
2つの<code class="literal">NOT NULL</code>列制約を<code class="classname">distributors</code>テーブルに定義します。
そのうち1つには明示的な名前を付けています。

</p><pre class="programlisting">
CREATE TABLE distributors (
    did     integer CONSTRAINT no_null NOT NULL,
    name    varchar(40) NOT NULL
);
</pre><p>
    </p><p>
<!--
     Define a unique constraint for the <literal>name</literal> column:
-->
<code class="literal">name</code>列に対し、一意性制約を定義します。

</p><pre class="programlisting">
CREATE TABLE distributors (
    did     integer,
    name    varchar(40) UNIQUE
);
</pre><p>

<!--
     The same, specified as a table constraint:
-->
上と同じですが、テーブル制約として指定します。

</p><pre class="programlisting">
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name)
);
</pre><p>
  </p><p>
<!--
   Create the same table, specifying 70% fill factor for both the table
   and its unique index:
-->
テーブルとその一意性インデックスの両方に70%のフィルファクタを指定して、同じテーブルを作成します。

</p><pre class="programlisting">
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name) WITH (fillfactor=70)
)
WITH (fillfactor=70);
</pre><p>
  </p><p>
<!--
   Create table <structname>circles</structname> with an exclusion
   constraint that prevents any two circles from overlapping:
-->
2つの円の重複を許さない排他制約を持つ<code class="structname">circles</code>テーブルを作成します。

</p><pre class="programlisting">
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</pre><p>
  </p><p>
<!--
   Create table <structname>cinemas</structname> in tablespace <structname>diskvol1</structname>:
-->
<code class="structname">diskvol1</code>テーブル空間に<code class="structname">cinemas</code>テーブルを作成します。

</p><pre class="programlisting">
CREATE TABLE cinemas (
        id serial,
        name text,
        location text
) TABLESPACE diskvol1;
</pre><p>
  </p><p>
<!--
   Create a composite type and a typed table:
-->
複合型と型付きテーブルを作成します。
</p><pre class="programlisting">
CREATE TYPE employee_type AS (name text, salary numeric);

CREATE TABLE employees OF employee_type (
    PRIMARY KEY (name),
    salary WITH OPTIONS DEFAULT 1000
);
</pre><p>
<!--
   Create a range partitioned table:
-->
範囲パーティションテーブルを作成します。
</p><pre class="programlisting">
CREATE TABLE measurement (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
</pre><p>
<!--
   Create a range partitioned table with multiple columns in the partition key:
-->
パーティションキーに複数の列がある範囲パーティションテーブルを作成します。
</p><pre class="programlisting">
CREATE TABLE measurement_year_month (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (EXTRACT(YEAR FROM logdate), EXTRACT(MONTH FROM logdate));
</pre><p>
<!--
   Create a list partitioned table:
-->
リストパーティションテーブルを作成します。
</p><pre class="programlisting">
CREATE TABLE cities (
    city_id      bigserial not null,
    name         text not null,
    population   bigint
) PARTITION BY LIST (left(lower(name), 1));
</pre><p>
<!--
   Create a hash partitioned table:
-->
ハッシュパーティションテーブルを作成します。
</p><pre class="programlisting">
CREATE TABLE orders (
    order_id     bigint not null,
    cust_id      bigint not null,
    status       text
) PARTITION BY HASH (order_id);
</pre><p>
<!--
   Create partition of a range partitioned table:
-->
範囲パーティションテーブルのパーティションを作成します。
</p><pre class="programlisting">
CREATE TABLE measurement_y2016m07
    PARTITION OF measurement (
    unitsales DEFAULT 0
) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
</pre><p>
<!--
   Create a few partitions of a range partitioned table with multiple
   columns in the partition key:
-->
パーティションキーに複数の列がある範囲パーティションテーブルに、パーティションをいくつか作成します。
</p><pre class="programlisting">
CREATE TABLE measurement_ym_older
    PARTITION OF measurement_year_month
    FOR VALUES FROM (MINVALUE, MINVALUE) TO (2016, 11);

CREATE TABLE measurement_ym_y2016m11
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 11) TO (2016, 12);

CREATE TABLE measurement_ym_y2016m12
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 12) TO (2017, 01);

CREATE TABLE measurement_ym_y2017m01
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2017, 01) TO (2017, 02);
</pre><p>
<!--
   Create partition of a list partitioned table:
-->
リストパーティションテーブルのパーティションを作成します。
</p><pre class="programlisting">
CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b');
</pre><p>
<!--
   Create partition of a list partitioned table that is itself further
   partitioned and then add a partition to it:
-->
リストパーティションテーブルにパーティションを作成しますが、それ自体がさらにパーティションになり、それにパーティションを追加します。
</p><pre class="programlisting">
CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b') PARTITION BY RANGE (population);

CREATE TABLE cities_ab_10000_to_100000
    PARTITION OF cities_ab FOR VALUES FROM (10000) TO (100000);
</pre><p>
<!--
   Create partitions of a hash partitioned table:
-->
ハッシュパーティションテーブルのパーティションを作成します。
</p><pre class="programlisting">
CREATE TABLE orders_p1 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE orders_p2 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE orders_p3 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE orders_p4 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 3);
</pre><p>
   Create a default partition:
</p><pre class="programlisting">
CREATE TABLE cities_partdef
    PARTITION OF cities DEFAULT;
</pre></div><div class="refsect1" id="SQL-CREATETABLE-COMPATIBILITY"><h2>互換性</h2><!--
  <title id="sql-createtable-compatibility-title">Compatibility</title>
--><p>
<!--
   The <command>CREATE TABLE</command> command conforms to the
   <acronym>SQL</acronym> standard, with exceptions listed below.
-->
<code class="command">CREATE TABLE</code>は、以下に挙げるものを除いて、標準<acronym class="acronym">SQL</acronym>に従います。
  </p><div class="refsect2" id="id-1.9.3.85.9.3"><h3>一時テーブル</h3><!--
   <title>Temporary Tables</title>
--><p>
<!--
    Although the syntax of <literal>CREATE TEMPORARY TABLE</literal>
    resembles that of the SQL standard, the effect is not the same.  In the
    standard,
    temporary tables are defined just once and automatically exist (starting
    with empty contents) in every session that needs them.
    <productname>PostgreSQL</productname> instead
    requires each session to issue its own <literal>CREATE TEMPORARY
    TABLE</literal> command for each temporary table to be used.  This allows
    different sessions to use the same temporary table name for different
    purposes, whereas the standard's approach constrains all instances of a
    given temporary table name to have the same table structure.
-->
<code class="literal">CREATE TEMPORARY TABLE</code>は標準SQLに類似していますが、その効果は同じではありません。
標準では、一時テーブルは一度だけ定義され、それを必要とするセッションごとに自動的に（空の内容で始まる形で）出現します。
<span class="productname">PostgreSQL</span>では、これと異なり、各セッションで独自に、使用する一時テーブル用の<code class="literal">CREATE TEMPORARY TABLE</code>コマンドを発行しなければなりません。
これにより、異なるセッションで同じ名前の一時テーブルを異なる目的で使用することができます。
一方、標準の方法では、ある一時テーブル名を持つインスタンスが、全て同一のテーブル構造を持つという制限があります。
   </p><p>
<!--
    The standard's definition of the behavior of temporary tables is
    widely ignored.  <productname>PostgreSQL</productname>'s behavior
    on this point is similar to that of several other SQL databases.
-->
標準における一時テーブルの動作定義の多くは無視されています。
この点での<span class="productname">PostgreSQL</span>の動作は、他の多くのSQLデータベースと似ています。
   </p><p>
<!--
    The SQL standard also distinguishes between global and local temporary
    tables, where a local temporary table has a separate set of contents for
    each SQL module within each session, though its definition is still shared
    across sessions.  Since <productname>PostgreSQL</productname> does not
    support SQL modules, this distinction is not relevant in
    <productname>PostgreSQL</productname>.
-->
また標準SQLではグローバル一時テーブルとローカル一時テーブルを区別しています。
ローカル一時テーブルは各セッション内のSQLモジュールそれぞれ用に内容の集合を分離しますが、その定義はセッション全体で共有されます。
<span class="productname">PostgreSQL</span>はSQLモジュールをサポートしませんので、<span class="productname">PostgreSQL</span>ではこの区別は適切ではありません。
   </p><p>
<!--
    For compatibility's sake, <productname>PostgreSQL</productname> will
    accept the <literal>GLOBAL</literal> and <literal>LOCAL</literal> keywords
    in a temporary table declaration, but they currently have no effect.
    Use of these keywords is discouraged, since future versions of
    <productname>PostgreSQL</productname> might adopt a more
    standard-compliant interpretation of their meaning.
-->
互換性を保持するため、<span class="productname">PostgreSQL</span>は一時テーブルの宣言において<code class="literal">GLOBAL</code>と<code class="literal">LOCAL</code>キーワードを受け付けますが、これらには現在、何の効果もありません。
<span class="productname">PostgreSQL</span>の今後のバージョンでは、これらの意味についてより標準に近い実装を取り入れる可能性がありますので、これらのキーワードの使用は勧めません。
   </p><p>
<!--
    The <literal>ON COMMIT</literal> clause for temporary tables
    also resembles the SQL standard, but has some differences.
    If the <literal>ON COMMIT</literal> clause is omitted, SQL specifies that the
    default behavior is <literal>ON COMMIT DELETE ROWS</literal>.  However, the
    default behavior in <productname>PostgreSQL</productname> is
    <literal>ON COMMIT PRESERVE ROWS</literal>.  The <literal>ON COMMIT
    DROP</literal> option does not exist in SQL.
-->
一時テーブル用の<code class="literal">ON COMMIT</code>句もまた、標準SQLに類似していますが、いくつか違いがあります。
<code class="literal">ON COMMIT</code>句が省略された場合、SQLでは、デフォルトの動作は<code class="literal">ON COMMIT DELETE ROWS</code>であると規定しています。
しかし、<span class="productname">PostgreSQL</span>でのデフォルトの動作は<code class="literal">ON COMMIT PRESERVE ROWS</code>です。
また、<code class="literal">ON COMMIT DROP</code>はSQLにはありません。
   </p></div><div class="refsect2" id="id-1.9.3.85.9.4"><h3>非遅延一意性制約</h3><!--
   <title>Non-deferred Uniqueness Constraints</title>
--><p>
<!--
    When a <literal>UNIQUE</literal> or <literal>PRIMARY KEY</literal> constraint is
    not deferrable, <productname>PostgreSQL</productname> checks for
    uniqueness immediately whenever a row is inserted or modified.
    The SQL standard says that uniqueness should be enforced only at
    the end of the statement; this makes a difference when, for example,
    a single command updates multiple key values.  To obtain
    standard-compliant behavior, declare the constraint as
    <literal>DEFERRABLE</literal> but not deferred (i.e., <literal>INITIALLY
    IMMEDIATE</literal>).  Be aware that this can be significantly slower than
    immediate uniqueness checking.
-->
<code class="literal">UNIQUE</code>または<code class="literal">PRIMARY KEY</code>制約が非遅延の場合、<span class="productname">PostgreSQL</span>は行が挿入または変更されると即座に一意性を検査します。
標準SQLでは一意性は文が完了した時にのみ強制されなければならないと記述しています。
これにより、たとえば、1つのコマンドが複数のキー値を更新する時に違いが現れます。
標準互換の動作をさせるためには、非遅延（つまり<code class="literal">INITIALLY IMMEDIATE</code>）ではなく<code class="literal">DEFERRABLE</code>として制約を宣言してください。
これが即座に行われる一意性検査よりかなり低速になる可能性があることに注意してください。
   </p></div><div class="refsect2" id="id-1.9.3.85.9.5"><h3>列検査制約</h3><!--
   <title>Column Check Constraints</title>
--><p>
<!--
    The SQL standard says that <literal>CHECK</literal> column constraints
    can only refer to the column they apply to; only <literal>CHECK</literal>
    table constraints can refer to multiple columns.
    <productname>PostgreSQL</productname> does not enforce this
    restriction; it treats column and table check constraints alike.
-->
標準SQLでは、<code class="literal">CHECK</code>列制約はそれを適用する列のみを参照でき、複数の列を参照できるのは<code class="literal">CHECK</code>テーブル制約のみであるとされています。
<span class="productname">PostgreSQL</span>にはこの制限はありません。
列検査制約とテーブル検査制約を同様のものとして扱っています。
   </p></div><div class="refsect2" id="id-1.9.3.85.9.6"><h3><code class="literal">EXCLUDE</code>制約</h3><!--
   <title><literal>EXCLUDE</literal> Constraint</title>
--><p>
<!--
    The <literal>EXCLUDE</literal> constraint type is a
    <productname>PostgreSQL</productname> extension.
-->
<code class="literal">EXCLUDE</code>という種類の制約は<span class="productname">PostgreSQL</span>の拡張です。
   </p></div><div class="refsect2" id="id-1.9.3.85.9.7"><h3><code class="literal">NULL</code> <span class="quote">「<span class="quote">制約</span>」</span></h3><!--
   <title><literal>NULL</literal> <quote>Constraint</quote></title>
--><p>
<!--
    The <literal>NULL</literal> <quote>constraint</quote> (actually a
    non-constraint) is a <productname>PostgreSQL</productname>
    extension to the SQL standard that is included for compatibility with some
    other database systems (and for symmetry with the <literal>NOT
    NULL</literal> constraint).  Since it is the default for any
    column, its presence is simply noise.
-->
<code class="literal">NULL</code><span class="quote">「<span class="quote">制約</span>」</span>（実際には非制約）は、標準SQLに対する<span class="productname">PostgreSQL</span>の拡張で、他のいくつかのデータベースシステムとの互換性（および <code class="literal">NOT NULL</code>制約との対称性）のために含まれています。
どんな列に対してもデフォルトとなるため、これには意味はありません。
   </p></div><div class="refsect2" id="id-1.9.3.85.9.8"><h3>制約の命名</h3><!--
   <title>Constraint Naming</title>
--><p>
<!--
    The SQL standard says that table and domain constraints must have names
    that are unique across the schema containing the table or domain.
    <productname>PostgreSQL</productname> is laxer: it only requires
    constraint names to be unique across the constraints attached to a
    particular table or domain.  However, this extra freedom does not exist
    for index-based constraints (<literal>UNIQUE</literal>,
    <literal>PRIMARY KEY</literal>, and <literal>EXCLUDE</literal>
    constraints), because the associated index is named the same as the
    constraint, and index names must be unique across all relations within
    the same schema.
-->
SQL標準ではテーブルとドメインの制約はテーブルやドメインを含むスキーマ中で一意な名前を持たなければなりません。
<span class="productname">PostgreSQL</span>はより緩やかで、制約名は特定のテーブルやドメインに付加された制約の中で一意であることだけが求められます。
しかしながら、この追加的な自由はインデックスに基づく制約（<code class="literal">UNIQUE</code>、<code class="literal">PRIMARY KEY</code>、および<code class="literal">EXCLUDE</code>制約）にはありません。なぜなら、関連付けられたインデックスは制約と同じに命名されて、インデックス名は同スキーマ内の全てのリレーションの中で一意でなければならないからです。
   </p><p>
<!--
    Currently, <productname>PostgreSQL</productname> does not record names
    for <literal>NOT NULL</literal> constraints at all, so they are not
    subject to the uniqueness restriction.  This might change in a future
    release.
-->
今のところ、<span class="productname">PostgreSQL</span>は<code class="literal">NOT NULL</code>制約の名前を全く記録しませんので、これらは一意性の制限の対象ではありません。
これは将来のリリースで変更されるかもしれません。
   </p></div><div class="refsect2" id="id-1.9.3.85.9.9"><h3>継承</h3><!--
   <title>Inheritance</title>
--><p>
<!--
    Multiple inheritance via the <literal>INHERITS</literal> clause is
    a <productname>PostgreSQL</productname> language extension.
    SQL:1999 and later define single inheritance using a
    different syntax and different semantics.  SQL:1999-style
    inheritance is not yet supported by
    <productname>PostgreSQL</productname>.
-->
<code class="literal">INHERITS</code>句による複数継承は、<span class="productname">PostgreSQL</span>の言語拡張です。
SQL:1999以降では、異なる構文と意味体系による単一継承を定義しています。
今のところ、SQL:1999方式の継承は<span class="productname">PostgreSQL</span>ではサポートされていません。
   </p></div><div class="refsect2" id="id-1.9.3.85.9.10"><h3>列を持たないテーブル</h3><!--
   <title>Zero-column Tables</title>
--><p>
<!--
    <productname>PostgreSQL</productname> allows a table of no columns
    to be created (for example, <literal>CREATE TABLE foo();</literal>).  This
    is an extension from the SQL standard, which does not allow zero-column
    tables.  Zero-column tables are not in themselves very useful, but
    disallowing them creates odd special cases for <command>ALTER TABLE
    DROP COLUMN</command>, so it seems cleaner to ignore this spec restriction.
-->
<span class="productname">PostgreSQL</span>では、列を持たないテーブルを作成することができます
（例えば、<code class="literal">CREATE TABLE foo();</code>）。
これは標準SQLからの拡張です。
標準SQLでは列を持たないテーブルは許されません。
列を持たないテーブルそれ自体は役に立ちませんが、これを無効とすると、<code class="command">ALTER TABLE DROP COLUMN</code>に対して奇妙な特例を生成することになります。
したがって、この仕様上の制限を無視する方が簡潔であると考えます。
   </p></div><div class="refsect2" id="id-1.9.3.85.9.11"><h3>複数のIDENTITY列</h3><!--
   <title>Multiple Identity Columns</title>
--><p>
<!--
    <productname>PostgreSQL</productname> allows a table to have more than one
    identity column.  The standard specifies that a table can have at most one
    identity column.  This is relaxed mainly to give more flexibility for
    doing schema changes or migrations.  Note that
    the <command>INSERT</command> command supports only one override clause
    that applies to the entire statement, so having multiple identity columns
    with different behaviors is not well supported.
-->
<span class="productname">PostgreSQL</span>ではテーブルに2つ以上のIDENTITY列を持つことを許しています。
標準SQLでは、1つのテーブルは最大で1つのIDENTITY列を持つことができると規定しています。
主にスキーマの変更や移行でより柔軟性を持たせるために、この制約を緩和しています。
<code class="command">INSERT</code>コマンドはOVERRIDING句を1つだけしかサポートせず、これが文全体に適用されるため、複数のIDENTITY列があり、これらの動作が異なる場合は正しくサポートされないことに注意してください。
   </p></div><div class="refsect2" id="id-1.9.3.85.9.12"><h3><code class="literal">LIKE</code>句</h3><!--
   <title><literal>LIKE</literal> Clause</title>
--><p>
<!--
    While a <literal>LIKE</literal> clause exists in the SQL standard, many of the
    options that <productname>PostgreSQL</productname> accepts for it are not
    in the standard, and some of the standard's options are not implemented
    by <productname>PostgreSQL</productname>.
-->
<code class="literal">LIKE</code>句は標準SQLにありますが、<span class="productname">PostgreSQL</span>で利用可能な多くのオプションは標準にはなく、また標準のオプションの一部は<span class="productname">PostgreSQL</span>では実装されていません。
   </p></div><div class="refsect2" id="id-1.9.3.85.9.13"><h3><code class="literal">WITH</code>句</h3><!--
   <title><literal>WITH</literal> Clause</title>
--><p>
<!--
    The <literal>WITH</literal> clause is a <productname>PostgreSQL</productname>
    extension; neither storage parameters nor OIDs are in the standard.
-->
<code class="literal">WITH</code>句は<span class="productname">PostgreSQL</span>の拡張です。
格納パラメータもOIDも標準にはありません。
   </p></div><div class="refsect2" id="id-1.9.3.85.9.14"><h3>テーブル空間</h3><!--
   <title>Tablespaces</title>
--><p>
<!--
    The <productname>PostgreSQL</productname> concept of tablespaces is not
    part of the standard.  Hence, the clauses <literal>TABLESPACE</literal>
    and <literal>USING INDEX TABLESPACE</literal> are extensions.
-->
<span class="productname">PostgreSQL</span>のテーブル空間の概念は標準にはありません。
したがって、<code class="literal">TABLESPACE</code>と<code class="literal">USING INDEX TABLESPACE</code>は、<span class="productname">PostgreSQL</span>における拡張です。
   </p></div><div class="refsect2" id="id-1.9.3.85.9.15"><h3>型付きテーブル</h3><!--
   <title>Typed Tables</title>
--><p>
<!--
    Typed tables implement a subset of the SQL standard.  According to
    the standard, a typed table has columns corresponding to the
    underlying composite type as well as one other column that is
    the <quote>self-referencing column</quote>.  PostgreSQL does not
    support these self-referencing columns explicitly, but the same
    effect can be had using the OID feature.
-->
型付きテーブルは標準SQLのサブセットを実装します。
標準に従うと、型付きテーブルは背後の複合型に対応した列の他に<span class="quote">「<span class="quote">自己参照列</span>」</span>という列も持ちます。
PostgreSQLはこうした自己参照列を明示的にサポートしません。
しかし、OID機能を使用して同様の効果を持たせることができます。
   </p></div><div class="refsect2" id="id-1.9.3.85.9.16"><h3><code class="literal">PARTITION BY</code>句</h3><!--
   <title><literal>PARTITION BY</literal> Clause</title>
--><p>
<!--
    The <literal>PARTITION BY</literal> clause is a
    <productname>PostgreSQL</productname> extension.
-->
<code class="literal">PARTITION BY</code>は<span class="productname">PostgreSQL</span>の拡張です。
   </p></div><div class="refsect2" id="id-1.9.3.85.9.17"><h3><code class="literal">PARTITION OF</code>句</h3><!--
   <title><literal>PARTITION OF</literal> Clause</title>
--><p>
<!--
    The <literal>PARTITION OF</literal> clause is a
    <productname>PostgreSQL</productname> extension.
-->
<code class="literal">PARTITION OF</code>句は<span class="productname">PostgreSQL</span>の拡張です。
   </p></div></div><div class="refsect1" id="id-1.9.3.85.10"><h2>関連項目</h2><!--
  <title>See Also</title>
--><span class="simplelist"><a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>, <a class="xref" href="sql-droptable.html" title="DROP TABLE"><span class="refentrytitle">DROP TABLE</span></a>, <a class="xref" href="sql-createtableas.html" title="CREATE TABLE AS"><span class="refentrytitle">CREATE TABLE AS</span></a>, <a class="xref" href="sql-createtablespace.html" title="CREATE TABLESPACE"><span class="refentrytitle">CREATE TABLESPACE</span></a>, <a class="xref" href="sql-createtype.html" title="CREATE TYPE"><span class="refentrytitle">CREATE TYPE</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createsubscription.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createtableas.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE SUBSCRIPTION </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> CREATE TABLE AS</td></tr></table></div></body></html>