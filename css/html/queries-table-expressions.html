<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>7.2. テーブル式</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="queries-overview.html" title="7.1. 概要" /><link rel="next" href="queries-select-lists.html" title="7.3. 選択リスト" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 11.4文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="queries.html" title="第7章 問い合わせ">第7章 問い合わせ</a></td><td width="20%" align="right"></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="queries-overview.html" title="7.1. 概要">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="queries.html" title="第7章 問い合わせ">上へ</a></td><td width="60%" align="center">7.2. テーブル式</td><td width="20%" align="right"> <a accesskey="n" href="queries-select-lists.html" title="7.3. 選択リスト">次へ</a></td></tr></table><hr /></div><div class="sect1" id="QUERIES-TABLE-EXPRESSIONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">7.2. テーブル式</h2></div></div></div><!--
  <title>Table Expressions</title>
--><a id="id-1.5.6.6.2" class="indexterm"></a><p>
<!--
   A <firstterm>table expression</firstterm> computes a table.  The
   table expression contains a <literal>FROM</literal> clause that is
   optionally followed by <literal>WHERE</literal>, <literal>GROUP BY</literal>, and
   <literal>HAVING</literal> clauses.  Trivial table expressions simply refer
   to a table on disk, a so-called base table, but more complex
   expressions can be used to modify or combine base tables in various
   ways.
-->
<em class="firstterm">テーブル式</em>はテーブルを計算するためのものです。
テーブル式には<code class="literal">FROM</code>句が含まれており、その後ろにオプションとして<code class="literal">WHERE</code>句、<code class="literal">GROUP BY</code>句、<code class="literal">HAVING</code>句を付けることができます。
単純なテーブル式は、単にディスク上のいわゆる基本テーブルと呼ばれるテーブルを参照するだけです。
しかし複雑な式では、様々な方法で基本テーブルを修正したり、結合させて使用することができます。
  </p><p>
<!--
   The optional <literal>WHERE</literal>, <literal>GROUP BY</literal>, and
   <literal>HAVING</literal> clauses in the table expression specify a
   pipeline of successive transformations performed on the table
   derived in the <literal>FROM</literal> clause.  All these transformations
   produce a virtual table that provides the rows that are passed to
   the select list to compute the output rows of the query.
-->
テーブル式のオプション<code class="literal">WHERE</code>句、<code class="literal">GROUP BY</code>句、および<code class="literal">HAVING</code>句は、<code class="literal">FROM</code>句で派生したテーブル上に対して次々に変換を実行するパイプラインを指定します。
これらの変換によって仮想テーブルが1つ生成されます。
そしてこの仮想テーブルの行が選択リストに渡され、問い合わせの出力行が計算されます。
  </p><div class="sect2" id="QUERIES-FROM"><div class="titlepage"><div><div><h3 class="title">7.2.1. <code class="literal">FROM</code>句</h3></div></div></div><!--
   <title>The <literal>FROM</literal> Clause</title>
--><p>
<!--
    The <xref linkend="sql-from" endterm="sql-from-title"/> derives a
    table from one or more other tables given in a comma-separated
    table reference list.
-->
<a class="xref" href="sql-select.html#SQL-FROM" title="FROM句"><code class="literal">FROM</code>句</a>は、カンマで分けられたテーブル参照リストで与えられる1つ以上のテーブルから、1つのテーブルを派生します。
</p><pre class="synopsis">
FROM <em class="replaceable"><code>table_reference</code></em> [<span class="optional">, <em class="replaceable"><code>table_reference</code></em> [<span class="optional">, ...</span>]</span>]
</pre><p>

<!--
    A table reference can be a table name (possibly schema-qualified),
    or a derived table such as a subquery, a <literal>JOIN</literal> construct, or
    complex combinations of these.  If more than one table reference is
    listed in the <literal>FROM</literal> clause, the tables are cross-joined
    (that is, the Cartesian product of their rows is formed; see below).
    The result of the <literal>FROM</literal> list is an intermediate virtual
    table that can then be subject to
    transformations by the <literal>WHERE</literal>, <literal>GROUP BY</literal>,
    and <literal>HAVING</literal> clauses and is finally the result of the
    overall table expression.
-->
テーブル参照は、テーブル名（スキーマで修飾することもできます）、あるいは、副問い合わせ、<code class="literal">JOIN</code>による結合、これらの複雑な組み合わせなどの派生テーブルとすることができます。
<code class="literal">FROM</code>句に複数のテーブル参照がある場合、クロス結合されます（テーブルの行のデカルト積が形成されます。下記を参照）。
<code class="literal">FROM</code>リストの結果は<code class="literal">WHERE</code>句、<code class="literal">GROUP BY</code>句、および<code class="literal">HAVING</code>句での変換対象となる中間的な仮想テーブルになり、最終的にはテーブル式全体の結果となります。
   </p><a id="id-1.5.6.6.5.3" class="indexterm"></a><p>
<!--
    When a table reference names a table that is the parent of a
    table inheritance hierarchy, the table reference produces rows of
    not only that table but all of its descendant tables, unless the
    key word <literal>ONLY</literal> precedes the table name.  However, the
    reference produces only the columns that appear in the named table
    &mdash; any columns added in subtables are ignored.
-->
テーブル参照で、テーブルの継承階層の親テーブルの名前を指定すると、テーブル名の前に<code class="literal">ONLY</code>キーワードがない場合は、テーブル参照はそのテーブルだけでなくその子テーブルに継承されたすべての行を生成します。
しかし、この参照は名前を指定したテーブルに現れる列のみを生成し、子テーブルで追加された列は無視されます。
   </p><p>
<!--
    Instead of writing <literal>ONLY</literal> before the table name, you can write
    <literal>*</literal> after the table name to explicitly specify that descendant
    tables are included.  There is no real reason to use this syntax any more,
    because searching descendant tables is now always the default behavior.
    However, it is supported for compatibility with older releases.
-->
テーブル名の前に<code class="literal">ONLY</code>を記述する代わりに、テーブル名の後に<code class="literal">*</code>を記述して、子テーブルが含まれることを明示的に指定することができます。
子テーブルを検索するのが今は常にデフォルトの振る舞いですので、この文法を使う本当の理由はもうありません。
しかし、古いリリースとの互換性のためにサポートされています。
   </p><div class="sect3" id="QUERIES-JOIN"><div class="titlepage"><div><div><h4 class="title">7.2.1.1. 結合テーブル</h4></div></div></div><!--
    <title>Joined Tables</title>
--><a id="id-1.5.6.6.5.6.2" class="indexterm"></a><p>
<!--
     A joined table is a table derived from two other (real or
     derived) tables according to the rules of the particular join
     type.  Inner, outer, and cross-joins are available.
     The general syntax of a joined table is
-->
結合テーブルは、2つの（実または派生）テーブルから、指定した結合種類の規則に従って派生したテーブルです。
内部結合、外部結合、およびクロス結合が使用可能です。
テーブル結合の一般的な構文は次のとおりです
</p><pre class="synopsis">
<em class="replaceable"><code>T1</code></em> <em class="replaceable"><code>join_type</code></em> <em class="replaceable"><code>T2</code></em> [<span class="optional"> <em class="replaceable"><code>join_condition</code></em> </span>]
</pre><p>
<!--
     Joins of all types can be chained together, or nested: either or
     both <replaceable>T1</replaceable> and
     <replaceable>T2</replaceable> can be joined tables.  Parentheses
     can be used around <literal>JOIN</literal> clauses to control the join
     order.  In the absence of parentheses, <literal>JOIN</literal> clauses
     nest left-to-right.
-->
すべての結合は、互いに結び付けたり、あるいは入れ子にしたりすることができます。
<em class="replaceable"><code>T1</code></em>と<em class="replaceable"><code>T2</code></em>のどちらか、あるいは両方が、結合テーブルになることがあります。
括弧で<code class="literal">JOIN</code>句を括ることで結合の順序を制御することができます。
括弧がない場合、<code class="literal">JOIN</code>句は左から右に入れ子にします。
    </p><div class="variablelist"><p class="title"><strong>結合の種類</strong></p><!--
     <title>Join Types</title>
--><dl class="variablelist"><dt><span class="term">クロス結合
      <a id="id-1.5.6.6.5.6.4.2.1.1" class="indexterm"></a>

      <a id="id-1.5.6.6.5.6.4.2.1.2" class="indexterm"></a>
      </span></dt><dd><pre class="synopsis">
<em class="replaceable"><code>T1</code></em> CROSS JOIN <em class="replaceable"><code>T2</code></em>
</pre><p>
<!--
        For every possible combination of rows from
        <replaceable>T1</replaceable> and
        <replaceable>T2</replaceable> (i.e., a Cartesian product),
        the joined table will contain a
        row consisting of all columns in <replaceable>T1</replaceable>
        followed by all columns in <replaceable>T2</replaceable>.  If
        the tables have N and M rows respectively, the joined
        table will have N * M rows.
-->
<em class="replaceable"><code>T1</code></em>および<em class="replaceable"><code>T2</code></em>からのすべての可能な行の組み合わせ（つまりデカルト積）に対し、結合されたテーブルは<em class="replaceable"><code>T1</code></em>のすべての列の後に<em class="replaceable"><code>T2</code></em>のすべての列が続く行を含みます。
テーブルがそれぞれN行とM行で構成されているとすると、結合されたテーブルの行数は N * M 行となります。
       </p><p>
<!--
        <literal>FROM <replaceable>T1</replaceable> CROSS JOIN
        <replaceable>T2</replaceable></literal> is equivalent to
        <literal>FROM <replaceable>T1</replaceable> INNER JOIN
        <replaceable>T2</replaceable> ON TRUE</literal> (see below).
        It is also equivalent to
        <literal>FROM <replaceable>T1</replaceable>,
        <replaceable>T2</replaceable></literal>.
-->
<code class="literal">FROM <em class="replaceable"><code>T1</code></em> CROSS JOIN <em class="replaceable"><code>T2</code></em></code> は <code class="literal">FROM <em class="replaceable"><code>T1</code></em> INNER JOIN <em class="replaceable"><code>T2</code></em> ON TRUE</code> と同じです（下記を参照）。
また <code class="literal">FROM <em class="replaceable"><code>T1</code></em>, <em class="replaceable"><code>T2</code></em></code> とも同じです。
        </p><div class="note"><h3 class="title">注記</h3><p>
<!--
         This latter equivalence does not hold exactly when more than two
         tables appear, because <literal>JOIN</literal> binds more tightly than
         comma.  For example
         <literal>FROM <replaceable>T1</replaceable> CROSS JOIN
         <replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable>
         ON <replaceable>condition</replaceable></literal>
         is not the same as
         <literal>FROM <replaceable>T1</replaceable>,
         <replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable>
         ON <replaceable>condition</replaceable></literal>
         because the <replaceable>condition</replaceable> can
         reference <replaceable>T1</replaceable> in the first case but not
         the second.
-->
３つ以上のテーブルが現れた場合、この後者の等価性は厳密には保たれてはいません。
なぜなら、<code class="literal">JOIN</code>はカンマより強固に結合するためです。
例えば
<code class="literal">FROM <em class="replaceable"><code>T1</code></em> CROSS JOIN
<em class="replaceable"><code>T2</code></em> INNER JOIN <em class="replaceable"><code>T3</code></em>
ON <em class="replaceable"><code>condition</code></em></code>
は
<code class="literal">FROM <em class="replaceable"><code>T1</code></em>,
<em class="replaceable"><code>T2</code></em> INNER JOIN <em class="replaceable"><code>T3</code></em>
ON <em class="replaceable"><code>condition</code></em></code>
と同じではありません。
なぜなら最初のケースでは<em class="replaceable"><code>condition</code></em>が<em class="replaceable"><code>T1</code></em>を参照できますが、2番目ではできないからです。
        </p></div><p>
       </p></dd><dt><span class="term">限定的な結合
      <a id="id-1.5.6.6.5.6.4.3.1.1" class="indexterm"></a>

      <a id="id-1.5.6.6.5.6.4.3.1.2" class="indexterm"></a>
      </span></dt><dd><pre class="synopsis">
<em class="replaceable"><code>T1</code></em> { [<span class="optional">INNER</span>] | { LEFT | RIGHT | FULL } [<span class="optional">OUTER</span>] } JOIN <em class="replaceable"><code>T2</code></em> ON <em class="replaceable"><code>boolean_expression</code></em>
<em class="replaceable"><code>T1</code></em> { [<span class="optional">INNER</span>] | { LEFT | RIGHT | FULL } [<span class="optional">OUTER</span>] } JOIN <em class="replaceable"><code>T2</code></em> USING ( <em class="replaceable"><code>join column list</code></em> )
<em class="replaceable"><code>T1</code></em> NATURAL { [<span class="optional">INNER</span>] | { LEFT | RIGHT | FULL } [<span class="optional">OUTER</span>] } JOIN <em class="replaceable"><code>T2</code></em>
</pre><p>
<!--
        The words <literal>INNER</literal> and
        <literal>OUTER</literal> are optional in all forms.
        <literal>INNER</literal> is the default;
        <literal>LEFT</literal>, <literal>RIGHT</literal>, and
        <literal>FULL</literal> imply an outer join.
-->
<code class="literal">INNER</code>や<code class="literal">OUTER</code>は省略可能です。
<code class="literal">INNER</code>がデフォルトとなります。
<code class="literal">LEFT</code>、<code class="literal">RIGHT</code>、<code class="literal">FULL</code>は外部結合を意味します。
       </p><p>
<!--
        The <firstterm>join condition</firstterm> is specified in the
        <literal>ON</literal> or <literal>USING</literal> clause, or implicitly by
        the word <literal>NATURAL</literal>.  The join condition determines
        which rows from the two source tables are considered to
        <quote>match</quote>, as explained in detail below.
-->
<em class="firstterm">結合条件</em>は、<code class="literal">ON</code>句か<code class="literal">USING</code>句で指定するか、または<code class="literal">NATURAL</code>記述で暗黙的に指定します。
結合条件は、以下で詳しく説明するように、2つの元となるテーブルのどの行が<span class="quote">「<span class="quote">一致するか</span>」</span>を決めます。
       </p><p>
<!--
        The possible types of qualified join are:
-->
限定的な結合には次のものがあります。

       </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">INNER JOIN</code>（内部結合）</span></dt><dd><p>
<!--
           For each row R1 of T1, the joined table has a row for each
           row in T2 that satisfies the join condition with R1.
-->
T1の各行R1に対して、T2において行R1との結合条件を満たしている各行が、結合されたテーブルに含まれます。
          </p></dd><dt><span class="term"><code class="literal">LEFT OUTER JOIN</code>（左外部結合）
         <a id="id-1.5.6.6.5.6.4.3.2.4.1.2.1.2" class="indexterm"></a>

         <a id="id-1.5.6.6.5.6.4.3.2.4.1.2.1.3" class="indexterm"></a>
         </span></dt><dd><p>
<!--
           First, an inner join is performed.  Then, for each row in
           T1 that does not satisfy the join condition with any row in
           T2, a joined row is added with null values in columns of
           T2.  Thus, the joined table always has at least
           one row for each row in T1.
-->
まず、内部結合が行われます。
その後、T2のどの行との結合条件も満たさないT1の各行については、T2の列をNULL値として結合行が追加されます。
したがって、連結されたテーブルは常にT1の行それぞれに少なくとも1つの行があります。
          </p></dd><dt><span class="term"><code class="literal">RIGHT OUTER JOIN</code>（右外部結合）
         <a id="id-1.5.6.6.5.6.4.3.2.4.1.3.1.2" class="indexterm"></a>

         <a id="id-1.5.6.6.5.6.4.3.2.4.1.3.1.3" class="indexterm"></a>
         </span></dt><dd><p>
<!--
           First, an inner join is performed.  Then, for each row in
           T2 that does not satisfy the join condition with any row in
           T1, a joined row is added with null values in columns of
           T1.  This is the converse of a left join: the result table
           will always have a row for each row in T2.
-->
まず、内部結合が行われます。
その後、T1のどの行の結合条件も満たさないT2の各行については、T1の列をNULL値として結合行が追加されます。
これは左結合の反対です。
結果のテーブルは、T2の行が常に入ります。
          </p></dd><dt><span class="term"><code class="literal">FULL OUTER JOIN</code>（完全外部結合）</span></dt><dd><p>
<!--
           First, an inner join is performed.  Then, for each row in
           T1 that does not satisfy the join condition with any row in
           T2, a joined row is added with null values in columns of
           T2.  Also, for each row of T2 that does not satisfy the
           join condition with any row in T1, a joined row with null
           values in the columns of T1 is added.
-->
まず、内部結合が行われます。
その後、T2のどの行の結合条件も満たさないT1の各行については、T2の列をNULL値として結合行が追加されます。
さらに、T1のどの行でも結合条件を満たさないT2の各行に対して、T1の列をNULL値として結合行が追加されます。
          </p></dd></dl></div><p>
       </p><p>
<!--
        The <literal>ON</literal> clause is the most general kind of join
        condition: it takes a Boolean value expression of the same
        kind as is used in a <literal>WHERE</literal> clause.  A pair of rows
        from <replaceable>T1</replaceable> and <replaceable>T2</replaceable> match if the
        <literal>ON</literal> expression evaluates to true.
-->
<code class="literal">ON</code>句は最も汎用的な結合条件であり、<code class="literal">WHERE</code>句で使われるものと同じ論理値評価式となります。
<code class="literal">ON</code>式の評価が真となる場合、<em class="replaceable"><code>T1</code></em>および<em class="replaceable"><code>T2</code></em>の対応する行が一致します。
       </p><p>
<!--
        The <literal>USING</literal> clause is a shorthand that allows you to take

        advantage of the specific situation where both sides of the join use
        the same name for the joining column(s).  It takes a
        comma-separated list of the shared column names
        and forms a join condition that includes an equality comparison
        for each one.  For example, joining <replaceable>T1</replaceable>
        and <replaceable>T2</replaceable> with <literal>USING (a, b)</literal> produces
        the join condition <literal>ON <replaceable>T1</replaceable>.a
        = <replaceable>T2</replaceable>.a AND <replaceable>T1</replaceable>.b
        = <replaceable>T2</replaceable>.b</literal>.
-->
<code class="literal">USING</code>句は、結合の両側で結合列に同じ名前を使っているという特別な状況の利点を活かすことができる省略形です。
それは、結合テーブルが共通で持つ列名をカンマで区切ったリストから、それぞれの列の等価性を結合条件として生成します。
例えば, <em class="replaceable"><code>T1</code></em>と<em class="replaceable"><code>T2</code></em>を<code class="literal">USING (a, b)</code>を使用して結合する場合は、<code class="literal">ON <em class="replaceable"><code>T1</code></em>.a = <em class="replaceable"><code>T2</code></em>.a AND <em class="replaceable"><code>T1</code></em>.b = <em class="replaceable"><code>T2</code></em>.b</code>という結合条件を生成します。
       </p><p>
<!--
        Furthermore, the output of <literal>JOIN USING</literal> suppresses
        redundant columns: there is no need to print both of the matched
        columns, since they must have equal values.  While <literal>JOIN
        ON</literal> produces all columns from <replaceable>T1</replaceable> followed by all
        columns from <replaceable>T2</replaceable>, <literal>JOIN USING</literal> produces one
        output column for each of the listed column pairs (in the listed
        order), followed by any remaining columns from <replaceable>T1</replaceable>,
        followed by any remaining columns from <replaceable>T2</replaceable>.
-->
さらに、<code class="literal">JOIN USING</code>の出力は、冗長列を抑制します。マッチした列は両方が同じ値を待つので両方を出力する必要がありません。
<code class="literal">JOIN ON</code> は <em class="replaceable"><code>T1</code></em> からのすべての列と、それに続く <em class="replaceable"><code>T2</code></em> からのすべての列を生成します。
<code class="literal">JOIN USING</code>は指定された列のペアのそれぞれについて１つの出力（結合リストでの指定順）、続いて<em class="replaceable"><code>T1</code></em>の残りの列、その後に<em class="replaceable"><code>T2</code></em>の残りの列を出力します。
       </p><p>
        <a id="id-1.5.6.6.5.6.4.3.2.8.1" class="indexterm"></a>
        <a id="id-1.5.6.6.5.6.4.3.2.8.2" class="indexterm"></a>
<!--
        Finally, <literal>NATURAL</literal> is a shorthand form of
        <literal>USING</literal>: it forms a <literal>USING</literal> list
        consisting of all column names that appear in both
        input tables.  As with <literal>USING</literal>, these columns appear
        only once in the output table.  If there are no common
        column names, <literal>NATURAL JOIN</literal> behaves like
        <literal>JOIN ... ON TRUE</literal>, producing a cross-product join.
-->
最後に、<code class="literal">NATURAL</code>は<code class="literal">USING</code>の略記形式で、２つの入力テーブルの両方に含まれているすべての列名で構成される<code class="literal">USING</code>リストを形成します。
<code class="literal">USING</code>と同様、これらの列は出力テーブルに一度だけ現れます。
共通する列が存在しない場合、<code class="literal">NATURAL JOIN</code>は<code class="literal">JOIN ... ON TRUE</code>と同様に動作し、クロス積結合を生成します。
       </p><div class="note"><h3 class="title">注記</h3><p>
<!--
         <literal>USING</literal> is reasonably safe from column changes
         in the joined relations since only the listed columns
         are combined.  <literal>NATURAL</literal> is considerably more risky since
         any schema changes to either relation that cause a new matching
         column name to be present will cause the join to combine that new
         column as well.
-->
<code class="literal">USING</code>は、リストされている列のみ結合するのでリレーションの列の変更から適度に安全です。
<code class="literal">NATURAL</code>は、<code class="literal">USING</code>よりもかなり危険です。
いずれかのリレーションのスキーマ変更により新しくマッチする列名が作られると、結合にその新しい列も使われるようになってしまうからです。
        </p></div></dd></dl></div><p>
<!--
     To put this together, assume we have tables <literal>t1</literal>:
-->
まとめとして、 以下のテーブル<code class="literal">t1</code>
</p><pre class="programlisting">
 num | name
-----+------
   1 | a
   2 | b
   3 | c
</pre><p>
<!--
     and <literal>t2</literal>:
-->
および、テーブル<code class="literal">t2</code>
</p><pre class="programlisting">
 num | value
-----+-------
   1 | xxx
   3 | yyy
   5 | zzz
</pre><p>
<!--
     then we get the following results for the various joins:
-->
を想定すると、以下のように様々な結合に関する結果が得られます。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 CROSS JOIN t2;</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   1 | a    |   3 | yyy
   1 | a    |   5 | zzz
   2 | b    |   1 | xxx
   2 | b    |   3 | yyy
   2 | b    |   5 | zzz
   3 | c    |   1 | xxx
   3 | c    |   3 | yyy
   3 | c    |   5 | zzz
(9 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
(2 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 INNER JOIN t2 USING (num);</code></strong>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 NATURAL INNER JOIN t2;</code></strong>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
(3 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 LEFT JOIN t2 USING (num);</code></strong>
 num | name | value
-----+------+-------
   1 | a    | xxx
   2 | b    |
   3 | c    | yyy
(3 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
     |      |   5 | zzz
(3 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
     |      |   5 | zzz
(4 rows)
</pre><p>
    </p><p>
<!--
     The join condition specified with <literal>ON</literal> can also contain
     conditions that do not relate directly to the join.  This can
     prove useful for some queries but needs to be thought out
     carefully.  For example:
-->
<code class="literal">ON</code>で指定される結合条件には、結合に直接関係しない条件も含めることができます。
これは一部の問い合わせにおいては便利ですが、使用の際には注意が必要です。
例を示します。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |     |
(3 rows)
</pre><p>
<!--
     Notice that placing the restriction in the <literal>WHERE</literal> clause
     produces a different result:
-->
<code class="literal">WHERE</code>句の中に制約を記述すると異なる結果になることに注意してください。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
(1 row)
</pre><p>
<!--
     This is because a restriction placed in the <literal>ON</literal>
     clause is processed <emphasis>before</emphasis> the join, while
     a restriction placed in the <literal>WHERE</literal> clause is processed
     <emphasis>after</emphasis> the join.
     That does not matter with inner joins, but it matters a lot with outer
     joins.
-->
この理由は<code class="literal">ON</code>句の中の制約は結合の<span class="emphasis"><em>前</em></span>に処理され、一方<code class="literal">WHERE</code>句の中の制約は結合の<span class="emphasis"><em>後</em></span>に処理されることによります。
これは内部結合には影響がありませんが、外部結合には大きな影響があります。
    </p></div><div class="sect3" id="QUERIES-TABLE-ALIASES"><div class="titlepage"><div><div><h4 class="title">7.2.1.2. テーブルと列の別名</h4></div></div></div><!--
    <title>Table and Column Aliases</title>
--><a id="id-1.5.6.6.5.7.2" class="indexterm"></a><a id="id-1.5.6.6.5.7.3" class="indexterm"></a><p>
<!--
     A temporary name can be given to tables and complex table
     references to be used for references to the derived table in
     the rest of the query.  This is called a <firstterm>table
     alias</firstterm>.
-->
テーブルや複雑なテーブル参照に一時的な名前を付与し、問い合わせの以降の部分では、その名前を使ってテーブルや複雑なテーブル参照を利用することができます。
これを<em class="firstterm">テーブルの別名</em>と呼びます。
    </p><p>
<!--
     To create a table alias, write
-->
テーブルの別名を作成するには以下のようにします。
</p><pre class="synopsis">
FROM <em class="replaceable"><code>table_reference</code></em> AS <em class="replaceable"><code>alias</code></em>
</pre><p>
<!--
     or
-->
もしくは
</p><pre class="synopsis">
FROM <em class="replaceable"><code>table_reference</code></em> <em class="replaceable"><code>alias</code></em>
</pre><p>
<!--
     The <literal>AS</literal> key word is optional noise.
     <replaceable>alias</replaceable> can be any identifier.
-->
<code class="literal">AS</code>キーワードはなくても構わないノイズです。
<em class="replaceable"><code>alias</code></em>は任意の識別子になります。
    </p><p>
<!--
     A typical application of table aliases is to assign short
     identifiers to long table names to keep the join clauses
     readable.  For example:
-->
テーブルの別名の一般的な適用法は、長いテーブル名に短縮した識別子を割り当てて結合句を読みやすくすることです。
例を示します。
</p><pre class="programlisting">
SELECT * FROM some_very_long_table_name s JOIN another_fairly_long_name a ON s.id = a.num;
</pre><p>
    </p><p>
<!--
     The alias becomes the new name of the table reference so far as the
     current query is concerned &mdash; it is not allowed to refer to the
     table by the original name elsewhere in the query.  Thus, this is not
     valid:
-->
現在の問い合わせに関しては、別名がテーブル参照をする時の新しい名前になります。
問い合わせの他の場所で元々の名前でテーブルを参照することはできなくなります。
よって、次の例は有効ではありません。
</p><pre class="programlisting">
<!--
SELECT * FROM my_table AS m WHERE my_table.a &gt; 5;    &#045;&#045; wrong
-->
SELECT * FROM my_table AS m WHERE my_table.a &gt; 5;    -- 間違い
</pre><p>
    </p><p>
<!--
     Table aliases are mainly for notational convenience, but it is
     necessary to use them when joining a table to itself, e.g.:
-->
テーブルの別名は主に表記を簡単にするためにあります。
しかし次のように、1つのテーブルが自分自身と結合する場合は、必須となります。
</p><pre class="programlisting">
SELECT * FROM people AS mother JOIN people AS child ON mother.id = child.mother_id;
</pre><p>
<!--
     Additionally, an alias is required if the table reference is a
     subquery (see <xref linkend="queries-subqueries"/>).
-->
さらに、テーブル参照が副問い合わせ（<a class="xref" href="queries-table-expressions.html#QUERIES-SUBQUERIES" title="7.2.1.3. 副問い合わせ">7.2.1.3</a>を参照）の場合に別名が必要になります。
    </p><p>
<!--
     Parentheses are used to resolve ambiguities.  In the following example,
     the first statement assigns the alias <literal>b</literal> to the second
     instance of <literal>my_table</literal>, but the second statement assigns the
     alias to the result of the join:
-->
括弧は曖昧さをなくすために使われます。
次の例では、最初の文で2つ目の<code class="literal">my_table</code>のインスタンスに<code class="literal">b</code>という別名を付与し、一方、2つ目の文では結合結果に対して別名を付与しています。
</p><pre class="programlisting">
SELECT * FROM my_table AS a CROSS JOIN my_table AS b ...
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...
</pre><p>
    </p><p>
<!--
     Another form of table aliasing gives temporary names to the columns of
     the table, as well as the table itself:
-->
次のような形式でテーブル別名を付けて、テーブル自身と同様にテーブルの列に一時的な名前を付けることができます。
</p><pre class="synopsis">
FROM <em class="replaceable"><code>table_reference</code></em> [<span class="optional">AS</span>] <em class="replaceable"><code>alias</code></em> ( <em class="replaceable"><code>column1</code></em> [<span class="optional">, <em class="replaceable"><code>column2</code></em> [<span class="optional">, ...</span>]</span>] )
</pre><p>
<!--
     If fewer column aliases are specified than the actual table has
     columns, the remaining columns are not renamed.  This syntax is
     especially useful for self-joins or subqueries.
-->
もし、実際のテーブルが持つ列よりも少ない数の列の別名が与えられる場合、残りの列は改名されません。
この構文は、自己結合あるいは副問い合わせで特に役立ちます。
    </p><p>
<!--
     When an alias is applied to the output of a <literal>JOIN</literal>
     clause, the alias hides the original
     name(s) within the <literal>JOIN</literal>.  For example:
-->
別名が<code class="literal">JOIN</code>句の結果に適用される場合、別名は<code class="literal">JOIN</code>内で参照される元々の名を隠します。
以下に例を示します。
</p><pre class="programlisting">
SELECT a.* FROM my_table AS a JOIN your_table AS b ON ...
</pre><p>
<!--
     is valid SQL, but:
-->
は有効なSQLですが、
</p><pre class="programlisting">
SELECT a.* FROM (my_table AS a JOIN your_table AS b ON ...) AS c
</pre><p>
<!--
     is not valid; the table alias <literal>a</literal> is not visible
     outside the alias <literal>c</literal>.
-->
は有効ではありません。
テーブルの別名<code class="literal">a</code>は、別名<code class="literal">c</code>の外側では参照することができません。
    </p></div><div class="sect3" id="QUERIES-SUBQUERIES"><div class="titlepage"><div><div><h4 class="title">7.2.1.3. 副問い合わせ</h4></div></div></div><!--
    <title>Subqueries</title>
--><a id="id-1.5.6.6.5.8.2" class="indexterm"></a><p>
<!--
     Subqueries specifying a derived table must be enclosed in
     parentheses and <emphasis>must</emphasis> be assigned a table
     alias name (as in <xref linkend="queries-table-aliases"/>).  For
     example:
-->
派生テーブルを指定する副問い合わせは括弧で囲む必要があります。
また、（<a class="xref" href="queries-table-expressions.html#QUERIES-TABLE-ALIASES" title="7.2.1.2. テーブルと列の別名">7.2.1.2</a>にあるように）<span class="emphasis"><em>必ず</em></span>テーブル別名が割り当てられている必要があります。
例を示します。
</p><pre class="programlisting">
FROM (SELECT * FROM table1) AS alias_name
</pre><p>
    </p><p>
<!--
     This example is equivalent to <literal>FROM table1 AS
     alias_name</literal>.  More interesting cases, which cannot be
     reduced to a plain join, arise when the subquery involves
     grouping or aggregation.
-->
この例は<code class="literal">FROM table1 AS alias_name</code>と同じです。
副問い合わせがグループ化や集約を含んでいる場合は、単純結合にまとめることはできない、より重要な例が発生します。
    </p><p>
<!--
     A subquery can also be a <command>VALUES</command> list:
-->
また、副問い合わせを<code class="command">VALUES</code>リストとすることもできます。
</p><pre class="programlisting">
FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))
     AS names(first, last)
</pre><p>
<!--
     Again, a table alias is required.  Assigning alias names to the columns
     of the <command>VALUES</command> list is optional, but is good practice.
     For more information see <xref linkend="queries-values"/>.
-->
繰り返しますが、テーブルの別名が必要です。
<code class="command">VALUES</code>リストの列に別名を付与することは省略することもできますが、付与することを勧めます。
<a class="xref" href="queries-values.html" title="7.7. VALUESリスト">7.7</a>を参照してください。
    </p></div><div class="sect3" id="QUERIES-TABLEFUNCTIONS"><div class="titlepage"><div><div><h4 class="title">7.2.1.4. テーブル関数</h4></div></div></div><!--
    <title>Table Functions</title>
--><!--
    <indexterm zone="queries-tablefunctions"><primary>table function</primary></indexterm>
--><a id="id-1.5.6.6.5.9.2" class="indexterm"></a><a id="id-1.5.6.6.5.9.3" class="indexterm"></a><p>
<!--
     Table functions are functions that produce a set of rows, made up
     of either base data types (scalar types) or composite data types
     (table rows).  They are used like a table, view, or subquery in
     the <literal>FROM</literal> clause of a query. Columns returned by table
     functions can be included in <literal>SELECT</literal>,
     <literal>JOIN</literal>, or <literal>WHERE</literal> clauses in the same manner
     as columns of a table, view, or subquery.
-->
テーブル関数は、基本データ型（スカラ型）、もしくは複合データ型（テーブル行）からなる行の集合を生成する関数です。
これらは、問い合わせの<code class="literal">FROM</code>句内でテーブル、ビュー、副問い合わせのように使用されます。
テーブル関数から返される列は、テーブル、ビュー、副問い合わせの列と同様の手順で、<code class="literal">SELECT</code>、<code class="literal">JOIN</code>、<code class="literal">WHERE</code>の中に含めることができます。
    </p><p>
<!--
     Table functions may also be combined using the <literal>ROWS FROM</literal>
     syntax, with the results returned in parallel columns; the number of
     result rows in this case is that of the largest function result, with
     smaller results padded with null values to match.
-->
テーブル関数は<code class="literal">ROWS FROM</code>構文を使用することで、それらの返却列を一緒に組み合わせることもできます。
このときの結果の行数は、行数が最大となる関数の結果と同じになり、少ない結果側は多い結果に合わせてnull値で埋められます。
    </p><pre class="synopsis">
<em class="replaceable"><code>function_call</code></em> [<span class="optional">WITH ORDINALITY</span>] [<span class="optional">[<span class="optional">AS</span>] <em class="replaceable"><code>table_alias</code></em> [<span class="optional">(<em class="replaceable"><code>column_alias</code></em> [<span class="optional">, ... </span>])</span>]</span>]
ROWS FROM( <em class="replaceable"><code>function_call</code></em> [<span class="optional">, ... </span>] ) [<span class="optional">WITH ORDINALITY</span>] [<span class="optional">[<span class="optional">AS</span>] <em class="replaceable"><code>table_alias</code></em> [<span class="optional">(<em class="replaceable"><code>column_alias</code></em> [<span class="optional">, ... </span>])</span>]</span>]
</pre><p>
<!--
     If the <literal>WITH ORDINALITY</literal> clause is specified, an
     additional column of type <type>bigint</type> will be added to the
     function result columns.  This column numbers the rows of the function
     result set, starting from 1. (This is a generalization of the
     SQL-standard syntax for <literal>UNNEST ... WITH ORDINALITY</literal>.)
     By default, the ordinal column is called <literal>ordinality</literal>, but
     a different column name can be assigned to it using
     an <literal>AS</literal> clause.
-->
WITH ORDINALITY句が指定されている場合、関数の結果の列に<code class="type">bigint</code>型の列が追加されます。
この列は関数の結果の行を1から数えます。
（これは標準SQLの構文<code class="literal">UNNEST ... WITH ORDINALITY</code>の一般化です。）
デフォルトでは、この序数(ordinal)の列は<code class="literal">ordinality</code>になります。しかし別の名前を<code class="literal">AS</code>句を使用して別名を割り当てることができます。
    </p><p>
<!--
     The special table function <literal>UNNEST</literal> may be called with
     any number of array parameters, and it returns a corresponding number of
     columns, as if <literal>UNNEST</literal>
     (<xref linkend="functions-array"/>) had been called on each parameter
     separately and combined using the <literal>ROWS FROM</literal> construct.
-->
特別なテーブル関数<code class="literal">UNNEST</code>は、任意の数の配列パラメータで呼ぶことができます。
そしてそれは、対応する数の列を返し、あたかも<code class="literal">UNNEST</code>(<a class="xref" href="functions-array.html" title="9.18. 配列関数と演算子">9.18</a>)が各パラメータ毎に<code class="literal">ROWS FROM</code>構文を使用して結合されているかのようになります。
    </p><pre class="synopsis">
UNNEST( <em class="replaceable"><code>array_expression</code></em> [<span class="optional">, ... </span>] ) [<span class="optional">WITH ORDINALITY</span>] [<span class="optional">[<span class="optional">AS</span>] <em class="replaceable"><code>table_alias</code></em> [<span class="optional">(<em class="replaceable"><code>column_alias</code></em> [<span class="optional">, ... </span>])</span>]</span>]
</pre><p>
<!--
     If no <replaceable>table_alias</replaceable> is specified, the function
     name is used as the table name; in the case of a <literal>ROWS FROM()</literal>
     construct, the first function's name is used.
-->
<em class="replaceable"><code>table_alias</code></em>が指定されない場合、テーブル名として関数名が使用されます。
<code class="literal">ROWS FROM()</code>の場合は最初の関数名が使用されます。
    </p><p>
<!--
     If column aliases are not supplied, then for a function returning a base
     data type, the column name is also the same as the function name.  For a
     function returning a composite type, the result columns get the names
     of the individual attributes of the type.
-->
列に別名が提供されない場合、基本データ型を返す関数に対しては、列名も関数名と同じになります。
複合型を返す関数の場合は、結果の列は型の個々の属性の名前を取得します。
    </p><p>
<!--
     Some examples:
-->
以下に数例示します。
</p><pre class="programlisting">
CREATE TABLE foo (fooid int, foosubid int, fooname text);

CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;

SELECT * FROM foo
    WHERE foosubid IN (
                        SELECT foosubid
                        FROM getfoo(foo.fooid) z
                        WHERE z.fooid = foo.fooid
                      );

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);

SELECT * FROM vw_getfoo;
</pre><p>
    </p><p>
<!--
     In some cases it is useful to define table functions that can
     return different column sets depending on how they are invoked.
     To support this, the table function can be declared as returning
     the pseudo-type <type>record</type>.  When such a function is used in
     a query, the expected row structure must be specified in the
     query itself, so that the system can know how to parse and plan
     the query.  This syntax looks like:
-->
呼び出し方法に応じて異なる列集合を返すテーブル関数を定義することが役に立つ場合があります。
これをサポートするために、テーブル関数を<code class="type">record</code>擬似型を返すものと宣言することができます。
こうした関数を問い合わせで使用する場合、システムがその問い合わせをどのように解析し計画を作成すればよいのかが判断できるように、想定した行構造を問い合わせ自身内に指定しなければなりません。
この構文は次のようになります。
    </p><pre class="synopsis">
<em class="replaceable"><code>function_call</code></em> [<span class="optional">AS</span>] <em class="replaceable"><code>alias</code></em> (<em class="replaceable"><code>column_definition</code></em> [<span class="optional">, ... </span>])
<em class="replaceable"><code>function_call</code></em> AS [<span class="optional"><em class="replaceable"><code>alias</code></em></span>] (<em class="replaceable"><code>column_definition</code></em> [<span class="optional">, ... </span>])
ROWS FROM( ... <em class="replaceable"><code>function_call</code></em> AS (<em class="replaceable"><code>column_definition</code></em> [<span class="optional">, ... </span>]) [<span class="optional">, ... </span>] )
</pre><p>
<!--
     When not using the <literal>ROWS FROM()</literal> syntax,
     the <replaceable>column_definition</replaceable> list replaces the column
     alias list that could otherwise be attached to the <literal>FROM</literal>
     item; the names in the column definitions serve as column aliases.
     When using the <literal>ROWS FROM()</literal> syntax,
     a <replaceable>column_definition</replaceable> list can be attached to
     each member function separately; or if there is only one member function
     and no <literal>WITH ORDINALITY</literal> clause,
     a <replaceable>column_definition</replaceable> list can be written in
     place of a column alias list following <literal>ROWS FROM()</literal>.
-->
<code class="literal">ROWS FROM()</code>構文を使用しない場合は、<em class="replaceable"><code>column_definition</code></em>のリストが<code class="literal">FROM</code>項目に取り付けることができる列の別名の代わりとなります。
列の定義内の名前は、列の別名として機能します。
<code class="literal">ROWS FROM()</code>構文を使用する場合は、<em class="replaceable"><code>column_definition</code></em>リストを個別に各メンバー関数に添付することができます。
またはメンバ関数が1つだけしかなく、かつ<code class="literal">WITH ORDINALITY</code>句がない場合は、<em class="replaceable"><code>column_definition</code></em>リストを、<code class="literal">ROWS FROM()</code>の後ろの列別名のリストの場所に書くことができます。
    </p><p>
<!--
     Consider this example:
-->
以下の例を考えます。

</p><pre class="programlisting">
SELECT *
    FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
</pre><p>
<!--
     The <xref linkend="contrib-dblink-function"/> function
     (part of the <xref linkend="dblink"/> module) executes
     a remote query.  It is declared to return
     <type>record</type> since it might be used for any kind of query.
     The actual column set must be specified in the calling query so
     that the parser knows, for example, what <literal>*</literal> should
     expand to.
-->
<a class="xref" href="contrib-dblink-function.html" title="dblink"><span class="refentrytitle">dblink</span></a>関数（<a class="xref" href="dblink.html" title="F.10. dblink">dblink</a>モジュールの一部）は遠隔問い合わせを実行します。
これは任意の問い合わせで使用できるように、<code class="type">record</code>を返すものと宣言されています。
実際の列集合は、パーサが例えば<code class="literal">*</code>がどのように展開されるかを理解できるように、呼び出した問い合わせ内で指定されなければなりません。
    </p></div><div class="sect3" id="QUERIES-LATERAL"><div class="titlepage"><div><div><h4 class="title">7.2.1.5. <code class="literal">LATERAL</code> 副問い合わせ</h4></div></div></div><!--
    <title><literal>LATERAL</literal> Subqueries</title>
--><a id="id-1.5.6.6.5.10.2" class="indexterm"></a><p>
<!--
     Subqueries appearing in <literal>FROM</literal> can be
     preceded by the key word <literal>LATERAL</literal>.  This allows them to
     reference columns provided by preceding <literal>FROM</literal> items.
     (Without <literal>LATERAL</literal>, each subquery is
     evaluated independently and so cannot cross-reference any other
     <literal>FROM</literal> item.)
-->
<code class="literal">FROM</code>に現れる副問い合わせの前にキーワード<code class="literal">LATERAL</code>を置くことができます。
こうすると、副問い合わせは先行する<code class="literal">FROM</code>項目によって提供される列を参照できます。
（<code class="literal">LATERAL</code>がない場合、それぞれの副問い合わせは個別に評価され、従ってその他の<code class="literal">FROM</code>項目を相互参照できません。）
    </p><p>
<!--
     Table functions appearing in <literal>FROM</literal> can also be
     preceded by the key word <literal>LATERAL</literal>, but for functions the
     key word is optional; the function's arguments can contain references
     to columns provided by preceding <literal>FROM</literal> items in any case.
-->
<code class="literal">FROM</code>に現れるテーブル関数の前にもキーワード<code class="literal">LATERAL</code>を置くことが可能ですが、関数に対してこのキーワードは省略可能です。
どんな場合であっても、関数の引数は先行する <code class="literal">FROM</code>項目により提供される列の参照を含むことができます。
    </p><p>
<!--
     A <literal>LATERAL</literal> item can appear at top level in the
     <literal>FROM</literal> list, or within a <literal>JOIN</literal> tree.  In the latter
     case it can also refer to any items that are on the left-hand side of a
     <literal>JOIN</literal> that it is on the right-hand side of.
-->
<code class="literal">LATERAL</code>項目は<code class="literal">FROM</code>リストの最上層、または<code class="literal">JOIN</code>木の中で表示することができます。
後者の場合、右側にある<code class="literal">JOIN</code>の左側のすべての項目を参照することが可能です。
    </p><p>
<!--
     When a <literal>FROM</literal> item contains <literal>LATERAL</literal>
     cross-references, evaluation proceeds as follows: for each row of the
     <literal>FROM</literal> item providing the cross-referenced column(s), or
     set of rows of multiple <literal>FROM</literal> items providing the
     columns, the <literal>LATERAL</literal> item is evaluated using that
     row or row set's values of the columns.  The resulting row(s) are
     joined as usual with the rows they were computed from.  This is
     repeated for each row or set of rows from the column source table(s).
-->
<code class="literal">FROM</code>項目が<code class="literal">LATERAL</code>相互参照を含む場合の評価は以下のようになります。
相互参照される列（複数可）を提供する<code class="literal">FROM</code>項目のそれぞれの行、もしくは列を提供する複数の<code class="literal">FROM</code>項目の行一式に対し、<code class="literal">LATERAL</code>項目は列の行または複数行の一式の値により評価されます。
結果行（複数可）は通常のように演算された行と結合されます。
元となるテーブル（複数可）の列からそれぞれの行、または行の一式に対し反復されます。
    </p><p>
<!--
     A trivial example of <literal>LATERAL</literal> is
-->
<code class="literal">LATERAL</code>の些細な例としては以下があげられます。
</p><pre class="programlisting">
SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;
</pre><p>
<!--
     This is not especially useful since it has exactly the same result as
     the more conventional
-->
上記は以下のより伝統的なやり方と全く同じ結果をもたらしますので特別に有用ではありません。
</p><pre class="programlisting">
SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;
</pre><p>
<!--
     <literal>LATERAL</literal> is primarily useful when the cross-referenced
     column is necessary for computing the row(s) to be joined.  A common
     application is providing an argument value for a set-returning function.
     For example, supposing that <function>vertices(polygon)</function> returns the
     set of vertices of a polygon, we could identify close-together vertices
     of polygons stored in a table with:
-->
<code class="literal">LATERAL</code>は、結合される行を計算するために相互参照する列を必須とする場合、第一義的に有用です。
一般的な利用方法は、集合を返す関数に対して引数の値を提供することです。
例えば、<code class="function">vertices(polygon)</code>が多角形の頂点の組みを返す関数だとして、以下のようにしてテーブルに格納されている多角形の互いに近接する頂点を特定できます。
</p><pre class="programlisting">
SELECT p1.id, p2.id, v1, v2
FROM polygons p1, polygons p2,
     LATERAL vertices(p1.poly) v1,
     LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;
</pre><p>
<!--
     This query could also be written
-->
この問い合わせは以下のようにも書くことができます。
</p><pre class="programlisting">
SELECT p1.id, p2.id, v1, v2
FROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1,
     polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;
</pre><p>
<!--
     or in several other equivalent formulations.  (As already mentioned,
     the <literal>LATERAL</literal> key word is unnecessary in this example, but
     we use it for clarity.)
-->
そのほか幾つかの同等の定式化が考えられます。
（既に言及したとおり、<code class="literal">LATERAL</code>キーワードはこの例に於いて必要ではありませんが、明確に示すために使用しました。）
    </p><p>
<!--
     It is often particularly handy to <literal>LEFT JOIN</literal> to a
     <literal>LATERAL</literal> subquery, so that source rows will appear in
     the result even if the <literal>LATERAL</literal> subquery produces no
     rows for them.  For example, if <function>get_product_names()</function> returns
     the names of products made by a manufacturer, but some manufacturers in
     our table currently produce no products, we could find out which ones
     those are like this:
-->
<code class="literal">LATERAL</code>副問い合わせは<code class="literal">LEFT JOIN</code>の対象として、しばしば特に重宝します。
たとえ<code class="literal">LATERAL</code>副問い合わせがそこから行を生成しない場合に於いても元となった行が結果に現れるからです。
たとえば、<code class="function">get_product_names()</code>が製造者により生産された製品名を返すとして、テーブル内のいくつかの製造者が現在製品を製造していない場合、それらは何であるかを以下のようにして見つけることができます。
</p><pre class="programlisting">
SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;
</pre><p>
    </p></div></div><div class="sect2" id="QUERIES-WHERE"><div class="titlepage"><div><div><h3 class="title">7.2.2. <code class="literal">WHERE</code>句</h3></div></div></div><!--
   <title>The <literal>WHERE</literal> Clause</title>
--><a id="id-1.5.6.6.6.2" class="indexterm"></a><p>
<!--
    The syntax of the <xref linkend="sql-where"
    endterm="sql-where-title"/> is
-->
<a class="xref" href="sql-select.html#SQL-WHERE" title="WHERE句"><code class="literal">WHERE</code>句</a>の構文は以下の通りです。
</p><pre class="synopsis">
WHERE <em class="replaceable"><code>search_condition</code></em>
</pre><p>
<!--
    where <replaceable>search_condition</replaceable> is any value
    expression (see <xref linkend="sql-expressions"/>) that
    returns a value of type <type>boolean</type>.
-->
ここで、<em class="replaceable"><code>search_condition</code></em>には<code class="type">boolean</code>型を返すどのような評価式（<a class="xref" href="sql-expressions.html" title="4.2. 評価式">4.2</a>を参照）も指定できます。
   </p><p>
<!--
    After the processing of the <literal>FROM</literal> clause is done, each
    row of the derived virtual table is checked against the search
    condition.  If the result of the condition is true, the row is
    kept in the output table, otherwise (i.e., if the result is
    false or null) it is discarded.  The search condition typically
    references at least one column of the table generated in the
    <literal>FROM</literal> clause; this is not required, but otherwise the
    <literal>WHERE</literal> clause will be fairly useless.
-->
<code class="literal">FROM</code>句の処理が終わった後、派生した仮想テーブルの各行は検索条件と照合されます。
条件の結果が真の場合、その行は出力されます。
そうでない（すなわち結果が偽またはNULLの）場合は、その行は捨てられます。
一般的に検索条件は、<code class="literal">FROM</code>句で生成されたテーブルの最低１列を参照します。
これは必須ではありませんが、そうしないと<code class="literal">WHERE</code>句はまったく意味がなくなります。
   </p><div class="note"><h3 class="title">注記</h3><p>
<!--
     The join condition of an inner join can be written either in
     the <literal>WHERE</literal> clause or in the <literal>JOIN</literal> clause.
     For example, these table expressions are equivalent:
-->
内部結合の結合条件は、<code class="literal">WHERE</code>句でも<code class="literal">JOIN</code>句でも記述することができます。
例えば、以下のテーブル式は等価です。
</p><pre class="programlisting">
FROM a, b WHERE a.id = b.id AND b.val &gt; 5
</pre><p>
<!--
     and:
-->
および
</p><pre class="programlisting">
FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5
</pre><p>
<!--
     or perhaps even:
-->
また、以下でも同じです。
</p><pre class="programlisting">
FROM a NATURAL JOIN b WHERE b.val &gt; 5
</pre><p>
<!--
     Which one of these you use is mainly a matter of style.  The
     <literal>JOIN</literal> syntax in the <literal>FROM</literal> clause is
     probably not as portable to other SQL database management systems,
     even though it is in the SQL standard.  For
     outer joins there is no choice:  they must be done in
     the <literal>FROM</literal> clause.  The <literal>ON</literal> or <literal>USING</literal>
     clause of an outer join is <emphasis>not</emphasis> equivalent to a
     <literal>WHERE</literal> condition, because it results in the addition
     of rows (for unmatched input rows) as well as the removal of rows
     in the final result.
-->
どれを使うかは、主にスタイルの問題です。
<code class="literal">FROM</code>句の<code class="literal">JOIN</code>構文はSQL標準であるにも関わらず、おそらく他のSQLデータベース管理システムへの移植性では劣るでしょう。
外部結合については、<code class="literal">FROM</code>句以外に選択の余地はありません。
外部結合の<code class="literal">ON</code>句または<code class="literal">USING</code>句は、<code class="literal">WHERE</code>条件とは等しく<span class="emphasis"><em>ありません</em></span>。
なぜなら、最終結果での行を除去すると同様に、（一致しない入力行に対する）行の追加となるからです。
    </p></div><p>
<!--
    Here are some examples of <literal>WHERE</literal> clauses:
-->
<code class="literal">WHERE</code>句の例を以下に示します。
</p><pre class="programlisting">
SELECT ... FROM fdt WHERE c1 &gt; 5

SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)

SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)

SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)

SELECT ... FROM fdt WHERE c1 BETWEEN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100

SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)
</pre><p>
<!--
    <literal>fdt</literal> is the table derived in the
    <literal>FROM</literal> clause. Rows that do not meet the search
    condition of the <literal>WHERE</literal> clause are eliminated from
    <literal>fdt</literal>. Notice the use of scalar subqueries as
    value expressions.  Just like any other query, the subqueries can
    employ complex table expressions.  Notice also how
    <literal>fdt</literal> is referenced in the subqueries.
    Qualifying <literal>c1</literal> as <literal>fdt.c1</literal> is only necessary
    if <literal>c1</literal> is also the name of a column in the derived
    input table of the subquery.  But qualifying the column name adds
    clarity even when it is not needed.  This example shows how the column
    naming scope of an outer query extends into its inner queries.
-->
<code class="literal">fdt</code>は<code class="literal">FROM</code>句で派生されたテーブルです。
<code class="literal">WHERE</code>句の検索条件を満たさなかった行は、<code class="literal">fdt</code>から削除されます。
評価式としてのスカラ副問い合わせの使い方に注目してください。
他の問い合わせのように、副問い合わせは複雑なテーブル式を使うことができます。
副問い合わせの中でどのように<code class="literal">fdt</code>が参照されるかにも注意してください。
<code class="literal">c1</code>を<code class="literal">fdt.c1</code>のように修飾することは、<code class="literal">c1</code>が副問い合わせの入力テーブルから派生した列名でもある時にだけ必要です。
列名の修飾は、必須の場合ではなくても、明確にするために役立ちます。
この例は、外側の問い合わせの列名の有効範囲を、どのようにして内側の問い合わせまで拡張するかを示します。
   </p></div><div class="sect2" id="QUERIES-GROUP"><div class="titlepage"><div><div><h3 class="title">7.2.3. <code class="literal">GROUP BY</code>句と<code class="literal">HAVING</code>句</h3></div></div></div><!--
   <title>The <literal>GROUP BY</literal> and <literal>HAVING</literal> Clauses</title>
--><a id="id-1.5.6.6.7.2" class="indexterm"></a><a id="id-1.5.6.6.7.3" class="indexterm"></a><p>
<!--
    After passing the <literal>WHERE</literal> filter, the derived input
    table might be subject to grouping, using the <literal>GROUP BY</literal>
    clause, and elimination of group rows using the <literal>HAVING</literal>
    clause.
-->
<code class="literal">WHERE</code>フィルタを通した後、派生された入力テーブルを<code class="literal">GROUP BY</code>句でグループ化し、また、<code class="literal">HAVING</code>句を使用して不要なグループを取り除くことができます。
   </p><pre class="synopsis">
SELECT <em class="replaceable"><code>select_list</code></em>
    FROM ...
    [<span class="optional">WHERE ...</span>]
    GROUP BY <em class="replaceable"><code>grouping_column_reference</code></em> [<span class="optional">, <em class="replaceable"><code>grouping_column_reference</code></em></span>]...
</pre><p>
<!--
    The <xref linkend="sql-groupby" endterm="sql-groupby-title"/> is
    used to group together those rows in a table that have the same
    values in all the columns listed. The order in which the columns
    are listed does not matter.  The effect is to combine each set
    of rows having common values into one group row that
    represents all rows in the group.  This is done to
    eliminate redundancy in the output and/or compute aggregates that
    apply to these groups.  For instance:
-->
<a class="xref" href="sql-select.html#SQL-GROUPBY" title="GROUP BY句"><code class="literal">GROUP BY</code>句</a>は、GROUP BY句で列挙されたすべての列で同じ値を所有する行をまとめてグループ化するために使用されます。
列の列挙順は関係ありません。
これは共通する値を持つそれぞれの行の集合をグループ内のすべての行を代表する１つのグループ行にまとめるものです。
これは、出力の冗長度を排除したり、それぞれのグループに適用される集約計算を行うためのものです。
以下に例を示します。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM test1;</code></strong>
 x | y
---+---
 a | 3
 c | 2
 b | 5
 a | 1
(4 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT x FROM test1 GROUP BY x;</code></strong>
 x
---
 a
 b
 c
(3 rows)
</pre><p>
   </p><p>
<!--
    In the second query, we could not have written <literal>SELECT *
    FROM test1 GROUP BY x</literal>, because there is no single value
    for the column <literal>y</literal> that could be associated with each
    group.  The grouped-by columns can be referenced in the select list since
    they have a single value in each group.
-->
2番目の問い合わせでは、<code class="literal">SELECT * FROM test1 GROUP BY x</code>と書くことはできません。
各グループに関連付けられる列<code class="literal">y</code>の単一の値がないからです。
<code class="literal">GROUP BY</code>で指定した列はグループごとに単一の値を持つので、選択リストで参照することができます。
   </p><p>
<!--
    In general, if a table is grouped, columns that are not
    listed in <literal>GROUP BY</literal> cannot be referenced except in aggregate
    expressions.  An example with aggregate expressions is:
-->
一般的に、テーブルがグループ化されている場合、<code class="literal">GROUP BY</code>でリストされていない列は集約式を除いて参照することはできません。
集約式の例は以下の通りです。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT x, sum(y) FROM test1 GROUP BY x;</code></strong>
 x | sum
---+-----
 a |   4
 b |   5
 c |   2
(3 rows)
</pre><p>
<!--
    Here <literal>sum</literal> is an aggregate function that
    computes a single value over the entire group.  More information
    about the available aggregate functions can be found in <xref
    linkend="functions-aggregate"/>.
-->
上記で<code class="literal">sum()</code> は、グループ全体について単一の値を計算する集約関数です。
使用可能な集約関数の詳細については、<a class="xref" href="functions-aggregate.html" title="9.20. 集約関数">9.20</a>を参照してください。
   </p><div class="tip"><h3 class="title">ヒント</h3><p>
<!--
     Grouping without aggregate expressions effectively calculates the
     set of distinct values in a column.  This can also be achieved
     using the <literal>DISTINCT</literal> clause (see <xref
     linkend="queries-distinct"/>).
-->
集約式を使用しないグループ化は、列内の重複しない値の集合を効率良く計算します。
これは<code class="literal">DISTINCT</code>句（<a class="xref" href="queries-select-lists.html#QUERIES-DISTINCT" title="7.3.3. DISTINCT">7.3.3</a>を参照）の使用で同じように達成することができます。
    </p></div><p>
<!--
    Here is another example:  it calculates the total sales for each
    product (rather than the total sales of all products):
-->
別の例を示します。
これは各製品の総売上を計算します
（全製品の総売上ではありません）。
</p><pre class="programlisting">
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
    FROM products p LEFT JOIN sales s USING (product_id)
    GROUP BY product_id, p.name, p.price;
</pre><p>
<!--
    In this example, the columns <literal>product_id</literal>,
    <literal>p.name</literal>, and <literal>p.price</literal> must be
    in the <literal>GROUP BY</literal> clause since they are referenced in
    the query select list (but see below).  The column
    <literal>s.units</literal> does not have to be in the <literal>GROUP
    BY</literal> list since it is only used in an aggregate expression
    (<literal>sum(...)</literal>), which represents the sales
    of a product.  For each product, the query returns a summary row about
    all sales of the product.
-->
この例では、<code class="literal">product_id</code>列、<code class="literal">p.name</code>列、<code class="literal">p.price</code>列は必ず<code class="literal">GROUP BY</code>句で指定する必要があります。
なぜなら、これらは問い合わせ選択リストの中で使われているからです（ただし、以下を参照）。
<code class="literal">s.units</code>列は<code class="literal">GROUP BY</code>で指定する必要はありません。
これは、製品ごとの売上計算の集約式（<code class="function">sum(...)</code>）の中だけで使われるためです。
この問い合わせは、各製品に対して製品の全販売に関する合計行が返されます。
   </p><!--
   <indexterm><primary>functional dependency</primary></indexterm>
--><a id="id-1.5.6.6.7.11" class="indexterm"></a><p>
<!--
    If the products table is set up so that, say,
    <literal>product_id</literal> is the primary key, then it would be
    enough to group by <literal>product_id</literal> in the above example,
    since name and price would be <firstterm>functionally
    dependent</firstterm> on the product ID, and so there would be no
    ambiguity about which name and price value to return for each product
    ID group.
-->
productsテーブルが、例えば、<code class="literal">product_id</code>が主キーであるように設定されている場合、nameとprice列は製品ID（product_id）に<em class="firstterm">関数依存</em>しており、このため製品IDグループそれぞれに対してどのnameとpriceの値を返すかに関するあいまいさがありませんので、上の例では<code class="literal">product_id</code>でグループ化することで十分です。
   </p><p>
<!--
    In strict SQL, <literal>GROUP BY</literal> can only group by columns of
    the source table but <productname>PostgreSQL</productname> extends
    this to also allow <literal>GROUP BY</literal> to group by columns in the
    select list.  Grouping by value expressions instead of simple
    column names is also allowed.
-->
厳密なSQLでは、<code class="literal">GROUP BY</code>は、元となるテーブルの列によってのみグループ化できますが、<span class="productname">PostgreSQL</span>では、選択リストの列によるグループ化もできるように拡張されています。
単純な列名の代わりに、評価式でグループ化することもできます。
   </p><a id="id-1.5.6.6.7.14" class="indexterm"></a><p>
<!--
    If a table has been grouped using <literal>GROUP BY</literal>,
    but only certain groups are of interest, the
    <literal>HAVING</literal> clause can be used, much like a
    <literal>WHERE</literal> clause, to eliminate groups from the result.
    The syntax is:
-->
<code class="literal">GROUP BY</code>を使ってグループ化されたテーブルで特定のグループのみ必要な場合、結果から不要なグループを除くのに、<code class="literal">WHERE</code>句のように<code class="literal">HAVING</code>句を使うことができます。
構文は以下の通りです。
</p><pre class="synopsis">
SELECT <em class="replaceable"><code>select_list</code></em> FROM ... [<span class="optional">WHERE ...</span>] GROUP BY ... HAVING <em class="replaceable"><code>boolean_expression</code></em>
</pre><p>
<!--
    Expressions in the <literal>HAVING</literal> clause can refer both to
    grouped expressions and to ungrouped expressions (which necessarily
    involve an aggregate function).
-->
<code class="literal">HAVING</code>句内の式は、グループ化された式とグループ化されてない式（この場合は集約関数が必要になります）の両方を参照することができます。
   </p><p>
<!--
    Example:
-->
例を示します。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) &gt; 3;</code></strong>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT x, sum(y) FROM test1 GROUP BY x HAVING x &lt; 'c';</code></strong>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)
</pre><p>
   </p><p>
<!--
    Again, a more realistic example:
-->
次に、より現実的な例を示します。
</p><pre class="programlisting">
SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit
    FROM products p LEFT JOIN sales s USING (product_id)
    WHERE s.date &gt; CURRENT_DATE - INTERVAL '4 weeks'
    GROUP BY product_id, p.name, p.price, p.cost
    HAVING sum(p.price * s.units) &gt; 5000;
</pre><p>
<!--
    In the example above, the <literal>WHERE</literal> clause is selecting
    rows by a column that is not grouped (the expression is only true for
    sales during the last four weeks), while the <literal>HAVING</literal>
    clause restricts the output to groups with total gross sales over
    5000.  Note that the aggregate expressions do not necessarily need
    to be the same in all parts of the query.
-->
上の例で、<code class="literal">WHERE</code>句は、グループ化されていない列によって行を選択している（この式では最近の4週間の売上のみが真になります）のに対し、<code class="literal">HAVING</code>句は出力を売上高が5000を超えるグループに制限しています。
集約式が、問い合わせ内で常に同じである必要がないことに注意してください。
   </p><p>
<!--
    If a query contains aggregate function calls, but no <literal>GROUP BY</literal>
    clause, grouping still occurs: the result is a single group row (or
    perhaps no rows at all, if the single row is then eliminated by
    <literal>HAVING</literal>).
    The same is true if it contains a <literal>HAVING</literal> clause, even
    without any aggregate function calls or <literal>GROUP BY</literal> clause.
-->
ある問い合わせが集約関数を含んでいるが<code class="literal">GROUP BY</code>句がない場合でも、グループ化は依然として行われます。
結果は単一グループ行（または<code class="literal">HAVING</code>で単一行が削除されれば、行が全くなくなるかもしれません）となります。
<code class="literal">HAVING</code>句を含んでいれば、集約関数呼び出しや<code class="literal">GROUP BY</code>句がまったく存在しなくても同じことが言えます。
   </p></div><div class="sect2" id="QUERIES-GROUPING-SETS"><div class="titlepage"><div><div><h3 class="title">7.2.4. <code class="literal">GROUPING SETS</code>、<code class="literal">CUBE</code>、<code class="literal">ROLLUP</code></h3></div></div></div><!--
   <title><literal>GROUPING SETS</literal>, <literal>CUBE</literal>, and <literal>ROLLUP</literal></title>
--><a id="id-1.5.6.6.8.2" class="indexterm"></a><a id="id-1.5.6.6.8.3" class="indexterm"></a><a id="id-1.5.6.6.8.4" class="indexterm"></a><p>
<!--
    More complex grouping operations than those described above are possible
    using the concept of <firstterm>grouping sets</firstterm>.  The data selected by
    the <literal>FROM</literal> and <literal>WHERE</literal> clauses is grouped separately
    by each specified grouping set, aggregates computed for each group just as
    for simple <literal>GROUP BY</literal> clauses, and then the results returned.
    For example:
-->
上述のものよりも複雑なグループ化の操作は、<em class="firstterm">グループ化セット</em>の概念を用いることで可能です。
<code class="literal">FROM</code>句と<code class="literal">WHERE</code>句によって選択されたデータは、指定されたグループ化セットによってそれぞれグループ化され、単純な<code class="literal">GROUP BY</code>句と同じように集約計算され、その後結果が返されます。
例を示します。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM items_sold;</code></strong>
 brand | size | sales
-------+------+-------
 Foo   | L    |  10
 Foo   | M    |  20
 Bar   | M    |  15
 Bar   | L    |  5
(4 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand), (size), ());</code></strong>
 brand | size | sum
-------+------+-----
 Foo   |      |  30
 Bar   |      |  20
       | L    |  15
       | M    |  35
       |      |  50
(5 rows)
</pre><p>
   </p><p>
<!--
    Each sublist of <literal>GROUPING SETS</literal> may specify zero or more columns
    or expressions and is interpreted the same way as though it were directly
    in the <literal>GROUP BY</literal> clause.  An empty grouping set means that all
    rows are aggregated down to a single group (which is output even if no
    input rows were present), as described above for the case of aggregate
    functions with no <literal>GROUP BY</literal> clause.
-->
<code class="literal">GROUPING SETS</code>の各サブリストはゼロ個以上の列または式を指定することが出来ます。
そして、それが直接<code class="literal">GROUP BY</code>句で指定したのと同じように解釈されます。
空のグループ化セットは、全行が一つのグループにまで集約されることを意味します（何も入力行が存在しない場合でも出力されます）。
これは、上述した<code class="literal">GROUP BY</code>句がない集約関数の場合と同様です。
   </p><p>
<!--
    References to the grouping columns or expressions are replaced
    by null values in result rows for grouping sets in which those
    columns do not appear.  To distinguish which grouping a particular output
    row resulted from, see <xref linkend="functions-grouping-table"/>.
-->
グループ化している列または式の参照は、その列が現われないグループ化セットの結果行ではNULL値に置き換えられます。
特定の出力行が、どのグループ化から生じたかを識別するには<a class="xref" href="functions-aggregate.html#FUNCTIONS-GROUPING-TABLE" title="表9.56 グループ化演算">表 9.56</a>を参照して下さい。
   </p><p>
<!--
    A shorthand notation is provided for specifying two common types of grouping set.
    A clause of the form
-->
グループ化セットの中で一般的な２種類については、略記法での指定方法が提供されています。
</p><pre class="programlisting">
ROLLUP ( <em class="replaceable"><code>e1</code></em>, <em class="replaceable"><code>e2</code></em>, <em class="replaceable"><code>e3</code></em>, ... )
</pre><p>
<!--
    represents the given list of expressions and all prefixes of the list including
    the empty list; thus it is equivalent to
-->
上の句は、式の指定されたリストと空のリストを含めたリストのすべてのプレフィックスを表します。
したがって、以下と同等です。
</p><pre class="programlisting">
GROUPING SETS (
    ( <em class="replaceable"><code>e1</code></em>, <em class="replaceable"><code>e2</code></em>, <em class="replaceable"><code>e3</code></em>, ... ),
    ...
    ( <em class="replaceable"><code>e1</code></em>, <em class="replaceable"><code>e2</code></em> ),
    ( <em class="replaceable"><code>e1</code></em> ),
    ( )
)
</pre><p>
<!--
    This is commonly used for analysis over hierarchical data; e.g. total
    salary by department, division, and company-wide total.
-->
これは一般に、階層データに対する分析のために使用されます。例えば、部署、部門、全社合計による総給与を出します。
   </p><p>
<!--
    A clause of the form
-->
</p><pre class="programlisting">
CUBE ( <em class="replaceable"><code>e1</code></em>, <em class="replaceable"><code>e2</code></em>, ... )
</pre><p>
<!--
    represents the given list and all of its possible subsets (i.e. the power
    set).  Thus
-->
上の句は、与えられたリストとその可能な部分集合（サブセット）のすべて（すなわち、べき集合）を表します。
したがって
</p><pre class="programlisting">
CUBE ( a, b, c )
</pre><p>
<!--
    is equivalent to
-->
は以下と同等です。
</p><pre class="programlisting">
GROUPING SETS (
    ( a, b, c ),
    ( a, b    ),
    ( a,    c ),
    ( a       ),
    (    b, c ),
    (    b    ),
    (       c ),
    (         )
)
</pre><p>
   </p><p>
<!--
    The individual elements of a <literal>CUBE</literal> or <literal>ROLLUP</literal>
    clause may be either individual expressions, or sublists of elements in
    parentheses.  In the latter case, the sublists are treated as single
    units for the purposes of generating the individual grouping sets.
    For example:
-->
<code class="literal">CUBE</code>句や<code class="literal">ROLLUP</code>句の各要素は、個々の式、または括弧で囲まれた要素のサブリスト、どちらかに出来ます。
後者の場合には、サブリストは個々のグループ化セットを生成する目的において一つの単位として扱われます。
例えば
</p><pre class="programlisting">
CUBE ( (a, b), (c, d) )
</pre><p>
<!--
    is equivalent to
-->
は以下と同等です。
</p><pre class="programlisting">
GROUPING SETS (
    ( a, b, c, d ),
    ( a, b       ),
    (       c, d ),
    (            )
)
</pre><p>
<!--
    and
-->
そして
</p><pre class="programlisting">
ROLLUP ( a, (b, c), d )
</pre><p>
<!--
    is equivalent to
-->
は以下と同等です。
</p><pre class="programlisting">
GROUPING SETS (
    ( a, b, c, d ),
    ( a, b, c    ),
    ( a          ),
    (            )
)
</pre><p>
   </p><p>
<!--
    The <literal>CUBE</literal> and <literal>ROLLUP</literal> constructs can be used either
    directly in the <literal>GROUP BY</literal> clause, or nested inside a
    <literal>GROUPING SETS</literal> clause.  If one <literal>GROUPING SETS</literal> clause
    is nested inside another, the effect is the same as if all the elements of
    the inner clause had been written directly in the outer clause.
-->
<code class="literal">CUBE</code>と<code class="literal">ROLLUP</code>構文は、<code class="literal">GROUP BY</code>句の中で直接使用、または<code class="literal">GROUPING SETS</code>句の中で入れ子に出来ます。
<code class="literal">GROUPING SETS</code>句が別の内側に入れ子になっている場合、内側の句が外側の句に直接書かれている場合と効果は同じになります。
   </p><p>
<!--
    If multiple grouping items are specified in a single <literal>GROUP BY</literal>
    clause, then the final list of grouping sets is the cross product of the
    individual items.  For example:
-->
複数の集約項目が<code class="literal">GROUP BY</code>句一つで指定されている場合、グループ化セットの最終的なリストは、個々の項目の外積（クロス積）です。
例えば
</p><pre class="programlisting">
GROUP BY a, CUBE (b, c), GROUPING SETS ((d), (e))
</pre><p>
<!--
    is equivalent to
-->
は以下と同等です。
</p><pre class="programlisting">
GROUP BY GROUPING SETS (
    (a, b, c, d), (a, b, c, e),
    (a, b, d),    (a, b, e),
    (a, c, d),    (a, c, e),
    (a, d),       (a, e)
)
</pre><p>
   </p><div class="note"><h3 class="title">注記</h3><p>
<!--
    The construct <literal>(a, b)</literal> is normally recognized in expressions as
    a <link linkend="sql-syntax-row-constructors">row constructor</link>.
    Within the <literal>GROUP BY</literal> clause, this does not apply at the top
    levels of expressions, and <literal>(a, b)</literal> is parsed as a list of
    expressions as described above.  If for some reason you <emphasis>need</emphasis>
    a row constructor in a grouping expression, use <literal>ROW(a, b)</literal>.
-->
<code class="literal">(a, b)</code>という構文は通常<a class="link" href="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS" title="4.2.13. 行コンストラクタ">行コンストラクタ</a>として式に認識されます。
<code class="literal">GROUP BY</code>句の中では、トップレベルの式の場合これは適用されず、<code class="literal">(a, b)</code>は上記のような式のリストとして解析されます。
何らかの理由で、グループ化式の中で行コンストラクタが<span class="emphasis"><em>必要</em></span>になった場合は、<code class="literal">ROW(a, b)</code>を使用して下さい。
   </p></div></div><div class="sect2" id="QUERIES-WINDOW"><div class="titlepage"><div><div><h3 class="title">7.2.5. ウィンドウ関数処理</h3></div></div></div><!--
   <title>Window Function Processing</title>
--><a id="id-1.5.6.6.9.2" class="indexterm"></a><p>
<!--
    If the query contains any window functions (see
    <xref linkend="tutorial-window"/>,
    <xref linkend="functions-window"/> and
    <xref linkend="syntax-window-functions"/>), these functions are evaluated
    after any grouping, aggregation, and <literal>HAVING</literal> filtering is
    performed.  That is, if the query uses any aggregates, <literal>GROUP
    BY</literal>, or <literal>HAVING</literal>, then the rows seen by the window functions
    are the group rows instead of the original table rows from
    <literal>FROM</literal>/<literal>WHERE</literal>.
-->
問い合わせがウィンドウ関数（<a class="xref" href="tutorial-window.html" title="3.5. ウィンドウ関数">3.5</a>、<a class="xref" href="functions-window.html" title="9.21. ウィンドウ関数">9.21</a>と<a class="xref" href="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS" title="4.2.8. ウィンドウ関数呼び出し">4.2.8</a>を参照）を含んでいれば、これらの関数はグループ化、集約および<code class="literal">HAVING</code>条件検索が行われた後に評価されます。
つまり、問い合わせが何らかの集約、<code class="literal">GROUP BY</code>または<code class="literal">HAVING</code>を使用していれば、ウィンドウ関数により見える行は<code class="literal">FROM</code>/<code class="literal">WHERE</code>での本来のテーブル行ではなく、グループ行となります。
   </p><p>
<!--
    When multiple window functions are used, all the window functions having
    syntactically equivalent <literal>PARTITION BY</literal> and <literal>ORDER BY</literal>
    clauses in their window definitions are guaranteed to be evaluated in a
    single pass over the data. Therefore they will see the same sort ordering,
    even if the <literal>ORDER BY</literal> does not uniquely determine an ordering.
    However, no guarantees are made about the evaluation of functions having
    different <literal>PARTITION BY</literal> or <literal>ORDER BY</literal> specifications.
    (In such cases a sort step is typically required between the passes of
    window function evaluations, and the sort is not guaranteed to preserve
    ordering of rows that its <literal>ORDER BY</literal> sees as equivalent.)
-->
複数のウィンドウ関数が使用された場合、そのウィンドウ定義にある構文的に同等である<code class="literal">PARTITION BY</code>および<code class="literal">ORDER BY</code>句を持つすべてのウィンドウ関数は、データ全体に渡って単一の実行手順により評価されることが保証されています。
したがって、<code class="literal">ORDER BY</code>が一意に順序付けを決定しなくても同一の並べ替え順序付けを見ることができます。
しかし、異なる<code class="literal">PARTITION BY</code>または<code class="literal">ORDER BY</code>仕様を持つ関数の評価については保証されません。
（このような場合、並べ替え手順がウィンドウ関数評価の諸手順間で一般的に必要となり、<code class="literal">ORDER BY</code>が等価と判断する行の順序付けを保存するような並べ替えは保証されません。）
   </p><p>
<!--
    Currently, window functions always require presorted data, and so the
    query output will be ordered according to one or another of the window
    functions' <literal>PARTITION BY</literal>/<literal>ORDER BY</literal> clauses.
    It is not recommended to rely on this, however.  Use an explicit
    top-level <literal>ORDER BY</literal> clause if you want to be sure the
    results are sorted in a particular way.
-->
現時点では、ウィンドウ関数は常に事前に並べ替えられたデータを必要とするので、問い合わせ出力はウィンドウ関数の<code class="literal">PARTITION BY</code>/<code class="literal">ORDER BY</code>句のどれか１つに従って順序付けされます。
とはいえ、これに依存することは薦められません。
確実に結果が特定の方法で並べ替えられるようにしたいのであれば、明示的な最上階層の<code class="literal">ORDER BY</code>を使用します。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="queries-overview.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="queries.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="queries-select-lists.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">7.1. 概要 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 7.3. 選択リスト</td></tr></table></div></body></html>