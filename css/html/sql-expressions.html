<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>4.2. 評価式</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-syntax-lexical.html" title="4.1. 字句の構造" /><link rel="next" href="sql-syntax-calling-funcs.html" title="4.3. 関数呼び出し" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 11.4文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="sql-syntax.html" title="第4章 SQLの構文">第4章 SQLの構文</a></td><td width="20%" align="right"></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-syntax-lexical.html" title="4.1. 字句の構造">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-syntax.html" title="第4章 SQLの構文">上へ</a></td><td width="60%" align="center">4.2. 評価式</td><td width="20%" align="right"> <a accesskey="n" href="sql-syntax-calling-funcs.html" title="4.3. 関数呼び出し">次へ</a></td></tr></table><hr /></div><div class="sect1" id="SQL-EXPRESSIONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">4.2. 評価式</h2></div></div></div><!--
  <title>Value Expressions</title>
--><a id="id-1.5.3.6.2" class="indexterm"></a><a id="id-1.5.3.6.3" class="indexterm"></a><a id="id-1.5.3.6.4" class="indexterm"></a><p>
<!--
   Value expressions are used in a variety of contexts, such
   as in the target list of the <command>SELECT</command> command, as
   new column values in <command>INSERT</command> or
   <command>UPDATE</command>, or in search conditions in a number of
   commands.  The result of a value expression is sometimes called a
   <firstterm>scalar</firstterm>, to distinguish it from the result of
   a table expression (which is a table).  Value expressions are
   therefore also called <firstterm>scalar expressions</firstterm> (or
   even simply <firstterm>expressions</firstterm>).  The expression
   syntax allows the calculation of values from primitive parts using
   arithmetic, logical, set, and other operations.
-->
評価式は、例えば<code class="command">SELECT</code>コマンドの目的リストとして、<code class="command">INSERT</code>や<code class="command">UPDATE</code>の新しい列の値として、もしくはいくつかのコマンドの検索条件として様々な文脈の中で使われます。
評価式の結果は、テーブル式の結果（つまりテーブル）から区別するために、<em class="firstterm">スカラ</em>と呼ばれることもあります。
したがって、評価式は<em class="firstterm">スカラ式</em>（またはもっと簡単に<em class="firstterm">式</em>）とも呼ばれます。
式の構文によって、基本的な部分から算術、論理、集合などの演算を使って値の計算を行うことができます。
  </p><p>
<!--
   A value expression is one of the following:
-->
評価式は下記のうちのいずれかです。

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<!--
      A constant or literal value
-->
定数あるいはリテラル値
     </p></li><li class="listitem"><p>
<!--
      A column reference
-->
列の参照
     </p></li><li class="listitem"><p>
<!--
      A positional parameter reference, in the body of a function definition
      or prepared statement
-->
関数定義の本体やプリペアド文における、位置パラメータ参照
     </p></li><li class="listitem"><p>
<!--
      A subscripted expression
-->
添字付きの式
     </p></li><li class="listitem"><p>
<!--
      A field selection expression
-->
フィールド選択式
     </p></li><li class="listitem"><p>
<!--
      An operator invocation
-->
演算子の呼び出し
     </p></li><li class="listitem"><p>
<!--
      A function call
-->
関数呼び出し
     </p></li><li class="listitem"><p>
<!--
      An aggregate expression
-->
集約式
     </p></li><li class="listitem"><p>
<!--
      A window function call
-->
      ウィンドウ関数呼び出し
     </p></li><li class="listitem"><p>
<!--
      A type cast
-->
型キャスト
     </p></li><li class="listitem"><p>
<!--
      A collation expression
-->
照合順序(collation)式
     </p></li><li class="listitem"><p>
<!--
      A scalar subquery
-->
スカラ副問い合わせ
     </p></li><li class="listitem"><p>
<!--
      An array constructor
-->
配列コンストラクタ
     </p></li><li class="listitem"><p>
<!--
      A row constructor
-->
行コンストラクタ
     </p></li><li class="listitem"><p>
<!--
      Another value expression in parentheses (used to group
      subexpressions and override
      precedence<indexterm><primary>parenthesis</primary></indexterm>)
-->
      （副式をグループ化したり<a id="id-1.5.3.6.6.1.15.1.1" class="indexterm"></a>優先順位を変更するのに使用される）括弧で囲まれた別の評価式
     </p></li></ul></div><p>
  </p><p>
<!--
   In addition to this list, there are a number of constructs that can
   be classified as an expression but do not follow any general syntax
   rules.  These generally have the semantics of a function or
   operator and are explained in the appropriate location in <xref
   linkend="functions"/>.  An example is the <literal>IS NULL</literal>
   clause.
-->
これ以外にも、式として分類されるけれども一般的な構文規約には従わない、いくつかの構成要素があります。
これらは一般的に関数あるいは演算子の意味を持ちます。
<a class="xref" href="functions.html" title="第9章 関数と演算子">第9章</a>の該当部分で説明されています。
例を挙げると<code class="literal">IS NULL</code>句があります。
  </p><p>
<!--
   We have already discussed constants in <xref
   linkend="sql-syntax-constants"/>.  The following sections discuss
   the remaining options.
-->
<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS" title="4.1.2. 定数">4.1.2</a>で既に定数については説明しました。
続く節では残りのオプションについて説明します。
  </p><div class="sect2" id="SQL-EXPRESSIONS-COLUMN-REFS"><div class="titlepage"><div><div><h3 class="title">4.2.1. 列の参照</h3></div></div></div><!--
   <title>Column References</title>
--><a id="id-1.5.3.6.9.2" class="indexterm"></a><p>
<!--
    A column can be referenced in the form:
-->
列は、下記のような形式で参照することができます。
</p><pre class="synopsis">
<em class="replaceable"><code>correlation</code></em>.<em class="replaceable"><code>columnname</code></em>
</pre><p>
   </p><p>
<!--
    <replaceable>correlation</replaceable> is the name of a
    table (possibly qualified with a schema name), or an alias for a table
    defined by means of a <literal>FROM</literal> clause.
    The correlation name and separating dot can be omitted if the column name
    is unique across all the tables being used in the current query.  (See also <xref linkend="queries"/>.)
-->
<em class="replaceable"><code>correlation</code></em>は、テーブル名（スキーマで修飾されている場合もあります）、あるいは<code class="literal">FROM</code>句で定義されたテーブルの別名です。
correlationの名前と区切り用のドットは、もし列名が現在の問い合わせで使われる全てのテーブルを通して一意である場合は省略することができます。
（<a class="xref" href="queries.html" title="第7章 問い合わせ">第7章</a>も参照してください）。
   </p></div><div class="sect2" id="SQL-EXPRESSIONS-PARAMETERS-POSITIONAL"><div class="titlepage"><div><div><h3 class="title">4.2.2. 位置パラメータ</h3></div></div></div><!--
   <title>Positional Parameters</title>
--><a id="id-1.5.3.6.10.2" class="indexterm"></a><a id="id-1.5.3.6.10.3" class="indexterm"></a><p>
<!--
    A positional parameter reference is used to indicate a value
    that is supplied externally to an SQL statement.  Parameters are
    used in SQL function definitions and in prepared queries.  Some
    client libraries also support specifying data values separately
    from the SQL command string, in which case parameters are used to
    refer to the out-of-line data values.
    The form of a parameter reference is:
-->
位置パラメータ参照は、外部からSQL文に渡される値を示すために使用されます。
パラメータはSQL関数定義およびプリペアド問い合わせの中で使用されます。
また、クライアントライブラリの中には、SQLコマンド文字列とデータ値を分離して指定できる機能をサポートするものもあります。
この場合、パラメータは行外データ値を参照するために使用されます。
パラメータ参照の形式は以下の通りです。
</p><pre class="synopsis">
$<em class="replaceable"><code>number</code></em>
</pre><p>
   </p><p>
<!--
    For example, consider the definition of a function,
    <function>dept</function>, as:
-->
例えば、関数 <code class="function">dept</code> の定義が以下のようにされたとします。

</p><pre class="programlisting">
CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;
</pre><p>

<!--
    Here the <literal>$1</literal> references the value of the first
    function argument whenever the function is invoked.
-->
ここで<code class="literal">$1</code>は関数が呼び出される時に最初の関数引数の値を参照します。
   </p></div><div class="sect2" id="SQL-EXPRESSIONS-SUBSCRIPTS"><div class="titlepage"><div><div><h3 class="title">4.2.3. 添字</h3></div></div></div><!--
   <title>Subscripts</title>
--><a id="id-1.5.3.6.11.2" class="indexterm"></a><p>
<!--
    If an expression yields a value of an array type, then a specific
    element of the array value can be extracted by writing
-->
式が配列型の値となる場合、配列値の特定要素は以下のように記述することで抽出できます。
</p><pre class="synopsis">
<em class="replaceable"><code>expression</code></em>[<em class="replaceable"><code>subscript</code></em>]
</pre><p>
<!--
    or multiple adjacent elements (an <quote>array slice</quote>) can be extracted
    by writing
-->
また、隣接する複数の要素（<span class="quote">「<span class="quote">配列の一部分</span>」</span>）は以下のように記述することで抽出できます。
</p><pre class="synopsis">
<em class="replaceable"><code>expression</code></em>[<em class="replaceable"><code>lower_subscript</code></em>:<em class="replaceable"><code>upper_subscript</code></em>]
</pre><p>
<!--
    (Here, the brackets <literal>[ ]</literal> are meant to appear literally.)
    Each <replaceable>subscript</replaceable> is itself an expression,
    which must yield an integer value.
-->
（ここで大括弧<code class="literal">[ ]</code>は文字通りに記述してください（訳注：これはオプション部分を表す大括弧ではありません）。）
各<em class="replaceable"><code>subscript</code></em>はそれ自体が式であり、整数値を生成しなければなりません。
   </p><p>
<!--
    In general the array <replaceable>expression</replaceable> must be
    parenthesized, but the parentheses can be omitted when the expression
    to be subscripted is just a column reference or positional parameter.
    Also, multiple subscripts can be concatenated when the original array
    is multidimensional.
    For example:
-->
一般的には、配列<em class="replaceable"><code>expression</code></em>は括弧で括らなければなりませんが、添字を付けるそのexpressionが単なる列参照や位置パラメータであった場合、その括弧を省略することができます。
また、元の配列が多次元の場合は複数の添字を連結することができます。
以下に例を示します。

</p><pre class="programlisting">
mytable.arraycolumn[4]
mytable.two_d_column[17][34]
$1[10:42]
(arrayfunction(a,b))[42]
</pre><p>

<!--
    The parentheses in the last example are required.
    See <xref linkend="arrays"/> for more about arrays.
-->
最後の例では括弧が必要です。
配列の詳細は<a class="xref" href="arrays.html" title="8.15. 配列">8.15</a>を参照してください。
   </p></div><div class="sect2" id="FIELD-SELECTION"><div class="titlepage"><div><div><h3 class="title">4.2.4. フィールド選択</h3></div></div></div><!--
   <title>Field Selection</title>
--><a id="id-1.5.3.6.12.2" class="indexterm"></a><p>
<!--
    If an expression yields a value of a composite type (row type), then a
    specific field of the row can be extracted by writing
-->
式が複合型（行型）の値を生成する場合、行の特定のフィールドは以下のように記述することで抽出できます。
</p><pre class="synopsis">
<em class="replaceable"><code>expression</code></em>.<em class="replaceable"><code>fieldname</code></em>
</pre><p>
   </p><p>
<!--
    In general the row <replaceable>expression</replaceable> must be
    parenthesized, but the parentheses can be omitted when the expression
    to be selected from is just a table reference or positional parameter.
    For example:
-->
一般的には、行<em class="replaceable"><code>expression</code></em>は括弧で括らなければなりません。
しかし、選択元となる式が単なるテーブル参照や位置パラメータの場合、括弧を省略することができます。
以下に例を示します。

</p><pre class="programlisting">
mytable.mycolumn
$1.somecolumn
(rowfunction(a,b)).col3
</pre><p>

<!--
    (Thus, a qualified column reference is actually just a special case
    of the field selection syntax.)  An important special case is
    extracting a field from a table column that is of a composite type:
-->
（したがって、修飾された列参照は実際のところ、単なるこのフィールド選択構文の特殊な場合です。）
重要となる特殊な場合としては、複合型のテーブル列からフィールドを抽出するときです。

</p><pre class="programlisting">
(compositecol).somefield
(mytable.compositecol).somefield
</pre><p>

<!--
    The parentheses are required here to show that
    <structfield>compositecol</structfield> is a column name not a table name,
    or that <structname>mytable</structname> is a table name not a schema name
    in the second case.
-->
<code class="structfield">compositecol</code>がテーブル名でなく列名であること、または２番目の場合の<code class="structname">mytable</code>がスキーマ名でなくテーブル名であることを示すため丸括弧が要求されます。
   </p><p>
<!--
    You can ask for all fields of a composite value by
    writing <literal>.*</literal>:
-->
<code class="literal">.*</code>を記述することで、複合型の全ての値を問い合わせることが可能です。
</p><pre class="programlisting">
(compositecol).*
</pre><p>
<!--
    This notation behaves differently depending on context;
    see <xref linkend="rowtypes-usage"/> for details.
-->
この表記はコンテキストに依存して異なった振る舞いをします。詳細は<a class="xref" href="rowtypes.html#ROWTYPES-USAGE" title="8.16.5. 問い合わせでの複合型の使用">8.16.5</a>を参照してください。
   </p></div><div class="sect2" id="SQL-EXPRESSIONS-OPERATOR-CALLS"><div class="titlepage"><div><div><h3 class="title">4.2.5. 演算子の呼び出し</h3></div></div></div><!--
   <title>Operator Invocations</title>
--><a id="id-1.5.3.6.13.2" class="indexterm"></a><p>
<!--
    There are three possible syntaxes for an operator invocation:
-->
演算子の呼び出しには以下の3構文が可能です。
    </p><table border="0" summary="Simple list" class="simplelist"><tr><td><em class="replaceable"><code>expression</code></em> <em class="replaceable"><code>operator</code></em> <em class="replaceable"><code>expression</code></em> （二項中置演算子）</td></tr><tr><td><em class="replaceable"><code>operator</code></em> <em class="replaceable"><code>expression</code></em> （単項前置演算子）</td></tr><tr><td><em class="replaceable"><code>expression</code></em> <em class="replaceable"><code>operator</code></em> （単項後置演算子）</td></tr></table><p>
<!--
    where the <replaceable>operator</replaceable> token follows the syntax
    rules of <xref linkend="sql-syntax-operators"/>, or is one of the
    key words <token>AND</token>, <token>OR</token>, and
    <token>NOT</token>, or is a qualified operator name in the form:
-->
ここで<em class="replaceable"><code>operator</code></em>トークンは、<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-OPERATORS" title="4.1.3. 演算子">4.1.3</a>構文規則に従うもの、もしくはキーワード<code class="token">AND</code>、<code class="token">OR</code>、<code class="token">NOT</code>のいずれか、または以下の形式の修飾された演算子名です。
</p><pre class="synopsis">
<code class="literal">OPERATOR(</code><em class="replaceable"><code>schema</code></em><code class="literal">.</code><em class="replaceable"><code>operatorname</code></em><code class="literal">)</code>
</pre><p>
<!--
    Which particular operators exist and whether
    they are unary or binary depends on what operators have been
    defined by the system or the user.  <xref linkend="functions"/>
    describes the built-in operators.
-->
具体的にどんな演算子が存在し、それが単項か二項かどうかは、システムやユーザによってどんな演算子が定義されたかに依存します。
<a class="xref" href="functions.html" title="第9章 関数と演算子">第9章</a>にて、組み込み演算子について説明します。
   </p></div><div class="sect2" id="SQL-EXPRESSIONS-FUNCTION-CALLS"><div class="titlepage"><div><div><h3 class="title">4.2.6. 関数呼び出し</h3></div></div></div><!--
   <title>Function Calls</title>
--><a id="id-1.5.3.6.14.2" class="indexterm"></a><p>
<!--
    The syntax for a function call is the name of a function
    (possibly qualified with a schema name), followed by its argument list
    enclosed in parentheses:
-->
関数呼び出しの構文は、関数名（スキーマ名で修飾されている場合があります）に続けてその引数を丸括弧で囲んで列挙したものです。

</p><pre class="synopsis">
<em class="replaceable"><code>function_name</code></em> ([<span class="optional"><em class="replaceable"><code>expression</code></em> [<span class="optional">, <em class="replaceable"><code>expression</code></em> ... </span>]</span>] )
</pre><p>
   </p><p>
<!--
    For example, the following computes the square root of 2:
-->
例えば、以下のものは2の平方根を計算します。
</p><pre class="programlisting">
sqrt(2)
</pre><p>
   </p><p>
<!--
    The list of built-in functions is in <xref linkend="functions"/>.
    Other functions can be added by the user.
-->
組み込み関数の一覧は<a class="xref" href="functions.html" title="第9章 関数と演算子">第9章</a>にあります。
他の関数はユーザが追加できます。
   </p><p>
<!--
    When issuing queries in a database where some users mistrust other users,
    observe security precautions from <xref linkend="typeconv-func"/> when
    writing function calls.
-->
あるユーザが他のユーザを信用しないデータベースで問い合わせを発行する場合には、関数呼び出しを書く時に<a class="xref" href="typeconv-func.html" title="10.3. 関数">10.3</a>のセキュリティの事前の対策を守ってください。
   </p><p>
<!--
    The arguments can optionally have names attached.
    See <xref linkend="sql-syntax-calling-funcs"/> for details.
-->
引数には名前を任意で付与することができます。詳細は<a class="xref" href="sql-syntax-calling-funcs.html" title="4.3. 関数呼び出し">4.3</a>を見て下さい。
   </p><div class="note"><h3 class="title">注記</h3><p>
<!--
     A function that takes a single argument of composite type can
     optionally be called using field-selection syntax, and conversely
     field selection can be written in functional style.  That is, the
     notations <literal>col(table)</literal> and <literal>table.col</literal> are
     interchangeable.  This behavior is not SQL-standard but is provided
     in <productname>PostgreSQL</productname> because it allows use of functions to
     emulate <quote>computed fields</quote>.  For more information see
     <xref linkend="rowtypes-usage"/>.
-->
複合型の単一引数をとる関数はフィールド選択の構文を使っても呼び出すことができます。
反対にフィールド選択を関数形式で記述することもできます。
つまり、<code class="literal">col(table)</code>や<code class="literal">table.col</code>のどちらを使っても良いということです。
この動作は標準SQLにはありませんが、<span class="productname">PostgreSQL</span>では、これにより<span class="quote">「<span class="quote">計算されたフィールド</span>」</span>のエミュレートをする関数の利用が可能になるため、提供しています。
詳しくは<a class="xref" href="rowtypes.html#ROWTYPES-USAGE" title="8.16.5. 問い合わせでの複合型の使用">8.16.5</a>を参照してください。
    </p></div></div><div class="sect2" id="SYNTAX-AGGREGATES"><div class="titlepage"><div><div><h3 class="title">4.2.7. 集約式</h3></div></div></div><!--
   <title>Aggregate Expressions</title>
--><a id="id-1.5.3.6.15.2" class="indexterm"></a><a id="id-1.5.3.6.15.3" class="indexterm"></a><a id="id-1.5.3.6.15.4" class="indexterm"></a><a id="id-1.5.3.6.15.5" class="indexterm"></a><p>
<!--
    An <firstterm>aggregate expression</firstterm> represents the
    application of an aggregate function across the rows selected by a
    query.  An aggregate function reduces multiple inputs to a single
    output value, such as the sum or average of the inputs.  The
    syntax of an aggregate expression is one of the following:
-->
<em class="firstterm">集約式</em>は、問い合わせによって選択される行に対して集約関数を適用することを表現します。
集約関数は、例えば入力の合計や平均などのように、複数の入力を単一の出力値にします。
集約式の構文は下記のうちのいずれかです。

</p><pre class="synopsis">
<em class="replaceable"><code>aggregate_name</code></em> (<em class="replaceable"><code>expression</code></em> [ , ... ] [ <em class="replaceable"><code>order_by_clause</code></em> ] ) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ]
<em class="replaceable"><code>aggregate_name</code></em> (ALL <em class="replaceable"><code>expression</code></em> [ , ... ] [ <em class="replaceable"><code>order_by_clause</code></em> ] ) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ]
<em class="replaceable"><code>aggregate_name</code></em> (DISTINCT <em class="replaceable"><code>expression</code></em> [ , ... ] [ <em class="replaceable"><code>order_by_clause</code></em> ] ) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ]
<em class="replaceable"><code>aggregate_name</code></em> ( * ) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ]
<em class="replaceable"><code>aggregate_name</code></em> ( [ <em class="replaceable"><code>expression</code></em> [ , ... ] ] ) WITHIN GROUP ( <em class="replaceable"><code>order_by_clause</code></em> ) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ]
</pre><p>

<!--
    where <replaceable>aggregate_name</replaceable> is a previously
    defined aggregate (possibly qualified with a schema name) and
    <replaceable>expression</replaceable> is
    any value expression that does not itself contain an aggregate
    expression or a window function call.  The optional
    <replaceable>order_by_clause</replaceable> and
    <replaceable>filter_clause</replaceable> are described below.
-->
ここで、<em class="replaceable"><code>aggregate_name</code></em>は事前に定義された集約（スキーマ名で修飾された場合もあります）、<em class="replaceable"><code>expression</code></em>はそれ自体に集約式またはウィンドウ関数呼び出しを含まない任意の値評価式です。
省略可能な<em class="replaceable"><code>order_by_clause</code></em>と<em class="replaceable"><code>filter_clause</code></em>は後述します。
   </p><p>
<!--
    The first form of aggregate expression invokes the aggregate
    once for each input row.
    The second form is the same as the first, since
    <literal>ALL</literal> is the default.
    The third form invokes the aggregate once for each distinct value
    of the expression (or distinct set of values, for multiple expressions)
    found in the input rows.
    The fourth form invokes the aggregate once for each input row; since no
    particular input value is specified, it is generally only useful
    for the <function>count(*)</function> aggregate function.
    The last form is used with <firstterm>ordered-set</firstterm> aggregate
    functions, which are described below.
-->
集約式の最初の構文は、それぞれの入力行に対して1回ずつ集計を呼び出します。
<code class="literal">ALL</code>はデフォルトなので、2つ目の形式は最初の形式と同じです。
3番目の形式は、入力行の中にある式の、全ての重複しない値（複数式では重複しない値集合）の集約を呼び出します。
4番目の形式はそれぞれの入力行に対して1回ずつ集約を呼び出します。具体的な入力値が指定されていないため、これは一般的に<code class="function">count(*)</code>集約関数でのみ役に立ちます。
最後の形式は<em class="firstterm">順序集合</em>集約関数で使われるもので、順序集合集約関数については後述します。
   </p><p>
<!--
    Most aggregate functions ignore null inputs, so that rows in which
    one or more of the expression(s) yield null are discarded.  This
    can be assumed to be true, unless otherwise specified, for all
    built-in aggregates.
-->
ほとんどの集約関数はNULL入力を無視するため、行内の1つ以上の式がNULLを返す行は破棄されます。
特記されていない限り、すべての組み込み集約がそのような動作になると想定して良いです。
   </p><p>
<!--
    For example, <literal>count(*)</literal> yields the total number
    of input rows; <literal>count(f1)</literal> yields the number of
    input rows in which <literal>f1</literal> is non-null, since
    <function>count</function> ignores nulls; and
    <literal>count(distinct f1)</literal> yields the number of
    distinct non-null values of <literal>f1</literal>.
-->
例えば、<code class="literal">count(*)</code>は入力行の合計数を求めます。
<code class="function">count</code>はNULLを無視しますので、<code class="literal">count(f1)</code>は<code class="literal">f1</code>が非NULLである入力行の数を求めます。
<code class="literal">count(distinct f1)</code>は<code class="literal">f1</code>の重複しない非NULL値の数を求めます。
   </p><p>
<!--
    Ordinarily, the input rows are fed to the aggregate function in an
    unspecified order.  In many cases this does not matter; for example,
    <function>min</function> produces the same result no matter what order it
    receives the inputs in.  However, some aggregate functions
    (such as <function>array_agg</function> and <function>string_agg</function>) produce
    results that depend on the ordering of the input rows.  When using
    such an aggregate, the optional <replaceable>order_by_clause</replaceable> can be
    used to specify the desired ordering.  The <replaceable>order_by_clause</replaceable>
    has the same syntax as for a query-level <literal>ORDER BY</literal> clause, as
    described in <xref linkend="queries-order"/>, except that its expressions
    are always just expressions and cannot be output-column names or numbers.
    For example:
-->
通常、入力行は順序を指定されずに集計関数に与えられます。
多くの場合では問題になりません。たとえば<code class="function">min</code>は入力順序に関係なく同一の結果を返します。
しかし一部の集約関数(<code class="function">array_agg</code>および<code class="function">string_agg</code>など)は入力行の順序に依存した結果を返します。
こうした集約関数を使用する際は、オプションの<em class="replaceable"><code>order_by_clause</code></em>を使用して必要とする順序を指定できます。
<em class="replaceable"><code>order_by_clause</code></em>は、<a class="xref" href="queries-order.html" title="7.5. 行の並べ替え">7.5</a>で説明する問い合わせレベルの<code class="literal">ORDER BY</code>句と同じ構文を取りますが、その式は常に単なる式であり、出力列名や序数とすることはできません。
以下に例を示します。
</p><pre class="programlisting">
SELECT array_agg(a ORDER BY b DESC) FROM table;
</pre><p>
   </p><p>
<!--
    When dealing with multiple-argument aggregate functions, note that the
    <literal>ORDER BY</literal> clause goes after all the aggregate arguments.
    For example, write this:
-->
複数の引数を取る集約関数を扱う場合、<code class="literal">ORDER BY</code>句はすべての集約引数の後に指定することに注意してください。
例えば、
</p><pre class="programlisting">
SELECT string_agg(a, ',' ORDER BY a) FROM table;
</pre><p>
<!--
    not this:
-->
であり、
</p><pre class="programlisting">
SELECT string_agg(a ORDER BY a, ',') FROM table;  -- incorrect
</pre><p>
ではありません。
<!--
    The latter is syntactically valid, but it represents a call of a
    single-argument aggregate function with two <literal>ORDER BY</literal> keys
    (the second one being rather useless since it's a constant).
-->
    後者は構文的には有効なものですが、2つの<code class="literal">ORDER BY</code>キーを持つ単一引数の集約関数の呼び出しを表しています。(2つ目のキーは定数なので役には立ちません。)
   </p><p>
<!--
    If <literal>DISTINCT</literal> is specified in addition to an
    <replaceable>order_by_clause</replaceable>, then all the <literal>ORDER BY</literal>
    expressions must match regular arguments of the aggregate; that is,
    you cannot sort on an expression that is not included in the
    <literal>DISTINCT</literal> list.
-->
<em class="replaceable"><code>order_by_clause</code></em>に加え<code class="literal">DISTINCT</code>が指定された場合、すべての<code class="literal">ORDER BY</code>式が集約関数の通常の引数に一致しなければなりません。つまり、<code class="literal">DISTINCT</code>リストに含まれない式でソートすることはできません。
   </p><div class="note"><h3 class="title">注記</h3><p>
<!--
     The ability to specify both <literal>DISTINCT</literal> and <literal>ORDER BY</literal>
     in an aggregate function is a <productname>PostgreSQL</productname> extension.
-->
集計関数において<code class="literal">DISTINCT</code>と<code class="literal">ORDER BY</code>の両方を指定できる機能はPostgreSQLの拡張です。
    </p></div><p>
<!--
    Placing <literal>ORDER BY</literal> within the aggregate's regular argument
    list, as described so far, is used when ordering the input rows for
    general-purpose and statistical aggregates, for which ordering is
    optional.  There is a
    subclass of aggregate functions called <firstterm>ordered-set
    aggregates</firstterm> for which an <replaceable>order_by_clause</replaceable>
    is <emphasis>required</emphasis>, usually because the aggregate's computation is
    only sensible in terms of a specific ordering of its input rows.
    Typical examples of ordered-set aggregates include rank and percentile
    calculations.  For an ordered-set aggregate,
    the <replaceable>order_by_clause</replaceable> is written
    inside <literal>WITHIN GROUP (...)</literal>, as shown in the final syntax
    alternative above.  The expressions in
    the <replaceable>order_by_clause</replaceable> are evaluated once per
    input row just like regular aggregate arguments, sorted as per
    the <replaceable>order_by_clause</replaceable>'s requirements, and fed
    to the aggregate function as input arguments.  (This is unlike the case
    for a non-<literal>WITHIN GROUP</literal> <replaceable>order_by_clause</replaceable>,
    which is not treated as argument(s) to the aggregate function.)  The
    argument expressions preceding <literal>WITHIN GROUP</literal>, if any, are
    called <firstterm>direct arguments</firstterm> to distinguish them from
    the <firstterm>aggregated arguments</firstterm> listed in
    the <replaceable>order_by_clause</replaceable>.  Unlike regular aggregate
    arguments, direct arguments are evaluated only once per aggregate call,
    not once per input row.  This means that they can contain variables only
    if those variables are grouped by <literal>GROUP BY</literal>; this restriction
    is the same as if the direct arguments were not inside an aggregate
    expression at all.  Direct arguments are typically used for things like
    percentile fractions, which only make sense as a single value per
    aggregation calculation.  The direct argument list can be empty; in this
    case, write just <literal>()</literal> not <literal>(*)</literal>.
    (<productname>PostgreSQL</productname> will actually accept either spelling, but
    only the first way conforms to the SQL standard.)
-->
上記のように集約の通常の引数リストに<code class="literal">ORDER BY</code>を置くことは、汎用的で統計的な集約への入力行を整列する時に使いますが、その整列は省略可能です。
たいていは集約の計算がその入力行の特定の順序に関してのみ意味を持つために、<em class="replaceable"><code>order_by_clause</code></em>が<span class="emphasis"><em>必要な</em></span><em class="firstterm">順序集合集約</em>と呼ばれる集約関数の副クラスがあります。
順序集合集約の典型的な例は順位や百分位数の計算を含みます。
順序集合集約では、<em class="replaceable"><code>order_by_clause</code></em>は上の構文の最後に示したように<code class="literal">WITHIN GROUP (...)</code>の中に書かれます。
<em class="replaceable"><code>order_by_clause</code></em>の式は、通常の集約の引数のように入力行1行につき一度評価され、<em class="replaceable"><code>order_by_clause</code></em>の要求に従って整列され、集約関数に入力引数として渡されます。
(非<code class="literal">WITHIN GROUP</code> <em class="replaceable"><code>order_by_clause</code></em>ではない場合はこれとは異なり、集約関数の引数としては扱われません。)
<code class="literal">WITHIN GROUP</code>の前に引数の式があれば、<em class="replaceable"><code>order_by_clause</code></em>に書かれた<em class="firstterm">集約引数</em>と区別するために<em class="firstterm">直接引数</em>と呼ばれます。
通常の集約引数とは異なり、直接引数は集約の呼び出しの時に一度だけ評価され、入力行1行に一度ではありません。
これは、変数が<code class="literal">GROUP BY</code>によりグループ化された場合にのみ、その変数を含むことが可能であることを意味します。この制限は直接引数が集約式の中に全くない場合と同じです。
直接引数は、典型的には1度の集約計算で1つの値だけが意味がある百分位数のようなもので使われます。
直接引数のリストは空でも構いません。この場合、<code class="literal">(*)</code>ではなく<code class="literal">()</code>と書いてください。
(<span class="productname">PostgreSQL</span>は実際にどちらの綴りも受け付けますが、後者だけが標準SQLに準拠しています。)
   </p><p>
    <a id="id-1.5.3.6.15.15.1" class="indexterm"></a>
<!--
    An example of an ordered-set aggregate call is:
-->
順序集合集約の例は以下の通りです。

</p><pre class="programlisting">
SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY income) FROM households;
 percentile_cont
-----------------
           50489
</pre><p>

<!--
   which obtains the 50th percentile, or median, value of
   the <structfield>income</structfield> column from table <structname>households</structname>.
   Here, <literal>0.5</literal> is a direct argument; it would make no sense
   for the percentile fraction to be a value varying across rows.
-->
これは、テーブル<code class="structname">households</code>から<code class="structfield">income</code>列の50番目の百分位数、すなわち中央値を得ます。
ここで<code class="literal">0.5</code>は直接引数です。百分位数が行毎に変化する値であったら意味がありません。
   </p><p>
<!--
    If <literal>FILTER</literal> is specified, then only the input
    rows for which the <replaceable>filter_clause</replaceable>
    evaluates to true are fed to the aggregate function; other rows
    are discarded.  For example:
-->
<code class="literal">FILTER</code>が指定されていれば、<em class="replaceable"><code>filter_clause</code></em>が真と評価した入力行のみがウィンドウ関数に渡されます。それ以外の行は破棄されます。
例えば、
</p><pre class="programlisting">
SELECT
    count(*) AS unfiltered,
    count(*) FILTER (WHERE i &lt; 5) AS filtered
FROM generate_series(1,10) AS s(i);
 unfiltered | filtered
------------+----------
         10 |        4
(1 row)
</pre><p>
   </p><p>
<!--
    The predefined aggregate functions are described in <xref
    linkend="functions-aggregate"/>.  Other aggregate functions can be added
    by the user.
-->
定義済みの集約関数は<a class="xref" href="functions-aggregate.html" title="9.20. 集約関数">9.20</a>で説明されています。
ユーザは他の集約関数を追加することができます。
   </p><p>
<!--
    An aggregate expression can only appear in the result list or
    <literal>HAVING</literal> clause of a <command>SELECT</command> command.
    It is forbidden in other clauses, such as <literal>WHERE</literal>,
    because those clauses are logically evaluated before the results
    of aggregates are formed.
-->
集約式は、<code class="command">SELECT</code>コマンドの結果リストもしくは<code class="literal">HAVING</code>句内でのみ記述することができます。
<code class="literal">WHERE</code>などの他の句では許されません。
これらの句は集計結果が形成される前に論理的に評価されるためです。
   </p><p>
<!--
    When an aggregate expression appears in a subquery (see
    <xref linkend="sql-syntax-scalar-subqueries"/> and
    <xref linkend="functions-subquery"/>), the aggregate is normally
    evaluated over the rows of the subquery.  But an exception occurs
    if the aggregate's arguments (and <replaceable>filter_clause</replaceable>
    if any) contain only outer-level variables:
    the aggregate then belongs to the nearest such outer level, and is
    evaluated over the rows of that query.  The aggregate expression
    as a whole is then an outer reference for the subquery it appears in,
    and acts as a constant over any one evaluation of that subquery.
    The restriction about
    appearing only in the result list or <literal>HAVING</literal> clause
    applies with respect to the query level that the aggregate belongs to.
-->
集約式が副問い合わせ（<a class="xref" href="sql-expressions.html#SQL-SYNTAX-SCALAR-SUBQUERIES" title="4.2.11. スカラ副問い合わせ">4.2.11</a>と<a class="xref" href="functions-subquery.html" title="9.22. 副問い合わせ式">9.22</a>を参照）内に現れた場合、通常、集約は副問い合わせの行全体に対して評価されます。
しかし、その集約の引数(と、もしあれば<em class="replaceable"><code>filter_clause</code></em>)が上位レベルの変数のみを持つ場合は例外です。
その場合、集約は最も近い外側のレベルに属し、その問い合わせの行全体に対して評価されます。
全体として、その集約式は、その後、その集約を含む副問い合わせでは外部参照となり、その副問い合わせにおける評価に対しては定数として動作します。
結果リストもしくは<code class="literal">HAVING</code>句にのみ現れるという制約は、その集約が属する問い合わせレベルに関連して適用されます。
   </p></div><div class="sect2" id="SYNTAX-WINDOW-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">4.2.8. ウィンドウ関数呼び出し</h3></div></div></div><!--
   <title>Window Function Calls</title>
--><a id="id-1.5.3.6.16.2" class="indexterm"></a><a id="id-1.5.3.6.16.3" class="indexterm"></a><p>
<!--
    A <firstterm>window function call</firstterm> represents the application
    of an aggregate-like function over some portion of the rows selected
    by a query.  Unlike non-window aggregate calls, this is not tied
    to grouping of the selected rows into a single output row &mdash; each
    row remains separate in the query output.  However the window function
    has access to all the rows that would be part of the current row's
    group according to the grouping specification (<literal>PARTITION BY</literal>
    list) of the window function call.
    The syntax of a window function call is one of the following:
-->
<em class="firstterm">ウィンドウ関数呼び出し</em>は、問い合わせにより選択された行のある部分に渡って集約のような機能を実現することを表します。
非ウィンドウ集約関数呼び出しと異なり、これは選択された行を1つの行にグループ化することに束縛されず、各行は別途問い合わせ出力に残ります。
しかしウィンドウ関数は、ウィンドウ関数呼び出しのグループ化指定（<code class="literal">PARTITION BY</code>リスト）に従った、現在の行のグループの一部となる行にすべてアクセスできます。
ウィンドウ関数呼び出しの構文は以下のいずれかです。

</p><pre class="synopsis">
<em class="replaceable"><code>function_name</code></em> ([<span class="optional"><em class="replaceable"><code>expression</code></em> [<span class="optional">, <em class="replaceable"><code>expression</code></em> ... </span>]</span>]) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ] OVER <em class="replaceable"><code>window_name</code></em>
<em class="replaceable"><code>function_name</code></em> ([<span class="optional"><em class="replaceable"><code>expression</code></em> [<span class="optional">, <em class="replaceable"><code>expression</code></em> ... </span>]</span>]) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ] OVER ( <em class="replaceable"><code>window_definition</code></em> )
<em class="replaceable"><code>function_name</code></em> ( * ) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ] OVER <em class="replaceable"><code>window_name</code></em>
<em class="replaceable"><code>function_name</code></em> ( * ) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ] OVER ( <em class="replaceable"><code>window_definition</code></em> )
</pre><p>
<!--
    where <replaceable class="parameter">window_definition</replaceable>
    has the syntax
-->
ここで、<em class="replaceable"><code>window_definition</code></em>は以下の構文になります。
</p><pre class="synopsis">
[ <em class="replaceable"><code>existing_window_name</code></em> ]
[ PARTITION BY <em class="replaceable"><code>expression</code></em> [, ...] ]
[ ORDER BY <em class="replaceable"><code>expression</code></em> [ ASC | DESC | USING <em class="replaceable"><code>operator</code></em> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <em class="replaceable"><code>frame_clause</code></em> ]
</pre><p>
<!--
    The optional <replaceable class="parameter">frame_clause</replaceable>
    can be one of
-->
オプションの<em class="replaceable"><code>frame_clause</code></em>は次の中の１つです。
</p><pre class="synopsis">
{ RANGE | ROWS | GROUPS } <em class="replaceable"><code>frame_start</code></em> [ <em class="replaceable"><code>frame_exclusion</code></em> ]
{ RANGE | ROWS | GROUPS } BETWEEN <em class="replaceable"><code>frame_start</code></em> AND <em class="replaceable"><code>frame_end</code></em> [ <em class="replaceable"><code>frame_exclusion</code></em> ]
</pre><p>
<!--
    where <replaceable>frame_start</replaceable>
    and <replaceable>frame_end</replaceable> can be one of
-->
ここで<em class="replaceable"><code>frame_start</code></em>および<em class="replaceable"><code>frame_end</code></em>は以下のいずれかです。
</p><pre class="synopsis">
UNBOUNDED PRECEDING
<em class="replaceable"><code>offset</code></em> PRECEDING
CURRENT ROW
<em class="replaceable"><code>offset</code></em> FOLLOWING
UNBOUNDED FOLLOWING
</pre><p>
<!--
    and <replaceable>frame_exclusion</replaceable> can be one of
-->
そして、<em class="replaceable"><code>frame_exclusion</code></em>は以下のいずれかです。
</p><pre class="synopsis">
EXCLUDE CURRENT ROW
EXCLUDE GROUP
EXCLUDE TIES
EXCLUDE NO OTHERS
</pre><p>
   </p><p>
<!--
    Here, <replaceable>expression</replaceable> represents any value
    expression that does not itself contain window function calls.
-->
ここで、<em class="replaceable"><code>expression</code></em>はそれ自身ウィンドウ関数呼び出しを含まない任意の値式を表わします。
   </p><p>
<!--
    <replaceable>window_name</replaceable> is a reference to a named window
    specification defined in the query's <literal>WINDOW</literal> clause.
    Alternatively, a full <replaceable>window_definition</replaceable> can
    be given within parentheses, using the same syntax as for defining a
    named window in the <literal>WINDOW</literal> clause; see the
    <xref linkend="sql-select"/> reference page for details.  It's worth
    pointing out that <literal>OVER wname</literal> is not exactly equivalent to
    <literal>OVER (wname ...)</literal>; the latter implies copying and modifying the
    window definition, and will be rejected if the referenced window
    specification includes a frame clause.
-->
<em class="replaceable"><code>window_name</code></em>は、問い合わせの<code class="literal">WINDOW</code>句で定義された名前付きウィンドウ仕様への参照です。
あるいはまた、完全な<em class="replaceable"><code>window_definition</code></em>を<code class="literal">WINDOW</code>句で定義された名前付きウィンドウと同じ構文を使って丸括弧の中に書くことができます。
詳細は<a class="xref" href="sql-select.html" title="SELECT"><span class="refentrytitle">SELECT</span></a>マニュアルページを見てください。
<code class="literal">OVER wname</code>は<code class="literal">OVER (wname ...)</code>とは厳密には等価ではないことを指摘しておくのは価値のあることでしょう。
後者はウィンドウ定義をコピーしたり修正したりすることを示唆しており、参照されるウィンドウ仕様がフレーム句を含む場合には拒絶されます。
   </p><p>
<!--
    The <literal>PARTITION BY</literal> clause groups the rows of the query into
    <firstterm>partitions</firstterm>, which are processed separately by the window
    function.  <literal>PARTITION BY</literal> works similarly to a query-level
    <literal>GROUP BY</literal> clause, except that its expressions are always just
    expressions and cannot be output-column names or numbers.
    Without <literal>PARTITION BY</literal>, all rows produced by the query are
    treated as a single partition.
    The <literal>ORDER BY</literal> clause determines the order in which the rows
    of a partition are processed by the window function.  It works similarly
    to a query-level <literal>ORDER BY</literal> clause, but likewise cannot use
    output-column names or numbers.  Without <literal>ORDER BY</literal>, rows are
    processed in an unspecified order.
-->
<code class="literal">PARTITION BY</code>句は問い合わせの行を<em class="firstterm">パーティション</em>に纏め、パーティションはウィンドウ関数により別々に処理されます。
<code class="literal">PARTITION BY</code>は、その式が常に式であって出力列名や番号ではないという点を除いて、問い合わせレベルの<code class="literal">GROUP BY</code>句と同様に動作します。
<code class="literal">PARTITION BY</code>がなければ、問い合わせで生じる行すべてが一つのパーティションとして扱われます。
<code class="literal">ORDER BY</code>句はパーティションの行がウィンドウ関数により処理される順序を決定します。
問い合わせレベルの<code class="literal">ORDER BY</code>句と同様に動作しますが、やはり出力列名や番号は使えません。
<code class="literal">ORDER BY</code>がなければ、行は不定の順序で処理されます。
   </p><p>
<!--
    The <replaceable class="parameter">frame_clause</replaceable> specifies
    the set of rows constituting the <firstterm>window frame</firstterm>, which is a
    subset of the current partition, for those window functions that act on
    the frame instead of the whole partition.  The set of rows in the frame
    can vary depending on which row is the current row.  The frame can be
    specified in <literal>RANGE</literal>, <literal>ROWS</literal>
    or <literal>GROUPS</literal> mode; in each case, it runs from
    the <replaceable>frame_start</replaceable> to
    the <replaceable>frame_end</replaceable>.
    If <replaceable>frame_end</replaceable> is omitted, the end defaults
    to <literal>CURRENT ROW</literal>.
-->
<em class="replaceable"><code>frame_clause</code></em>は、パーティション全体ではなくフレーム上で作動するウィンドウ関数に対して、<em class="firstterm">ウィンドウフレーム</em>を構成する行の集合を指定します。
ウィンドウフレームは現在のパーティションの部分集合になります。
フレームの中の行の集合は、どの行が現在の行であるかによって変わります。
フレームは<code class="literal">RANGE</code>モードでも<code class="literal">ROWS</code>モードでも指定できます。
どちらの場合でも<em class="replaceable"><code>frame_start</code></em>から<em class="replaceable"><code>frame_end</code></em>までです。
<em class="replaceable"><code>frame_end</code></em>を省略した場合のデフォルトは<code class="literal">CURRENT ROW</code>です。
   </p><p>
<!--
    A <replaceable>frame_start</replaceable> of <literal>UNBOUNDED PRECEDING</literal> means
    that the frame starts with the first row of the partition, and similarly
    a <replaceable>frame_end</replaceable> of <literal>UNBOUNDED FOLLOWING</literal> means
    that the frame ends with the last row of the partition.
-->
<em class="replaceable"><code>frame_start</code></em>が<code class="literal">UNBOUNDED PRECEDING</code>ならばフレームがパーティションの最初の行から始まること意味し、同様に、<em class="replaceable"><code>frame_end</code></em>が<code class="literal">UNBOUNDED FOLLOWING</code>ならばフレームがパーティションの最後の行で終わること意味します。
   </p><p>
<!--
    In <literal>RANGE</literal> or <literal>GROUPS</literal> mode,
    a <replaceable>frame_start</replaceable> of
    <literal>CURRENT ROW</literal> means the frame starts with the current
    row's first <firstterm>peer</firstterm> row (a row that the
    window's <literal>ORDER BY</literal> clause sorts as equivalent to the
    current row), while a <replaceable>frame_end</replaceable> of
    <literal>CURRENT ROW</literal> means the frame ends with the current
    row's last peer row.
    In <literal>ROWS</literal> mode, <literal>CURRENT ROW</literal> simply
    means the current row.
-->
<code class="literal">RANGE</code>あるいは<code class="literal">GROUPS</code>モードでは、<em class="replaceable"><code>frame_start</code></em>が<code class="literal">CURRENT ROW</code>ならば、フレームが現在行の最初の<em class="firstterm">ピア</em>行（ウィンドウの<code class="literal">ORDER BY</code>句が現在行と同じ順序とみなす行）から始まることを意味し、一方、<em class="replaceable"><code>frame_end</code></em>が<code class="literal">CURRENT ROW</code>ならばフレームが現在行の最後の同等な<code class="literal">ORDER BY</code>ピア行で終わることを意味します。
<code class="literal">ROWS</code>モードでは、<code class="literal">CURRENT ROW</code>は単に現在行を意味します。
   </p><p>
<!--
    In the <replaceable>offset</replaceable> <literal>PRECEDING</literal>
    and <replaceable>offset</replaceable> <literal>FOLLOWING</literal> frame
    options, the <replaceable>offset</replaceable> must be an expression not
    containing any variables, aggregate functions, or window functions.
    The meaning of the <replaceable>offset</replaceable> depends on the
    frame mode:
-->
<em class="replaceable"><code>offset</code></em> <code class="literal">PRECEDING</code>と<em class="replaceable"><code>offset</code></em> <code class="literal">FOLLOWING</code>フレームオプションでは、<em class="replaceable"><code>offset</code></em>は一切の変数、集計関数、あるいはウィンドウ関数を含まない式でなければなりません。
<em class="replaceable"><code>offset</code></em>の意味はフレームモードに依存します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<!--
       In <literal>ROWS</literal> mode,
       the <replaceable>offset</replaceable> must yield a non-null,
       non-negative integer, and the option means that the frame starts or
       ends the specified number of rows before or after the current row.
-->
<code class="literal">ROWS</code>モードでは、<em class="replaceable"><code>offset</code></em>の評価値は非NULL、非負の整数でなければならず、このオプションは現在行の前あるいは後の指定した数の行でフレームが開始あるいは終了することを意味します。
      </p></li><li class="listitem"><p>
<!--
       In <literal>GROUPS</literal> mode,
       the <replaceable>offset</replaceable> again must yield a non-null,
       non-negative integer, and the option means that the frame starts or
       ends the specified number of <firstterm>peer groups</firstterm>
       before or after the current row's peer group, where a peer group is a
       set of rows that are equivalent in the <literal>ORDER BY</literal>
       ordering.  (There must be an <literal>ORDER BY</literal> clause
       in the window definition to use <literal>GROUPS</literal> mode.)
-->
<code class="literal">GROUPS</code>モードでも、<em class="replaceable"><code>offset</code></em>の評価値は非NULL、非負の整数でなければならず、このオプションは現在行のピアグループ(peer group)の前あるいは後の指定した数の<em class="firstterm">ピアグループ</em>でフレームが開始あるいは終了することを意味します。
ここでピアグループは、<code class="literal">ORDER BY</code>による順序付け中で等しい行の集合です。
（ウィンドウ定義で<code class="literal">GROUPS</code>モードを使うには、<code class="literal">ORDER BY</code>句が存在しなければなりません。）
      </p></li><li class="listitem"><p>
<!--
       In <literal>RANGE</literal> mode, these options require that
       the <literal>ORDER BY</literal> clause specify exactly one column.
       The <replaceable>offset</replaceable> specifies the maximum
       difference between the value of that column in the current row and
       its value in preceding or following rows of the frame.  The data type
       of the <replaceable>offset</replaceable> expression varies depending
       on the data type of the ordering column.  For numeric ordering
       columns it is typically of the same type as the ordering column,
       but for datetime ordering columns it is an <type>interval</type>.
       For example, if the ordering column is of type <type>date</type>
       or <type>timestamp</type>, one could write <literal>RANGE BETWEEN
       '1 day' PRECEDING AND '10 days' FOLLOWING</literal>.
       The <replaceable>offset</replaceable> is still required to be
       non-null and non-negative, though the meaning
       of <quote>non-negative</quote> depends on its data type.
-->
<code class="literal">RANGE</code>モードでは、<code class="literal">ORDER BY</code>句が正確に一つの列を指定することがこれらのオプションによって要求されます。
<em class="replaceable"><code>offset</code></em>は現在行の列の値と、フレーム中の前あるいは後ろの行の値の最大の差を指定します。
<em class="replaceable"><code>offset</code></em>式のデータ型は、順序付けをしている列のデータ型に依存して変わります。
数値型の順序付け列では、典型的には順序付け列と同じですが、日付時間の順序付け列では、<code class="type">interval</code>になります。
たとえば、順序付け列の型が<code class="type">date</code>あるいは<code class="type">timestamp</code>なら、<code class="literal">RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING</code>と書くことができるでしょう。
ここでも<em class="replaceable"><code>offset</code></em>は非NULLかつ非負である必要があります。
ただし、<span class="quote">「<span class="quote">非負</span>」</span>の意味はデータ型に依存します。
      </p></li></ul></div><p>
<!--
    In any case, the distance to the end of the frame is limited by the
    distance to the end of the partition, so that for rows near the partition
    ends the frame might contain fewer rows than elsewhere.
-->
どの場合でも、フレームの最後までの距離はパーティションの最後までの距離に制限されます。
ですからパーティションの最後近くの行では他の場合に比べてフレームには少ない行が含まれるかも知れません。
   </p><p>
<!--
    Notice that in both <literal>ROWS</literal> and <literal>GROUPS</literal>
    mode, <literal>0 PRECEDING</literal> and <literal>0 FOLLOWING</literal>
    are equivalent to <literal>CURRENT ROW</literal>.  This normally holds
    in <literal>RANGE</literal> mode as well, for an appropriate
    data-type-specific meaning of <quote>zero</quote>.
-->
<code class="literal">ROWS</code>と<code class="literal">GROUPS</code>モードでは、<code class="literal">0 PRECEDING</code>と<code class="literal">0 FOLLOWING</code>は<code class="literal">CURRENT ROW</code>と同じであることに注意してください。
データ型固有の意味で<span class="quote">「<span class="quote">0</span>」</span>が適切ならば、通常<code class="literal">RANGE</code>においても同様です。
   </p><p>
<!--
    The <replaceable>frame_exclusion</replaceable> option allows rows around
    the current row to be excluded from the frame, even if they would be
    included according to the frame start and frame end options.
    <literal>EXCLUDE CURRENT ROW</literal> excludes the current row from the
    frame.
    <literal>EXCLUDE GROUP</literal> excludes the current row and its
    ordering peers from the frame.
    <literal>EXCLUDE TIES</literal> excludes any peers of the current
    row from the frame, but not the current row itself.
    <literal>EXCLUDE NO OTHERS</literal> simply specifies explicitly the
    default behavior of not excluding the current row or its peers.
-->
フレームの開始、終了オプションで含まれることになる行であっても、<em class="replaceable"><code>frame_exclusion</code></em>オプションで現在行周辺の行がフレームに含まれないようにすることができます。
<code class="literal">EXCLUDE GROUP</code>は、現在行とその順序付ピアをフレームから除外します。
<code class="literal">EXCLUDE TIES</code>は、現在行そのものを除き、フレームにおける現在行のピアをフレームから除外します。
<code class="literal">EXCLUDE NO OTHERS</code>は、現在の行あるいはそのピアを除外しないというデフォルトの挙動を明示的に指定するだけです。
   </p><p>
<!--
    The default framing option is <literal>RANGE UNBOUNDED PRECEDING</literal>,
    which is the same as <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND
    CURRENT ROW</literal>.  With <literal>ORDER BY</literal>, this sets the frame to be
    all rows from the partition start up through the current row's last
    <literal>ORDER BY</literal> peer.  Without <literal>ORDER BY</literal>,
    this means all rows of the partition are included in the window frame,
    since all rows become peers of the current row.
-->
デフォルトのフレーム化オプションは<code class="literal">RANGE UNBOUNDED PRECEDING</code>で、<code class="literal">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>と同じです。
<code class="literal">ORDER BY</code>があると、フレームはパーティションの開始から現在行の最後の<code class="literal">ORDER BY</code>ピア行までのすべての行になります。
<code class="literal">ORDER BY</code>が無い場合は、すべての行が現在行のピアとなるので、パーティションのすべての行がウィンドウフレームに含まれることを意味することになります。
   </p><p>
<!--
    Restrictions are that
    <replaceable>frame_start</replaceable> cannot be <literal>UNBOUNDED FOLLOWING</literal>,
    <replaceable>frame_end</replaceable> cannot be <literal>UNBOUNDED PRECEDING</literal>,
    and the <replaceable>frame_end</replaceable> choice cannot appear earlier in the
    above list of <replaceable>frame_start</replaceable>
    and <replaceable>frame_end</replaceable> options than
    the <replaceable>frame_start</replaceable> choice does &mdash; for example
    <literal>RANGE BETWEEN CURRENT ROW AND <replaceable>offset</replaceable>
    PRECEDING</literal> is not allowed.
    But, for example, <literal>ROWS BETWEEN 7 PRECEDING AND 8
    PRECEDING</literal> is allowed, even though it would never select any
    rows.
-->
制限は、<em class="replaceable"><code>frame_start</code></em>を<code class="literal">UNBOUNDED FOLLOWING</code>とすることができない点、<em class="replaceable"><code>frame_end</code></em>を<code class="literal">UNBOUNDED PRECEDING</code>とすることができない点、および、上記の<em class="replaceable"><code>frame_start</code></em>と<em class="replaceable"><code>frame_end</code></em>のオプションのリストで、<em class="replaceable"><code>frame_end</code></em>の選択が<em class="replaceable"><code>frame_start</code></em>の選択よりも先に現れるものであってはならない点です。
例えば、<code class="literal">RANGE BETWEEN CURRENT ROW AND <em class="replaceable"><code>offset</code></em> PRECEDING</code>は許されません。
しかし、例えば、決してどの行も選択しないとしても、<code class="literal">ROWS BETWEEN 7 PRECEDING AND 8 PRECEDING</code>は許されます。
   </p><p>
<!--
    If <literal>FILTER</literal> is specified, then only the input
    rows for which the <replaceable>filter_clause</replaceable>
    evaluates to true are fed to the window function; other rows
    are discarded.  Only window functions that are aggregates accept
    a <literal>FILTER</literal> clause.
-->
<code class="literal">FILTER</code>が指定されていれば、<em class="replaceable"><code>filter_clause</code></em>が真と評価した入力行のみがウィンドウ関数に渡されます。それ以外の行は破棄されます。
集約ウィンドウ関数だけが<code class="literal">FILTER</code>句を受け付けます。
   </p><p>
<!--
    The built-in window functions are described in <xref
    linkend="functions-window-table"/>.  Other window functions can be added by
    the user.  Also, any built-in or user-defined general-purpose or
    statistical aggregate can be used as a window function.  (Ordered-set
    and hypothetical-set aggregates cannot presently be used as window functions.)
-->
組み込みウィンドウ関数は<a class="xref" href="functions-window.html#FUNCTIONS-WINDOW-TABLE" title="表9.57 汎用ウィンドウ関数">表 9.57</a>に記載されています。その他のウィンドウ関数をユーザが追加することが可能です。
また、全ての組み込み、またはユーザ定義の、汎用または統計集約関数もウィンドウ関数として使用できます。
(順序集合と仮想集合集約は現在のところウィンドウ関数として使用できません。)
   </p><p>
<!--
    The syntaxes using <literal>*</literal> are used for calling parameter-less
    aggregate functions as window functions, for example
    <literal>count(*) OVER (PARTITION BY x ORDER BY y)</literal>.
    The asterisk (<literal>*</literal>) is customarily not used for
    window-specific functions.  Window-specific functions do not
    allow <literal>DISTINCT</literal> or <literal>ORDER BY</literal> to be used within the
    function argument list.
-->
<code class="literal">*</code>を使用した構文は、例えば<code class="literal">count(*) OVER (PARTITION BY x ORDER BY y)</code>のように、パラメータのない集約関数をウィンドウ関数として呼び出すために使用されます。
アスタリスク(<code class="literal">*</code>)は習慣的にウィンドウ固有の関数には使われません。
ウィンドウ固有の関数は、関数引数リストの中で<code class="literal">DISTINCT</code>や<code class="literal">ORDER BY</code>が使われることを許可しません。
   </p><p>
<!--
    Window function calls are permitted only in the <literal>SELECT</literal>
    list and the <literal>ORDER BY</literal> clause of the query.
-->
ウィンドウ関数呼び出しは問い合わせの<code class="literal">SELECT</code>リストと<code class="literal">ORDER BY</code>句の中でのみ許可されます。
   </p><p>
<!--
    More information about window functions can be found in
    <xref linkend="tutorial-window"/>,
    <xref linkend="functions-window"/>, and
    <xref linkend="queries-window"/>.
-->
更なるウィンドウ関数についての情報は<a class="xref" href="tutorial-window.html" title="3.5. ウィンドウ関数">3.5</a>、<a class="xref" href="functions-window.html" title="9.21. ウィンドウ関数">9.21</a>、<a class="xref" href="queries-table-expressions.html#QUERIES-WINDOW" title="7.2.5. ウィンドウ関数処理">7.2.5</a>にあります。
   </p></div><div class="sect2" id="SQL-SYNTAX-TYPE-CASTS"><div class="titlepage"><div><div><h3 class="title">4.2.9. 型キャスト</h3></div></div></div><!--
   <title>Type Casts</title>
--><a id="id-1.5.3.6.17.2" class="indexterm"></a><a id="id-1.5.3.6.17.3" class="indexterm"></a><a id="id-1.5.3.6.17.4" class="indexterm"></a><p>
<!--
    A type cast specifies a conversion from one data type to another.
    <productname>PostgreSQL</productname> accepts two equivalent syntaxes
    for type casts:
-->
型キャストは、あるデータ型から他のデータ型への変換を指定します。
<span class="productname">PostgreSQL</span>は型キャストに2つの等価な構文を受け付けます。
</p><pre class="synopsis">
CAST ( <em class="replaceable"><code>expression</code></em> AS <em class="replaceable"><code>type</code></em> )
<em class="replaceable"><code>expression</code></em>::<em class="replaceable"><code>type</code></em>
</pre><p>
<!--
    The <literal>CAST</literal> syntax conforms to SQL; the syntax with
    <literal>::</literal> is historical <productname>PostgreSQL</productname>
    usage.
-->
<code class="literal">CAST</code>構文はSQLに準拠したものです。
<code class="literal">::</code>を使用する構文は、<span class="productname">PostgreSQL</span>で伝統的に使用されている方法です。
   </p><p>
<!--
    When a cast is applied to a value expression of a known type, it
    represents a run-time type conversion.  The cast will succeed only
    if a suitable type conversion operation has been defined.  Notice that this
    is subtly different from the use of casts with constants, as shown in
    <xref linkend="sql-syntax-constants-generic"/>.  A cast applied to an
    unadorned string literal represents the initial assignment of a type
    to a literal constant value, and so it will succeed for any type
    (if the contents of the string literal are acceptable input syntax for the
    data type).
-->
キャストが既知の型の評価式に適用された場合、それは実行時型変換を表します。
このキャストは、適切な型変換操作が定義されている場合のみ成功します。
<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS-GENERIC" title="4.1.2.7. 他の型の定数">4.1.2.7</a>で示すように、これと定数のキャストの使用との微妙な違いに注意してください。
修飾されていない文字列リテラルに対するキャストは、リテラル定数値の初期に割り当てられる型を表します。
ですから、これは（文字列リテラル定数の内容がそのデータ型の入力構文で受け付けられるのであれば）全ての型で成功します。
   </p><p>
<!--
    An explicit type cast can usually be omitted if there is no ambiguity as
    to the type that a value expression must produce (for example, when it is
    assigned to a table column); the system will automatically apply a
    type cast in such cases.  However, automatic casting is only done for
    casts that are marked <quote>OK to apply implicitly</quote>
    in the system catalogs.  Other casts must be invoked with
    explicit casting syntax.  This restriction is intended to prevent
    surprising conversions from being applied silently.
-->
評価式が生成しなければならない型に曖昧さがない場合（例えばテーブル列への代入時など）、明示的な型キャストは通常は省略することができます。
その場合、システムは自動的に型キャストを適用します。
しかし、自動キャストは、システムカタログに<span class="quote">「<span class="quote">暗黙的に適用しても問題なし</span>」</span>と示されている場合にのみ実行されます。
その他のキャストは明示的なキャスト構文で呼び出す必要があります。
この制限は、知らないうちに変換が実行されてしまうことを防ぐためのものです。
   </p><p>
<!--
    It is also possible to specify a type cast using a function-like
    syntax:
-->
また、関数のような構文を使用して型キャストを指定することもできます。
</p><pre class="synopsis">
<em class="replaceable"><code>typename</code></em> ( <em class="replaceable"><code>expression</code></em> )
</pre><p>
<!--
    However, this only works for types whose names are also valid as
    function names.  For example, <literal>double precision</literal>
    cannot be used this way, but the equivalent <literal>float8</literal>
    can.  Also, the names <literal>interval</literal>, <literal>time</literal>, and
    <literal>timestamp</literal> can only be used in this fashion if they are
    double-quoted, because of syntactic conflicts.  Therefore, the use of
    the function-like cast syntax leads to inconsistencies and should
    probably be avoided.
-->
しかし、これはその型の名前が関数の名前としても有効な場合にのみ動作します。
例えば、<code class="literal">double precision</code> はこの方式で使用できませんが、同等の<code class="literal">float8</code>は使用できます。
また、<code class="literal">interval</code>、<code class="literal">time</code>、<code class="literal">timestamp</code>という名前は、構文が衝突するため、二重引用符で括った場合にのみこの方式で使用できます。
このように、この関数のようなキャスト構文は一貫性がなくなりがちですので、おそらくアプリケーションでは使用すべきではありません。
   </p><div class="note"><h3 class="title">注記</h3><p>
<!--
     The function-like syntax is in fact just a function call.  When
     one of the two standard cast syntaxes is used to do a run-time
     conversion, it will internally invoke a registered function to
     perform the conversion.  By convention, these conversion functions
     have the same name as their output type, and thus the <quote>function-like
     syntax</quote> is nothing more than a direct invocation of the underlying
     conversion function.  Obviously, this is not something that a portable
     application should rely on.  For further details see
     <xref linkend="sql-createcast"/>.
-->
この関数のような構文は、実際には単なる関数呼び出しです。
2つの標準的なキャスト構文のうちの1つが実行時変換で使用されると、この構文は登録済みの関数を内部的に呼び出して変換を実行します。
慣習的に、これらの変換関数は自身の出力型と同じ名前を持ち、これにより、<span class="quote">「<span class="quote">関数のような構文</span>」</span>は背後にある変換用関数を直接呼び出す以上のことを行いません。
移植性を持つアプリケーションが依存すべきものでないことは明確です。
詳細については<a class="xref" href="sql-createcast.html" title="CREATE CAST"><span class="refentrytitle">CREATE CAST</span></a>を参照してください。
    </p></div></div><div class="sect2" id="SQL-SYNTAX-COLLATE-EXPRS"><div class="titlepage"><div><div><h3 class="title">4.2.10. 照合順序式</h3></div></div></div><!--
   <title>Collation Expressions</title>
--><a id="id-1.5.3.6.18.2" class="indexterm"></a><p>
<!--
    The <literal>COLLATE</literal> clause overrides the collation of
    an expression.  It is appended to the expression it applies to:
-->
<code class="literal">COLLATE</code>句は式の照合順序規則を上書きします。
適用するため次の様に式の後に追記します。
</p><pre class="synopsis">
<em class="replaceable"><code>expr</code></em> COLLATE <em class="replaceable"><code>collation</code></em>
</pre><p>
<!--
    where <replaceable>collation</replaceable> is a possibly
    schema-qualified identifier.  The <literal>COLLATE</literal>
    clause binds tighter than operators; parentheses can be used when
    necessary.
-->
ここで<em class="replaceable"><code>collation</code></em>は識別子で、スキーマ修飾可能です。
<code class="literal">COLLATE</code>句は演算子よりも結合優先度が高いです。
必要に応じて括弧で囲うことができます。
   </p><p>
<!--
    If no collation is explicitly specified, the database system
    either derives a collation from the columns involved in the
    expression, or it defaults to the default collation of the
    database if no column is involved in the expression.
-->
もし照合順序が何も指定されなければ、データベースシステムは式にある列から照合順序を取得します。もし列に関する照合順序が式になければ、データベースのデフォルトの照合順序を使います。
   </p><p>
<!--
    The two common uses of the <literal>COLLATE</literal> clause are
    overriding the sort order in an <literal>ORDER BY</literal> clause, for
    example:
-->
<code class="literal">COLLATE</code>句の主な使われ方が２つあります。
１つは<code class="literal">ORDER BY</code>句での並び替え順序を上書きをするもので、例えば次のようにします。
</p><pre class="programlisting">
SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE "C";
</pre><p>
<!--
    and overriding the collation of a function or operator call that
    has locale-sensitive results, for example:
-->
もう一つは、計算結果がロケールに依存する関数や演算子の呼び出しについて、照合順序を上書きするもので、例えば次のようにします。
</p><pre class="programlisting">
SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE "C";
</pre><p>
<!--
    Note that in the latter case the <literal>COLLATE</literal> clause is
    attached to an input argument of the operator we wish to affect.
    It doesn't matter which argument of the operator or function call the
    <literal>COLLATE</literal> clause is attached to, because the collation that is
    applied by the operator or function is derived by considering all
    arguments, and an explicit <literal>COLLATE</literal> clause will override the
    collations of all other arguments.  (Attaching non-matching
    <literal>COLLATE</literal> clauses to more than one argument, however, is an
    error.  For more details see <xref linkend="collation"/>.)
    Thus, this gives the same result as the previous example:
-->
とします。後者の場合、<code class="literal">COLLATE</code>句が、処理対象と想定している入力演算子の引数に対して付与されることに注意してください。演算子や関数の呼び出しのどの引数に対して<code class="literal">COLLATE</code>句が付与されるかは問題ではありません。演算子や関数により適用される照合順序は対象となる全ての引数を考慮して引き出され、そして明示的に指定された<code class="literal">COLLATE</code>句がその他の全ての引数に対しての照合順序を上書きするからです。(しかし、複数の引数に対して一致しない<code class="literal">COLLATE</code>句の付与はエラーとなります。詳細は<a class="xref" href="collation.html" title="23.2. 照合順序サポート">23.2</a>を参照してください)。このため、前述の例と同じ結果を次の様にして取得することができます。
</p><pre class="programlisting">
SELECT * FROM tbl WHERE a COLLATE "C" &gt; 'foo';
</pre><p>
<!--
    But this is an error:
-->
ただし、次の例はエラーになります。
</p><pre class="programlisting">
SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE "C";
</pre><p>
<!--
    because it attempts to apply a collation to the result of the
    <literal>&gt;</literal> operator, which is of the non-collatable data type
    <type>boolean</type>.
-->
<code class="literal">&gt;</code>演算子の結果に対して照合順序を適用しようとしますが、<code class="literal">&gt;</code>演算子は照合不可能なデータ型である<code class="type">boolean</code>となるからです。
   </p></div><div class="sect2" id="SQL-SYNTAX-SCALAR-SUBQUERIES"><div class="titlepage"><div><div><h3 class="title">4.2.11. スカラ副問い合わせ</h3></div></div></div><!--
   <title>Scalar Subqueries</title>
--><a id="id-1.5.3.6.19.2" class="indexterm"></a><p>
<!--
    A scalar subquery is an ordinary
    <command>SELECT</command> query in parentheses that returns exactly one
    row with one column.  (See <xref linkend="queries"/> for information about writing queries.)
    The <command>SELECT</command> query is executed
    and the single returned value is used in the surrounding value expression.
    It is an error to use a query that
    returns more than one row or more than one column as a scalar subquery.
    (But if, during a particular execution, the subquery returns no rows,
    there is no error; the scalar result is taken to be null.)
    The subquery can refer to variables from the surrounding query,
    which will act as constants during any one evaluation of the subquery.
    See also <xref linkend="functions-subquery"/> for other expressions involving subqueries.
-->
スカラ副問い合わせは、正確に1行1列を返す、括弧内の通常の<code class="command">SELECT</code>問い合わせです
（問い合わせの記述方法については<a class="xref" href="queries.html" title="第7章 問い合わせ">第7章</a>を参照してください）。
その<code class="command">SELECT</code>問い合わせは実行され、返される単一の値はその値の前後の評価式で使用されます。
1行を超える行や1列を超える列がスカラ副問い合わせ用の問い合わせとして使用された場合はエラーになります
（しかし、ある実行時に、副問い合わせが行を返さない場合はエラーとはなりません。
そのスカラ結果はNULLとして扱われます）。
副問い合わせは、その周りの問い合わせ内の値を参照することができます。
その値は副問い合わせの評価時には定数として扱われます。
副問い合わせに関する他の式については<a class="xref" href="functions-subquery.html" title="9.22. 副問い合わせ式">9.22</a>も参照してください。
   </p><p>
<!--
    For example, the following finds the largest city population in each
    state:
-->
例えば、以下は各州の最大都市の人口を検索します。
</p><pre class="programlisting">
SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
    FROM states;
</pre><p>
   </p></div><div class="sect2" id="SQL-SYNTAX-ARRAY-CONSTRUCTORS"><div class="titlepage"><div><div><h3 class="title">4.2.12. 配列コンストラクタ</h3></div></div></div><!--
   <title>Array Constructors</title>
--><a id="id-1.5.3.6.20.2" class="indexterm"></a><a id="id-1.5.3.6.20.3" class="indexterm"></a><p>
<!--
    An array constructor is an expression that builds an
    array value using values for its member elements.  A simple array
    constructor
    consists of the key word <literal>ARRAY</literal>, a left square bracket
    <literal>[</literal>, a list of expressions (separated by commas) for the
    array element values, and finally a right square bracket <literal>]</literal>.
    For example:
-->
配列コンストラクタは、メンバー要素に対する値を用いて配列値を構築する式です。
単純な配列コンストラクタの構成は、<code class="literal">ARRAY</code>キーワード、左大括弧<code class="literal">[</code>、（カンマで区切った）配列要素値用の式のリストで、最後に右大括弧<code class="literal">]</code>です。
以下に例を示します。
</p><pre class="programlisting">
SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
(1 row)
</pre><p>
<!--
    By default,
    the array element type is the common type of the member expressions,
    determined using the same rules as for <literal>UNION</literal> or
    <literal>CASE</literal> constructs (see <xref linkend="typeconv-union-case"/>).
    You can override this by explicitly casting the array constructor to the
    desired type, for example:
    -->
    デフォルトで配列要素型は、メンバ式の型と同じで、<code class="literal">UNION</code>や<code class="literal">CASE</code>構文と同じ規則を使用して決定されます
（<a class="xref" href="typeconv-union-case.html" title="10.5. UNION、CASEおよび関連する構文">10.5</a>を参照してください）。これを明示的に配列コンストラクタを希望する型にキャストすることで書き換えることができます。例をあげます。
</p><pre class="programlisting">
SELECT ARRAY[1,2,22.7]::integer[];
  array
----------
 {1,2,23}
(1 row)
</pre><p>
<!--
    This has the same effect as casting each expression to the array
    element type individually.
    For more on casting, see <xref linkend="sql-syntax-type-casts"/>.
-->
これはそれぞれの式を配列要素の型に個別にキャストするのと同じ効果があります。
キャストについてより多くは<a class="xref" href="sql-expressions.html#SQL-SYNTAX-TYPE-CASTS" title="4.2.9. 型キャスト">4.2.9</a>を参照してください。
   </p><p>
<!--
    Multidimensional array values can be built by nesting array
    constructors.
    In the inner constructors, the key word <literal>ARRAY</literal> can
    be omitted.  For example, these produce the same result:
-->
多次元配列値は、配列コンストラクタを入れ子にすることで構築できます。
内側のコンストラクタでは<code class="literal">ARRAY</code>キーワードは省略可能です。
例えば、以下は同じ結果になります。

</p><pre class="programlisting">
SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)
</pre><p>

<!--
    Since multidimensional arrays must be rectangular, inner constructors
    at the same level must produce sub-arrays of identical dimensions.
    Any cast applied to the outer <literal>ARRAY</literal> constructor propagates
    automatically to all the inner constructors.
-->
多次元配列は長方形配列でなければなりませんので、同一レベルの内部コンストラクタは同一次元の副配列を生成しなければなりません。外部<code class="literal">ARRAY</code>コンストラクタに適用される全てのキャストは自動的に全ての内部コンストラクタに伝播します。
  </p><p>
<!--
    Multidimensional array constructor elements can be anything yielding
    an array of the proper kind, not only a sub-<literal>ARRAY</literal> construct.
    For example:
-->
多次元配列コンストラクタの要素は、副<code class="literal">ARRAY</code>構文だけでなく、適切な種類の配列を生成するものをとることができます。
以下に例を示します。
</p><pre class="programlisting">
CREATE TABLE arr(f1 int[], f2 int[]);

INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)
</pre><p>
  </p><p>
<!--
   You can construct an empty array, but since it's impossible to have an
   array with no type, you must explicitly cast your empty array to the
   desired type.  For example:
-->
空配列を構築できますが、型を所有しない配列を持つことは不可能なので、空配列を望まれる型に明示的にキャストしなければなりません。例をあげます。
</p><pre class="programlisting">
SELECT ARRAY[]::integer[];
 array
-------
 {}
(1 row)
</pre><p>
  </p><p>
<!--
   It is also possible to construct an array from the results of a
   subquery.  In this form, the array constructor is written with the
   key word <literal>ARRAY</literal> followed by a parenthesized (not
   bracketed) subquery. For example:
-->
また、副問い合わせの結果から配列を構成することも可能です。
この形式の場合、配列コンストラクタは<code class="literal">ARRAY</code>キーワードの後に括弧（大括弧ではない）で括られた副問い合わせとして記述されます。
以下に例を示します。
</p><pre class="programlisting">
SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                                 array
-----------------------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412,2413}
(1 row)

SELECT ARRAY(SELECT ARRAY[i, i*2] FROM generate_series(1,5) AS a(i));
              array
----------------------------------
 {{1,2},{2,4},{3,6},{4,8},{5,10}}
(1 row)
</pre><p>
<!--
   The subquery must return a single column.
   If the subquery's output column is of a non-array type, the resulting
   one-dimensional array will have an element for each row in the
   subquery result, with an element type matching that of the
   subquery's output column.
   If the subquery's output column is of an array type, the result will be
   an array of the same type but one higher dimension; in this case all
   the subquery rows must yield arrays of identical dimensionality, else
   the result would not be rectangular.
-->
副問い合わせは単一の列を返さなければなりません。
副問い合わせの出力列が非配列型であれば、その結果である一次元配列は、副問い合わせの出力列と一致する型を要素型とした、副問い合わせの結果内の各行を要素として持ちます。
副問い合わせの出力列が配列型であれば、その結果は、同じ型で1つ次元の高い配列になります。この場合、副問い合わせの列はすべて同じ次元の配列とならなければなりません。そうでないと結果が長方形になりません。
  </p><p>
<!--
   The subscripts of an array value built with <literal>ARRAY</literal>
   always begin with one.  For more information about arrays, see
   <xref linkend="arrays"/>.
-->
<code class="literal">ARRAY</code>で構築された配列値の添字は、常に1から始まります。
配列についての詳細は<a class="xref" href="arrays.html" title="8.15. 配列">8.15</a>を参照してください。
  </p></div><div class="sect2" id="SQL-SYNTAX-ROW-CONSTRUCTORS"><div class="titlepage"><div><div><h3 class="title">4.2.13. 行コンストラクタ</h3></div></div></div><!--
   <title>Row Constructors</title>
--><a id="id-1.5.3.6.21.2" class="indexterm"></a><a id="id-1.5.3.6.21.3" class="indexterm"></a><a id="id-1.5.3.6.21.4" class="indexterm"></a><p>
<!--
    A row constructor is an expression that builds a row value (also
    called a composite value) using values
    for its member fields.  A row constructor consists of the key word
    <literal>ROW</literal>, a left parenthesis, zero or more
    expressions (separated by commas) for the row field values, and finally
    a right parenthesis.  For example:
-->
行コンストラクタは、そのメンバフィールドに対する値を用いて行値（複合値とも呼ばれます）を構築する式です。
行コンストラクタは、<code class="literal">ROW</code>キーワード、左括弧、行のフィールド値用の0個以上の式（カンマ区切り）、最後に右括弧からなります。
以下に例を示します。
</p><pre class="programlisting">
SELECT ROW(1,2.5,'this is a test');
</pre><p>
<!--
    The key word <literal>ROW</literal> is optional when there is more than one
    expression in the list.
-->
<code class="literal">ROW</code>キーワードは、2つ以上の式がリスト内にある場合は省略することができます。
   </p><p>
<!--
    A row constructor can include the syntax
    <replaceable>rowvalue</replaceable><literal>.*</literal>,
    which will be expanded to a list of the elements of the row value,
    just as occurs when the <literal>.*</literal> syntax is used at the top level
    of a <command>SELECT</command> list (see <xref linkend="rowtypes-usage"/>).
    For example, if table <literal>t</literal> has
    columns <literal>f1</literal> and <literal>f2</literal>, these are the same:
-->
行コンストラクタには<em class="replaceable"><code>rowvalue</code></em><code class="literal">.*</code>構文を含めることができます。
これは、<code class="command">SELECT</code>リストの最上位レベルで<code class="literal">.*</code>構文が使用された時とまったく同様に、行値の要素の列挙に展開されます(<a class="xref" href="rowtypes.html#ROWTYPES-USAGE" title="8.16.5. 問い合わせでの複合型の使用">8.16.5</a>参照)。
たとえば、テーブル<code class="literal">t</code>が<code class="literal">f1</code>列と<code class="literal">f2</code>列を持つ場合、以下は同一です。
</p><pre class="programlisting">
SELECT ROW(t.*, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;
</pre><p>
   </p><div class="note"><h3 class="title">注記</h3><p>
<!--
     Before <productname>PostgreSQL</productname> 8.2, the
     <literal>.*</literal> syntax was not expanded in row constructors, so
     that writing <literal>ROW(t.*, 42)</literal> created a two-field row whose first
     field was another row value.  The new behavior is usually more useful.
     If you need the old behavior of nested row values, write the inner
     row value without <literal>.*</literal>, for instance
     <literal>ROW(t, 42)</literal>.
-->
<span class="productname">PostgreSQL</span> 8.2より前では、<code class="literal">.*</code>構文は行コンストラクタ内では展開されませんでした。
<code class="literal">ROW(t.*, 42)</code>と記述すると、1つ目のフィールドにもう一つの行値を持つ、2つのフィールドからなる行が作成されました。
たいていの場合、新しい動作はより使いやすくなっています。
入れ子状の行値という古い動作が必要であれば、内側の行値には<code class="literal">.*</code>を使用せずに、たとえば<code class="literal">ROW(t, 42)</code>と記述してください。
    </p></div><p>
<!--
    By default, the value created by a <literal>ROW</literal> expression is of
    an anonymous record type.  If necessary, it can be cast to a named
    composite type &mdash; either the row type of a table, or a composite type
    created with <command>CREATE TYPE AS</command>.  An explicit cast might be needed
    to avoid ambiguity.  For example:
-->
デフォルトでは、<code class="literal">ROW</code>式により作成される値は匿名レコード型になります。
必要に応じて、名前付きの複合型、つまりテーブルの行型あるいは<code class="command">CREATE TYPE AS</code>で作成された複合型にキャストすることができます。
曖昧性を防止するために明示的なキャストが必要となることもあります。
以下に例を示します。
</p><pre class="programlisting">
CREATE TABLE mytable(f1 int, f2 float, f3 text);

CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

<!--
&#045;&#045; No cast needed since only one getf1() exists
-->
-- getf1()が1つしか存在しないためキャスト不要。
SELECT getf1(ROW(1,2.5,'this is a test'));
 getf1
-------
     1
(1 row)

CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

<!--
&#045;&#045; Now we need a cast to indicate which function to call:
-->
-- ここでは、どの関数を呼び出すのかを示すためにキャストが必要。
SELECT getf1(ROW(1,2.5,'this is a test'));
ERROR:  function getf1(record) is not unique

SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
 getf1
-------
     1
(1 row)

SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
 getf1
-------
    11
(1 row)
</pre><p>
  </p><p>
<!--
   Row constructors can be used to build composite values to be stored
   in a composite-type table column, or to be passed to a function that
   accepts a composite parameter.  Also,
   it is possible to compare two row values or test a row with
   <literal>IS NULL</literal> or <literal>IS NOT NULL</literal>, for example:
-->
行コンストラクタは、複合型のテーブル列に格納する複合型の値を構築するため、あるいは複合型のパラメータを受け付ける関数に渡すために使用することができます。
また、以下の例のように、2つの行値を比較することも、<code class="literal">IS NULL</code>もしくは<code class="literal">IS NOT NULL</code>で行を検査することも可能です。
</p><pre class="programlisting">
SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');

<!--
SELECT ROW(table.*) IS NULL FROM table;  &#045;&#045; detect all-null rows
-->
SELECT ROW(table.*) IS NULL FROM table;  -- すべてがNULLの行を検出します。
</pre><p>
<!--
   For more detail see <xref linkend="functions-comparisons"/>.
   Row constructors can also be used in connection with subqueries,
   as discussed in <xref linkend="functions-subquery"/>.
-->
詳細は<a class="xref" href="functions-comparisons.html" title="9.23. 行と配列の比較">9.23</a>を参照してください。
行コンストラクタは、<a class="xref" href="functions-subquery.html" title="9.22. 副問い合わせ式">9.22</a>で説明するように、副問い合わせと一緒に使用することもできます。
  </p></div><div class="sect2" id="SYNTAX-EXPRESS-EVAL"><div class="titlepage"><div><div><h3 class="title">4.2.14. 式の評価規則</h3></div></div></div><!--
   <title>Expression Evaluation Rules</title>
--><a id="id-1.5.3.6.22.2" class="indexterm"></a><p>
<!--
    The order of evaluation of subexpressions is not defined.  In
    particular, the inputs of an operator or function are not necessarily
    evaluated left-to-right or in any other fixed order.
-->
副式の評価の順序は定義されていません。
特に演算子や関数の入力は、必ずしも左から右などの決まった順序で評価されるわけではありません。
   </p><p>
<!--
    Furthermore, if the result of an expression can be determined by
    evaluating only some parts of it, then other subexpressions
    might not be evaluated at all.  For instance, if one wrote:
-->
さらに、その式の一部を評価しただけで式の結果を決定できる場合には、他の副式がまったく評価されないこともあります。
例えば、
</p><pre class="programlisting">
SELECT true OR somefunc();
</pre><p>
<!--
    then <literal>somefunc()</literal> would (probably) not be called
    at all. The same would be the case if one wrote:
-->
では、（おそらく）<code class="literal">somefunc()</code>は呼び出されないでしょう。
以下の場合も同様です。
</p><pre class="programlisting">
SELECT somefunc() OR true;
</pre><p>
<!--
    Note that this is not the same as the left-to-right
    <quote>short-circuiting</quote> of Boolean operators that is found
    in some programming languages.
-->
これは一部のプログラミング言語に見られる、ブーリアン演算子での左から右への<span class="quote">「<span class="quote">短絡評価</span>」</span>とは異なることに注意してください。
   </p><p>
<!--
    As a consequence, it is unwise to use functions with side effects
    as part of complex expressions.  It is particularly dangerous to
    rely on side effects or evaluation order in <literal>WHERE</literal> and <literal>HAVING</literal> clauses,
    since those clauses are extensively reprocessed as part of
    developing an execution plan.  Boolean
    expressions (<literal>AND</literal>/<literal>OR</literal>/<literal>NOT</literal> combinations) in those clauses can be reorganized
    in any manner allowed by the laws of Boolean algebra.
-->
そのため、副次作用がある関数を複雑な式の一部として使用することは推奨されません。
特に、<code class="literal">WHERE</code>句および<code class="literal">HAVING</code>句で副次作用や評価順に依存するのは危険です。
これらの句は、実行計画を作成する過程で頻繁に再処理されるからです。
これらの句のブール式（<code class="literal">AND</code>/<code class="literal">OR</code>/<code class="literal">NOT</code>の組み合わせ）は、ブール代数の規則で許されるあらゆる方式で再編成される可能性があります。
   </p><p>
<!--
    When it is essential to force evaluation order, a <literal>CASE</literal>
    construct (see <xref linkend="functions-conditional"/>) can be
    used.  For example, this is an untrustworthy way of trying to
    avoid division by zero in a <literal>WHERE</literal> clause:
-->
評価の順序を強制することが重要であれば、<code class="literal">CASE</code>構文（<a class="xref" href="functions-conditional.html" title="9.17. 条件式">9.17</a>を参照）を使用できます。
例えば、次の式は<code class="literal">WHERE</code>句で0除算を避ける方法としては信頼性の低いものです。
</p><pre class="programlisting">
SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;
</pre><p>
<!--
    But this is safe:
-->
しかし、次のようにすれば安全です。
</p><pre class="programlisting">
SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</pre><p>
<!--
    A <literal>CASE</literal> construct used in this fashion will defeat optimization
    attempts, so it should only be done when necessary.  (In this particular
    example, it would be better to sidestep the problem by writing
    <literal>y &gt; 1.5*x</literal> instead.)
-->
このような方法で使用される<code class="literal">CASE</code>構文は最適化を妨げるものなので、必要な場合にのみ使用してください。
（特に、この例では、<code class="literal">y &gt; 1.5*x</code>と代わりに記述することが問題を回避するより優れた方法です。）
   </p><p>
<!--
    <literal>CASE</literal> is not a cure-all for such issues, however.
    One limitation of the technique illustrated above is that it does not
    prevent early evaluation of constant subexpressions.
    As described in <xref linkend="xfunc-volatility"/>, functions and
    operators marked <literal>IMMUTABLE</literal> can be evaluated when
    the query is planned rather than when it is executed.  Thus for example
-->
しかしながら、<code class="literal">CASE</code>はそのような問題に対する万能薬ではありません。
上で示したような方法の限界の1つは、定数副式が早く評価されるのを防げないことです。
<a class="xref" href="xfunc-volatility.html" title="38.7. 関数の変動性分類">38.7</a>に記すように、<code class="literal">IMMUTABLE</code>と印をつけられた関数と演算子は、実行される時ではなく問い合わせが計画される時に評価されるかもしれません。
そのため、例えば
</p><pre class="programlisting">
SELECT CASE WHEN x &gt; 0 THEN x ELSE 1/0 END FROM tab;
</pre><p>
<!--
    is likely to result in a division-by-zero failure due to the planner
    trying to simplify the constant subexpression,
    even if every row in the table has <literal>x &gt; 0</literal> so that the
    <literal>ELSE</literal> arm would never be entered at run time.
-->
は、たとえテーブルのすべての行が<code class="literal">x &gt; 0</code>であり、実行時には<code class="literal">ELSE</code>節に決して入らないとしても、プランナが定数副式を単純化しようとするためにゼロによる除算での失敗という結果に終わるでしょう。
   </p><p>
<!--
    While that particular example might seem silly, related cases that don't
    obviously involve constants can occur in queries executed within
    functions, since the values of function arguments and local variables
    can be inserted into queries as constants for planning purposes.
    Within <application>PL/pgSQL</application> functions, for example, using an
    <literal>IF</literal>-<literal>THEN</literal>-<literal>ELSE</literal> statement to protect
    a risky computation is much safer than just nesting it in a
    <literal>CASE</literal> expression.
-->
この特別な例は馬鹿げたものに見えるかもしれませんが、定数を含むことが明らかではない関連する場合が関数の中で実行される問い合わせで起こり得ます。関数の引数とローカル変数は計画作成の都合で定数として問い合わせに入れられることがあるからです。
例えば、<span class="application">PL/pgSQL</span>関数の中では、<code class="literal">IF</code>-<code class="literal">THEN</code>-<code class="literal">ELSE</code>文を使って危険な計算を保護する方が<code class="literal">CASE</code>式の中で入れ子にするよりもずっと安全です。
   </p><p>
<!--
    Another limitation of the same kind is that a <literal>CASE</literal> cannot
    prevent evaluation of an aggregate expression contained within it,
    because aggregate expressions are computed before other
    expressions in a <literal>SELECT</literal> list or <literal>HAVING</literal> clause
    are considered.  For example, the following query can cause a
    division-by-zero error despite seemingly having protected against it:
-->
同種の別の限界は、その中に含まれる集約式の評価を<code class="literal">CASE</code>が防げないことです。なぜなら、<code class="literal">SELECT</code>リストや<code class="literal">HAVING</code>句の別の式が考慮される前に、集約式が計算されるからです。
例えば、以下の問い合わせは対策を施しているように見えるにも関わらずゼロ除算エラーになり得ます。
</p><pre class="programlisting">
SELECT CASE WHEN min(employees) &gt; 0
            THEN avg(expenses / employees)
       END
    FROM departments;
</pre><p>
<!--
    The <function>min()</function> and <function>avg()</function> aggregates are computed
    concurrently over all the input rows, so if any row
    has <structfield>employees</structfield> equal to zero, the division-by-zero error
    will occur before there is any opportunity to test the result of
    <function>min()</function>.  Instead, use a <literal>WHERE</literal>
    or <literal>FILTER</literal> clause to prevent problematic input rows from
    reaching an aggregate function in the first place.
-->
<code class="function">min()</code>と<code class="function">avg()</code>集約は入力行すべてに対して同時に計算されますので、もし<code class="structfield">employees</code>がゼロになる行があれば、<code class="function">min()</code>の結果が検査される機会の前にゼロ除算エラーが起こります。
代わりに、まずは問題のある入力行が集約関数に渡されないようにするために<code class="literal">WHERE</code>または<code class="literal">FILTER</code>句を使ってください。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-syntax-lexical.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-syntax.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-syntax-calling-funcs.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">4.1. 字句の構造 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 4.3. 関数呼び出し</td></tr></table></div></body></html>