<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>12.3. テキスト検索の制御</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="textsearch-tables.html" title="12.2. テーブルとインデックス" /><link rel="next" href="textsearch-features.html" title="12.4. 追加機能" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 11.4文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="textsearch.html" title="第12章 全文検索">第12章 全文検索</a></td><td width="20%" align="right"></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="textsearch-tables.html" title="12.2. テーブルとインデックス">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="textsearch.html" title="第12章 全文検索">上へ</a></td><td width="60%" align="center">12.3. テキスト検索の制御</td><td width="20%" align="right"> <a accesskey="n" href="textsearch-features.html" title="12.4. 追加機能">次へ</a></td></tr></table><hr /></div><div class="sect1" id="TEXTSEARCH-CONTROLS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">12.3. テキスト検索の制御</h2></div></div></div><!--
  <title>Controlling Text Search</title>
--><p>
<!--
   To implement full text searching there must be a function to create a
   <type>tsvector</type> from a document and a <type>tsquery</type> from a
   user query. Also, we need to return results in a useful order, so we need
   a function that compares documents with respect to their relevance to
   the query. It's also important to be able to display the results nicely.
   <productname>PostgreSQL</productname> provides support for all of these
   functions.
-->
全文検索を実装するためには、文書から<code class="type">tsvector</code>を、そしてユーザの問い合わせから<code class="type">tsquery</code>を作成する関数が存在しなければなりません。また、結果を意味のある順で返す必要があります。そこで、問い合わせとの関連性で文書を比較する関数も必要になってきます。結果を体裁良く表示できることも重要です。<span class="productname">PostgreSQL</span>はこれらすべての機能を提供しています。
  </p><div class="sect2" id="TEXTSEARCH-PARSING-DOCUMENTS"><div class="titlepage"><div><div><h3 class="title">12.3.1. 文書のパース</h3></div></div></div><!--
   <title>Parsing Documents</title>
--><p>
<!--
    <productname>PostgreSQL</productname> provides the
    function <function>to_tsvector</function> for converting a document to
    the <type>tsvector</type> data type.
-->
<span class="productname">PostgreSQL</span>は、文書を<code class="type">tsvector</code>データ型に変換する<code class="function">to_tsvector</code>関数を提供しています。
   </p><a id="id-1.5.11.6.3.3" class="indexterm"></a><pre class="synopsis">
to_tsvector([<span class="optional"> <em class="replaceable"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="replaceable"><code>document</code></em> <code class="type">text</code>) returns <code class="type">tsvector</code>
</pre><p>
<!--
    <function>to_tsvector</function> parses a textual document into tokens,
    reduces the tokens to lexemes, and returns a <type>tsvector</type> which
    lists the lexemes together with their positions in the document.
    The document is processed according to the specified or default
    text search configuration.
    Here is a simple example:
-->
<code class="function">to_tsvector</code>は、テキスト文書をパースしてトークンにし、トークンを語彙素に変換、文書中の位置とともに語彙素をリストとして持つ<code class="type">tsvector</code>を返します。文書は、指定したものか、あるいはデフォルトのテキスト検索設定にしたがって処理されます。単純な例を示します。

</p><pre class="screen">
SELECT to_tsvector('english', 'a fat  cat sat on a mat - it ate a fat rats');
                  to_tsvector
-----------------------------------------------------
 'ate':9 'cat':3 'fat':2,11 'mat':7 'rat':12 'sat':4
</pre><p>
   </p><p>
<!--
    In the example above we see that the resulting <type>tsvector</type> does not
    contain the words <literal>a</literal>, <literal>on</literal>, or
    <literal>it</literal>, the word <literal>rats</literal> became
    <literal>rat</literal>, and the punctuation sign <literal>-</literal> was
    ignored.
-->
上に示す例では、結果の<code class="type">tsvector</code>で、<code class="literal">a</code>、<code class="literal">on</code>、<code class="literal">it</code>という単語が含まれないこと、<code class="literal">rats</code>という単語が<code class="literal">rat</code>になっていること、句読点記号<code class="literal">-</code>が無視されていることがわかります。
   </p><p>
<!--
    The <function>to_tsvector</function> function internally calls a parser
    which breaks the document text into tokens and assigns a type to
    each token.  For each token, a list of
    dictionaries (<xref linkend="textsearch-dictionaries"/>) is consulted,
    where the list can vary depending on the token type.  The first dictionary
    that <firstterm>recognizes</firstterm> the token emits one or more normalized
    <firstterm>lexemes</firstterm> to represent the token.  For example,
    <literal>rats</literal> became <literal>rat</literal> because one of the
    dictionaries recognized that the word <literal>rats</literal> is a plural
    form of <literal>rat</literal>.  Some words are recognized as
    <firstterm>stop words</firstterm> (<xref linkend="textsearch-stopwords"/>), which
    causes them to be ignored since they occur too frequently to be useful in
    searching.  In our example these are
    <literal>a</literal>, <literal>on</literal>, and <literal>it</literal>.
    If no dictionary in the list recognizes the token then it is also ignored.
    In this example that happened to the punctuation sign <literal>-</literal>
    because there are in fact no dictionaries assigned for its token type
    (<literal>Space symbols</literal>), meaning space tokens will never be
    indexed. The choices of parser, dictionaries and which types of tokens to
    index are determined by the selected text search configuration (<xref
    linkend="textsearch-configuration"/>).  It is possible to have
    many different configurations in the same database, and predefined
    configurations are available for various languages. In our example
    we used the default configuration <literal>english</literal> for the
    English language.
-->
<code class="function">to_tsvector</code>関数は、文書をトークンに分解して、そのトークンに型を割り当てるパーサを内部的に呼び出しています。それぞれのトークンに対して辞書(<a class="xref" href="textsearch-dictionaries.html" title="12.6. 辞書">12.6</a>)のリストが検索されます。ここで、辞書のリストはトークンの型によって異なります。最初の辞書は、トークンを<em class="firstterm">認識</em>し、トークンを表現する一つ以上の正規化された<em class="firstterm">語彙素</em>を出力します。例えば、ある辞書は<code class="literal">rats</code>は<code class="literal">rat</code>の複数形であることを認識しているので、<code class="literal">rats</code>は<code class="literal">rat</code>になります。
ある単語は<em class="firstterm">ストップワード</em>(<a class="xref" href="textsearch-dictionaries.html#TEXTSEARCH-STOPWORDS" title="12.6.1. ストップワード">12.6.1</a>)として認識されます。これは、あまりにも多く出現し検索の役に立たないため、無視されるものです。
先の例では、<code class="literal">a</code>、<code class="literal">on</code>、および<code class="literal">it</code>がそれです。
もしリスト中の辞書のどれもがトークンを認識しなければ、そのトークンは無視されます。先の例では、句読点の<code class="literal">-</code>がそうです。なぜなら、実際にはそのトークン型(<code class="literal">Space symbols</code>)に対して辞書が割り当てられておらず、空白トークンは決してインデックス付けされないことを意味します。パーサ、辞書、そしてどのトークンがインデックス付けされるかという選択は、テキスト検索設定(<a class="xref" href="textsearch-configuration.html" title="12.7. 設定例">12.7</a>)によって決められます。同じデータベース中に多くの異なった設定を持つことができ、多くの言語用に定義済の設定が用意されています。先の例では、英語用として、デフォルトの<code class="literal">english</code>設定を使っています。
   </p><p>
<!--
    The function <function>setweight</function> can be used to label the
    entries of a <type>tsvector</type> with a given <firstterm>weight</firstterm>,
    where a weight is one of the letters <literal>A</literal>, <literal>B</literal>,
    <literal>C</literal>, or <literal>D</literal>.
    This is typically used to mark entries coming from
    different parts of a document, such as title versus body.  Later, this
    information can be used for ranking of search results.
-->
関数<code class="function">setweight</code>を使って<code class="type">tsvector</code>のエントリに与えられた<em class="firstterm">重み</em>のラベルを与えることができます。ここで重みは、<code class="literal">A</code>, <code class="literal">B</code>, <code class="literal">C</code>, <code class="literal">D</code>のどれかの文字です。重みの典型的な使い方は、文書の各部分がどこから来たのかをマークすることです。たとえば、タイトルから来たのか、本文から来たのかなど。後でこの情報は検索結果のランキングに利用できます。
   </p><p>
<!--
    Because <function>to_tsvector</function>(<literal>NULL</literal>) will
    return <literal>NULL</literal>, it is recommended to use
    <function>coalesce</function> whenever a field might be null.
    Here is the recommended method for creating
    a <type>tsvector</type> from a structured document:
-->
<code class="function">to_tsvector</code>(<code class="literal">NULL</code>)は<code class="literal">NULL</code>を返すので、NULLになる可能性のある列に対しては<code class="function">coalesce</code>を使うことをお勧めします。構造化された文書から<code class="type">tsvector</code>を作るための推奨できる方法を示します。

</p><pre class="programlisting">
UPDATE tt SET ti =
    setweight(to_tsvector(coalesce(title,'')), 'A')    ||
    setweight(to_tsvector(coalesce(keyword,'')), 'B')  ||
    setweight(to_tsvector(coalesce(abstract,'')), 'C') ||
    setweight(to_tsvector(coalesce(body,'')), 'D');
</pre><p>

<!--
    Here we have used <function>setweight</function> to label the source
    of each lexeme in the finished <type>tsvector</type>, and then merged
    the labeled <type>tsvector</type> values using the <type>tsvector</type>
    concatenation operator <literal>||</literal>.  (<xref
    linkend="textsearch-manipulate-tsvector"/> gives details about these
    operations.)
-->
ここでは、完成した<code class="type">tsvector</code>の語彙素に対して、ラベル付けのために<code class="function">setweight</code>を使っています。そして、<code class="type">tsvector</code>の連結演算子<code class="literal">||</code>を使って、ラベルづけされた<code class="type">tsvector</code>の値をマージします。(詳細は<a class="xref" href="textsearch-features.html#TEXTSEARCH-MANIPULATE-TSVECTOR" title="12.4.1. 文書の操作">12.4.1</a>を参照してください。)
   </p></div><div class="sect2" id="TEXTSEARCH-PARSING-QUERIES"><div class="titlepage"><div><div><h3 class="title">12.3.2. 問い合わせのパース</h3></div></div></div><!--
   <title>Parsing Queries</title>
--><p>
<!--
    <productname>PostgreSQL</productname> provides the
    functions <function>to_tsquery</function>,
    <function>plainto_tsquery</function>,
    <function>phraseto_tsquery</function> and
    <function>websearch_to_tsquery</function>
    for converting a query to the <type>tsquery</type> data type.
    <function>to_tsquery</function> offers access to more features
    than either <function>plainto_tsquery</function> or
    <function>phraseto_tsquery</function>, but it is less forgiving about its
    input. <function>websearch_to_tsquery</function> is a simplified version
    of <function>to_tsquery</function> with an alternative syntax, similar
    to the one used by web search engines.
-->
<span class="productname">PostgreSQL</span>は、問い合わせを<code class="type">tsquery</code>に変換する関数<code class="function">to_tsquery</code>、<code class="function">plainto_tsquery</code>、<code class="function">phraseto_tsquery</code>、<code class="function">websearch_to_tsquery</code>を提供しています。
<code class="function">to_tsquery</code>は、<code class="function">plainto_tsquery</code>と<code class="function">phraseto_tsquery</code>のいずれよりも多くの機能を提供していますが、入力のチェックはより厳格です。
<code class="function">websearch_to_tsquery</code>は、webサーチエンジンで使われているものに似た別の構文を使う<code class="function">to_tsquery</code>の簡易バージョンです。
   </p><a id="id-1.5.11.6.4.3" class="indexterm"></a><pre class="synopsis">
to_tsquery([<span class="optional"> <em class="replaceable"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="replaceable"><code>querytext</code></em> <code class="type">text</code>) returns <code class="type">tsquery</code>
</pre><p>
<!--
    <function>to_tsquery</function> creates a <type>tsquery</type> value from
    <replaceable>querytext</replaceable>, which must consist of single tokens
    separated by the <type>tsquery</type> operators <literal>&amp;</literal> (AND),
    <literal>|</literal> (OR), <literal>!</literal> (NOT), and
    <literal>&lt;-&gt;</literal> (FOLLOWED BY), possibly grouped
    using parentheses.  In other words, the input to
    <function>to_tsquery</function> must already follow the general rules for
    <type>tsquery</type> input, as described in <xref
    linkend="datatype-tsquery"/>.  The difference is that while basic
    <type>tsquery</type> input takes the tokens at face value,
    <function>to_tsquery</function> normalizes each token into a lexeme using
    the specified or default configuration, and discards any tokens that are
    stop words according to the configuration.  For example:
-->
<code class="function">to_tsquery</code>は、<em class="replaceable"><code>querytext</code></em>から<code class="type">tsquery</code>としての値を生成します。
<em class="replaceable"><code>querytext</code></em>は、<code class="type">tsquery</code>演算子<code class="literal">&amp;</code> (AND), <code class="literal">|</code> (OR)、<code class="literal">!</code> (NOT)、<code class="literal">&lt;-&gt;</code> (FOLLOWED BY)で区切られる単一のトークンから構成されなければなりません。
これらの演算子は括弧でグループ化できます。
言い換えると、<code class="function">to_tsquery</code>の入力は、<a class="xref" href="datatype-textsearch.html#DATATYPE-TSQUERY" title="8.11.2. tsquery">8.11.2</a>で述べられている一般規則にしたがっていなければなりません。
違いは、基本的な<code class="type">tsquery</code>の入力はトークンの表面的な値を受け取るのに対し、<code class="function">to_tsquery</code>は指定した、あるいはデフォルトの設定を使ってトークンを語彙素へと正規化し、設定にしたがって、ストップワードであるようなトークンを破棄します。
例を示します。

</p><pre class="screen">
SELECT to_tsquery('english', 'The &amp; Fat &amp; Rats');
  to_tsquery   
---------------
 'fat' &amp; 'rat'
</pre><p>

<!--
    As in basic <type>tsquery</type> input, weight(s) can be attached to each
    lexeme to restrict it to match only <type>tsvector</type> lexemes of those
    weight(s).  For example:
-->
基本的な<code class="type">tsquery</code>の入力では、各々の語彙素に重みを付加することにより、同じ重みを持つ<code class="type">tsvector</code>の語彙素のみに照合するようにすることができます。例を示します。

</p><pre class="screen">
SELECT to_tsquery('english', 'Fat | Rats:AB');
    to_tsquery    
------------------
 'fat' | 'rat':AB
</pre><p>

<!--
    Also, <literal>*</literal> can be attached to a lexeme to specify prefix matching:
-->
また、明示的な前方一致検索のため、<code class="literal">*</code>を語彙素に与えることもできます。

</p><pre class="screen">
SELECT to_tsquery('supern:*A &amp; star:A*B');
        to_tsquery        
--------------------------
 'supern':*A &amp; 'star':*AB
</pre><p>

<!--
    Such a lexeme will match any word in a <type>tsvector</type> that begins
    with the given string.
-->
このような語彙素は、与えられた文字列で始まる<code class="type">tsvector</code>中のどんな単語にも照合するでしょう。
   </p><p>
<!--
    <function>to_tsquery</function> can also accept single-quoted
    phrases.  This is primarily useful when the configuration includes a
    thesaurus dictionary that may trigger on such phrases.
    In the example below, a thesaurus contains the rule <literal>supernovae
    stars : sn</literal>:
-->
<code class="function">to_tsquery</code>は、単一引用符で囲まれた語句を受け付けることもできます。これは主に、設定の中にそういった語句を持つ同義語辞書を含んでいるときに有用です。以下の例では、ある同義語の中に<code class="literal">supernovae stars : sn</code>という規則が含まれています。

</p><pre class="screen">
SELECT to_tsquery('''supernovae stars'' &amp; !crab');
  to_tsquery
---------------
 'sn' &amp; !'crab'
</pre><p>

<!--
    Without quotes, <function>to_tsquery</function> will generate a syntax
    error for tokens that are not separated by an AND, OR, or FOLLOWED BY
    operator.
-->
引用符がない場合は、<code class="function">to_tsquery</code>は、AND、ORあるいはFOLLOWED BY演算子で区切られていないトークンに対して構文エラーを引き起こします。
   </p><a id="id-1.5.11.6.4.7" class="indexterm"></a><pre class="synopsis">
plainto_tsquery([<span class="optional"> <em class="replaceable"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="replaceable"><code>querytext</code></em> <code class="type">text</code>) returns <code class="type">tsquery</code>
</pre><p>
<!--
    <function>plainto_tsquery</function> transforms the unformatted text
    <replaceable>querytext</replaceable> to a <type>tsquery</type> value.
    The text is parsed and normalized much as for <function>to_tsvector</function>,
    then the <literal>&amp;</literal> (AND) <type>tsquery</type> operator is
    inserted between surviving words.
-->
<code class="function">plainto_tsquery</code>は整形されていないテキスト<em class="replaceable"><code>querytext</code></em>を、<code class="type">tsquery</code>の値に変換します。
テキストはパースされ、<code class="function">to_tsvector</code>としてできる限り正規化されます。
そして、<code class="type">tsquery</code>演算子<code class="literal">&amp;</code> (AND) が存続した単語の間に挿入されます。
   </p><p>
<!--
    Example:
-->
例：

</p><pre class="screen">
SELECT plainto_tsquery('english', 'The Fat Rats');
 plainto_tsquery 
-----------------
 'fat' &amp; 'rat'
</pre><p>

<!--
    Note that <function>plainto_tsquery</function> will not
    recognize <type>tsquery</type> operators, weight labels,
    or prefix-match labels in its input:
-->
<code class="function">plainto_tsquery</code>は、入力中の<code class="type">tsquery</code>演算子も、重み付けラベルも、前方一致ラベルも認識しないことに注意してください。

</p><pre class="screen">
SELECT plainto_tsquery('english', 'The Fat &amp; Rats:C');
   plainto_tsquery   
---------------------
 'fat' &amp; 'rat' &amp; 'c'
</pre><p>

<!--
    Here, all the input punctuation was discarded as being space symbols.
-->
ここでは、入力中のすべての句読点がスペース記号に変換された結果、破棄されています。
   </p><a id="id-1.5.11.6.4.11" class="indexterm"></a><pre class="synopsis">
phraseto_tsquery([<span class="optional"> <em class="replaceable"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="replaceable"><code>querytext</code></em> <code class="type">text</code>) returns <code class="type">tsquery</code>
</pre><p>
<!--
    <function>phraseto_tsquery</function> behaves much like
    <function>plainto_tsquery</function>, except that it inserts
    the <literal>&lt;-&gt;</literal> (FOLLOWED BY) operator between
    surviving words instead of the <literal>&amp;</literal> (AND) operator.
    Also, stop words are not simply discarded, but are accounted for by
    inserting <literal>&lt;<replaceable>N</replaceable>&gt;</literal> operators rather
    than <literal>&lt;-&gt;</literal> operators.  This function is useful
    when searching for exact lexeme sequences, since the FOLLOWED BY
    operators check lexeme order not just the presence of all the lexemes.
-->
<code class="function">phraseto_tsquery</code>は<code class="function">plainto_tsquery</code>とほぼ同じ動作をしますが、残った語の間に<code class="literal">&amp;</code> (AND) 演算子ではなく、<code class="literal">&lt;-&gt;</code> (FOLLOWED BY) 演算子を挿入するところが違います。
また、ストップワードを単に無視するのでなく、<code class="literal">&lt;-&gt;</code>演算子の代わりに<code class="literal">&lt;<em class="replaceable"><code>N</code></em>&gt;</code>演算子を挿入することで、意味のあるものとします。
FOLLOWED BY演算子は、単にすべての語彙素が存在することだけでなく、語彙素の順序についても確認するため、この関数は語彙素の正確な順序について検索するときに役立ちます。
   </p><p>
<!--
    Example:
-->
例を示します。

</p><pre class="screen">
SELECT phraseto_tsquery('english', 'The Fat Rats');
 phraseto_tsquery
------------------
 'fat' &lt;-&gt; 'rat'
</pre><p>

<!--
    Like <function>plainto_tsquery</function>, the
    <function>phraseto_tsquery</function> function will not
    recognize <type>tsquery</type> operators, weight labels,
    or prefix-match labels in its input:
-->
<code class="function">plainto_tsquery</code>と同じく、<code class="function">phraseto_tsquery</code>関数もその入力内の<code class="type">tsquery</code>演算子、重み付けラベル、前方一致ラベルを認識しません。

</p><pre class="screen">
SELECT phraseto_tsquery('english', 'The Fat &amp; Rats:C');
      phraseto_tsquery
-----------------------------
 'fat' &lt;-&gt; 'rat' &lt;-&gt; 'c'
</pre><p>
   </p><pre class="synopsis">
websearch_to_tsquery([<span class="optional"> <em class="replaceable"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="replaceable"><code>querytext</code></em> <code class="type">text</code>) returns <code class="type">tsquery</code>
</pre><p>
<!--
    <function>websearch_to_tsquery</function> creates a <type>tsquery</type>
    value from <replaceable>querytext</replaceable> using an alternative
    syntax in which simple unformatted text is a valid query.
    Unlike <function>plainto_tsquery</function>
    and <function>phraseto_tsquery</function>, it also recognizes certain
    operators. Moreover, this function should never raise syntax errors,
    which makes it possible to use raw user-supplied input for search.
    The following syntax is supported:
-->
<code class="function">websearch_to_tsquery</code>は、問い合わせとして、単純で整形されていないテキストが代わりに使えるような構文を使って<em class="replaceable"><code>querytext</code></em>から<code class="type">tsquery</code>を作り出します。
<code class="function">plainto_tsquery</code>および<code class="function">phraseto_tsquery</code>と違って、ある種の演算子を理解します。
更にこの関数は決して構文エラーを引き起こさないので、ユーザ入力をそのまま検索で使用することができます。
以下の構文をサポートします。
    </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>
<!--
        <literal>unquoted text</literal>: text not inside quote marks will be
        converted to terms separated by <literal>&amp;</literal> operators, as
        if processed by
        <function>plainto_tsquery</function>.
-->
<code class="literal">引用符なしのテキスト</code>:引用符の内側にないテキストは、あたかも<code class="function">plainto_tsquery</code>で処理されたように<code class="literal">&amp;</code>演算子で区切られます。
      </p></li><li class="listitem" style="list-style-type: disc"><p>
<!--
        <literal>"quoted text"</literal>: text inside quote marks will be
        converted to terms separated by <literal>&lt;-&gt;</literal>
        operators, as if processed by <function>phraseto_tsquery</function>.
-->
<code class="literal">"引用符内のテキスト"</code>:引用符内のテキストは、あたかも<code class="function">phraseto_tsquery</code>で処理されたように<code class="literal">&lt;-&gt;</code>で区切られた表現に変換されます。
      </p></li><li class="listitem" style="list-style-type: disc"><p>
<!--
       <literal>OR</literal>: logical or will be converted to
       the <literal>|</literal> operator.
-->
<code class="literal">OR</code>:論理和は<code class="literal">|</code>演算子に変換されます。
      </p></li><li class="listitem" style="list-style-type: disc"><p>
<!--
       <literal>-</literal>: the logical not operator, converted to the
       the <literal>!</literal> operator.
-->
<code class="literal">-</code>:論理否定演算子。<code class="literal">!</code>演算子に変換されます。
      </p></li></ul></div><p>
   </p><p>
<!--
    Examples:
  -->
例を示します。
</p><pre class="screen">
SELECT websearch_to_tsquery('english', 'The fat rats');
 websearch_to_tsquery
----------------------
 'fat' &amp; 'rat'
(1 row)

SELECT websearch_to_tsquery('english', '"supernovae stars" -crab');
       websearch_to_tsquery
----------------------------------
 'supernova' &lt;-&gt; 'star' &amp; !'crab'
(1 row)

SELECT websearch_to_tsquery('english', '"sad cat" or "fat rat"');
       websearch_to_tsquery
-----------------------------------
 'sad' &lt;-&gt; 'cat' | 'fat' &lt;-&gt; 'rat'
(1 row)

SELECT websearch_to_tsquery('english', 'signal -"segmentation fault"');
         websearch_to_tsquery
---------------------------------------
 'signal' &amp; !( 'segment' &lt;-&gt; 'fault' )
(1 row)

SELECT websearch_to_tsquery('english', '""" )( dummy \\ query &lt;-&gt;');
 websearch_to_tsquery
----------------------
 'dummi' &amp; 'queri'
(1 row)
</pre><p>
    </p></div><div class="sect2" id="TEXTSEARCH-RANKING"><div class="titlepage"><div><div><h3 class="title">12.3.3. 検索結果のランキング</h3></div></div></div><!--
   <title>Ranking Search Results</title>
--><p>
<!--
    Ranking attempts to measure how relevant documents are to a particular
    query, so that when there are many matches the most relevant ones can be
    shown first.  <productname>PostgreSQL</productname> provides two
    predefined ranking functions, which take into account lexical, proximity,
    and structural information; that is, they consider how often the query
    terms appear in the document, how close together the terms are in the
    document, and how important is the part of the document where they occur.
    However, the concept of relevancy is vague and very application-specific.
    Different applications might require additional information for ranking,
    e.g., document modification time.  The built-in ranking functions are only
    examples.  You can write your own ranking functions and/or combine their
    results with additional factors to fit your specific needs.
-->
ランキングはある問い合わせに対して、どの程度文書が関連しているかを計測しようとするものです。合致している文書が多数あるとき、もっとも関連している文書が最初に表示されるようにするためです。
<span class="productname">PostgreSQL</span>は、2つの定義済ランキング関数を提供しています。それらは、辞書情報、近接度情報、構造的情報を加味します。すなわち、問い合わせの用語がどの位の頻度で文書に出現するか、文書中でどの程度それらの用語が近接しているか、どの用語が含まれる文書部位がどの程度重要なのかを考慮します。
しかし、関連度という概念は曖昧で、用途に強く依存します。
異なる用途は、ランキングのために追加の情報を必要とするかも知れません。たとえば、文書の更新時刻など。
組み込みのランキング関数は例に過ぎません。
利用者の目的に応じて、自分用のランキング関数を作ったり、その結果を追加の情報と組み合わせることができます。
   </p><p>
<!--
    The two ranking functions currently available are:
-->
今のところ、二種類のランキング関数が利用可能です。

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
       <a id="id-1.5.11.6.5.3.1.1.1.1" class="indexterm"></a>

       <code class="literal">ts_rank([<span class="optional"> <em class="replaceable"><code>weights</code></em> <code class="type">float4[]</code>, </span>] <em class="replaceable"><code>vector</code></em> <code class="type">tsvector</code>, <em class="replaceable"><code>query</code></em> <code class="type">tsquery</code> [<span class="optional">, <em class="replaceable"><code>normalization</code></em> <code class="type">integer</code> </span>]) returns <code class="type">float4</code></code>
      </span></dt><dd><p>
<!--
        Ranks vectors based on the frequency of their matching lexemes.
-->
それらの語彙素にマッチした頻度に基づくベクトルのランク。
       </p></dd><dt><span class="term">
      <a id="id-1.5.11.6.5.3.1.2.1.1" class="indexterm"></a>

       <code class="literal">ts_rank_cd([<span class="optional"> <em class="replaceable"><code>weights</code></em> <code class="type">float4[]</code>, </span>] <em class="replaceable"><code>vector</code></em> <code class="type">tsvector</code>, <em class="replaceable"><code>query</code></em> <code class="type">tsquery</code> [<span class="optional">, <em class="replaceable"><code>normalization</code></em> <code class="type">integer</code> </span>]) returns <code class="type">float4</code></code>
      </span></dt><dd><p>
<!--
        This function computes the <firstterm>cover density</firstterm>
        ranking for the given document vector and query, as described in
        Clarke, Cormack, and Tudhope's "Relevance Ranking for One to Three
        Term Queries" in the journal "Information Processing and Management",
        1999.  Cover density is similar to <function>ts_rank</function> ranking
        except that the proximity of matching lexemes to each other is
        taken into consideration.
-->
この関数は、1999年の"Information Processing and Management"ジャーナルに掲載されたClarke, Cormack, Tudhopeの"Relevance Ranking for One to Three Term Queries"で述べられている方法で、与えられた文書ベクトルと問い合わせの<em class="firstterm">被覆密度(cover density)</em>ランクを計算します。
被覆密度は互いにマッチする語彙素の近接度を考慮に入れる点を除いて<code class="function">ts_rank</code>のランク付けと似ています。
       </p><p>
<!--
        This function requires lexeme positional information to perform
        its calculation.  Therefore, it ignores any <quote>stripped</quote>
        lexemes in the <type>tsvector</type>.  If there are no unstripped
        lexemes in the input, the result will be zero.  (See <xref
        linkend="textsearch-manipulate-tsvector"/> for more information
        about the <function>strip</function> function and positional information
        in <type>tsvector</type>s.)
-->
この関数は、計算を実行するために語彙素の位置情報を必要とします。
ですから、<code class="type">tsvector</code>内の<span class="quote">「<span class="quote">剥き出しの</span>」</span>語彙素は無視します。
入力に剥き出しでない語彙素がなければ、 結果は0です。
(<code class="function">strip</code>関数と<code class="type">tsvector</code>内の位置情報についてのより詳しい情報は<a class="xref" href="textsearch-features.html#TEXTSEARCH-MANIPULATE-TSVECTOR" title="12.4.1. 文書の操作">12.4.1</a>を参照してください。)
       </p></dd></dl></div><p>

   </p><p>
<!--
    For both these functions,
    the optional <replaceable class="parameter">weights</replaceable>
    argument offers the ability to weigh word instances more or less
    heavily depending on how they are labeled.  The weight arrays specify
    how heavily to weigh each category of word, in the order:
-->
これらの関数では、単語がどの程度ラベル付けに依存するかを、単語ごとに指定する機能が<em class="replaceable"><code>weights</code></em>オプションパラメータによって提供されています。
重み配列で、それぞれのカテゴリの単語がどの程度重み付けするかを指定します。その順は以下のようになっています。

</p><pre class="synopsis">
{D-weight, C-weight, B-weight, A-weight}
</pre><p>

<!--
    If no <replaceable class="parameter">weights</replaceable> are provided,
    then these defaults are used:
-->
<em class="replaceable"><code>weights</code></em>を与えない場合は、次のデフォルト値が使われます。

</p><pre class="programlisting">
{0.1, 0.2, 0.4, 1.0}
</pre><p>

<!--
    Typically weights are used to mark words from special areas of the
    document, like the title or an initial abstract, so they can be
    treated with more or less importance than words in the document body.
-->
重みの典型的な使い方は、文書のタイトルやアブストラクトのような特定の場所にある単語をマーク付けするような使い方です。そうすることにより、文書の本体に比べてそこにある単語がより重要なのか、そうでないのか、扱いを変えることができます。
   </p><p>
<!--
    Since a longer document has a greater chance of containing a query term
    it is reasonable to take into account document size, e.g., a hundred-word
    document with five instances of a search word is probably more relevant
    than a thousand-word document with five instances.  Both ranking functions
    take an integer <replaceable>normalization</replaceable> option that
    specifies whether and how a document's length should impact its rank.
    The integer option controls several behaviors, so it is a bit mask:
    you can specify one or more behaviors using
    <literal>|</literal> (for example, <literal>2|4</literal>).
-->
文書が長ければ、それだけ問い合わせ用語を含む確率が高くなるため、文書のサイズを考慮にいれることは理にかなっています。たとえば、5つの検索語を含む100語の文書は、たぶん5つの検索語を含む1000語の文書よりも関連性が高いでしょう。ランキング関数には、どちらも整数型の<em class="replaceable"><code>正規化</code></em>オプションがあります。これは、文書の長さがランクに影響を与えるのかどうか、与えるとすればどの程度か、ということを指定します。この整数オプションは、いくつかの挙動を制御するので、ビットマスクになっています。複数の挙動を<code class="literal">|</code>で指定できます(例：<code class="literal">2|4</code>)。

    </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>
<!--
       0 (the default) ignores the document length
-->
0(デフォルト):文書の長さを無視します
      </p></li><li class="listitem" style="list-style-type: disc"><p>
<!--
       1 divides the rank by 1 + the logarithm of the document length
-->
1:ランクを(1 + log(文書の長さ))で割ります
      </p></li><li class="listitem" style="list-style-type: disc"><p>
<!--
       2 divides the rank by the document length
-->
2:ランクを文書の長さで割ります
      </p></li><li class="listitem" style="list-style-type: disc"><p>
<!--
       4 divides the rank by the mean harmonic distance between extents
       (this is implemented only by <function>ts_rank_cd</function>)
-->
4:ランクをエクステントの間の調和平均距離で割ります(これは<code class="function">ts_rank_cd</code>のみで実装されています)
      </p></li><li class="listitem" style="list-style-type: disc"><p>
<!--
       8 divides the rank by the number of unique words in document
-->
8: ランクを文書中の一意の単語の数で割ります
      </p></li><li class="listitem" style="list-style-type: disc"><p>
<!--
       16 divides the rank by 1 + the logarithm of the number
       of unique words in document
-->
16: ランクをlog(文書中の一意の単語の数)+1 で割ります
      </p></li><li class="listitem" style="list-style-type: disc"><p>
<!--
       32 divides the rank by itself + 1
-->
32: ランクをランク自身+1 で割ります
      </p></li></ul></div><p>

<!--
    If more than one flag bit is specified, the transformations are
    applied in the order listed.
-->
2以上のフラグビットが指定された場合には、変換は上記に列挙された順に行われます。
   </p><p>
<!--
    It is important to note that the ranking functions do not use any global
    information, so it is impossible to produce a fair normalization to 1% or
    100% as sometimes desired.  Normalization option 32
    (<literal>rank/(rank+1)</literal>) can be applied to scale all ranks
    into the range zero to one, but of course this is just a cosmetic change;
    it will not affect the ordering of the search results.
-->
これは重要なことですが、ランキング関数はグローバル情報を一切使わないので、時には必要になる1%から100%までの均一な正規化はできません。正規化オプション32(<code class="literal">rank/(rank+1)</code>)を適用することにより、すべてのランクを0から1に分布させることができます。しかし、もちろんこれは表面的な変更に過ぎません。検索結果のならび順に影響を与えるものではありません。
   </p><p>
<!--
    Here is an example that selects only the ten highest-ranked matches:
-->
マッチする順位の高い10位までを選ぶ例を示します。

</p><pre class="screen">
SELECT title, ts_rank_cd(textsearch, query) AS rank
FROM apod, to_tsquery('neutrino|(dark &amp; matter)') query
WHERE query @@ textsearch
ORDER BY rank DESC
LIMIT 10;
                     title                     |   rank
-----------------------------------------------+----------
 Neutrinos in the Sun                          |      3.1
 The Sudbury Neutrino Detector                 |      2.4
 A MACHO View of Galactic Dark Matter          |  2.01317
 Hot Gas and Dark Matter                       |  1.91171
 The Virgo Cluster: Hot Plasma and Dark Matter |  1.90953
 Rafting for Solar Neutrinos                   |      1.9
 NGC 4650A: Strange Galaxy and Dark Matter     |  1.85774
 Hot Gas and Dark Matter                       |   1.6123
 Ice Fishing for Cosmic Neutrinos              |      1.6
 Weak Lensing Distorts the Universe            | 0.818218
</pre><p>

<!--
    This is the same example using normalized ranking:
-->
同じ例を正規化ランキングを使ったものを示します。

</p><pre class="screen">
SELECT title, ts_rank_cd(textsearch, query, 32 /* rank/(rank+1) */ ) AS rank
FROM apod, to_tsquery('neutrino|(dark &amp; matter)') query
WHERE  query @@ textsearch
ORDER BY rank DESC
LIMIT 10;
                     title                     |        rank
-----------------------------------------------+-------------------
 Neutrinos in the Sun                          | 0.756097569485493
 The Sudbury Neutrino Detector                 | 0.705882361190954
 A MACHO View of Galactic Dark Matter          | 0.668123210574724
 Hot Gas and Dark Matter                       |  0.65655958650282
 The Virgo Cluster: Hot Plasma and Dark Matter | 0.656301290640973
 Rafting for Solar Neutrinos                   | 0.655172410958162
 NGC 4650A: Strange Galaxy and Dark Matter     | 0.650072921219637
 Hot Gas and Dark Matter                       | 0.617195790024749
 Ice Fishing for Cosmic Neutrinos              | 0.615384618911517
 Weak Lensing Distorts the Universe            | 0.450010798361481
</pre><p>
   </p><p>
<!--
    Ranking can be expensive since it requires consulting the
    <type>tsvector</type> of each matching document, which can be I/O bound and
    therefore slow. Unfortunately, it is almost impossible to avoid since
    practical queries often result in large numbers of matches.
-->
ランキングは、I/Oに結び付けられていて遅い可能性のある、一致する各文書の<code class="type">tsvector</code>へのアクセスが必要なので、高価な処理であるかもしれません。
不幸なことに、実際の問い合わせでは往々にして大量の検索結果が生じるため、これはほとんど不可避であると言えます。
   </p></div><div class="sect2" id="TEXTSEARCH-HEADLINE"><div class="titlepage"><div><div><h3 class="title">12.3.4. 結果の強調</h3></div></div></div><!--
   <title>Highlighting Results</title>
--><p>
<!--
    To present search results it is ideal to show a part of each document and
    how it is related to the query. Usually, search engines show fragments of
    the document with marked search terms.  <productname>PostgreSQL</productname>
    provides a function <function>ts_headline</function> that
    implements this functionality.
-->
検索結果を表示する際には、文書の該当部分を表示し、どの程度問い合わせと関連しているかを示すのが望ましいです。<span class="productname">PostgreSQL</span>はこの機能を実装した<code class="function">ts_headline</code>関数を提供しています。
   </p><a id="id-1.5.11.6.6.3" class="indexterm"></a><pre class="synopsis">
ts_headline([<span class="optional"> <em class="replaceable"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="replaceable"><code>document</code></em> <code class="type">text</code>, <em class="replaceable"><code>query</code></em> <code class="type">tsquery</code> [<span class="optional">, <em class="replaceable"><code>options</code></em> <code class="type">text</code> </span>]) returns <code class="type">text</code>
</pre><p>
<!--
    <function>ts_headline</function> accepts a document along
    with a query, and returns an excerpt from
    the document in which terms from the query are highlighted.  The
    configuration to be used to parse the document can be specified by
    <replaceable>config</replaceable>; if <replaceable>config</replaceable>
    is omitted, the
    <varname>default_text_search_config</varname> configuration is used.
-->
<code class="function">ts_headline</code>は、問い合わせと一緒に文書を受け取り、問い合わせが注目した文書中の語句を抜粋して返します。文書をパースするのに使われる設定を<em class="replaceable"><code>config</code></em>で指定することができます。<em class="replaceable"><code>config</code></em>が省略された場合は、<code class="varname">default_text_search_config</code>設定が使われます。
   </p><p>
<!--
    If an <replaceable>options</replaceable> string is specified it must
    consist of a comma-separated list of one or more
    <replaceable>option</replaceable><literal>=</literal><replaceable>value</replaceable> pairs.
    The available options are:
-->
<em class="replaceable"><code>options</code></em>文字列を指定する場合は、一つ以上の<em class="replaceable"><code>option</code></em><code class="literal">=</code><em class="replaceable"><code>value</code></em>のペアをカンマで区切ったものでなければなりません。

    </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>
<!--
       <literal>StartSel</literal>, <literal>StopSel</literal>: the strings with
       which to delimit query words appearing in the document, to distinguish
       them from other excerpted words.  You must double-quote these strings
       if they contain spaces or commas.
-->
<code class="literal">StartSel</code>, <code class="literal">StopSel</code>: 文書中に現れる問い合わせ単語を区切るこの文字列は、他の抜粋される単語と区別されます。これらの文字列が空白やカンマを含んでいる場合は、二重引用符で囲う必要があります。
      </p></li><li class="listitem" style="list-style-type: disc"><p>
<!--
       <literal>MaxWords</literal>, <literal>MinWords</literal>: these numbers
       determine the longest and shortest headlines to output.
-->
<code class="literal">MaxWords</code>, <code class="literal">MinWords</code>: この数字を使って見出しの最大の長さと最小の長さを指定します。
      </p></li><li class="listitem" style="list-style-type: disc"><p>
<!--
       <literal>ShortWord</literal>: words of this length or less will be
       dropped at the start and end of a headline. The default
       value of three eliminates common English articles.
-->
<code class="literal">ShortWord</code>: この長さか、それ以下の長さの単語は、見出しの最初と最後から削除されます。デフォルト値の3は、常用される英語の冠詞を取り除きます。
      </p></li><li class="listitem" style="list-style-type: disc"><p>
<!--
       <literal>HighlightAll</literal>: Boolean flag;  if
       <literal>true</literal> the whole document will be used as the
       headline, ignoring the preceding three parameters.
-->
<code class="literal">HighlightAll</code>: 論理値フラグ; <code class="literal">true</code>なら文書全体が見出しの様にハイライトされ、前の3つのパラメータは無視されます。
      </p></li><li class="listitem" style="list-style-type: disc"><p>
<!--
       <literal>MaxFragments</literal>: maximum number of text excerpts
       or fragments to display.  The default value of zero selects a
       non-fragment-oriented headline generation method.  A value greater than
       zero selects fragment-based headline generation.  This method
       finds text fragments with as many query words as possible and
       stretches those fragments around the query words.  As a result
       query words are close to the middle of each fragment and have words on
       each side. Each fragment will be of at most <literal>MaxWords</literal> and
       words of length <literal>ShortWord</literal> or less are dropped at the start
       and end of each fragment. If not all query words are found in the
       document, then a single fragment of the first <literal>MinWords</literal>
       in the document will be displayed.
-->
<code class="literal">MaxFragments</code>:表示するテキスト引用句、もしくは断片の最大数です。デフォルト値の0は断片化を起こさない見出しの生成の選択となります。0より大きい場合は断片化を基本とした見出しの生成の選択となります。この方法は、可能な限り多くの検索単語でテキスト断片を探し出し、検索単語周辺のそれらのテキスト断片を広げます。結果として、検索単語が各断片の中央部分近くに位置し、両端に単語を持つことになります。各断片は最大で<code class="literal">MaxWords</code>と同数の単語を持ち、<code class="literal">ShortWord</code>より少ないサイズの単語を断片の両端に持ちません。もし全ての検索単語を文書から見つけられなかった場合は、文書中の最初の<code class="literal">MinWords</code>分の単語数から成る一つの断片が表示されるでしょう。
      </p></li><li class="listitem" style="list-style-type: disc"><p>
<!--
       <literal>FragmentDelimiter</literal>: When more than one fragment is
       displayed, the fragments will be separated by this string.
-->
<code class="literal">FragmentDelimiter</code>: 複数の断片が表示される時、その断片はこの文字で区切られます。
      </p></li></ul></div><p>

<!--
    These option names are recognized case-insensitively.
    Any unspecified options receive these defaults:
-->
指定されなかったオプションの値は以下のデフォルトになります。

</p><pre class="programlisting">
StartSel=&lt;b&gt;, StopSel=&lt;/b&gt;,
MaxWords=35, MinWords=15, ShortWord=3, HighlightAll=FALSE,
MaxFragments=0, FragmentDelimiter=" ... "
</pre><p>
   </p><p>
<!--
    For example:
-->
例を示します。

</p><pre class="screen">
SELECT ts_headline('english',
  'The most common type of search
is to find all documents containing given query terms
and return them in order of their similarity to the
query.',
  to_tsquery('query &amp; similarity'));
                        ts_headline                         
------------------------------------------------------------
 containing given &lt;b&gt;query&lt;/b&gt; terms
 and return them in order of their &lt;b&gt;similarity&lt;/b&gt; to the
 &lt;b&gt;query&lt;/b&gt;.

SELECT ts_headline('english',
  'The most common type of search
is to find all documents containing given query terms
and return them in order of their similarity to the
query.',
  to_tsquery('query &amp; similarity'),
  'StartSel = &lt;, StopSel = &gt;');
                      ts_headline                      
-------------------------------------------------------
 containing given &lt;query&gt; terms
 and return them in order of their &lt;similarity&gt; to the
 &lt;query&gt;.
</pre><p>
   </p><p>
<!--
    <function>ts_headline</function> uses the original document, not a
    <type>tsvector</type> summary, so it can be slow and should be used with
    care.
-->
<code class="function">ts_headline</code>は、<code class="type">tsvector</code>の要約ではなく、元の文書を使います。ですので遅い可能性があり、注意深く使用する必要があります。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="textsearch-tables.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="textsearch.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="textsearch-features.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">12.2. テーブルとインデックス </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 12.4. 追加機能</td></tr></table></div></body></html>