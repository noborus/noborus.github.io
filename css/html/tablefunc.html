<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>F.38. tablefunc</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sslinfo.html" title="F.37. sslinfo" /><link rel="next" href="tcn.html" title="F.39. tcn" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 11.4文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="contrib.html" title="付録F 追加で提供されるモジュール">付録F 追加で提供されるモジュール</a></td><td width="20%" align="right"></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="sslinfo.html" title="F.37. sslinfo">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="contrib.html" title="付録F 追加で提供されるモジュール">上へ</a></td><td width="60%" align="center">F.38. tablefunc</td><td width="20%" align="right"> <a accesskey="n" href="tcn.html" title="F.39. tcn">次へ</a></td></tr></table><hr /></div><div class="sect1" id="TABLEFUNC"><div class="titlepage"><div><div><h2 class="title" style="clear: both">F.38. tablefunc</h2></div></div></div><a id="id-1.11.7.47.2" class="indexterm"></a><p>
<!--
  The <filename>tablefunc</filename> module includes various functions that return
  tables (that is, multiple rows).  These functions are useful both in their
  own right and as examples of how to write C functions that return
  multiple rows.
-->
<code class="filename">tablefunc</code>モジュールにはテーブル（つまり複数行）を返す各種関数があります。
これらの関数は、その独自の目的として、および、複数行を返すC関数の作成方法を示す例として、有用です。
 </p><div class="sect2" id="id-1.11.7.47.4"><div class="titlepage"><div><div><h3 class="title">F.38.1. 提供される関数</h3></div></div></div><!--
  <title>Functions Provided</title>
--><p>
<!--
   <xref linkend="tablefunc-functions"/> shows the functions provided
   by the <filename>tablefunc</filename> module.
-->
  <code class="filename">tablefunc</code>モジュールにより提供される関数を<a class="xref" href="tablefunc.html#TABLEFUNC-FUNCTIONS" title="表F.30 tablefuncの関数">表 F.30</a>に示します。
  </p><div class="table" id="TABLEFUNC-FUNCTIONS"><p class="title"><strong>表F.30 <code class="filename">tablefunc</code>の関数</strong></p><div class="table-contents"><!--
   <title><filename>tablefunc</filename> Functions</title>
--><table class="table" summary="tablefuncの関数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>関数</th><th>戻り値</th><th>説明</th></tr></thead><tbody><tr><td><code class="function">normal_rand(int numvals, float8 mean, float8 stddev)</code></td><td><code class="type">setof float8</code></td><td>
<!--
       Produces a set of normally distributed random values
-->
正規分布乱数値の集合を生成します。
      </td></tr><tr><td><code class="function">crosstab(text sql)</code></td><td><code class="type">setof record</code></td><td>
<!--
       Produces a <quote>pivot table</quote> containing
       row names plus <replaceable>N</replaceable> value columns, where
       <replaceable>N</replaceable> is determined by the row type specified in the calling
       query
-->
行の名前と<em class="replaceable"><code>N</code></em>個の値列からなる<span class="quote">「<span class="quote">ピボット表</span>」</span>を生成します。
ここで<em class="replaceable"><code>N</code></em>は呼出元の問い合わせで指定される行型で決定します。
      </td></tr><tr><td><code class="function">crosstab<em class="replaceable"><code>N</code></em>(text sql)</code></td><td><code class="type">setof table_crosstab_<em class="replaceable"><code>N</code></em></code></td><td>
<!--
       Produces a <quote>pivot table</quote> containing
       row names plus <replaceable>N</replaceable> value columns.
       <function>crosstab2</function>, <function>crosstab3</function>, and
       <function>crosstab4</function> are predefined, but you can create additional
       <function>crosstab<replaceable>N</replaceable></function> functions as described below
-->
行の名前と<em class="replaceable"><code>N</code></em>個の値列からなる<span class="quote">「<span class="quote">ピボット表</span>」</span>を生成します。
<code class="function">crosstab2</code>、<code class="function">crosstab3</code>、<code class="function">crosstab4</code>が定義されていますが、後述する手順で追加の<code class="function">crosstab<em class="replaceable"><code>N</code></em></code>関数を作成することが可能です。
      </td></tr><tr><td><code class="function">crosstab(text source_sql, text category_sql)</code></td><td><code class="type">setof record</code></td><td>
<!--
       Produces a <quote>pivot table</quote>
       with the value columns specified by a second query
-->
2番目の問い合わせで指定された値列を持つ<span class="quote">「<span class="quote">ピボット表</span>」</span>を生成します。
      </td></tr><tr><td><code class="function">crosstab(text sql, int N)</code></td><td><code class="type">setof record</code></td><td>
<!--
       <para>Obsolete version of <function>crosstab(text)</function>.
        The parameter <replaceable>N</replaceable> is now ignored, since the number of
        value columns is always determined by the calling query
-->
       <p>
廃止予定の<code class="function">crosstab(text)</code>です。
値列の数は呼び出す問い合わせで常に決まりますので、現在引数Nは無視されます。
       </p>
      </td></tr><tr><td>
       <code class="function">
        connectby(text relname, text keyid_fld, text parent_keyid_fld
        [, text orderby_fld ], text start_with, int max_depth
        [, text branch_delim ])
       </code>
       <a id="id-1.11.7.47.4.3.2.2.6.1.2" class="indexterm"></a>
      </td><td><code class="type">setof record</code></td><td>
<!--
       Produces a representation of a hierarchical tree structure
-->
階層ツリー構造表現を生成します。
      </td></tr></tbody></table></div></div><br class="table-break" /><div class="sect3" id="id-1.11.7.47.4.4"><div class="titlepage"><div><div><h4 class="title">F.38.1.1. <code class="function">normal_rand</code></h4></div></div></div><a id="id-1.11.7.47.4.4.2" class="indexterm"></a><pre class="synopsis">
normal_rand(int numvals, float8 mean, float8 stddev) returns setof float8
</pre><p>
<!--
     <function>normal_rand</function> produces a set of normally distributed random
     values (Gaussian distribution).
-->
<code class="function">normal_rand</code>は正規乱数値の集合（ガウス分布）を生成します。
    </p><p>
<!--
     <parameter>numvals</parameter> is the number of values to be returned
     from the function. <parameter>mean</parameter> is the mean of the normal
     distribution of values and <parameter>stddev</parameter> is the standard
     deviation of the normal distribution of values.
-->
ここで<em class="parameter"><code>numvals</code></em>はこの関数が返す値の数です。
<em class="parameter"><code>mean</code></em>は正規分布の平均値、<em class="parameter"><code>stddev</code></em>は正規分布値の標準偏差です。
    </p><p>
<!--
     For example, this call requests 1000 values with a mean of 5 and a
     standard deviation of 3:
-->
例えば、以下の呼出しは、平均5、標準偏差3で1000個の値を要求します。
    </p><pre class="screen">
test=# SELECT * FROM normal_rand(1000, 5, 3);
     normal_rand
----------------------
     1.56556322244898
     9.10040991424657
     5.36957140345079
   -0.369151492880995
    0.283600703686639
       .
       .
       .
     4.82992125404908
     9.71308014517282
     2.49639286969028
(1000 rows)
</pre></div><div class="sect3" id="id-1.11.7.47.4.5"><div class="titlepage"><div><div><h4 class="title">F.38.1.2. <code class="function">crosstab(text)</code></h4></div></div></div><a id="id-1.11.7.47.4.5.2" class="indexterm"></a><pre class="synopsis">
crosstab(text sql)
crosstab(text sql, int N)
</pre><p>
<!--
    The <function>crosstab</function> function is used to produce <quote>pivot</quote>
    displays, wherein data is listed across the page rather than down.
    For example, we might have data like
-->
<code class="function">crosstab</code>関数は<span class="quote">「<span class="quote">ピボット</span>」</span>表示を生成するために使用されます。
ここでは、データは下方向にではなくページ横方向に渡って列挙されます。
例えば、以下のようなデータがあるとします。
</p><pre class="programlisting">
row1    val11
row1    val12
row1    val13
...
row2    val21
row2    val22
row2    val23
...
</pre><p>
<!--
    which we wish to display like
-->
これを次のように表示したいとします。
</p><pre class="programlisting">
row1    val11   val12   val13   ...
row2    val21   val22   val23   ...
...
</pre><p>
<!--
    The <function>crosstab</function> function takes a text parameter that is a SQL
    query producing raw data formatted in the first way, and produces a table
    formatted in the second way.
-->
<code class="function">crosstab</code>関数は、最初のような書式を持つ生データを生成するSQL問い合わせとなるテキストパラメータを取り、2番目のような書式を持つテーブルを生成します。
   </p><p>
<!--
    The <parameter>sql</parameter> parameter is a SQL statement that produces
    the source set of data. This statement must return one
    <structfield>row_name</structfield> column, one
    <structfield>category</structfield> column, and one
    <structfield>value</structfield> column.  <parameter>N</parameter> is an
    obsolete parameter, ignored if supplied (formerly this had to match the
    number of output value columns, but now that is determined by the
    calling query).
-->
<em class="parameter"><code>sql</code></em>パラメータは元となるデータ集合を生成するSQL文です。
この文は<code class="structfield">row_name</code>列を1つ、<code class="structfield">category</code>列を1つ、<code class="structfield">value</code>列を1つ返さなければなりません。
<em class="parameter"><code>N</code></em>は廃れたパラメータであり、指定されたとしても無視されます。
（これまでは、これは出力値列の数と一致する必要がありました。しかし、現在これは呼び出し元の問い合わせにより決まります。）
   </p><p>
<!--
    For example, the provided query might produce a set something like:
-->
例：指定したSQLは以下のような集合を生成しても構いません。
</p><pre class="programlisting">
 row_name    cat    value
----------+-------+-------
  row1      cat1    val1
  row1      cat2    val2
  row1      cat3    val3
  row1      cat4    val4
  row2      cat1    val5
  row2      cat2    val6
  row2      cat3    val7
  row2      cat4    val8
</pre><p>
   </p><p>
<!--
    The <function>crosstab</function> function is declared to return <type>setof
    record</type>, so the actual names and types of the output columns must be
    defined in the <literal>FROM</literal> clause of the calling <command>SELECT</command>
    statement, for example:
-->
<code class="function">crosstab</code>関数は<code class="type">setof record</code>を返すものとして宣言されています。
このため、出力列の実際の名前と型を呼び出し元の<code class="command">SELECT</code>文の<code class="literal">FROM</code>内で宣言しなければなりません。
以下に例を示します。
</p><pre class="programlisting">
SELECT * FROM crosstab('...') AS ct(row_name text, category_1 text, category_2 text);
</pre><p>
<!--
    This example produces a set something like:
-->
この例は以下のような集合を生成します。
</p><pre class="programlisting">
           &lt;== value  columns  ==&gt;
 row_name   category_1   category_2
----------+------------+------------
  row1        val1         val2
  row2        val5         val6
</pre><p>
   </p><p>
<!--
    The <literal>FROM</literal> clause must define the output as one
    <structfield>row_name</structfield> column (of the same data type as the first result
    column of the SQL query) followed by N <structfield>value</structfield> columns
    (all of the same data type as the third result column of the SQL query).
    You can set up as many output value columns as you wish.  The names of the
    output columns are up to you.
-->
<code class="literal">FROM</code>句は出力を1つの<code class="structfield">row_name</code>列（SQL問い合わせの最初の結果列と同一データ型）と続くN個の<code class="structfield">value</code>列（SQL問い合わせの3番目の結果列とすべて同じデータ型）を持つものとして定義しなければなりません。
必要なだけの個数の値列を出力するように設定することができます。
出力列の名前は使用者に任されています。
   </p><p>
<!--
    The <function>crosstab</function> function produces one output row for each
    consecutive group of input rows with the same
    <structfield>row_name</structfield> value.  It fills the output
    <structfield>value</structfield> columns, left to right, with the
    <structfield>value</structfield> fields from these rows.  If there
    are fewer rows in a group than there are output <structfield>value</structfield>
    columns, the extra output columns are filled with nulls; if there are
    more rows, the extra input rows are skipped.
-->
<code class="function">crosstab</code>関数は、同じ<code class="structfield">row_name</code>値を持つ入力行の各連続的なグループに対して、1つの出力行を生成します。
左から右へこれらの行の<code class="structfield">value</code>フィールドで出力<code class="structfield">value</code>列を埋めていきます。
もしグループ内の行が存在する出力<code class="structfield">value</code>列より少なければ、余った出力列はNULLになります。
もし行が多ければ、余った入力行は無視されます。
   </p><p>
<!--
    In practice the SQL query should always specify <literal>ORDER BY 1,2</literal>
    to ensure that the input rows are properly ordered, that is, values with
    the same <structfield>row_name</structfield> are brought together and
    correctly ordered within the row.  Notice that <function>crosstab</function>
    itself does not pay any attention to the second column of the query
    result; it's just there to be ordered by, to control the order in which
    the third-column values appear across the page.
-->
実際のところ、入力行の順序が適切になるように、つまり、同じ<code class="structfield">row_name</code>を持つ値がまとまり、行内で正しく順序付けられるように、SQL問い合わせは常に<code class="literal">ORDER BY 1,2</code>を指定しなければなりません。
<code class="function">crosstab</code>自体が問い合わせ結果の2番目の列に注意を払わないことに注意してください。
これは順序付けのため、3番目の列の値がページに渡って現れる順序を制御するためだけに存在します。
   </p><p>
<!--
    Here is a complete example:
-->
以下に複雑な例を示します。
</p><pre class="programlisting">
CREATE TABLE ct(id SERIAL, rowid TEXT, attribute TEXT, value TEXT);
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att1','val1');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att2','val2');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att3','val3');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att4','val4');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att1','val5');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att2','val6');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att3','val7');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att4','val8');

SELECT *
FROM crosstab(
  'select rowid, attribute, value
   from ct
   where attribute = ''att2'' or attribute = ''att3''
   order by 1,2')
AS ct(row_name text, category_1 text, category_2 text, category_3 text);

 row_name | category_1 | category_2 | category_3
----------+------------+------------+------------
 test1    | val2       | val3       |
 test2    | val6       | val7       |
(2 rows)
</pre><p>
   </p><p>
<!--
    You can avoid always having to write out a <literal>FROM</literal> clause to
    define the output columns, by setting up a custom crosstab function that
    has the desired output row type wired into its definition.  This is
    described in the next section.  Another possibility is to embed the
    required <literal>FROM</literal> clause in a view definition.
-->
必要な出力行型をその定義に反映した独自のcrosstab関数を構築することで、常に出力列を定義するための<code class="literal">FROM</code>句を書く必要性をなくすことができます。
これは次節で説明します。
他にも必要な<code class="literal">FROM</code>句をビュー定義に埋め込むことでも実現可能です。
   </p><div class="note"><h3 class="title">注記</h3><p>
<!--
     See also the <command><link linkend="app-psql-meta-commands-crosstabview">\crosstabview</link></command>
     command in <application>psql</application>, which provides functionality similar
     to <function>crosstab()</function>.
-->
<span class="application">psql</span>の<code class="command"><a class="link" href="app-psql.html#APP-PSQL-META-COMMANDS-CROSSTABVIEW">\crosstabview</a></code>コマンドも参照してください。<code class="function">crosstab()</code>と類似の機能を提供します。
    </p></div></div><div class="sect3" id="id-1.11.7.47.4.6"><div class="titlepage"><div><div><h4 class="title">F.38.1.3. <code class="function">crosstab<em class="replaceable"><code>N</code></em>(text)</code></h4></div></div></div><a id="id-1.11.7.47.4.6.2" class="indexterm"></a><pre class="synopsis">
crosstab<em class="replaceable"><code>N</code></em>(text sql)
</pre><p>
<!--
     The <function>crosstab<replaceable>N</replaceable></function> functions are examples of how
     to set up custom wrappers for the general <function>crosstab</function> function,
     so that you need not write out column names and types in the calling
     <command>SELECT</command> query.  The <filename>tablefunc</filename> module includes
     <function>crosstab2</function>, <function>crosstab3</function>, and
     <function>crosstab4</function>, whose output row types are defined as
-->
<code class="function">crosstab<em class="replaceable"><code>N</code></em></code>関数は、呼び出し元の<code class="command">SELECT</code>問い合わせで列名と型を書き出す必要性をなくすことができるように、一般的な<code class="function">crosstab</code>関数に対する独自のラッパを構築する方法の例です。
<code class="filename">tablefunc</code>モジュールには、次のように出力行型が定義された<code class="function">crosstab2</code>、<code class="function">crosstab3</code>、<code class="function">crosstab4</code>が含まれています。
    </p><pre class="programlisting">
CREATE TYPE tablefunc_crosstab_N AS (
    row_name TEXT,
    category_1 TEXT,
    category_2 TEXT,
        .
        .
        .
    category_N TEXT
);
</pre><p>
<!--
     Thus, these functions can be used directly when the input query produces
     <structfield>row_name</structfield> and <structfield>value</structfield> columns of type
     <type>text</type>, and you want 2, 3, or 4 output values columns.
     In all other ways they behave exactly as described above for the
     general <function>crosstab</function> function.
-->
このように、入力問い合わせが<code class="type">text</code>型の<code class="structfield">row_name</code>列と<code class="structfield">value</code>列を生成し、かつ、2、3、または4個の出力値列を持つ場合、これらの関数を直接使用することができます。
この他の点はすべて、上述の一般的な<code class="function">crosstab</code>関数で説明した通りの動作をします。
    </p><p>
<!--
     For instance, the example given in the previous section would also
     work as
-->
例えば、上で挙げた例は下のように動作します。
</p><pre class="programlisting">
SELECT *
FROM crosstab3(
  'select rowid, attribute, value
   from ct
   where attribute = ''att2'' or attribute = ''att3''
   order by 1,2');
</pre><p>
    </p><p>
<!--
     These functions are provided mostly for illustration purposes. You
     can create your own return types and functions based on the
     underlying <function>crosstab()</function> function.  There are two ways
     to do it:
-->
これらの関数はほぼ説明を目的として提供されたものです。
背後の<code class="function">crosstab()</code>関数に基いた独自の戻り型と関数を作成することができます。
独自のcrosstab関数を構築する方法は2つあります。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<!--
       Create a composite type describing the desired output columns,
       similar to the examples in
       <filename>contrib/tablefunc/tablefunc&#045;&#045;1.0.sql</filename>.
       Then define a
       unique function name accepting one <type>text</type> parameter and returning
       <type>setof your_type_name</type>, but linking to the same underlying
       <function>crosstab</function> C function.  For example, if your source data
       produces row names that are <type>text</type>, and values that are
       <type>float8</type>, and you want 5 value columns:
-->
<code class="filename">contrib/tablefunc/tablefunc--1.0.sql</code>の例と同様にして、必要な出力列を記述する複合型を作成します。
そして、<code class="type">text</code>型のパラメータを1つ取り、<code class="type">setof your_type_name</code>を返す一意な名前の関数を、同じ背後の<code class="function">crosstab</code> C関数をリンクさせて定義します。
例えば、元データが行名として<code class="type">text</code>型を、値として<code class="type">float8</code>を生成し、5つの値列を希望する場合、以下のようになります。
</p><pre class="programlisting">
CREATE TYPE my_crosstab_float8_5_cols AS (
    my_row_name text,
    my_category_1 float8,
    my_category_2 float8,
    my_category_3 float8,
    my_category_4 float8,
    my_category_5 float8
);

CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(text)
    RETURNS setof my_crosstab_float8_5_cols
    AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;
</pre><p>
      </p></li><li class="listitem"><p>
<!--
       Use <literal>OUT</literal> parameters to define the return type implicitly.
       The same example could also be done this way:
-->
暗黙的に戻り値の型を定義する場合は<code class="literal">OUT</code>パラメータを使用してください。
同じ例を以下のように書くこともできます。
</p><pre class="programlisting">
CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(
    IN text,
    OUT my_row_name text,
    OUT my_category_1 float8,
    OUT my_category_2 float8,
    OUT my_category_3 float8,
    OUT my_category_4 float8,
    OUT my_category_5 float8)
  RETURNS setof record
  AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;
</pre><p>
      </p></li></ul></div><p>
    </p></div><div class="sect3" id="id-1.11.7.47.4.7"><div class="titlepage"><div><div><h4 class="title">F.38.1.4. <code class="function">crosstab(text, text)</code></h4></div></div></div><a id="id-1.11.7.47.4.7.2" class="indexterm"></a><pre class="synopsis">
crosstab(text source_sql, text category_sql)
</pre><p>
<!--
    The main limitation of the single-parameter form of <function>crosstab</function>
    is that it treats all values in a group alike, inserting each value into
    the first available column.  If you want the value
    columns to correspond to specific categories of data, and some groups
    might not have data for some of the categories, that doesn't work well.
    The two-parameter form of <function>crosstab</function> handles this case by
    providing an explicit list of the categories corresponding to the
    output columns.
-->
単一パラメータの<code class="function">crosstab</code>構文の大きな制限は、各値を最初の利用可能な列に挿入して、すべての値をグループのように扱う点です。
値列を特定のデータカテゴリに対応させ、グループの一部はカテゴリの一部のデータを持たない可能性がある場合は、うまく動作しません。
2パラメータを取る<code class="function">crosstab</code>構文は、出力列に対応するカテゴリのリストを明示的に提供することで、こうした状況を扱います。
   </p><p>
<!--
    <parameter>source_sql</parameter> is a SQL statement that produces the
    source set of data.  This statement must return one
    <structfield>row_name</structfield> column, one
    <structfield>category</structfield> column, and one
    <structfield>value</structfield> column. It may also have one or more
    <quote>extra</quote> columns.
    The <structfield>row_name</structfield> column must be first. The
    <structfield>category</structfield> and <structfield>value</structfield>
    columns must be the last two columns, in that order.  Any columns between
    <structfield>row_name</structfield> and
    <structfield>category</structfield> are treated as <quote>extra</quote>.
    The <quote>extra</quote> columns are expected to be the same for all rows
    with the same <structfield>row_name</structfield> value.
-->
<em class="parameter"><code>source_sql</code></em>は元となるデータ集合を生成するSQL文です。
このSQL文は<code class="structfield">row_name</code>列を1つ<code class="structfield">category</code>列を1つ、<code class="structfield">value</code>列を1つ返さなければなりません。
また1つ以上の<span class="quote">「<span class="quote">追加</span>」</span>の列を持つこともできます。
<code class="structfield">row_name</code>列が先頭でなければなりません。
<code class="structfield">category</code>と<code class="structfield">value</code>列は、この順番で最後の2列でなければなりません。
<code class="structfield">row_name</code>と<code class="structfield">category</code>との間の列はすべて<span class="quote">「<span class="quote">追加</span>」</span>の列とみなされます。
<span class="quote">「<span class="quote">追加</span>」</span>の列は同じ<code class="structfield">row_name</code>値を持つ行すべてで同一であるということが前提です。
   </p><p>
<!--
    For example, <parameter>source_sql</parameter> might produce a set
    something like:
-->
例えば、<em class="parameter"><code>source_sql</code></em>は以下のような集合を生成しなければなりません。
</p><pre class="programlisting">
SELECT row_name, extra_col, cat, value FROM foo ORDER BY 1;

 row_name    extra_col   cat    value
----------+------------+-----+---------
  row1         extra1    cat1    val1
  row1         extra1    cat2    val2
  row1         extra1    cat4    val4
  row2         extra2    cat1    val5
  row2         extra2    cat2    val6
  row2         extra2    cat3    val7
  row2         extra2    cat4    val8
</pre><p>
   </p><p>
<!--
    <parameter>category_sql</parameter> is a SQL statement that produces
    the set of categories. This statement must return only one column.
    It must produce at least one row, or an error will be generated.
    Also, it must not produce duplicate values, or an error will be
    generated.  <parameter>category_sql</parameter> might be something like:
-->
<em class="parameter"><code>category_sql</code></em>はカテゴリの集合を生成するSQL文でなければなりません。
このSQL文は1つの列のみを返さなければなりません。
また、少なくとも1つの結果行を生成しなければならず、さもないと、エラーになります。
さらに重複するカテゴリを生成してはなりません。
さもないとエラーとなります。
<em class="parameter"><code>category_sql</code></em>は以下のようなものになります。

</p><pre class="programlisting">
SELECT DISTINCT cat FROM foo ORDER BY 1;
    cat
  -------
    cat1
    cat2
    cat3
    cat4
</pre><p>
   </p><p>
<!--
    The <function>crosstab</function> function is declared to return <type>setof
    record</type>, so the actual names and types of the output columns must be
    defined in the <literal>FROM</literal> clause of the calling <command>SELECT</command>
    statement, for example:
-->
<code class="function">crosstab</code>関数は<code class="type">setof record</code>を返すものとして宣言されていますので、出力列の実際の名前と型を、以下の例のように、呼出元の<code class="command">SELECT</code>の<code class="literal">FROM</code>句で定義しなければなりません。

</p><pre class="programlisting">
SELECT * FROM crosstab('...', '...')
    AS ct(row_name text, extra text, cat1 text, cat2 text, cat3 text, cat4 text);
</pre><p>
   </p><p>
<!--
    This will produce a result something like:
-->
これは以下のような集合を生成します。
</p><pre class="programlisting">
                  &lt;==  value  columns   ==&gt;
row_name   extra   cat1   cat2   cat3   cat4
---------+-------+------+------+------+------
  row1     extra1  val1   val2          val4
  row2     extra2  val5   val6   val7   val8
</pre><p>
   </p><p>
<!--
    The <literal>FROM</literal> clause must define the proper number of output
    columns of the proper data types.  If there are <replaceable>N</replaceable>
    columns in the <parameter>source_sql</parameter> query's result, the first
    <replaceable>N</replaceable>-2 of them must match up with the first
    <replaceable>N</replaceable>-2 output columns.  The remaining output columns
    must have the type of the last column of the <parameter>source_sql</parameter>
    query's result, and there must be exactly as many of them as there
    are rows in the <parameter>category_sql</parameter> query's result.
-->
<code class="literal">FROM</code>句は、出力列の適切な個数、およびその適切なデータ型を定義しなければなりません。
<em class="parameter"><code>source_sql</code></em>問い合わせ結果に<em class="replaceable"><code>N</code></em>個の列がある場合、最初の<em class="replaceable"><code>N</code></em>-2は最初の<em class="replaceable"><code>N</code></em>-2出力列と一致しなければなりません。
残りの出力列は<em class="parameter"><code>source_sql</code></em>問い合わせ結果の最後の列の型を持たなければならず、かつ、<em class="parameter"><code>category_sql</code></em>問い合わせ結果内の行と同じ個数でなければなりません。
   </p><p>
<!--
    The <function>crosstab</function> function produces one output row for each
    consecutive group of input rows with the same
    <structfield>row_name</structfield> value.  The output
    <structfield>row_name</structfield> column, plus any <quote>extra</quote>
    columns, are copied from the first row of the group.  The output
    <structfield>value</structfield> columns are filled with the
    <structfield>value</structfield> fields from rows having matching
    <structfield>category</structfield> values.  If a row's <structfield>category</structfield>
    does not match any output of the <parameter>category_sql</parameter>
    query, its <structfield>value</structfield> is ignored.  Output
    columns whose matching category is not present in any input row
    of the group are filled with nulls.
-->
<code class="function">crosstab</code>関数は、同一<code class="structfield">row_name</code>値を持つ入力行の連続したグループ毎に1つの出力行を生成します。
<code class="structfield">row_name</code>出力列と任意の<span class="quote">「<span class="quote">追加</span>」</span>列はグループの最初の行からコピーされます。
<code class="structfield">value</code>出力列は、<code class="structfield">category</code>値と一致する行の<code class="structfield">value</code>で埋められます。
行の<code class="structfield">category</code>が<em class="parameter"><code>category_sql</code></em>問い合わせの出力とまったく一致しなかった場合、その<code class="structfield">value</code>は無視されます。
グループの入力行内にまったくカテゴリに一致する出力列が存在しない場合、NULLで埋められます。
   </p><p>
<!--
    In practice the <parameter>source_sql</parameter> query should always
    specify <literal>ORDER BY 1</literal> to ensure that values with the same
    <structfield>row_name</structfield> are brought together.  However,
    ordering of the categories within a group is not important.
    Also, it is essential to be sure that the order of the
    <parameter>category_sql</parameter> query's output matches the specified
    output column order.
-->
実際は、同じ<code class="structfield">row_name</code>を持つ値をまとめられるように、<em class="parameter"><code>source_sql</code></em>問い合わせでは常に<code class="literal">ORDER BY 1</code>を指定すべきです。
しかし、グループ内のカテゴリの順序は重要ではありません。
また、<em class="parameter"><code>category_sql</code></em>問い合わせの出力順序が指定された出力列の順序と一致することを確実にすることが重要です。
   </p><p>
<!--
    Here are two complete examples:
-->
以下に複雑な例を2つ示します。
</p><pre class="programlisting">
create table sales(year int, month int, qty int);
insert into sales values(2007, 1, 1000);
insert into sales values(2007, 2, 1500);
insert into sales values(2007, 7, 500);
insert into sales values(2007, 11, 1500);
insert into sales values(2007, 12, 2000);
insert into sales values(2008, 1, 1000);

select * from crosstab(
  'select year, month, qty from sales order by 1',
  'select m from generate_series(1,12) m'
) as (
  year int,
  "Jan" int,
  "Feb" int,
  "Mar" int,
  "Apr" int,
  "May" int,
  "Jun" int,
  "Jul" int,
  "Aug" int,
  "Sep" int,
  "Oct" int,
  "Nov" int,
  "Dec" int
);
 year | Jan  | Feb  | Mar | Apr | May | Jun | Jul | Aug | Sep | Oct | Nov  | Dec
------+------+------+-----+-----+-----+-----+-----+-----+-----+-----+------+------
 2007 | 1000 | 1500 |     |     |     |     | 500 |     |     |     | 1500 | 2000
 2008 | 1000 |      |     |     |     |     |     |     |     |     |      |
(2 rows)
</pre><p>

</p><pre class="programlisting">
CREATE TABLE cth(rowid text, rowdt timestamp, attribute text, val text);
INSERT INTO cth VALUES('test1','01 March 2003','temperature','42');
INSERT INTO cth VALUES('test1','01 March 2003','test_result','PASS');
INSERT INTO cth VALUES('test1','01 March 2003','volts','2.6987');
INSERT INTO cth VALUES('test2','02 March 2003','temperature','53');
INSERT INTO cth VALUES('test2','02 March 2003','test_result','FAIL');
INSERT INTO cth VALUES('test2','02 March 2003','test_startdate','01 March 2003');
INSERT INTO cth VALUES('test2','02 March 2003','volts','3.1234');

SELECT * FROM crosstab
(
  'SELECT rowid, rowdt, attribute, val FROM cth ORDER BY 1',
  'SELECT DISTINCT attribute FROM cth ORDER BY 1'
)
AS
(
       rowid text,
       rowdt timestamp,
       temperature int4,
       test_result text,
       test_startdate timestamp,
       volts float8
);
 rowid |          rowdt           | temperature | test_result |      test_startdate      | volts
-------+--------------------------+-------------+-------------+--------------------------+--------
 test1 | Sat Mar 01 00:00:00 2003 |          42 | PASS        |                          | 2.6987
 test2 | Sun Mar 02 00:00:00 2003 |          53 | FAIL        | Sat Mar 01 00:00:00 2003 | 3.1234
(2 rows)
</pre><p>
   </p><p>
<!--
    You can create predefined functions to avoid having to write out
    the result column names and types in each query.  See the examples
    in the previous section.  The underlying C function for this form
    of <function>crosstab</function> is named <literal>crosstab_hash</literal>.
-->
各問い合わせで結果列の名前と型を記述する必要性をなくすために、事前定義した関数を作成することができます。
前節の例を参照してください。
この<code class="function">crosstab</code>構文用の背後のC関数は<code class="literal">crosstab_hash</code>という名前です。
   </p></div><div class="sect3" id="id-1.11.7.47.4.8"><div class="titlepage"><div><div><h4 class="title">F.38.1.5. <code class="function">connectby</code></h4></div></div></div><a id="id-1.11.7.47.4.8.2" class="indexterm"></a><pre class="synopsis">
connectby(text relname, text keyid_fld, text parent_keyid_fld
          [, text orderby_fld ], text start_with, int max_depth
          [, text branch_delim ])
</pre><p>
<!--
    The <function>connectby</function> function produces a display of hierarchical
    data that is stored in a table.  The table must have a key field that
    uniquely identifies rows, and a parent-key field that references the
    parent (if any) of each row.  <function>connectby</function> can display the
    sub-tree descending from any row.
-->
<code class="function">connectby</code>関数はテーブル内に格納された階層データ表示を生成します。
テーブルは行を一意に識別するキーフィールドと各行の親（もしあれば）を参照する親キーフィールドを持たなければなりません。
<code class="function">connectby</code>は任意の行から辿った部分ツリーを表示することができます。
   </p><p>
<!--
    <xref linkend="tablefunc-connectby-parameters"/> explains the
    parameters.
-->
<a class="xref" href="tablefunc.html#TABLEFUNC-CONNECTBY-PARAMETERS" title="表F.31 connectbyパラメータ">表 F.31</a>ではパラメータを解説します。
   </p><div class="table" id="TABLEFUNC-CONNECTBY-PARAMETERS"><p class="title"><strong>表F.31 <code class="function">connectby</code>パラメータ</strong></p><div class="table-contents"><!--
    <title><function>connectby</function> Parameters</title>
--><table class="table" summary="connectbyパラメータ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>パラメータ</th><th>説明</th></tr></thead><tbody><tr><td><em class="parameter"><code>relname</code></em></td><td>元となるリレーション名</td></tr><tr><td><em class="parameter"><code>keyid_fld</code></em></td><td>キーフィールドの名前</td></tr><tr><td><em class="parameter"><code>parent_keyid_fld</code></em></td><td>親のキーフィールドの名前</td></tr><tr><td><em class="parameter"><code>orderby_fld</code></em></td><td>兄弟の順序付け用のフィールド名（省略可能）</td></tr><tr><td><em class="parameter"><code>start_with</code></em></td><td>開始行のキー値</td></tr><tr><td><em class="parameter"><code>max_depth</code></em></td><td>辿る深さに対する制限。無制限の場合はゼロ</td></tr><tr><td><em class="parameter"><code>branch_delim</code></em></td><td>キーと分岐出力で区切る文字列（省略可能）</td></tr></tbody></table></div></div><br class="table-break" /><p>
<!--
     The key and parent-key fields can be any data type, but they must be
     the same type.  Note that the <parameter>start_with</parameter> value must be
     entered as a text string, regardless of the type of the key field.
-->
キーおよび親キーフィールドは任意のデータ型を取ることができますが、これらは同じデータ型でなければなりません。
キーフィールドのデータ型に関係なく、<em class="parameter"><code>start_with</code></em>はテキスト文字列として入力されなければならないことに注意してください。
    </p><p>
<!--
     The <function>connectby</function> function is declared to return <type>setof
     record</type>, so the actual names and types of the output columns must be
     defined in the <literal>FROM</literal> clause of the calling <command>SELECT</command>
     statement, for example:
-->
<code class="function">connectby</code>関数は<code class="type">setof record</code>を返すものとして宣言されていますので、以下の例のように、出力列の実際の名前と型を呼出し元の<code class="command">SELECT</code>文の<code class="literal">FROM</code>句で定義しなければなりません。
    </p><pre class="programlisting">
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
    AS t(keyid text, parent_keyid text, level int, branch text, pos int);
</pre><p>
<!--
     The first two output columns are used for the current row's key and
     its parent row's key; they must match the type of the table's key field.
     The third output column is the depth in the tree and must be of type
     <type>integer</type>.  If a <parameter>branch_delim</parameter> parameter was
     given, the next output column is the branch display and must be of type
     <type>text</type>.  Finally, if an <parameter>orderby_fld</parameter>
     parameter was given, the last output column is a serial number, and must
     be of type <type>integer</type>.
-->
先頭から2つの出力列は、現在の行のキーおよび親行のキーとして使用されます。
これらはテーブルのキーフィールドのデータ型と一致する必要があります。
3番目の出力列はツリーの深さであり、<code class="type">integer</code>型である必要があります。
<em class="parameter"><code>branch_delim</code></em>パラメータが与えられた場合、次の出力列は分岐表示であり、<code class="type">text</code>型である必要があります。
最後に、<em class="parameter"><code>orderby_fld</code></em>パラメータが与えられた場合、最後の出力列は連番であり、<code class="type">integer</code>型である必要があります。
    </p><p>
<!--
     The <quote>branch</quote> output column shows the path of keys taken to
     reach the current row.  The keys are separated by the specified
     <parameter>branch_delim</parameter> string.  If no branch display is
     wanted, omit both the <parameter>branch_delim</parameter> parameter
     and the branch column in the output column list.
-->
<span class="quote">「<span class="quote">分岐</span>」</span>出力列は現在の行まで達するために取られるキーの経路を示します。
キーは指定された<em class="parameter"><code>branch_delim</code></em>文字列で区切られます。
分岐表示が不要ならば、<em class="parameter"><code>branch_delim</code></em>パラメータと出力列リスト内の分岐列を省略してください。
    </p><p>
<!--
     If the ordering of siblings of the same parent is important,
     include the <parameter>orderby_fld</parameter> parameter to
     specify which field to order siblings by.  This field can be of any
     sortable data type.  The output column list must include a final
     integer serial-number column, if and only if
     <parameter>orderby_fld</parameter> is specified.
-->
同じ親を持つ兄弟の順序が重要な場合、どのフィールドで兄弟の順序付けを行うかを指定する<em class="parameter"><code>orderby_fld</code></em>パラメータを含めてください。
このフィールドは任意のソート可能なデータ型を取ることができます。
<em class="parameter"><code>orderby_fld</code></em>が指定された場合のみ、出力列リストには、最終整数型連番列を含めなければなりません。
    </p><p>
<!--
     The parameters representing table and field names are copied as-is
     into the SQL queries that <function>connectby</function> generates internally.
     Therefore, include double quotes if the names are mixed-case or contain
     special characters.  You may also need to schema-qualify the table name.
-->
テーブルおよびフィールド名を表すパラメータはそのまま<code class="function">connectby</code>が内部的に生成するSQL問い合わせにコピーされます。
したがって、大文字小文字が混在した名前または特殊文字を含む名前の場合は二重引用符で括ってください。
またテーブル名をスキーマで修飾する必要があるかもしれません。
    </p><p>
<!--
     In large tables, performance will be poor unless there is an index on
     the parent-key field.
-->
大規模なテーブルでは、親キーフィールド上にインデックスがないと性能が劣化します。
    </p><p>
<!--
     It is important that the <parameter>branch_delim</parameter> string
     not appear in any key values, else <function>connectby</function> may incorrectly
     report an infinite-recursion error.  Note that if
     <parameter>branch_delim</parameter> is not provided, a default value
     of <literal>~</literal> is used for recursion detection purposes.
-->
<em class="parameter"><code>branch_delim</code></em>文字列がキー値内にまったく出現しないことが重要です。
さもないと、<code class="function">connectby</code>は無限再帰エラーを間違って報告するかもしれません。
<em class="parameter"><code>branch_delim</code></em>が提供されていない場合、再帰を検知するためにデフォルト値<code class="literal">~</code>が使用されます。
     <!--原文コメント That pretty well sucks.  FIXME -->
    </p><p>
<!--
     Here is an example:
-->
以下に例を示します。
</p><pre class="programlisting">
CREATE TABLE connectby_tree(keyid text, parent_keyid text, pos int);

INSERT INTO connectby_tree VALUES('row1',NULL, 0);
INSERT INTO connectby_tree VALUES('row2','row1', 0);
INSERT INTO connectby_tree VALUES('row3','row1', 0);
INSERT INTO connectby_tree VALUES('row4','row2', 1);
INSERT INTO connectby_tree VALUES('row5','row2', 0);
INSERT INTO connectby_tree VALUES('row6','row4', 0);
INSERT INTO connectby_tree VALUES('row7','row3', 0);
INSERT INTO connectby_tree VALUES('row8','row6', 0);
INSERT INTO connectby_tree VALUES('row9','row5', 0);

<!--
&#045;- with branch, without orderby_fld (order of results is not guaranteed)
-->
-- 分岐あり、orderby_fldなし(結果の順序は保証されない)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text);
 keyid | parent_keyid | level |       branch
-------+--------------+-------+---------------------
 row2  |              |     0 | row2
 row4  | row2         |     1 | row2~row4
 row6  | row4         |     2 | row2~row4~row6
 row8  | row6         |     3 | row2~row4~row6~row8
 row5  | row2         |     1 | row2~row5
 row9  | row5         |     2 | row2~row5~row9
(6 rows)

<!--
&#045;- without branch, without orderby_fld (order of results is not guaranteed)
-->
-- 分岐なし、orderby_fldなし(結果の順序は保証されない)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int);
 keyid | parent_keyid | level
-------+--------------+-------
 row2  |              |     0
 row4  | row2         |     1
 row6  | row4         |     2
 row8  | row6         |     3
 row5  | row2         |     1
 row9  | row5         |     2
(6 rows)

<!--
&#045;- with branch, with orderby_fld (notice that row5 comes before row4)
-->
-- 分岐あり、orderby_fldあり(row5がrow4の前に来ていることに注目)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text, pos int);
 keyid | parent_keyid | level |       branch        | pos
-------+--------------+-------+---------------------+-----
 row2  |              |     0 | row2                |   1
 row5  | row2         |     1 | row2~row5           |   2
 row9  | row5         |     2 | row2~row5~row9      |   3
 row4  | row2         |     1 | row2~row4           |   4
 row6  | row4         |     2 | row2~row4~row6      |   5
 row8  | row6         |     3 | row2~row4~row6~row8 |   6
(6 rows)

<!--
&#045;- without branch, with orderby_fld (notice that row5 comes before row4)
-->
-- 分岐なし、orderby_fldあり(row5がrow4の前に来ていることに注目)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int, pos int);
 keyid | parent_keyid | level | pos
-------+--------------+-------+-----
 row2  |              |     0 |   1
 row5  | row2         |     1 |   2
 row9  | row5         |     2 |   3
 row4  | row2         |     1 |   4
 row6  | row4         |     2 |   5
 row8  | row6         |     3 |   6
(6 rows)
</pre><p>
    </p></div></div><div class="sect2" id="id-1.11.7.47.5"><div class="titlepage"><div><div><h3 class="title">F.38.2. 作者</h3></div></div></div><!--
  <title>Author</title>
--><p>
   Joe Conway
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sslinfo.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="contrib.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="tcn.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">F.37. sslinfo </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> F.39. tcn</td></tr></table></div></body></html>