<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>43.10. トリガ関数</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="plpgsql-errors-and-messages.html" title="43.9. エラーとメッセージ" /><link rel="next" href="plpgsql-implementation.html" title="43.11. PL/pgSQLの秘訣" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 11.4文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="plpgsql.html" title="第43章 PL/pgSQL - SQL手続き言語">第43章 <span class="application">PL/pgSQL</span> - <acronym class="acronym">SQL</acronym>手続き言語</a></td><td width="20%" align="right"></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="plpgsql-errors-and-messages.html" title="43.9. エラーとメッセージ">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="plpgsql.html" title="第43章 PL/pgSQL - SQL手続き言語">上へ</a></td><td width="60%" align="center">43.10. トリガ関数</td><td width="20%" align="right"> <a accesskey="n" href="plpgsql-implementation.html" title="43.11. PL/pgSQLの秘訣">次へ</a></td></tr></table><hr /></div><div class="sect1" id="PLPGSQL-TRIGGER"><div class="titlepage"><div><div><h2 class="title" style="clear: both">43.10. トリガ関数</h2></div></div></div><!--
  <title>Trigger Functions</title>
--><a id="id-1.8.8.12.2" class="indexterm"></a><p>
<!--
   <application>PL/pgSQL</application> can be used to define trigger
   functions on data changes or database events.
   A trigger function is created with the <command>CREATE FUNCTION</command>
   command, declaring it as a function with no arguments and a return type of
   <type>trigger</type> (for data change triggers) or
   <type>event_trigger</type> (for database event triggers).
   Special local variables named <varname>TG_<replaceable>something</replaceable></varname> are
   automatically defined to describe the condition that triggered the call.
-->
<span class="application">PL/pgSQL</span>はデータ変更やデータベースのイベントによるトリガ関数の定義に使用できます。
トリガ関数は、<code class="command">CREATE FUNCTION</code>コマンドを使って、(データ変更トリガには)<code class="type">trigger</code>、(データベースイベントトリガには)<code class="type">event_trigger</code>という戻り値の型を持った引数のない関数として作成されます。
その呼出しのトリガの原因となった条件を記述するため、<code class="varname">TG_<em class="replaceable"><code>something</code></em></code>という名前の特別な局所変数が自動的に定義されます。
  </p><div class="sect2" id="PLPGSQL-DML-TRIGGER"><div class="titlepage"><div><div><h3 class="title">43.10.1. データ変更によるトリガ</h3></div></div></div><!--
   <title>Triggers on Data Changes</title>
--><p>
<!--
   A <link linkend="triggers">data change trigger</link> is declared as a
   function with no arguments and a return type of <type>trigger</type>.
   Note that the function must be declared with no arguments even if it
   expects to receive some arguments specified in <command>CREATE TRIGGER</command>
   &mdash; such arguments are passed via <varname>TG_ARGV</varname>, as described
   below.
-->
<a class="link" href="triggers.html" title="第39章 トリガ">データ変更トリガ</a>は<code class="type">trigger</code>という戻り値の型を持った引数のない関数として宣言されます。
その関数は、たとえ、<code class="command">CREATE TRIGGER</code>にて引数を取るものとしていたとしても、引数を持たないものと宣言しなければならないことに注意してください。
トリガの引数は、後述する通り、<code class="varname">TG_ARGV</code>経由で渡されます。
  </p><p>
<!--
   When a <application>PL/pgSQL</application> function is called as a
   trigger, several special variables are created automatically in the
   top-level block. They are:
-->
<span class="application">PL/pgSQL</span>関数がトリガとして呼び出された場合、いくつかの特殊な変数が自動的に最上位レベルのブロックで作成されます。
それらを以下に示します。

   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="varname">NEW</code></span></dt><dd><p>
<!--
       Data type <type>RECORD</type>; variable holding the new
       database row for <command>INSERT</command>/<command>UPDATE</command> operations in row-level
       triggers. This variable is null in statement-level triggers
       and for <command>DELETE</command> operations.
-->
<code class="type">RECORD</code>データ型。
この変数は行レベルのトリガでの<code class="command">INSERT</code>/<code class="command">UPDATE</code>操作によって更新された、新しいデータベースの行を保持します。
文レベルのトリガおよび<code class="command">DELETE</code>操作では、この変数はnullです。
      </p></dd><dt><span class="term"><code class="varname">OLD</code></span></dt><dd><p>
<!--
       Data type <type>RECORD</type>; variable holding the old
       database row for <command>UPDATE</command>/<command>DELETE</command> operations in row-level
       triggers. This variable is null in statement-level triggers
       and for <command>INSERT</command> operations.
-->
<code class="type">RECORD</code>データ型。
この変数は、行レベルのトリガでの<code class="command">UPDATE</code>/<code class="command">DELETE</code>操作によって更新される前のデータベースの行を保持します。
文レベルのトリガおよび<code class="command">INSERT</code>操作では、この変数はnullです。
      </p></dd><dt><span class="term"><code class="varname">TG_NAME</code></span></dt><dd><p>
<!--
       Data type <type>name</type>; variable that contains the name of the trigger actually
       fired.
-->
<code class="type">name</code>データ型。
実際に発行されたトリガの名前を持つ変数。
      </p></dd><dt><span class="term"><code class="varname">TG_WHEN</code></span></dt><dd><p>
<!--
       Data type <type>text</type>; a string of
       <literal>BEFORE</literal>, <literal>AFTER</literal>, or
       <literal>INSTEAD OF</literal>, depending on the trigger's definition.
-->
<code class="type">text</code>データ型。
トリガの定義に依存した<code class="literal">BEFORE</code>、<code class="literal">AFTER</code>、または<code class="literal">INSTEAD OF</code>という文字列。
      </p></dd><dt><span class="term"><code class="varname">TG_LEVEL</code></span></dt><dd><p>
<!--
       Data type <type>text</type>; a string of either
       <literal>ROW</literal> or <literal>STATEMENT</literal>
       depending on the trigger's definition.
-->
<code class="type">text</code>データ型。
トリガの定義に依存した<code class="literal">ROW</code> または <code class="literal">STATEMENT</code>という文字列。
      </p></dd><dt><span class="term"><code class="varname">TG_OP</code></span></dt><dd><p>
<!--
       Data type <type>text</type>; a string of
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, or <literal>TRUNCATE</literal>
       telling for which operation the trigger was fired.
-->
<code class="type">text</code>データ型。
トリガを起動した操作を示す、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、または<code class="literal">TRUNCATE</code>という文字列。
      </p></dd><dt><span class="term"><code class="varname">TG_RELID</code></span></dt><dd><p>
<!--
       Data type <type>oid</type>; the object ID of the table that caused the
       trigger invocation.
-->
<code class="type">oid</code>データ型。
このトリガの呼び出し元になるテーブルのオブジェクトID。
      </p></dd><dt><span class="term"><code class="varname">TG_RELNAME</code></span></dt><dd><p>
<!--
       Data type <type>name</type>; the name of the table that caused the trigger
       invocation. This is now deprecated, and could disappear in a future
       release. Use <literal>TG_TABLE_NAME</literal> instead.
-->
<code class="type">name</code>データ型。
このトリガの呼び出し元になるテーブルの名前。
将来これは廃止されそうです。
代わりに<code class="literal">TG_TABLE_NAME</code>を使用してください。
      </p></dd><dt><span class="term"><code class="varname">TG_TABLE_NAME</code></span></dt><dd><p>
<!--
       Data type <type>name</type>; the name of the table that
       caused the trigger invocation.
-->
<code class="type">name</code>データ型。
このトリガの呼び出し元になるテーブルの名前。
      </p></dd><dt><span class="term"><code class="varname">TG_TABLE_SCHEMA</code></span></dt><dd><p>
<!--
       Data type <type>name</type>; the name of the schema of the
       table that caused the trigger invocation.
-->
<code class="type">name</code>データ型。
このトリガの呼び出し元になるテーブルのスキーマ名。
      </p></dd><dt><span class="term"><code class="varname">TG_NARGS</code></span></dt><dd><p>
<!--
       Data type <type>integer</type>; the number of arguments given to the trigger
       function in the <command>CREATE TRIGGER</command> statement.
-->
<code class="type">integer</code>型。
<code class="command">CREATE TRIGGER</code>文におけるトリガ関数に与えられる引数の数。
      </p></dd><dt><span class="term"><code class="varname">TG_ARGV[]</code></span></dt><dd><p>
<!--
       Data type array of <type>text</type>; the arguments from
       the <command>CREATE TRIGGER</command> statement.
       The index counts from 0. Invalid
       indexes (less than 0 or greater than or equal to <varname>tg_nargs</varname>)
       result in a null value.
-->
<code class="type">text</code>型の配列型。
<code class="command">CREATE TRIGGER</code>文での引数。
このインデックスは0から始まります。
無効なインデックス（0未満や<code class="varname">tg_nargs</code>以上）は、NULL値という結果になります。
      </p></dd></dl></div><p>
  </p><p>
<!--
    A trigger function must return either <symbol>NULL</symbol> or a
    record/row value having exactly the structure of the table the
    trigger was fired for.
-->
トリガ関数はNULLまたは、トリガの発行元になったテーブルの構造を正確に持ったレコード/行を返さなければなりません。
   </p><p>
<!--
    Row-level triggers fired <literal>BEFORE</literal> can return null to signal the
    trigger manager to skip the rest of the operation for this row
    (i.e., subsequent triggers are not fired, and the
    <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> does not occur
    for this row).  If a nonnull
    value is returned then the operation proceeds with that row value.
    Returning a row value different from the original value
    of <varname>NEW</varname> alters the row that will be inserted or
    updated.  Thus, if the trigger function wants the triggering
    action to succeed normally without altering the row
    value, <varname>NEW</varname> (or a value equal thereto) has to be
    returned.  To alter the row to be stored, it is possible to
    replace single values directly in <varname>NEW</varname> and return the
    modified <varname>NEW</varname>, or to build a complete new record/row to
    return.  In the case of a before-trigger
    on <command>DELETE</command>, the returned value has no direct
    effect, but it has to be nonnull to allow the trigger action to
    proceed.  Note that <varname>NEW</varname> is null
    in <command>DELETE</command> triggers, so returning that is
    usually not sensible.  The usual idiom in <command>DELETE</command>
    triggers is to return <varname>OLD</varname>.
-->
<code class="literal">BEFORE</code>として発行された行レベルトリガがNULLを返す場合には、トリガマネージャに実際の行への操作を取りやめるように通知します
（つまり、その後にトリガが発行されず、その<code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code>はその行に対して実行されません）。
非NULL値を返す場合には、その操作はその行値で処理されます。
元の<code class="varname">NEW</code>の値と異なる行値を返すことは、挿入、更新される値を変更します。
したがってトリガ関数が行値を変更せずにトリガ処理を普通に成功させたい場合は、<code class="varname">NEW</code>(またはその等価な値)を返さなければなりません。
格納する行を変更するために、<code class="varname">NEW</code>の個々の値を直接置き換え、変更した<code class="varname">NEW</code>を返すことも、新しいレコード/行を完全に作成して返すことも可能です。
<code class="command">DELETE</code>に対するBEFOREトリガの場合、返される値は直接的な影響を与えませんが、トリガ動作を継続させるためには非NULLを返さなければなりません。
<code class="command">DELETE</code>トリガでは<code class="varname">NEW</code>がNULLであり、これを返すことは通常無意味であることに注意して下さい。
<code class="command">DELETE</code>トリガにおける通常の慣例は<code class="varname">OLD</code>を返すことです。
   </p><p>
<!--
    <literal>INSTEAD OF</literal> triggers (which are always row-level triggers,
    and may only be used on views) can return null to signal that they did
    not perform any updates, and that the rest of the operation for this
    row should be skipped (i.e., subsequent triggers are not fired, and the
    row is not counted in the rows-affected status for the surrounding
    <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>).
    Otherwise a nonnull value should be returned, to signal
    that the trigger performed the requested operation. For
    <command>INSERT</command> and <command>UPDATE</command> operations, the return value
    should be <varname>NEW</varname>, which the trigger function may modify to
    support <command>INSERT RETURNING</command> and <command>UPDATE RETURNING</command>
    (this will also affect the row value passed to any subsequent triggers,
    or passed to a special <varname>EXCLUDED</varname> alias reference within
    an <command>INSERT</command> statement with an <literal>ON CONFLICT DO
    UPDATE</literal> clause).  For <command>DELETE</command> operations, the return
    value should be <varname>OLD</varname>.
-->
<code class="literal">INSTEAD OF</code>トリガ（これは常に行レベルトリガであり、ビューに対してのみ使用可能です）は、まったく更新を行わなかったためにこの行に対する残りの操作を飛ばさなければならない（つまり後続のトリガは発行されず、 トリガの発生元の<code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code>において影響を受けた行数として数えられない）ことを通知するNULLを返すことができます。
この他の場合は、トリガが要求された操作を実行したことを通知するために、非NULLの値を返さなければなりません。
<code class="command">INSERT</code>および<code class="command">UPDATE</code>操作では、戻り値は、トリガ関数が<code class="command">INSERT RETURNING</code>および<code class="command">UPDATE RETURNING</code>をサポートするために変更しているかもしれない、<code class="varname">NEW</code>となるはずです
（これは後続のトリガ、または、<code class="literal">ON CONFLICT DO UPDATE</code>句を伴う<code class="command">INSERT</code>文の中で特別な<code class="varname">EXCLUDED</code>別名参照に渡される行値にも影響します）。
<code class="command">DELETE</code>操作では、戻り値は<code class="varname">OLD</code>となるはずです。
   </p><p>
<!--
    The return value of a row-level trigger
    fired <literal>AFTER</literal> or a statement-level trigger
    fired <literal>BEFORE</literal> or <literal>AFTER</literal> is
    always ignored; it might as well be null. However, any of these types of
    triggers might still abort the entire operation by raising an error.
-->
行レベルの<code class="literal">AFTER</code>トリガ、文レベルの<code class="literal">BEFORE</code>または<code class="literal">AFTER</code>トリガの戻り値は常に無視されます。
NULLとしても構いません。
しかし、これらの種類のトリガでも、エラーを発生させることで操作全体を中断させることが可能です。
   </p><p>
<!--
    <xref linkend="plpgsql-trigger-example"/> shows an example of a
    trigger function in <application>PL/pgSQL</application>.
-->
<a class="xref" href="plpgsql-trigger.html#PLPGSQL-TRIGGER-EXAMPLE" title="例43.3 PL/pgSQLトリガ関数">例 43.3</a>に<span class="application">PL/pgSQL</span>のトリガ関数の例を示します。
   </p><div class="example" id="PLPGSQL-TRIGGER-EXAMPLE"><p class="title"><strong>例43.3 <span class="application">PL/pgSQL</span>トリガ関数</strong></p><div class="example-contents"><!--
    <title>A <application>PL/pgSQL</application> Trigger Function</title>
--><p>
<!--
     This example trigger ensures that any time a row is inserted or updated
     in the table, the current user name and time are stamped into the
     row. And it checks that an employee's name is given and that the
     salary is a positive value.
-->
このトリガの例では、テーブルの行が挿入または更新された時には必ず、現在のユーザ名と時刻がその行に入っていることを確実にします。
そして、従業員名が与えられていることとその給料が正の値であることを確認します。
    </p><pre class="programlisting">
CREATE TABLE emp (
    empname text,
    salary integer,
    last_date timestamp,
    last_user text
);

CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
    BEGIN
<!--
        &#045;&#045; Check that empname and salary are given
-->
        -- empnameとsalaryが与えられていることをチェック
        IF NEW.empname IS NULL THEN
            RAISE EXCEPTION 'empname cannot be null';
        END IF;
        IF NEW.salary IS NULL THEN
            RAISE EXCEPTION '% cannot have null salary', NEW.empname;
        END IF;

<!--
        &#045;&#045; Who works for us when they must pay for it?
-->
        -- 支払時に問題が起こらないように
        IF NEW.salary &lt; 0 THEN
            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;
        END IF;

<!--
        &#045;&#045; Remember who changed the payroll when
-->
        -- 誰がいつ変更したかを記録
        NEW.last_date := current_timestamp;
        NEW.last_user := current_user;
        RETURN NEW;
    END;
$emp_stamp$ LANGUAGE plpgsql;

CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp
    FOR EACH ROW EXECUTE FUNCTION emp_stamp();
</pre></div></div><br class="example-break" /><p>
<!--
    Another way to log changes to a table involves creating a new table that
    holds a row for each insert, update, or delete that occurs. This approach
    can be thought of as auditing changes to a table.
    <xref linkend="plpgsql-trigger-audit-example"/> shows an example of an
    audit trigger function in <application>PL/pgSQL</application>.
-->
テーブルにおける変更のログを取る他の方法は、挿入、更新または削除の各々に対する行を保有する新テーブルを作成することです。
この方法はテーブルにおける変更の監査と考えることができます。
<a class="xref" href="plpgsql-trigger.html#PLPGSQL-TRIGGER-AUDIT-EXAMPLE" title="例43.4 PL/pgSQLによる監査用のトリガ関数">例 43.4</a>は<span class="application">PL/pgSQL</span>による監査用トリガ関数の一例を示します。
   </p><div class="example" id="PLPGSQL-TRIGGER-AUDIT-EXAMPLE"><p class="title"><strong>例43.4 <span class="application">PL/pgSQL</span>による監査用のトリガ関数</strong></p><div class="example-contents"><!--
    <title>A <application>PL/pgSQL</application> Trigger Function For Auditing</title>
--><p>
<!--
     This example trigger ensures that any insert, update or delete of a row
     in the <literal>emp</literal> table is recorded (i.e., audited) in the <literal>emp_audit</literal> table.
     The current time and user name are stamped into the row, together with
     the type of operation performed on it.
-->
このトリガの例では、<code class="literal">emp</code>テーブルにおける行の挿入、更新または削除のどれもがemp_auditテーブルの中へ確実に記録（すなわち監査）されます。
現在時刻とユーザ名は、行った操作の種類とともに<code class="literal">emp_audit</code>の行の中に記録されます。
    </p><pre class="programlisting">
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        --
<!--
        &#045;&#045; Create a row in emp_audit to reflect the operation performed on emp,
        &#045;&#045; make use of the special variable TG_OP to work out the operation.
-->
        -- empで行った操作を反映する行をemp_auditに作成
        -- 操作の種類を決定するために、特殊な変数TG_OPを活用
        --
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;
        END IF;
<!--
        RETURN NULL; &#045;&#045; result is ignored since this is an AFTER trigger
-->
        RETURN NULL; -- AFTERトリガですので、結果は無視されます
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
    FOR EACH ROW EXECUTE FUNCTION process_emp_audit();
</pre></div></div><br class="example-break" /><p>
<!--
    A variation of the previous example uses a view joining the main table
    to the audit table, to show when each entry was last modified. This
    approach still records the full audit trail of changes to the table,
    but also presents a simplified view of the audit trail, showing just
    the last modified timestamp derived from the audit trail for each entry.
    <xref linkend="plpgsql-view-trigger-audit-example"/> shows an example
    of an audit trigger on a view in <application>PL/pgSQL</application>.
-->
前例の変形では、各エントリが最終修正された時を表示するため、主テーブルを監査テーブルに結合したビューを使用します。
この方法でもテーブルの変化の監査証跡を全て記録できますが、監査証跡から抽出した各エントリの最終修正のタイムスタンプ表示することにより、監査証跡の簡単なビューを表示することにもなります。
<a class="xref" href="plpgsql-trigger.html#PLPGSQL-VIEW-TRIGGER-AUDIT-EXAMPLE" title="例43.5 監査のためのPL/pgSQLビュートリガ関数">例 43.5</a>で示すものは、<span class="application">PL/pgSQL</span>を用いたビューの監査トリガの例です。
   </p><div class="example" id="PLPGSQL-VIEW-TRIGGER-AUDIT-EXAMPLE"><p class="title"><strong>例43.5 監査のための<span class="application">PL/pgSQL</span>ビュートリガ関数</strong></p><div class="example-contents"><!--
    <title>A <application>PL/pgSQL</application> View Trigger Function For Auditing</title>
--><p>
<!--
     This example uses a trigger on the view to make it updatable, and
     ensure that any insert, update or delete of a row in the view is
     recorded (i.e., audited) in the <literal>emp_audit</literal> table. The current time
     and user name are recorded, together with the type of operation
     performed, and the view displays the last modified time of each row.
-->
この例では、ビューを更新可能とし、その行の挿入、更新、削除を<code class="literal">emp_audit</code>テーブルに確実に記録（つまり監査）するためにビューに対するトリガを使用します。
現在時刻とユーザ名が実行された操作種類と一緒に記録されます。
ビューは各行の最終更新時間を表示します。
    </p><pre class="programlisting">
CREATE TABLE emp (
    empname           text PRIMARY KEY,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary            integer,
    stamp             timestamp NOT NULL
);

CREATE VIEW emp_view AS
    SELECT e.empname,
           e.salary,
           max(ea.stamp) AS last_updated
      FROM emp e
      LEFT JOIN emp_audit ea ON ea.empname = e.empname
     GROUP BY 1, 2;

CREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS $$
    BEGIN
        --
<!--

        &#045;&#045; Perform the required operation on emp, and create a row in emp_audit
        &#045;&#045; to reflect the change made to emp.
-->
        -- 要求された操作を emp に実行し
        -- emp_audit に行を作成し
        -- emp の変化を反映する
        --
        IF (TG_OP = 'DELETE') THEN
            DELETE FROM emp WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            OLD.last_updated = now();
            INSERT INTO emp_audit VALUES('D', user, OLD.*);
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('U', user, NEW.*);
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp VALUES(NEW.empname, NEW.salary);

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('I', user, NEW.*);
            RETURN NEW;
        END IF;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
INSTEAD OF INSERT OR UPDATE OR DELETE ON emp_view
    FOR EACH ROW EXECUTE FUNCTION update_emp_view();
</pre></div></div><br class="example-break" /><p>
<!--
    One use of triggers is to maintain a summary table
    of another table. The resulting summary can be used in place of the
    original table for certain queries &mdash; often with vastly reduced run
    times.
    This technique is commonly used in Data Warehousing, where the tables
    of measured or observed data (called fact tables) might be extremely large.
    <xref linkend="plpgsql-trigger-summary-example"/> shows an example of a
    trigger function in <application>PL/pgSQL</application> that maintains
    a summary table for a fact table in a data warehouse.
-->
トリガの使用目的の1つは、あるテーブルのサマリテーブルを維持することです。
結果のサマリテーブルは、元のテーブルに代わって、ある種の問い合わせに対して使用でき、しばしば実行時間を大幅に縮小します。
通常この手法は、計測または観測データ（ファクトテーブルと言います）が非常に大きくなるかもしれない、データウェアハウスに使用されます。
データウェアハウス内のファクトテーブルに対してサマリテーブルを維持する<span class="application">PL/pgSQL</span>のトリガ関数の例を<a class="xref" href="plpgsql-trigger.html#PLPGSQL-TRIGGER-SUMMARY-EXAMPLE" title="例43.6 サマリテーブルを維持するためのPL/pgSQLトリガ関数">例 43.6</a>に示します。
   </p><div class="example" id="PLPGSQL-TRIGGER-SUMMARY-EXAMPLE"><p class="title"><strong>例43.6 サマリテーブルを維持するための<span class="application">PL/pgSQL</span>トリガ関数</strong></p><div class="example-contents"><!--
    <title>A <application>PL/pgSQL</application> Trigger Function For Maintaining A Summary Table</title>
--><p>
<!--
     The schema detailed here is partly based on the <emphasis>Grocery Store
     </emphasis> example from <emphasis>The Data Warehouse Toolkit</emphasis>
     by Ralph Kimball.
-->
ここに述べるスキーマの一部はRalph Kimballによる<span class="emphasis"><em>The Data Warehouse Toolkit</em></span>の<span class="emphasis"><em>Grocery Store</em></span>の例に基づいています。
    </p><pre class="programlisting">
--
<!--
&#045;&#045; Main tables - time dimension and sales fact.
-->
-- time dimensionとsales factの主テーブル
--
CREATE TABLE time_dimension (
    time_key                    integer NOT NULL,
    day_of_week                 integer NOT NULL,
    day_of_month                integer NOT NULL,
    month                       integer NOT NULL,
    quarter                     integer NOT NULL,
    year                        integer NOT NULL
);
CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);

CREATE TABLE sales_fact (
    time_key                    integer NOT NULL,
    product_key                 integer NOT NULL,
    store_key                   integer NOT NULL,
    amount_sold                 numeric(12,2) NOT NULL,
    units_sold                  integer NOT NULL,
    amount_cost                 numeric(12,2) NOT NULL
);
CREATE INDEX sales_fact_time ON sales_fact(time_key);

--
<!--
&#045;&#045; Summary table - sales by time.
-->
-- sales by timeのサマリテーブル
--
CREATE TABLE sales_summary_bytime (
    time_key                    integer NOT NULL,
    amount_sold                 numeric(15,2) NOT NULL,
    units_sold                  numeric(12) NOT NULL,
    amount_cost                 numeric(15,2) NOT NULL
);
CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);

--
<!--
&#045;&#045; Function and trigger to amend summarized column(s) on UPDATE, INSERT, DELETE.
-->
-- 更新、挿入および削除によりサマリテーブルの列を修正する関数とトリガ
--
CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER
AS $maint_sales_summary_bytime$
    DECLARE
        delta_time_key          integer;
        delta_amount_sold       numeric(15,2);
        delta_units_sold        numeric(12);
        delta_amount_cost       numeric(15,2);
    BEGIN

<!--
        &#045;&#045; Work out the increment/decrement amount(s).
-->
        -- 増加または減少量を算出
        IF (TG_OP = 'DELETE') THEN

            delta_time_key = OLD.time_key;
            delta_amount_sold = -1 * OLD.amount_sold;
            delta_units_sold = -1 * OLD.units_sold;
            delta_amount_cost = -1 * OLD.amount_cost;

        ELSIF (TG_OP = 'UPDATE') THEN

<!--
            &#045;&#045; forbid updates that change the time_key -
            &#045;&#045; (probably not too onerous, as DELETE + INSERT is how most 
            &#045;&#045; changes will be made).
-->
            -- time_keyを変更する更新を禁止します
            -- （削除 + 挿入の方法により大部分の変更を行うため
            -- それほど厄介ではありません）。
            IF ( OLD.time_key != NEW.time_key) THEN
                RAISE EXCEPTION 'Update of time_key : % -&gt; % not allowed',
                                                      OLD.time_key, NEW.time_key;
            END IF;

            delta_time_key = OLD.time_key;
            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;
            delta_units_sold = NEW.units_sold - OLD.units_sold;
            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;

        ELSIF (TG_OP = 'INSERT') THEN

            delta_time_key = NEW.time_key;
            delta_amount_sold = NEW.amount_sold;
            delta_units_sold = NEW.units_sold;
            delta_amount_cost = NEW.amount_cost;

        END IF;


<!--
        &#045;&#045; Insert or update the summary row with the new values.
-->
        -- サマリテーブルの行を挿入または新しい値で更新します。
        &lt;&lt;insert_update&gt;&gt;
        LOOP
            UPDATE sales_summary_bytime
                SET amount_sold = amount_sold + delta_amount_sold,
                    units_sold = units_sold + delta_units_sold,
                    amount_cost = amount_cost + delta_amount_cost
                WHERE time_key = delta_time_key;

            EXIT insert_update WHEN found;

            BEGIN
                INSERT INTO sales_summary_bytime (
                            time_key,
                            amount_sold,
                            units_sold,
                            amount_cost)
                    VALUES (
                            delta_time_key,
                            delta_amount_sold,
                            delta_units_sold,
                            delta_amount_cost
                           );

                EXIT insert_update;

            EXCEPTION
                WHEN UNIQUE_VIOLATION THEN
<!--
                    &#045;&#045; do nothing
-->
                    -- 何もしません
            END;
        END LOOP insert_update;

        RETURN NULL;

    END;
$maint_sales_summary_bytime$ LANGUAGE plpgsql;

CREATE TRIGGER maint_sales_summary_bytime
AFTER INSERT OR UPDATE OR DELETE ON sales_fact
    FOR EACH ROW EXECUTE FUNCTION maint_sales_summary_bytime();

INSERT INTO sales_fact VALUES(1,1,1,10,3,15);
INSERT INTO sales_fact VALUES(1,2,1,20,5,35);
INSERT INTO sales_fact VALUES(2,2,1,40,15,135);
INSERT INTO sales_fact VALUES(2,3,1,10,1,13);
SELECT * FROM sales_summary_bytime;
DELETE FROM sales_fact WHERE product_key = 1;
SELECT * FROM sales_summary_bytime;
UPDATE sales_fact SET units_sold = units_sold * 2;
SELECT * FROM sales_summary_bytime;
</pre></div></div><br class="example-break" /><p>
<!--
    <literal>AFTER</literal> triggers can also make use of <firstterm>transition
    tables</firstterm> to inspect the entire set of rows changed by the triggering
    statement.  The <command>CREATE TRIGGER</command> command assigns names to one
    or both transition tables, and then the function can refer to those names
    as though they were read-only temporary tables.
    <xref linkend="plpgsql-trigger-audit-transition-example"/> shows an example.
-->
<code class="literal">AFTER</code>トリガは、トリガ文により変更された行の集合全体を調べるために<em class="firstterm">遷移テーブル</em>を使うこともできます。
<code class="command">CREATE TRIGGER</code>コマンドで名前を1つまたは2つの遷移テーブルに割り当てると、関数はその名前を読み込み専用の一時テーブルであるかのように参照できます。
<a class="xref" href="plpgsql-trigger.html#PLPGSQL-TRIGGER-AUDIT-TRANSITION-EXAMPLE" title="例43.7 遷移テーブルでの監査">例 43.7</a>に例を示します。
   </p><div class="example" id="PLPGSQL-TRIGGER-AUDIT-TRANSITION-EXAMPLE"><p class="title"><strong>例43.7 遷移テーブルでの監査</strong></p><div class="example-contents"><!--
    <title>Auditing with Transition Tables</title>
--><p>
<!--
     This example produces the same results as
     <xref linkend="plpgsql-trigger-audit-example"/>, but instead of using a
     trigger that fires for every row, it uses a trigger that fires once
     per statement, after collecting the relevant information in a transition
     table.  This can be significantly faster than the row-trigger approach
     when the invoking statement has modified many rows.  Notice that we must
     make a separate trigger declaration for each kind of event, since the
     <literal>REFERENCING</literal> clauses must be different for each case.  But
     this does not stop us from using a single trigger function if we choose.
     (In practice, it might be better to use three separate functions and
     avoid the run-time tests on <varname>TG_OP</varname>.)
-->
この例は<a class="xref" href="plpgsql-trigger.html#PLPGSQL-TRIGGER-AUDIT-EXAMPLE" title="例43.4 PL/pgSQLによる監査用のトリガ関数">例 43.4</a>と同じ結果になりますが、行毎に起動するトリガを使う代わりに、関係のある情報を遷移テーブルに集めた後に文毎に1回起動するトリガを使っています。
これは、呼び出された文が多くの行を変更する場合には行トリガの方法よりとても速くなる場合があります。
<code class="literal">REFERENCING</code>句はそれぞれの場合で異ならなければなりませんので、それぞれの種類のイベントに対して別々のトリガ宣言をしなければならないことに注意してください。
ですが、もし選ぶのなら、このために単一のトリガ関数が使えなくなることはありません。
(実際には、3つに別れた関数を使い、実行時の<code class="varname">TG_OP</code>の確認を避ける方が良いでしょう。)
    </p><pre class="programlisting">
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        --
<!--
        &#045;- Create rows in emp_audit to reflect the operations performed on emp,
        &#045;- making use of the special variable TG_OP to work out the operation.
-->
        -- empで実行された操作を反映するためにemp_auditに行を作り、
        -- 操作を完了するために特殊な変数TG_OPを使う。
        --
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit
                SELECT 'D', now(), user, o.* FROM old_table o;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit
                SELECT 'U', now(), user, n.* FROM new_table n;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit
                SELECT 'I', now(), user, n.* FROM new_table n;
        END IF;
<!--
        RETURN NULL; &#045;- result is ignored since this is an AFTER trigger
-->
        RETURN NULL; -- これはAFTERトリガなので結果は無視される
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit_ins
    AFTER INSERT ON emp
    REFERENCING NEW TABLE AS new_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
CREATE TRIGGER emp_audit_upd
    AFTER UPDATE ON emp
    REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
CREATE TRIGGER emp_audit_del
    AFTER DELETE ON emp
    REFERENCING OLD TABLE AS old_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
</pre></div></div><br class="example-break" /></div><div class="sect2" id="PLPGSQL-EVENT-TRIGGER"><div class="titlepage"><div><div><h3 class="title">43.10.2. イベントによるトリガ</h3></div></div></div><!--
   <title>Triggers on Events</title>
--><p>
<!--
    <application>PL/pgSQL</application> can be used to define
    <link linkend="event-triggers">event triggers</link>.
    <productname>PostgreSQL</productname> requires that a function that
    is to be called as an event trigger must be declared as a function with
    no arguments and a return type of <literal>event_trigger</literal>.
-->
<span class="application">PL/pgSQL</span>は<a class="link" href="event-triggers.html" title="第40章 イベントトリガ">イベントトリガ</a>の定義に使用できます。
イベントトリガとして呼び出される関数は、引数のない関数として宣言され、戻り値の型は<code class="literal">event_trigger</code>となることが<span class="productname">PostgreSQL</span>では必須です。
   </p><p>
<!--
    When a <application>PL/pgSQL</application> function is called as an
    event trigger, several special variables are created automatically
    in the top-level block. They are:
-->
<span class="application">PL/pgSQL</span>関数がイベントトリガとして呼び出された場合、数個の特別な変数が最高レベルのブロックで自動的に作成されます。
以下に示します。

   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="varname">TG_EVENT</code></span></dt><dd><p>
<!--
       Data type <type>text</type>; a string representing the event the
       trigger is fired for.
-->
<code class="type">text</code>データ型。
トリガが発行されたイベントを示す文字列。
      </p></dd><dt><span class="term"><code class="varname">TG_TAG</code></span></dt><dd><p>
<!--
       Data type <type>text</type>; variable that contains the command tag
       for which the trigger is fired.
-->
<code class="type">text</code>データ型。
トリガが発行されたコマンドタグを含む変数。
      </p></dd></dl></div><p>
  </p><p>
<!--
    <xref linkend="plpgsql-event-trigger-example"/> shows an example of an
    event trigger function in <application>PL/pgSQL</application>.
-->
<a class="xref" href="plpgsql-trigger.html#PLPGSQL-EVENT-TRIGGER-EXAMPLE" title="例43.8 PL/pgSQLイベントトリガ関数">例 43.8</a>は<span class="application">PL/pgSQL</span>におけるイベントトリガ関数の一例を示します。
   </p><div class="example" id="PLPGSQL-EVENT-TRIGGER-EXAMPLE"><p class="title"><strong>例43.8 <span class="application">PL/pgSQL</span>イベントトリガ関数</strong></p><div class="example-contents"><!--
    <title>A <application>PL/pgSQL</application> Event Trigger Function</title>
--><p>
<!--
     This example trigger simply raises a <literal>NOTICE</literal> message
     each time a supported command is executed.
-->
以下の例では、サポートされたコマンドが実行されたとき、トリガは<code class="literal">NOTICE</code>を発生させるだけです。
    </p><pre class="programlisting">
CREATE OR REPLACE FUNCTION snitch() RETURNS event_trigger AS $$
BEGIN
    RAISE NOTICE 'snitch: % %', tg_event, tg_tag;
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER snitch ON ddl_command_start EXECUTE FUNCTION snitch();
</pre></div></div><br class="example-break" /></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="plpgsql-errors-and-messages.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="plpgsql.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="plpgsql-implementation.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">43.9. エラーとメッセージ </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 43.11. <span class="application">PL/pgSQL</span>の秘訣</td></tr></table></div></body></html>