<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>json on Noboru Saito's page</title><link>https://noborus.github.io/tags/json/</link><description>Recent content in json on Noboru Saito's page</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Sun, 22 Dec 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://noborus.github.io/tags/json/index.xml" rel="self" type="application/rss+xml"/><item><title>trdsql JSON出力</title><link>https://noborus.github.io/blog/22_json_output/</link><pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/22_json_output/</guid><description>CSVやLTSVなどのフラットな形式のデータは、JSONにしたいときには（-ojsonによる）JSON出力をすれば良いですが、JSONは本来より深い階層も表現できるフォーマットです。
そのようなJSONは、データベースのJSON関数を使用することにより作成できます。
以下のCSVからJSON関数でJSON出力をしてみます。
id,name 1,Orange 2,Melon 3,Apple JSON関数で出力する場合は、「”」等がエスケープされない-orawを使用して出力すると、有効なJSONとして出力できます。
SQLite3、MySQL SQLite3、MySQLでは、json_array()やjson_object()を使用することによりJSONを生成できます。 ここでは「名前:値」の形式で出力するためjson_objectを使用します。2つペアの引数で、指定していきます。
trdsql -ih -oraw \ &amp;quot;SELECT json_object('id',id,'name',name) FROM header.csv&amp;quot; {&amp;quot;id&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;Orange&amp;quot;} {&amp;quot;id&amp;quot;:&amp;quot;2&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;Melon&amp;quot;} {&amp;quot;id&amp;quot;:&amp;quot;3&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;Apple&amp;quot;} 階層を深くするには、json_object()を内部でさらに使います。 SQLite3にはjson_pretty()関数が無いので、jqで見やすくしています。
trdsql -ih -oraw \ &amp;quot;SELECT json_object('fruits', json_object('id',id,'name',name)) &amp;quot;\ &amp;quot;FROM header.csv&amp;quot;|jq . { &amp;quot;fruits&amp;quot;: { &amp;quot;id&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Orange&amp;quot; } } { &amp;quot;fruits&amp;quot;: { &amp;quot;id&amp;quot;: &amp;quot;2&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Melon&amp;quot; } } { &amp;quot;fruits&amp;quot;: { &amp;quot;id&amp;quot;: &amp;quot;3&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Apple&amp;quot; } } 上記の結果は1行1JSONで出力されています。これをさらに配列にして、一つのJSONにするには、SQLite3では json_group_array()、MySQLではjson_arrayagg()でグループ化して出力できます。
SQLite3</description></item><item><title>trdsql JSON解析</title><link>https://noborus.github.io/blog/21_json_parse/</link><pubDate>Sat, 21 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/21_json_parse/</guid><description>これまでtrdsqlでは、JSONの入力が可能と書きましたが、例として書いたのは基本的にフラットな構造のJSONでした。 ただ、２階層以上の階層構造が含まれるJSONはエラーになる訳ではなく、そのまま文字列として扱われます。
以下のようなJSONがあるとします。
sample.json
[ { &amp;quot;color&amp;quot;: &amp;quot;white&amp;quot;, &amp;quot;category&amp;quot;: &amp;quot;value&amp;quot;, &amp;quot;code&amp;quot;: { &amp;quot;rgba&amp;quot;: [0, 0, 0, 1], &amp;quot;hex&amp;quot;: &amp;quot;#FFF&amp;quot; } }, { &amp;quot;color&amp;quot;: &amp;quot;red&amp;quot;, &amp;quot;category&amp;quot;: &amp;quot;hue&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;primary&amp;quot;, &amp;quot;code&amp;quot;: { &amp;quot;rgba&amp;quot;: [255, 0, 0, 1], &amp;quot;hex&amp;quot;: &amp;quot;#FF0&amp;quot; } }, { &amp;quot;color&amp;quot;: &amp;quot;blue&amp;quot;, &amp;quot;category&amp;quot;: &amp;quot;hue&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;primary&amp;quot;, &amp;quot;code&amp;quot;: { &amp;quot;rgba&amp;quot;: [0, 0, 255, 1], &amp;quot;hex&amp;quot;: &amp;quot;#00F&amp;quot; } } ] これをそのままtrdsqlを実行すると以下のようになります(見やすいように-oatを付けています。CSV出力にすると「&amp;quot;」が含まれる文字列のためエスケープされて出力されます。)
trdsql -oat &amp;quot;SELECT color,category,code FROM sample.json&amp;quot; +-------+----------+-----------------------------------+ | color | category | code | +-------+----------+-----------------------------------+ | white | value | {&amp;quot;hex&amp;quot;:&amp;quot;#FFF&amp;quot;,&amp;quot;rgba&amp;quot;:[0,0,0,1]} | | red | hue | {&amp;quot;hex&amp;quot;:&amp;quot;#FF0&amp;quot;,&amp;quot;rgba&amp;quot;:[255,0,0,1]} | | blue | hue | {&amp;quot;hex&amp;quot;:&amp;quot;#00F&amp;quot;,&amp;quot;rgba&amp;quot;:[0,0,255,1]} | +-------+----------+-----------------------------------+ このcodeは文字列の扱いですが、各データベースは既にJSONを扱える関数を備えているため、データベース側の関数を使って変更できます。</description></item></channel></rss>