<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on Noboru Saito's page</title><link>https://noborus.github.io/tags/go/</link><description>Recent content in go on Noboru Saito's page</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Thu, 31 Dec 2020 14:00:00 +0900</lastBuildDate><atom:link href="https://noborus.github.io/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>goのTUIについて2020年最終版</title><link>https://noborus.github.io/blog/go_tui2020/</link><pubDate>Thu, 31 Dec 2020 14:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/go_tui2020/</guid><description>概要 goのTUIについての2020年の最終更新版です。
goでTUI(text user interface)を作成する場合にライブラリを使用するのが一般的です。
goのTUIライブラリはだいたい以下に分類されます。
termbox-go系 tcell系 bubbletea系 その他 goのTUIライブラリはtermbox-go系、tcell系の利用が多かったですが、彗星のごとくbubbleteaが登場しました。
bubbleteaはThe Elm Architectureに基づいて作られているというフレームワークで、追加のコンポーネントとしてbubblesもあり、もう一つの系統として選択肢になると思います。
TUIライブラリを謳っている場合は、だいたい上記3つを元に実装されている場合が多いです。
TUIはエスケープシーケンスを使用すれば、ライブラリを使用しなくても実現できますが、端末によりエスケープシーケンスが変わっていたりするので、マルチプラットフォームで動作するのは難しくなります。 そのため、独自に一から作成するよりは、これらのライブラリの上に便利な機能を足す形になります。
termbox-go系 termbox-goは、老舗で現在も多く使われていますが、開発は停滞傾向で、termbox-goにもそれほど保守しない方向だと書かれています。
termbox-goを使用して、より高度なウィジットを実装したライブラリにgocuiがあります。
termbox-go gocui termui termbox-goのimported by tcell系 tcellは、termbox-goよりも新しくtermbox-goを意識して開発され、今も開発も続いています。 tcellは基本的な機能しか提供しませんが、tcell/viewsには、少し高度なウィジットがあります。
また、より高度なウィジットを実装したライブラリとしてtviewがあり、よく使用されています。また、そこからForkしたcviewも候補に入れておくと良いかも知れません。
さらに元々termbox-goを使用していたgocuiをtcellに変更したawesome-gocui/gocuiも開発されています。
tcell tcell/views tview cview cbind gowid goban awesome-gocui/gocui tcellのimported by bubbletea系 端末全部を使用するモードしかないtermbox-goとtcellと違い彗星のごとく現われたbubbleteaは現在のプロンプトから対話するような、ちょっとしたプログラムから端末全部を使用するTUIまでサポートしています。
既に例が豊富に用意されていて、十分に実用に耐えるように思います。
bubbletea bubbles bubbleteaのimported by その他 はいずれも端末画面をまるまる使用することを前提に作られています。起動すると現在の端末画面は消えて（終了時に戻すことは可能）、新しい画面が表示されます。
現在のshellプロンプトで動作するような対話型プログラムの場合は、termbox-goやtcellでは作ることはできないので、bubbletea系か別のライブラリや自前で実装することになります。
別のプログラムとしては、対話型のライブラリとして go-promptやlinerがあります。
また、コンソール上の表示を助けるツールとして色を付けたり、その行のまま表示を変えるプログレスバー的な表示をするライブラリがあります。
どれを選択すべきか？ 2020年12月現在、端末全体を使用する以外の使用の可能性がある場合は、bubbleteaを使用するのが良いと思います。端末全体を使用するアプリケーションを開発するなら、tview とbubbleteaで、例を見ながらどちらを使用するか決めるのが良いでしょう。</description></item><item><title>tcell/tviewでTUIを作るならキー割り当てにcbindを利用しよう</title><link>https://noborus.github.io/blog/cbind/</link><pubDate>Tue, 27 Oct 2020 10:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/cbind/</guid><description>cbindとは？ cbindはtcellのキーイベントとイベントハンドラを結びつけるライブラリです。
現在cbindの最新はtcellのversion 2が対象になっています。まだtcell のversion 2は開発版のため、version 1を対象にする場合は cbind v0.1.1を使用して下さい。 go get gitlab.com/tslocum/cbind@v0.1.1 ここでも v0.1.1を対象にしています。
tcellのキーイベント tcell ではキー入力がイベントの１つとして取得できます。tviewでもtcellのイベントを使用しているので、同じ様にイベントとして取得します。
tcellのキーイベントを取得するのは以下のようにswitch caseでキーを判別して、イベントハンドラを呼び出すのが一般的です。
ev := screen.PollEvent() switch ev := ev.(type) { case *tcell.EventKey: switch ev.Key() { case tcell.KeyEscape: close(quit) return } case tcell.KeyEnter: action() return } ここのtcell.KeyEscapeは constの数値として定義されています（キーボードに存在する英数字などの文字はruneで入ってきます）。 キー割り当てが少ないうちは、このまま追加していけば機能を増やせるので分かりやすいですが、キー割り当てが多くなってくると以下のような問題が出てきます。
修飾キー(CTRL、ALT&amp;hellip;)が押された場合に動作が変わる場合はさらに分岐する キー割り当てをドキュメント化するのが大変になる キー割り当てのヘルプが必要になる キー割り当てを人によって変更したくなる ドキュメント化やヘルプはコードで実装した後、手間を掛けて書いていけばなんとか解決できますが、キー割り当ての変更に対応するには、元のままのコードでは不可能です。
cbindを使用 そこで使用したいのがcbindです。
cbind は *tcell.EventKeyを文字列にするEncodeとキー文字列（ctrl+a等）をtcellのイベントキーに変換するDecodeがあり、それらを利用して「文字列」にイベントハンドラを結びつけて登録できます。実際にキーイベントが起きたら、cbindに任せれば登録されていたイベントハンドラが実行されることになります。
実際の使用例です。 キーの登録は、まずcbind.NewConfiguration()をしてConfigurationを作成します。 そのConfigurationにキー文字列をDecodeでイベントキーに変換して、SetRuneまたはSetKeyで登録します。
実際に登録するときには、キー文字列（ctrl+a等）とイベントハンドラ（func）を直接結びつけるのではなく、アクション名（文字列）を介しておくと、ヘルプや設定ファイル化するときに便利です。
アクション名とキー文字列のマップ(keyBind)とアクション名とイベントハンドラのマップ(actionHandlers)をあらかじめ定義しておいてsetKeyBindで登録しています。
const ( // アクション名 actionQuit = &amp;quot;quit&amp;quot; ) var keyBind = map[string][]string{ // アクション名に対してキー文字列をマッピング（キー文字列は複数可能） actionQuit: {&amp;quot;q&amp;quot;, &amp;quot;ctrl+q&amp;quot;}, } var actionHandlers = map[string]func(){ // アクション名に対してイベントハンドラをマッピング actionQuit: handleQuit, } // 終了のイベントハンドラ var quit = make(chan struct{}) var handleQuit = func() { close(quit) } func setKeyBind() (*cbind.</description></item><item><title>tcellについて2</title><link>https://noborus.github.io/blog/tcell_02/</link><pubDate>Sun, 17 May 2020 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/tcell_02/</guid><description>これまで goのTUIについて tcellについて イベント tcellのイベントは、NewScreen()で作成したスクリーンのPollEvent()で取得できます。
その名の通り、イベントが起こるまでポーリング（polling）して待つので、起こらない限り止まったままになります。
PollEvent()でイベントが起こったらイベントに応じて処理し、SetContent()でセットし、次のイベントが起こる前にDraw()で描画する。 というのが、実際のメインルーチンになります。
このメインルーチンをgoroutineで動かし、終了のイベントがきたらchannelに通知して通知を受信したらFini()を実行して終了するのが一般的な流れです。
キーイベント イベントの中でも重要でよく使用するのがキーイベントです。 以下のプログラムは左上に打ったキーが表示されます。ESCキー又はEnterキーで終了します。
package main import ( &amp;quot;log&amp;quot; &amp;quot;time&amp;quot; &amp;quot;github.com/gdamore/tcell&amp;quot; ) func main() { screen, err := tcell.NewScreen() if err != nil { log.Fatal(err) } if err = screen.Init(); err != nil { log.Fatal(err) } defer screen.Fini() screen.SetContent(0, 0, '_', nil, tcell.StyleDefault) quit := make(chan struct{}) go func() { for { screen.Show() ev := screen.PollEvent() switch ev := ev.(type) { case *tcell.</description></item><item><title>tcellについて</title><link>https://noborus.github.io/blog/tcell_01/</link><pubDate>Wed, 13 May 2020 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/tcell_01/</guid><description>SetContent() goのTUIについてで書いたようにtcellのSetContent()は1文字設置していくのでASCIIの範囲内だと簡単ですが、Unicodeの世界では注意すべき点があります。
まず日本語などの全角幅の文字と半角幅の文字が混在すると全角幅のときには、次の文字は1つとばして設置するといったことが必要になります。
単純に実装する場合はrunewidth.RuneWidth()を使用すれば、runeの文字幅を0,1,2で返してくれるので、その分xをずらせば表示されます。以下が実装例です。文字列を渡せるsetContents()で処理しています。
package main import ( &amp;quot;log&amp;quot; &amp;quot;github.com/gdamore/tcell&amp;quot; &amp;quot;github.com/mattn/go-runewidth&amp;quot; ) func setContents(screen tcell.Screen, x int, y int, str string, style tcell.Style) { for _, r := range str { screen.SetContent(x, y, r, nil, style) x += runewidth.RuneWidth(r) } } func main() { screen, err := tcell.NewScreen() if err != nil { log.Fatal(err) } if err = screen.Init(); err != nil { log.Fatal(err) } defer screen.Fini() setContents(screen, 0, 10, &amp;quot;あいうえお&amp;quot;, tcell.</description></item><item><title>goのTUIについて</title><link>https://noborus.github.io/blog/go_tui/</link><pubDate>Tue, 12 May 2020 23:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/go_tui/</guid><description>概要 ライブラリの状況を鑑みてgoのTUIについて2020年最終版に更新しました。
goでTUI(text user interface)を作成する場合にライブラリを使用するのが一般的です。
goのTUIライブラリはだいたい以下に分類されます。
termbox-go系 tcell系 その他 TUIライブラリを謳っている場合は、だいたい上記2つを元に実装されている場合が多いです。
TUIはエスケープシーケンスを使用すれば、ライブラリを使用しなくても実現できますが、端末によりエスケープシーケンスが変わっていたりするので、マルチプラットフォームで動作するのは難しくなります。 そのため、独自に一から作成するよりは、これらのライブラリの上に便利な機能を足す形になります。
termbox-go系 termbox-goは、老舗で現在も多く使われていますが、開発は停滞傾向で、termbox-goにもそれほど保守しない方向だと書かれています。
termbox-goを使用して、より高度なウィジットを実装したライブラリにgocuiがあります。
termbox-go gocui termui termbox-goのimported by tcell系 tcellは、termbox-goよりも新しくtermbox-goを意識して開発され、今も開発も続いています。 tcellは基本的な機能しか提供しませんが、tcell/viewsには、少し高度なウィジットがあります。
また、より高度なウィジットを実装したライブラリとしてtviewがあり、よく使用されています。
tcell tcell/views tview gowid goban tcellのimported by その他 termbox-goとtcellはいずれも端末画面をまるまる使用することを前提に作られています。起動すると現在の端末画面は消えて（終了時に戻すことは可能）、新しい画面が表示されます。
現在のshellプロンプトで動作するような対話型プログラムの場合は、上記2つで作ることはできないので、別のライブラリや自前で実装することになります。
別のプログラムとしては、対話型のライブラリとして go-promptやlinerがあります。
また、コンソール上の表示を助けるツールとして色を付けたり、その行のまま表示を変えるプログレスバー的な表示をするライブラリがあります。
どれを選択すべきか？ 2020年5月現在で端末全体を使用するアプリケーションを開発するなら、tview が第一候補だと思います。tviewが作ろうとしているアプリに当てはまるかを考えて、足りない機能は、tcellを使用して自分で実装できないか考えます。
それでも難しいようであればtermbox-goを検討するのが良いでしょう。
tviewは豊富なデモの実装例があり、また多く使われているので、それらを見れば使い方は分かっていくと思います。
tcellによる低レベルな実装 ということで、tviewの使い方は他に任せて、tcellの解説をします。tviewを使う場合もその下層について理解するのは有用だと思います。
個人的にtcellの一番大事な機能だと思うのはSetContentです。 SetContent()は指定された座標に文字を描画します。
SetContent( x int, y int, mainc rune, combc []rune, style Style) 端末上の左上（0）からx,y座標を指定して、maincにrune（文字）を描画します。 低レベルなので、文字列ではなく1文字1文字を設置します。
指定するのはgoのruneなので、マルチバイトであっても1文字として指定できます。
ただgoのruneは符号化単位なので、Unicodeの結合文字は別文字扱いになります。その結合文字をcombcのrune配列に追加して表現できます。
そして、styleには、文字色、背景色、反転等のスタイルをtcellの値で渡します。
SetContent()を使って端末画面分埋めれば自由に描画ができるわけです。</description></item><item><title>GoのTUIで表示が崩れる場合</title><link>https://noborus.github.io/blog/runewidth/</link><pubDate>Mon, 06 Apr 2020 16:10:00 +0900</pubDate><guid>https://noborus.github.io/blog/runewidth/</guid><description>結論 gnome-terminalを使用している場合は、設定の「曖昧幅の文字(W)」と環境変数RUNEWIDTH_EASTASIANを一致させよう。
Ambiguous width(曖昧幅) ターミナル上のアプリケーション(TUI)では、GUIと違って文字単位で描画されます。 そして1文字の幅は固定されていて、アルファベットは1文字分とすると日本語などは2文字分使用する、いわゆる半角全角の世界です。 ただし、既にUnicode(UTF-8)が標準となっているので、バイト数と文字幅は関係しないようになっています。
Unicodeでは幅が決まっている文字がほとんどですが、一部に「Ambiguous; 曖昧」とされている文字があります。
以前は英語圏のアプリケーションではASCIIの範囲内のみを使用していて「Ambiguous」な範囲の文字を使用するのは、それ以外の地域の人だったため、全角幅で問題になることは無かったのですが、Unicodeの使用が拡大するにつれて英語圏の方が作るアプリケーションでも「Ambiguous」な幅の文字が使用されることが増えてきました。
特にTUIアプリケーションでは、罫線「┌ ├ ─ ┘等」を使用して枠線を表現することがあります。これが「Ambiguous」な幅として、英語圏では1文字幅で表示できる様になっているため、2文字幅と解釈して表示しようとすると表示が崩れてしまいます。
ターミナル上で罫線を使用したプログラムがズレる場合はこれが原因です。
そのための対応として、gnome-terminalではPreferencesから「曖昧幅の文字(W)」を半角／全角で変更出来るようになっています。
これを半角にすれば、罫線が1文字幅で表示されるため、表示が直ります。
例えば、psqlの \pset linestyle unicodeをgnome-terminalで使用するには、ここを半角にしておかないと縦の線が揃わなくなります。
ただし、これはアプリケーションが幅を半角幅と仮定しているのに合わせているだけなので、別のアプリケーションでは合わなくなるといったことが起こります。
go-runewidth のAmbiguous width go言語では、１文字がターミナルで半角なのか全角なのかを判断するには、go-runewidthで判断するのがデファクトスタンダードになっていると思います。
go-runewidthでは、ロケールに従ってAmbiguousな幅を決定していて日本語を使用している場合(ja_JP.UTF-8等)は、全角（2文字幅）になります。
この場合、上記のgnome-terminalで「曖昧幅の文字(W)」を半角にしていた場合は、余分な隙間が空いて表示が崩れたようになります。 LANG=Cでアプリケーションを起動し直してみて表示が正常になる場合は、この「曖昧幅の文字(W)」とgo-runewidthが解釈するロケールに齟齬が起こっていることになります。
go-runewideth ではロケールの他に環境変数RUNEWIDTH_EASTASIANによりAmbiguousな幅を変更できますので、gnome-terminalではPreferencesの「曖昧幅の文字(W)」が半角の場合は、環境変数RUNEWIDTH_EASTASIANを0に全角の場合は1に設定しておくとgo言語のTUIアプリケーションの表示の乱れが無くなるのでは無いかと思います。</description></item></channel></rss>