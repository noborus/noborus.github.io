<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>jq on Noboru Saito's page</title><link>https://noborus.github.io/tags/jq/</link><description>Recent content in jq on Noboru Saito's page</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Thu, 02 Jun 2022 07:00:00 +0900</lastBuildDate><atom:link href="https://noborus.github.io/tags/jq/index.xml" rel="self" type="application/rss+xml"/><item><title>trdsql output</title><link>https://noborus.github.io/blog/35_jq/</link><pubDate>Thu, 02 Jun 2022 07:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/35_jq/</guid><description>これまでtdsqlが対象とするJSONはフラットなJSONでした。そのためSQLの対象となるのはトップレベルが配列になっている場合は、その中のオブジェクトが対象となります。
[ {&amp;quot;age&amp;quot;: &amp;quot;26&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Tanaka&amp;quot;}, {&amp;quot;age&amp;quot;: &amp;quot;32&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Suzuki&amp;quot;} ] JSONは階層を深くすることができるので、さらに下の階層をSQLの対象としたい場合がありました。SQLの関数を使用して、アクセスすることも出来ますが、少し面倒でした。
{ &amp;quot;list&amp;quot;: [ {&amp;quot;age&amp;quot;: &amp;quot;26&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Tanaka&amp;quot;}, {&amp;quot;age&amp;quot;: &amp;quot;32&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Suzuki&amp;quot;} ] } tdsqlではJSONに対し、まずjqの構文を使用して処理し、その結果に対してSQLを実行できます。 jqの構文はファイル名の後に&amp;quot;::&amp;ldquo;を付け、その後に書きます。 jqの構文なので、主に&amp;rdquo;.&amp;ldquo;ドットではじまり、中の値にアクセスします。
trdsql &amp;quot;SELECT * FROM example0-s.json （配列全体を１つの列と解釈してしまう）。
&amp;quot;[{&amp;quot;&amp;quot;age&amp;quot;&amp;quot;:&amp;quot;&amp;quot;26&amp;quot;&amp;quot;,&amp;quot;&amp;quot;name&amp;quot;&amp;quot;:&amp;quot;&amp;quot;Tanaka&amp;quot;&amp;quot;},{&amp;quot;&amp;quot;age&amp;quot;&amp;quot;:&amp;quot;&amp;quot;32&amp;quot;&amp;quot;,&amp;quot;&amp;quot;name&amp;quot;&amp;quot;:&amp;quot;&amp;quot;Suzuki&amp;quot;&amp;quot;}]&amp;quot; trdsql &amp;quot;SELECT * FROM example0-s.json::.list （listをテーブルとして解釈して、中のオブジェクトを列として解釈する）。
26,Tanaka 32,Suzuki 深い階層にアクセスしたいときは、jqの構文では .list.menu.itemのようにドットで繋いでいけば簡単にアクセスすることができます。 階層途中に配列があってもjqの構文（[]等が含まれる場合は「&amp;quot;」で括る等してください）が書ければアクセスすることができます。
trdsql &amp;quot;SELECT * FROM example0-s.json::\&amp;quot;.list[1].name\&amp;quot;&amp;quot; 複雑な集計をjqで書くのは難しいため、対象をテーブル化することでSQLで集計するといったことができます。 また、CSVや他の形式に変換するのもtrdsqlでは簡単です。</description></item><item><title>Another way to aggregate json(jq + SQL)</title><link>https://noborus.github.io/blog/jqsql/</link><pubDate>Tue, 03 May 2022 12:58:24 +0900</pubDate><guid>https://noborus.github.io/blog/jqsql/</guid><description>Aggregate json with trdsql I agree that the aggregation of jq described in the Introducing zq is not easy.
I&amp;rsquo;ve seen A Practical Example of zq, zq was not easy for me.
SQL is not easy for everyone, but it is a language that many people can use. I am one of them.
Of course, it is difficult to process all JSON with SQL. But what about using them in combination?</description></item><item><title>trdsql+PostgreSQL 14でJSONを処理する</title><link>https://noborus.github.io/blog/trdsql_jq/</link><pubDate>Sat, 18 Dec 2021 15:40:00 +0900</pubDate><guid>https://noborus.github.io/blog/trdsql_jq/</guid><description>trdsql はCSVやLTSVと共にJSONに対してもSQLを実行できるツールですが、SQLを使用するため得意な対象はフラットなJSONです。 ただし、v0.9.0からjqの構文が使え、SQL内でもSQLの関数が使えるため、内容によっては簡単に書くことができる場合があります。
デフォルトのsqlite3にもJSON関数がありますが、ここではよりJSON関数が充実しているPostgreSQL 14を使用します。
基本的な使用法 SQLを実行する対象として複数の列のリストの形になっているものが対象です。 以下のように{``}で囲まれた複数の名前: 値が,で並べられたJSONが基本的な形です。 改行で区切られた（実際には）複数のJSONが並べられたLDJSONやJSONLと呼ばれるものは一番SQLで実行しやすい形です。
{ &amp;quot;name&amp;quot;: &amp;quot;Tanaka&amp;quot;, &amp;quot;age&amp;quot;: 26 } { &amp;quot;name&amp;quot;: &amp;quot;Suzuki&amp;quot;, &amp;quot;age&amp;quot;: 32 } 一つのJSONの場合は上記を配列化します。
[ { &amp;quot;age&amp;quot;: &amp;quot;26&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Tanaka&amp;quot; }, { &amp;quot;age&amp;quot;: &amp;quot;32&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Suzuki&amp;quot; } ] どちらもそのままSELECT name, age FROM example0.jsonのようにtrdsqlのSQLとして実行できます。
JSONはオブジェクトや配列で入れ子に出来るため、ルートが対象とならない場合があります。以下の場合は、そのまま実行すると menu 列が一つに中身がすべて入っていることになります。
{ &amp;quot;menu&amp;quot;: { &amp;quot;id&amp;quot;: &amp;quot;file&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;File&amp;quot;, &amp;quot;popup&amp;quot;: { &amp;quot;menuitem&amp;quot;: [ { &amp;quot;value&amp;quot;: &amp;quot;New&amp;quot;, &amp;quot;onclick&amp;quot;: &amp;quot;CreateDoc()&amp;quot; }, { &amp;quot;value&amp;quot;: &amp;quot;Open&amp;quot;, &amp;quot;onclick&amp;quot;: &amp;quot;OpenDoc()&amp;quot; }, { &amp;quot;value&amp;quot;: &amp;quot;Save&amp;quot;, &amp;quot;onclick&amp;quot;: &amp;quot;SaveDoc()&amp;quot; } ] } } } SQLのJSON関数を使用することで内部のオブジェクトにアクセスできますが、ほとんどがJSON関数の記述になってしまうのでSQLで実行するメリットが感じられません。</description></item></channel></rss>