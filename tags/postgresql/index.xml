<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>postgresql on Noboru Saito's page</title><link>https://noborus.github.io/tags/postgresql/</link><description>Recent content in postgresql on Noboru Saito's page</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Wed, 14 Jul 2021 15:00:00 +0900</lastBuildDate><atom:link href="https://noborus.github.io/tags/postgresql/index.xml" rel="self" type="application/rss+xml"/><item><title>pgsp</title><link>https://noborus.github.io/blog/pgsp/</link><pubDate>Wed, 14 Jul 2021 15:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/pgsp/</guid><description>pgsp は PostgreSQLの pg_stat_progress viewを監視して表示するCLIツールです。
pg_stat_progress PostgreSQLでは、いくつか時間がかかる処理に対して進捗状況が見られるViewがあります。 Viewの名前は pg_stat_progressではじまり、analyze, cluster, create_index, vacuum, basebackup (version 14からは copyが追加される予定)などが取得できます。
詳しくは progress-reportingを参照してください。
これらのViewは処理が始まったときにレコードが追加されて、変化する処理状況（フェーズや処理した数）を更新していき、終了するとレコードが消えます。SQLで簡単に確認できるので便利ですが、常に更新されていくため、状況を逐一見たいときにはpsqlでは\watch等を利用してSELECTを繰り返して見る必要があります。
SELECT * FROM pg_stat_progress_analyze; pgsp pgspはこれらのViewを監視して表示する専用のCLIツールです。Go製です。 やっていることはシンプルでpg_stat_progress_* のViewを定期的にSELECTで取得し、レコードが追加、更新されたら進捗に相当する数値でプログレスバーを更新します。
PostgreSQLに普通に接続にいくので接続情報（ホスト、ポート、ユーザー、パスワード等）が必要です。 --dsnで設定してください。
pgsp --dsn 'host=ホスト名 port=ポート番号 user=ユーザー名 password=パスワード' UNIXドメインソケットを使用する場合はhostにpathを書きます。
pgsp --dsn 'host=/var/run/postgresql' 設定ファイルとして $HOME/.pgsp.yaml に書くこともできます。
dsn: host='/var/run/postgresql/' user='postgres' 起動すると定期的にViewにSELECTを実行します。レコードがなければスピンが回るだけです。
何らかの処理が走ってViewにレコードが追加されるとViewの内容とプログレスバーが表示されます。Viewの内容はTerminalの表示域によって変わるようになっています。
また、Viewは処理が終わるとレコードが削除されますが、pgspでは少しの間（デフォルトで10秒）表示し続けるようになっています。この時間は -a --AfterCompletionにより調整できます。
10分経過まで表示しておきたい場合は以下のようにします。
pgsp -a 600 更新間隔は-i --Intervalによって指定できます（デフォルトは 0.5秒)。処理によってはすぐに終わってしまうので、0.5秒間隔だと、実際には処理が行われていたにも関わらず捕捉出来ない場合があります。その場合は更新間隔を0.1秒等にしてみてください。
逆に負荷が気になる場合は1以上に設定すると良いでしょう。
Bubble Tea CLIツールの表示はBubble Tea を使用しておこなっています。
Bubble TeaではTerminal上で、その場で表示するアプリケーションが簡単に作成出来るようになっています。その例でもあるプログレスバーをシンプルに利用しています。</description></item><item><title>trdsql 合計を行に追加する</title><link>https://noborus.github.io/blog/31_rollup/</link><pubDate>Sat, 04 Jan 2020 13:38:00 +0900</pubDate><guid>https://noborus.github.io/blog/31_rollup/</guid><description>Window関数により元のファイルの内容に列を追加して、集計結果を出せました。 ただ、人が確認する場合は、集計の結果行が最後に出るほうが確認しやすくなります。
通常のSQLでも元の内容と集計結果を別々に出してUNIONを使うことで、一つの結果として出すことが出来ますが、一回で済むならばそれに越したことはありません。
SQLite3ではサポートされていませんが、PostgreSQLとMySQLならばサポートされている文があります。
ROLLUP Window関数でも使用した以下のCSVファイルを使用します。
id,class,name,score 1,A,bob,174 2,A,alice,248 3,A,carol,163 4,B,dave,289 5,B,eve,157 6,B,flank,272 通常のGROUP BYで全体の合計又は、class毎の合計が出せました。 ただし、class毎の合計と全体の合計を出すにはWindow関数を使用して別の列に出していました。
GROUP BYに ROLLUPを指定することで、両方を出力できます。
PostgreSQL PostgreSQLでは、GROUP BY 列名の代わりにGROUP BY ROLLUP(列名)を使用することで、通常のGROUP BYに加えて、全体の集計結果を出力します。
trdsql -driver &amp;quot;postgres&amp;quot; -dsn &amp;quot;dbname=trdsql_test&amp;quot; -oat -ih \ &amp;quot;SELECT class, SUM(score::int) AS score FROM score.csv GROUP BY ROLLUP(class) ORDER BY class&amp;quot; +-------+------+ | class | sum | +-------+------+ | A | 585 | | B | 718 | | | 1303 | +-------+------+ MySQL MySQLでは、GROUP BY 列名の後に WITH ROLLUPを付けると、通常のGROUP BYに加えて、全体の集計結果を出力します。</description></item><item><title>trdsql generate_series</title><link>https://noborus.github.io/blog/29_generate_series/</link><pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/29_generate_series/</guid><description>generate_series PostgreSQLにはgenerate_series()という便利な関数があります。 これはUnixのseqコマンドと同じような働きをする関数です。またgenerate_series()は、タイムスタンプ型にも使用できる拡張があります。
使い方は簡単で「開始値」、「終了値」、「刻み値（省略可能）」を指定して実行します。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; &amp;quot;SELECT * FROM generate_series(1,10)&amp;quot; 1 2 3 4 5 6 7 8 9 10 generate_series()はテーブルを返す関数で、テーブルの代わりに使用できます。 （SELECT generate_series(1,10)と書くこともできます）。
もちろん、trdsqlでは、外部からの入力を簡単に取り入れられるので、seqコマンドで代用することもできます。
seq 1 10|trdsql &amp;quot;SELECT * FROM -&amp;quot; 1 2 3 4 5 6 7 8 9 10 seqコマンドは、引数の順序が「開始値」、「刻み値（省略可能）」「終了値」になります。 2つの値を渡すときには同じですが、刻み値を指定する場合は、順序が異なるので注意が必要です。
タイムスタンプ generate_series()では、タイムスタンプを扱えるので、2020年のカレンダーを日本語で出すと少々トリッキーですが、以下のようになります。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; \ &amp;quot;SET LC_TIME='ja_JP.UTF-8'; &amp;quot; \ &amp;quot;SELECT to_char(day,'YYYY年TMMonthDD日 (TMDay)') &amp;quot; \ &amp;quot; FROM generate_series('2020-01-1'::timestamp,'2020-12-31','1 day') as day&amp;quot; 2020年1月01日 (水曜日) 2020年1月02日 (木曜日) 2020年1月03日 (金曜日) 2020年1月04日 (土曜日) .</description></item><item><title>trdsql DBインポート</title><link>https://noborus.github.io/blog/15_import/</link><pubDate>Sun, 15 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/15_import/</guid><description>trdsqlにはデータベースにインポートするオプションはありません。 しかしながら、SELECT以外のSQLの実行も可能なので、SQLによるインポートが可能です。
以下は、メモリデータベースにインポートしても終了すると消えてしまうので、メモリデータベース以外のデータベースに接続して実行します。
CREATE TABLE AS テーブルを作成してインポートするには CREATE TABLE ASを使用します。
PostgreSQL で CREATE TABLE AS まず、PostgreSQLへデータをインポートしてみます。 これまで、SELECTで実行してきた内容に CREATE TABLE テーブル名 AS を前につければ、テーブルが作成されデータがインポートされます。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; -ih \ &amp;quot;CREATE TABLE test AS SELECT * FROM header.csv&amp;quot; 成功した場合、何も表示されずに終了します。失敗した場合、エラーが表示されます。
SELECTの結果がインポートされるため、SELECT側で列名の変更、列の型指定、インポートするデータの条件指定をすれば良いことになります。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; -ih \ &amp;quot;CREATE TABLE fruits AS SELECT id::int AS num, name::VARCHAR(20) FROM header.csv&amp;quot; trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; -ih -oh\ &amp;quot;SELECT * FROM fruits&amp;quot; num,name 1,Orange 2,Melon 3,Apple もし、テーブルの作成のみを先にして、INSERTを後でおこないたい場合はWITH NO DATAを付けます。</description></item><item><title>trdsql PostgreSQLエンジンの使用</title><link>https://noborus.github.io/blog/12_postgres/</link><pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/12_postgres/</guid><description>trdsqlは組込みのSQLite3を利用してSQLを実行していますが、データベースの処理を別のデータベースに変更出来ます。
ここではPostgreSQLを使用する方法を説明します。
PostgreSQLに接続 SQLite3と違いPostgreSQLは動作しているPostgreSQLサーバーが必要です。接続できテーブルが作成できる権限があるデータベースを作成しておきます。
オプションの -driver に postgres を指定し、-dsn にサーバーへの接続情報を指定します。
dsnの項目には以下が指定できます。デフォルトの場合は省略可能です。
項目名 説明 dbname データベース名（デフォルト:ログインユーザー名） user ユーザー名（デフォルト:ログインユーザー名） password パスワード（デフォルト:なし） host ホスト名又はIPアドレス（デフォルト:localhost） port ポート番号(デフォルト: 5432) sslmode SSLモード（デフォルト: require） fallback_application_name （提供されない場合の）アプリケーション名（デフォルト:なし） connect_timeout 接続の最大待機時間 sslcert 証明書ファイルの場所 sslkey 秘密鍵ファイルの場所 sslrootcert ルート証明書ファイルの場所 項目=値をスペース区切りで指定します。
DSN指定 例えば、ローカルホストのportが5433でデータベース名がtrdsql_testに接続するには以下のようにします。</description></item></channel></rss>