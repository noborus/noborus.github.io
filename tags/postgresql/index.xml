<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>postgresql on Noboru Saito's page</title><link>https://noborus.github.io/tags/postgresql/</link><description>Recent content in postgresql on Noboru Saito's page</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Thu, 14 Jul 2022 20:00:00 +0900</lastBuildDate><atom:link href="https://noborus.github.io/tags/postgresql/index.xml" rel="self" type="application/rss+xml"/><item><title>PostgreSQLで0列の扱い</title><link>https://noborus.github.io/blog/column0/</link><pubDate>Thu, 14 Jul 2022 20:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/column0/</guid><description>きっかけ 現在のバージョンのPostgreSQLではSELECT ;というSQL文を実行してもエラーになりません。 試してみると(1 row)と返ってきたので、あれ？なんで？となりました。
これは、列数が0なんですね。PostgreSQLは列数が0のテーブルが作れるので、それに合わせているようです。
CREATE empty();
&amp;mdash; Tatsuo Ishii (@tatsuo_ishii) July 13, 2022 列数が0という指摘を受けて、一応0列があることを理解していたつもりだったのですけど、 その仕様を勘違いしていたことに気づきました。
テーブルを省略したSELECTの扱い 全部のSQL実装では無いですが、SQLのSELECTはFROM句がなくても動作する実装が多いです。 psqlで実行すると以下のようになります。
SELECT '1'; ?column? ---------- 1 (1 row) のようにすれば文字列1が返ってきます。列名は無いので?column?で表されていますが、1行1列のテーブルと同じ扱いになります。
SELECT ;はこの流れで行数が1で、列数が0のテーブルということになります。
psqlでは実行すると以下のように行が（改行も含めて）表示されないまま 1 row と表示されるのでちょっと変な感じがしたのですが、これはpsql側でどう表示するかの問題であって、1行0列のテーブルと同じ扱いになっています。
SELECT ; -- (1 row) なにも指定していないので、0行0列になるかと勘違いしてましたが、1行0列の方が正しいとわかります。
PostgreSQLは0列のテーブルが作れる 前述の石井さんから指摘にあるように最近のPostgreSQLでは0列のテーブルが作成できるようになっています。
CREATE TABLE empty (); 元からSQLでは行をINSERTしなければ0行のテーブルになるので、0列のテーブルを作っただけだと0列0行のテーブルになります。
SELECT * FROM empty; -- (0 rows) psqlの表示では0列の場合(1 row)と(0 rows)の表示でしか区別出来ないですが、0行と1行でちゃんと違いがあって整合が取れている動作になっています。
0列のテーブル操作 前は0列のSQLが許可されないところが多かったのですが、現在進行形で0列を許可するように修正されているので、前はエラーになったものが通るようになっていたり、これから通るようになったりする可能性があります。
INSERT 0列のテーブルにINSERTしようとすると素直にできませんでした。
INSERT INTO empty () VALUES (); ERROR: 42601: syntax error at or near &amp;quot;)&amp;quot; SELECT 列数が0のテーブルだけでなく、列数が1つ以上のテーブルであってもSELECT FROM oneで列数が0で返すことができます。 これにより列数が0で、複数行のテーブルを表現できます。</description></item><item><title>第32回 PostgreSQLアンカンファレンス@オンラインで発表しました</title><link>https://noborus.github.io/blog/pgunconf/</link><pubDate>Fri, 01 Apr 2022 09:54:52 +0900</pubDate><guid>https://noborus.github.io/blog/pgunconf/</guid><description>「作ったツール紹介」というタイトルで発表しました https://pgunconf.connpass.com/event/240528/
自分で作った以下のツールを紹介してます。
trdsql ov pgsp jpug-doc-tool また、ovの関連でページャーとして、lessとpspgも紹介してます。
とくに、lessはまだ正式リリース版ではないですが、ヘッダーオプションが追加されるということで、PostgreSQLに限らず全DBのCLIを使っている人にとって、朗報だと思います。
また、ヘッダー固定が可能なことを前提にすると他のアプリケーションの作り方も変わっていくものだと思っています。
jpug-doc-toolでみんなの自動翻訳＠TexTraを使用できるようにしていることを紹介しました。
みんなの自動翻訳の説明はだいぶ省略しましたが、対訳語の登録や対訳集を学習させる等によりカスタマイズエンジンをみんなで育てることができれば、PostgreSQL向けの翻訳精度が上がっていくと思うので、利用者を増やしたいところです。</description></item><item><title>trdsql+PostgreSQL 14でJSONを処理する</title><link>https://noborus.github.io/blog/trdsql_jq/</link><pubDate>Sat, 18 Dec 2021 15:40:00 +0900</pubDate><guid>https://noborus.github.io/blog/trdsql_jq/</guid><description>trdsql はCSVやLTSVと共にJSONに対してもSQLを実行できるツールですが、SQLを使用するため得意な対象はフラットなJSONです。 ただし、v0.9.0からjqの構文が使え、SQL内でもSQLの関数が使えるため、内容によっては簡単に書くことができる場合があります。
デフォルトのsqlite3にもJSON関数がありますが、ここではよりJSON関数が充実しているPostgreSQL 14を使用します。
基本的な使用法 SQLを実行する対象として複数の列のリストの形になっているものが対象です。 以下のように{``}で囲まれた複数の名前: 値が,で並べられたJSONが基本的な形です。 改行で区切られた（実際には）複数のJSONが並べられたLDJSONやJSONLと呼ばれるものは一番SQLで実行しやすい形です。
{ &amp;quot;name&amp;quot;: &amp;quot;Tanaka&amp;quot;, &amp;quot;age&amp;quot;: 26 } { &amp;quot;name&amp;quot;: &amp;quot;Suzuki&amp;quot;, &amp;quot;age&amp;quot;: 32 } 一つのJSONの場合は上記を配列化します。
[ { &amp;quot;age&amp;quot;: &amp;quot;26&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Tanaka&amp;quot; }, { &amp;quot;age&amp;quot;: &amp;quot;32&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Suzuki&amp;quot; } ] どちらもそのままSELECT name, age FROM example0.jsonのようにtrdsqlのSQLとして実行できます。
JSONはオブジェクトや配列で入れ子に出来るため、ルートが対象とならない場合があります。以下の場合は、そのまま実行すると menu 列が一つに中身がすべて入っていることになります。
{ &amp;quot;menu&amp;quot;: { &amp;quot;id&amp;quot;: &amp;quot;file&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;File&amp;quot;, &amp;quot;popup&amp;quot;: { &amp;quot;menuitem&amp;quot;: [ { &amp;quot;value&amp;quot;: &amp;quot;New&amp;quot;, &amp;quot;onclick&amp;quot;: &amp;quot;CreateDoc()&amp;quot; }, { &amp;quot;value&amp;quot;: &amp;quot;Open&amp;quot;, &amp;quot;onclick&amp;quot;: &amp;quot;OpenDoc()&amp;quot; }, { &amp;quot;value&amp;quot;: &amp;quot;Save&amp;quot;, &amp;quot;onclick&amp;quot;: &amp;quot;SaveDoc()&amp;quot; } ] } } } SQLのJSON関数を使用することで内部のオブジェクトにアクセスできますが、ほとんどがJSON関数の記述になってしまうのでSQLで実行するメリットが感じられません。</description></item><item><title>pgsp</title><link>https://noborus.github.io/blog/pgsp/</link><pubDate>Wed, 14 Jul 2021 15:00:00 +0900</pubDate><guid>https://noborus.github.io/blog/pgsp/</guid><description>pgsp は PostgreSQLの pg_stat_progress viewを監視して表示するCLIツールです。
pg_stat_progress PostgreSQLでは、いくつか時間がかかる処理に対して進捗状況が見られるViewがあります。 Viewの名前は pg_stat_progressではじまり、analyze, cluster, create_index, vacuum, basebackup (version 14からは copyが追加される予定)などが取得できます。
詳しくは progress-reportingを参照してください。
これらのViewは処理が始まったときにレコードが追加されて、変化する処理状況（フェーズや処理した数）を更新していき、終了するとレコードが消えます。SQLで簡単に確認できるので便利ですが、常に更新されていくため、状況を逐一見たいときにはpsqlでは\watch等を利用してSELECTを繰り返して見る必要があります。
SELECT * FROM pg_stat_progress_analyze; pgsp pgspはこれらのViewを監視して表示する専用のCLIツールです。Go製です。 やっていることはシンプルでpg_stat_progress_* のViewを定期的にSELECTで取得し、レコードが追加、更新されたら進捗に相当する数値でプログレスバーを更新します。
PostgreSQLに普通に接続にいくので接続情報（ホスト、ポート、ユーザー、パスワード等）が必要です。 --dsnで設定してください。
pgsp --dsn 'host=ホスト名 port=ポート番号 user=ユーザー名 password=パスワード' UNIXドメインソケットを使用する場合はhostにpathを書きます。
pgsp --dsn 'host=/var/run/postgresql' 設定ファイルとして $HOME/.pgsp.yaml に書くこともできます。
dsn: host='/var/run/postgresql/' user='postgres' 起動すると定期的にViewにSELECTを実行します。レコードがなければスピンが回るだけです。
何らかの処理が走ってViewにレコードが追加されるとViewの内容とプログレスバーが表示されます。Viewの内容はTerminalの表示域によって変わるようになっています。
また、Viewは処理が終わるとレコードが削除されますが、pgspでは少しの間（デフォルトで10秒）表示し続けるようになっています。この時間は -a --AfterCompletionにより調整できます。
10分経過まで表示しておきたい場合は以下のようにします。
pgsp -a 600 更新間隔は-i --Intervalによって指定できます（デフォルトは 0.5秒)。処理によってはすぐに終わってしまうので、0.5秒間隔だと、実際には処理が行われていたにも関わらず捕捉出来ない場合があります。その場合は更新間隔を0.1秒等にしてみてください。
逆に負荷が気になる場合は1以上に設定すると良いでしょう。
Bubble Tea CLIツールの表示はBubble Tea を使用しておこなっています。
Bubble TeaではTerminal上で、その場で表示するアプリケーションが簡単に作成出来るようになっています。その例でもあるプログレスバーをシンプルに利用しています。
また、Terminal全体を使用してのアプリケーションも作成出来るため、pgspでも-f --fullscreenオプションによりTerminal全体を表示できるようになっています。
fullscreenで表示した場合は起動前の表示内容はそのまま、別途別のコンソールが開かれ、終了後は元の画面に戻ります。お好みで使い分けてください。</description></item><item><title>trdsql 合計を行に追加する</title><link>https://noborus.github.io/blog/31_rollup/</link><pubDate>Sat, 04 Jan 2020 13:38:00 +0900</pubDate><guid>https://noborus.github.io/blog/31_rollup/</guid><description>Window関数により元のファイルの内容に列を追加して、集計結果を出せました。 ただ、人が確認する場合は、集計の結果行が最後に出るほうが確認しやすくなります。
通常のSQLでも元の内容と集計結果を別々に出してUNIONを使うことで、一つの結果として出すことが出来ますが、一回で済むならばそれに越したことはありません。
SQLite3ではサポートされていませんが、PostgreSQLとMySQLならばサポートされている文があります。
ROLLUP Window関数でも使用した以下のCSVファイルを使用します。
id,class,name,score 1,A,bob,174 2,A,alice,248 3,A,carol,163 4,B,dave,289 5,B,eve,157 6,B,flank,272 通常のGROUP BYで全体の合計又は、class毎の合計が出せました。 ただし、class毎の合計と全体の合計を出すにはWindow関数を使用して別の列に出していました。
GROUP BYに ROLLUPを指定することで、両方を出力できます。
PostgreSQL PostgreSQLでは、GROUP BY 列名の代わりにGROUP BY ROLLUP(列名)を使用することで、通常のGROUP BYに加えて、全体の集計結果を出力します。
trdsql -driver &amp;quot;postgres&amp;quot; -dsn &amp;quot;dbname=trdsql_test&amp;quot; -oat -ih \ &amp;quot;SELECT class, SUM(score::int) AS score FROM score.csv GROUP BY ROLLUP(class) ORDER BY class&amp;quot; +-------+------+ | class | sum | +-------+------+ | A | 585 | | B | 718 | | | 1303 | +-------+------+ MySQL MySQLでは、GROUP BY 列名の後に WITH ROLLUPを付けると、通常のGROUP BYに加えて、全体の集計結果を出力します。</description></item><item><title>trdsql generate_series</title><link>https://noborus.github.io/blog/29_generate_series/</link><pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/29_generate_series/</guid><description>generate_series PostgreSQLにはgenerate_series()という便利な関数があります。 これはUnixのseqコマンドと同じような働きをする関数です。またgenerate_series()は、タイムスタンプ型にも使用できる拡張があります。
使い方は簡単で「開始値」、「終了値」、「刻み値（省略可能）」を指定して実行します。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; &amp;quot;SELECT * FROM generate_series(1,10)&amp;quot; 1 2 3 4 5 6 7 8 9 10 generate_series()はテーブルを返す関数で、テーブルの代わりに使用できます。 （SELECT generate_series(1,10)と書くこともできます）。
もちろん、trdsqlでは、外部からの入力を簡単に取り入れられるので、seqコマンドで代用することもできます。
seq 1 10|trdsql &amp;quot;SELECT * FROM -&amp;quot; 1 2 3 4 5 6 7 8 9 10 seqコマンドは、引数の順序が「開始値」、「刻み値（省略可能）」「終了値」になります。 2つの値を渡すときには同じですが、刻み値を指定する場合は、順序が異なるので注意が必要です。
タイムスタンプ generate_series()では、タイムスタンプを扱えるので、2020年のカレンダーを日本語で出すと少々トリッキーですが、以下のようになります。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; \ &amp;quot;SET LC_TIME='ja_JP.UTF-8'; &amp;quot; \ &amp;quot;SELECT to_char(day,'YYYY年TMMonthDD日 (TMDay)') &amp;quot; \ &amp;quot; FROM generate_series('2020-01-1'::timestamp,'2020-12-31','1 day') as day&amp;quot; 2020年1月01日 (水曜日) 2020年1月02日 (木曜日) 2020年1月03日 (金曜日) 2020年1月04日 (土曜日) .</description></item><item><title>trdsql DBインポート</title><link>https://noborus.github.io/blog/15_import/</link><pubDate>Sun, 15 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/15_import/</guid><description>trdsqlにはデータベースにインポートするオプションはありません。 しかしながら、SELECT以外のSQLの実行も可能なので、SQLによるインポートが可能です。
以下は、メモリデータベースにインポートしても終了すると消えてしまうので、メモリデータベース以外のデータベースに接続して実行します。
CREATE TABLE AS テーブルを作成してインポートするには CREATE TABLE ASを使用します。
PostgreSQL で CREATE TABLE AS まず、PostgreSQLへデータをインポートしてみます。 これまで、SELECTで実行してきた内容に CREATE TABLE テーブル名 AS を前につければ、テーブルが作成されデータがインポートされます。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; -ih \ &amp;quot;CREATE TABLE test AS SELECT * FROM header.csv&amp;quot; 成功した場合、何も表示されずに終了します。失敗した場合、エラーが表示されます。
SELECTの結果がインポートされるため、SELECT側で列名の変更、列の型指定、インポートするデータの条件指定をすれば良いことになります。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; -ih \ &amp;quot;CREATE TABLE fruits AS SELECT id::int AS num, name::VARCHAR(20) FROM header.csv&amp;quot; trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; -ih -oh\ &amp;quot;SELECT * FROM fruits&amp;quot; num,name 1,Orange 2,Melon 3,Apple もし、テーブルの作成のみを先にして、INSERTを後でおこないたい場合はWITH NO DATAを付けます。</description></item><item><title>trdsql PostgreSQLエンジンの使用</title><link>https://noborus.github.io/blog/12_postgres/</link><pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/12_postgres/</guid><description>trdsqlは組込みのSQLite3を利用してSQLを実行していますが、データベースの処理を別のデータベースに変更出来ます。
ここではPostgreSQLを使用する方法を説明します。
PostgreSQLに接続 SQLite3と違いPostgreSQLは動作しているPostgreSQLサーバーが必要です。接続できテーブルが作成できる権限があるデータベースを作成しておきます。
オプションの -driver に postgres を指定し、-dsn にサーバーへの接続情報を指定します。
dsnの項目には以下が指定できます。デフォルトの場合は省略可能です。
項目名 説明 dbname データベース名（デフォルト:ログインユーザー名） user ユーザー名（デフォルト:ログインユーザー名） password パスワード（デフォルト:なし） host ホスト名又はIPアドレス（デフォルト:localhost） port ポート番号(デフォルト: 5432) sslmode SSLモード（デフォルト: require） fallback_application_name （提供されない場合の）アプリケーション名（デフォルト:なし） connect_timeout 接続の最大待機時間 sslcert 証明書ファイルの場所 sslkey 秘密鍵ファイルの場所 sslrootcert ルート証明書ファイルの場所 項目=値をスペース区切りで指定します。
DSN指定 例えば、ローカルホストのportが5433でデータベース名がtrdsql_testに接続するには以下のようにします。
trdsql -driver postgres -dsn &amp;#34;host=localhost port=5433 dbname=trdsql_test&amp;#34; &amp;#34;SELECT 1&amp;#34; UNIXドメインソケット UNIXドメインソケットへ接続もできます。
パッケージ等でPostgreSQLをインストールすると以下のような場所にUNIXドメインソケットファイルが作成されています。
/var/run/postgresql/.s.PGSQL.5432 上記の場合、hostに/var/run/postgresql/を指定します。「/」から始まるとUnixドメインソケットとみなされます。portは.s.PGSQL.の後にある「5432」を指定します。
trdsql -driver postgres -dsn &amp;#34;host=/var/run/postgresql/ port=5432 dbname=trdsql_test&amp;#34; &amp;#34;SELECT VERSION()&amp;#34; &amp;quot;PostgreSQL 10.10 (Ubuntu 10.10-0ubuntu0.18.04.1) on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 7.</description></item></channel></rss>