<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>postgresql on Noboru Saito's page</title><link>https://noborus.github.io/tags/postgresql/</link><description>Recent content in postgresql on Noboru Saito's page</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Sat, 04 Jan 2020 13:38:00 +0900</lastBuildDate><atom:link href="https://noborus.github.io/tags/postgresql/index.xml" rel="self" type="application/rss+xml"/><item><title>trdsql 合計を行に追加する</title><link>https://noborus.github.io/blog/31_rollup/</link><pubDate>Sat, 04 Jan 2020 13:38:00 +0900</pubDate><guid>https://noborus.github.io/blog/31_rollup/</guid><description>Window関数により元のファイルの内容に列を追加して、集計結果を出せました。 ただ、人が確認する場合は、集計の結果行が最後に出るほうが確認しやすくなります。
通常のSQLでも元の内容と集計結果を別々に出してUNIONを使うことで、一つの結果として出すことが出来ますが、一回で済むならばそれに越したことはありません。
SQLite3ではサポートされていませんが、PostgreSQLとMySQLならばサポートされている文があります。
ROLLUP Window関数でも使用した以下のCSVファイルを使用します。
id,class,name,score 1,A,bob,174 2,A,alice,248 3,A,carol,163 4,B,dave,289 5,B,eve,157 6,B,flank,272 通常のGROUP BYで全体の合計又は、class毎の合計が出せました。 ただし、class毎の合計と全体の合計を出すにはWindow関数を使用して別の列に出していました。
GROUP BYに ROLLUPを指定することで、両方を出力できます。
PostgreSQL PostgreSQLでは、GROUP BY 列名の代わりにGROUP BY ROLLUP(列名)を使用することで、通常のGROUP BYに加えて、全体の集計結果を出力します。
trdsql -driver &amp;quot;postgres&amp;quot; -dsn &amp;quot;dbname=trdsql_test&amp;quot; -oat -ih \ &amp;quot;SELECT class, SUM(score::int) AS score FROM score.csv GROUP BY ROLLUP(class) ORDER BY class&amp;quot; +-------+------+ | class | sum | +-------+------+ | A | 585 | | B | 718 | | | 1303 | +-------+------+ MySQL MySQLでは、GROUP BY 列名の後に WITH ROLLUPを付けると、通常のGROUP BYに加えて、全体の集計結果を出力します。</description></item><item><title>trdsql generate_series</title><link>https://noborus.github.io/blog/29_generate_series/</link><pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/29_generate_series/</guid><description>generate_series PostgreSQLにはgenerate_series()という便利な関数があります。 これはUnixのseqコマンドと同じような働きをする関数です。またgenerate_series()は、タイムスタンプ型にも使用できる拡張があります。
使い方は簡単で「開始値」、「終了値」、「刻み値（省略可能）」を指定して実行します。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; &amp;quot;SELECT * FROM generate_series(1,10)&amp;quot; 1 2 3 4 5 6 7 8 9 10 generate_series()はテーブルを返す関数で、テーブルの代わりに使用できます。 （SELECT generate_series(1,10)と書くこともできます）。
もちろん、trdsqlでは、外部からの入力を簡単に取り入れられるので、seqコマンドで代用することもできます。
seq 1 10|trdsql &amp;quot;SELECT * FROM -&amp;quot; 1 2 3 4 5 6 7 8 9 10 seqコマンドは、引数の順序が「開始値」、「刻み値（省略可能）」「終了値」になります。 2つの値を渡すときには同じですが、刻み値を指定する場合は、順序が異なるので注意が必要です。
タイムスタンプ generate_series()では、タイムスタンプを扱えるので、2020年のカレンダーを日本語で出すと少々トリッキーですが、以下のようになります。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; \ &amp;quot;SET LC_TIME='ja_JP.UTF-8'; &amp;quot; \ &amp;quot;SELECT to_char(day,'YYYY年TMMonthDD日 (TMDay)') &amp;quot; \ &amp;quot; FROM generate_series('2020-01-1'::timestamp,'2020-12-31','1 day') as day&amp;quot; 2020年1月01日 (水曜日) 2020年1月02日 (木曜日) 2020年1月03日 (金曜日) 2020年1月04日 (土曜日) .</description></item><item><title>trdsql DBインポート</title><link>https://noborus.github.io/blog/15_import/</link><pubDate>Sun, 15 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/15_import/</guid><description>trdsqlにはデータベースにインポートするオプションはありません。 しかしながら、SELECT以外のSQLの実行も可能なので、SQLによるインポートが可能です。
以下は、メモリデータベースにインポートしても終了すると消えてしまうので、メモリデータベース以外のデータベースに接続して実行します。
CREATE TABLE AS テーブルを作成してインポートするには CREATE TABLE ASを使用します。
PostgreSQL で CREATE TABLE AS まず、PostgreSQLへデータをインポートしてみます。 これまで、SELECTで実行してきた内容に CREATE TABLE テーブル名 AS を前につければ、テーブルが作成されデータがインポートされます。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; -ih \ &amp;quot;CREATE TABLE test AS SELECT * FROM header.csv&amp;quot; 成功した場合、何も表示されずに終了します。失敗した場合、エラーが表示されます。
SELECTの結果がインポートされるため、SELECT側で列名の変更、列の型指定、インポートするデータの条件指定をすれば良いことになります。
trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; -ih \ &amp;quot;CREATE TABLE fruits AS SELECT id::int AS num, name::VARCHAR(20) FROM header.csv&amp;quot; trdsql -driver postgres -dsn &amp;quot;dbname=trdsql_test&amp;quot; -ih -oh\ &amp;quot;SELECT * FROM fruits&amp;quot; num,name 1,Orange 2,Melon 3,Apple もし、テーブルの作成のみを先にして、INSERTを後でおこないたい場合はWITH NO DATAを付けます。</description></item><item><title>trdsql PostgreSQLエンジンの使用</title><link>https://noborus.github.io/blog/12_postgres/</link><pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate><guid>https://noborus.github.io/blog/12_postgres/</guid><description>trdsqlは組込みのSQLite3を利用してSQLを実行していますが、データベースの処理を別のデータベースに変更出来ます。
ここではPostgreSQLを使用する方法を説明します。
PostgreSQLに接続 SQLite3と違いPostgreSQLは動作しているPostgreSQLサーバーが必要です。接続できテーブルが作成できる権限があるデータベースを作成しておきます。
オプションの -driver に postgres を指定し、-dsn にサーバーへの接続情報を指定します。
dsnの項目には以下が指定できます。デフォルトの場合は省略可能です。
項目名 説明 dbname データベース名（デフォルト:ログインユーザー名） user ユーザー名（デフォルト:ログインユーザー名） password パスワード（デフォルト:なし） host ホスト名又はIPアドレス（デフォルト:localhost） port ポート番号(デフォルト: 5432) sslmode SSLモード（デフォルト: require） fallback_application_name （提供されない場合の）アプリケーション名（デフォルト:なし） connect_timeout 接続の最大待機時間 sslcert 証明書ファイルの場所 sslkey 秘密鍵ファイルの場所 sslrootcert ルート証明書ファイルの場所 項目=値をスペース区切りで指定します。
DSN指定 例えば、ローカルホストのportが5433でデータベース名がtrdsql_testに接続するには以下のようにします。</description></item></channel></rss>