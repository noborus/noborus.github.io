<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.15. XML関数</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="functions-uuid.html" title="9.14. UUID関数" /><link rel="next" href="functions-json.html" title="9.16. JSON関数と演算子" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="other_version"><a href="https://www.postgresql.jp/document/">バージョンごとのドキュメント一覧</a></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 15.0文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="functions.html" title="第9章 関数と演算子">第9章 関数と演算子</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?template=bug_report.yml&amp;what-happened=version 15.0 : functions-xml.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-uuid.html" title="9.14. UUID関数">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="第9章 関数と演算子">上へ</a></td><td width="60%" align="center">9.15. XML関数</td><td width="20%" align="right"> <a accesskey="n" href="functions-json.html" title="9.16. JSON関数と演算子">次へ</a></td></tr></table><hr /></div><div class="sect1" id="FUNCTIONS-XML"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.15. XML関数</h2></div></div></div><span class="original">
  &lt;title&gt;XML Functions&lt;/title&gt;
</span><a id="id-1.5.8.23.2" class="indexterm"></a><p>
<span class="original">
   The functions and function-like expressions described in this
   section operate on values of type &lt;type&gt;xml&lt;/type&gt;.  See &lt;xref
   linkend="datatype-xml"/&gt; for information about the &lt;type&gt;xml&lt;/type&gt;
   type.  The function-like expressions &lt;function&gt;xmlparse&lt;/function&gt;
   and &lt;function&gt;xmlserialize&lt;/function&gt; for converting to and from
   type &lt;type&gt;xml&lt;/type&gt; are documented there, not in this section.
</span>
この節で説明される関数および擬似関数式は、<code class="type">xml</code>型の値に対して機能します。
<code class="type">xml</code>型についての情報は<a class="xref" href="datatype-xml.html" title="8.13. XML型">8.13</a>を参照してください。
<code class="type">xml</code>型のやりとりを変換する<code class="function">xmlparse</code>および<code class="function">xmlserialize</code>擬似関数式はこの節ではなく、そこに記載されています。
  </p><p>
<span class="original">
   Use of most of these functions
   requires &lt;productname&gt;PostgreSQL&lt;/productname&gt; to have been built
   with &lt;command&gt;configure &amp;#45;-with-libxml&lt;/command&gt;.
</span>
これらの関数の大半は<span class="productname">PostgreSQL</span>が<code class="command">configure --with-libxml</code>でビルドされていることを必要としています。
  </p><div class="sect2" id="FUNCTIONS-PRODUCING-XML"><div class="titlepage"><div><div><h3 class="title">9.15.1. XML内容の生成</h3></div></div></div><span class="original">
   &lt;title&gt;Producing XML Content&lt;/title&gt;
</span><p>
<span class="original">
    A set of functions and function-like expressions is available for
    producing XML content from SQL data.  As such, they are
    particularly suitable for formatting query results into XML
    documents for processing in client applications.
</span>
SQLデータからXML内容を生成するために関数と擬似関数式の一式が提供されています。
そのようなものとして、クライアントアプリケーションが問い合わせ結果を処理のためXML文書に書式化するのにこれらは特に適しています。
   </p><div class="sect3" id="id-1.5.8.23.5.3"><div class="titlepage"><div><div><h4 class="title">9.15.1.1. <code class="literal">xmlcomment</code></h4></div></div></div><a id="id-1.5.8.23.5.3.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlcomment</code> ( <code class="type">text</code> ) → <code class="returnvalue">xml</code>
</pre><p>
<span class="original">
     The function &lt;function&gt;xmlcomment&lt;/function&gt; creates an XML value
     containing an XML comment with the specified text as content.
     The text cannot contain &lt;quote&gt;&lt;literal&gt;&amp;#45;-&lt;/literal&gt;&lt;/quote&gt; or end with a
     &lt;quote&gt;&lt;literal&gt;-&lt;/literal&gt;&lt;/quote&gt;, otherwise the resulting construct
     would not be a valid XML comment.
     If the argument is null, the result is null.
</span>
関数<code class="function">xmlcomment</code>は指定のテキストを内容とするXMLコメントを含んだXML値を作成します。
テキストは<span class="quote">「<span class="quote"><code class="literal">--</code></span>」</span>を含むこと、または<span class="quote">「<span class="quote"><code class="literal">-</code></span>」</span>で終結することはできません。さもないと結果として構築されるXMLコメントは有効になりません。
引数がNULLならば結果もNULLになります。
    </p><p>
<span class="original">
     Example:
</span>
例：
</p><pre class="screen">
SELECT xmlcomment('hello');

  xmlcomment
--------------
 &lt;!--hello--&gt;
</pre><p>
    </p></div><div class="sect3" id="id-1.5.8.23.5.4"><div class="titlepage"><div><div><h4 class="title">9.15.1.2. <code class="literal">xmlconcat</code></h4></div></div></div><a id="id-1.5.8.23.5.4.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlconcat</code> ( <code class="type">xml</code> [<span class="optional">, ...</span>] ) → <code class="returnvalue">xml</code>
</pre><p>
<span class="original">
     The function &lt;function&gt;xmlconcat&lt;/function&gt; concatenates a list
     of individual XML values to create a single value containing an
     XML content fragment.  Null values are omitted; the result is
     only null if there are no nonnull arguments.
</span>
関数<code class="function">xmlconcat</code>は、個々のXML値のリストを結合し、XMLの内容断片を含む単一の値を作成します。
NULL値は削除され、NULL以外の引数が存在しないときのみ結果はNULLになります。
    </p><p>
<span class="original">
     Example:
</span>
例：
</p><pre class="screen">
SELECT xmlconcat('&lt;abc/&gt;', '&lt;bar&gt;foo&lt;/bar&gt;');

      xmlconcat
----------------------
 &lt;abc/&gt;&lt;bar&gt;foo&lt;/bar&gt;
</pre><p>
    </p><p>
<span class="original">
     XML declarations, if present, are combined as follows.  If all
     argument values have the same XML version declaration, that
     version is used in the result, else no version is used.  If all
     argument values have the standalone declaration value
     &lt;quote&gt;yes&lt;/quote&gt;, then that value is used in the result.  If
     all argument values have a standalone declaration value and at
     least one is &lt;quote&gt;no&lt;/quote&gt;, then that is used in the result.
     Else the result will have no standalone declaration.  If the
     result is determined to require a standalone declaration but no
     version declaration, a version declaration with version 1.0 will
     be used because XML requires an XML declaration to contain a
     version declaration.  Encoding declarations are ignored and
     removed in all cases.
</span>
XML宣言が提示されている場合は次のように組み合わされます。
全ての引数の値が同一のXML version宣言を持っていれば、そのversionが結果に使用されます。さもなければversionは使用されません。
全ての引数の値でstandaloneの宣言値が<span class="quote">「<span class="quote">yes</span>」</span>であれば、その値が結果に使用されます。
全ての引数の値にstandalone宣言値があり、その中で１つでも<span class="quote">「<span class="quote">no</span>」</span>がある場合、それが結果に使用されます。
それ以外の場合は、結果はstandalone宣言を持ちません。
standalone宣言を必要とするが、standalone宣言がないという結果になった場合には、version 1.0のversion宣言が使用されます。
これはXMLがXML宣言においてversion宣言を含むことを要求するためです。
encoding宣言は無視され、全ての場合で削除されます。
    </p><p>
<span class="original">
     Example:
</span>
例：
</p><pre class="screen">
SELECT xmlconcat('&lt;?xml version="1.1"?&gt;&lt;foo/&gt;', '&lt;?xml version="1.1" standalone="no"?&gt;&lt;bar/&gt;');

             xmlconcat
-----------------------------------
 &lt;?xml version="1.1"?&gt;&lt;foo/&gt;&lt;bar/&gt;
</pre><p>
    </p></div><div class="sect3" id="id-1.5.8.23.5.5"><div class="titlepage"><div><div><h4 class="title">9.15.1.3. <code class="literal">xmlelement</code></h4></div></div></div><a id="id-1.5.8.23.5.5.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlelement</code> ( <code class="literal">NAME</code> <em class="replaceable"><code>name</code></em> [<span class="optional">, <code class="literal">XMLATTRIBUTES</code> ( <em class="replaceable"><code>attvalue</code></em> [<span class="optional"> <code class="literal">AS</code> <em class="replaceable"><code>attname</code></em> </span>] [<span class="optional">, ...</span>] ) </span>] [<span class="optional">, <em class="replaceable"><code>content</code></em> [<span class="optional">, ...</span>]</span>] ) → <code class="returnvalue">xml</code>
</pre><p>
<span class="original">
     The &lt;function&gt;xmlelement&lt;/function&gt; expression produces an XML
     element with the given name, attributes, and content.
     The &lt;replaceable&gt;name&lt;/replaceable&gt;
     and &lt;replaceable&gt;attname&lt;/replaceable&gt; items shown in the syntax are
     simple identifiers, not values.  The &lt;replaceable&gt;attvalue&lt;/replaceable&gt;
     and &lt;replaceable&gt;content&lt;/replaceable&gt; items are expressions, which can
     yield any &lt;productname&gt;PostgreSQL&lt;/productname&gt; data type.  The
     argument(s) within &lt;literal&gt;XMLATTRIBUTES&lt;/literal&gt; generate attributes
     of the XML element; the &lt;replaceable&gt;content&lt;/replaceable&gt; value(s) are
     concatenated to form its content.
</span>
<code class="function">xmlelement</code>式は与えられた名前、属性、および内容を持つXML要素を生成します。
構文中に示す<em class="replaceable"><code>name</code></em>と<em class="replaceable"><code>attname</code></em>項目は単純な識別子で値ではありません。
<em class="replaceable"><code>attvalue</code></em>と<em class="replaceable"><code>content</code></em>項目は式で、<span class="productname">PostgreSQL</span>の任意のデータ型を出力できます。
<code class="literal">XMLATTRIBUTES</code>中の引数はXML要素の属性を生成します。<em class="replaceable"><code>content</code></em>値は結合して内容を構成します。
    </p><p>
<span class="original">
     Examples:
</span>
例：
</p><pre class="screen">
SELECT xmlelement(name foo);

 xmlelement
------------
 &lt;foo/&gt;

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
------------------
 &lt;foo bar="xyz"/&gt;

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-------------------------------------
 &lt;foo bar="2007-01-26"&gt;content&lt;/foo&gt;
</pre><p>
    </p><p>
<span class="original">
     Element and attribute names that are not valid XML names are
     escaped by replacing the offending characters by the sequence
     &lt;literal&gt;_x&lt;replaceable&gt;HHHH&lt;/replaceable&gt;_&lt;/literal&gt;, where
     &lt;replaceable&gt;HHHH&lt;/replaceable&gt; is the character's Unicode
     codepoint in hexadecimal notation.  For example:
</span>
有効なXML名ではない要素名と属性名は、シーケンス<code class="literal">_x<em class="replaceable"><code>HHHH</code></em>_</code>により障害となる文字を置換することでエスケープされます。ここで、<em class="replaceable"><code>HHHH</code></em>は16進数によるその文字のUnicode文字コード番号です。
例をあげます。
</p><pre class="screen">
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&amp;b"));

            xmlelement
----------------------------------
 &lt;foo_x0024_bar a_x0026_b="xyz"/&gt;
</pre><p>
    </p><p>
<span class="original">
     An explicit attribute name need not be specified if the attribute
     value is a column reference, in which case the column's name will
     be used as the attribute name by default.  In other cases, the
     attribute must be given an explicit name.  So this example is
     valid:
</span>
属性値が列参照の場合、明示的な属性名を指定する必要はありません。この場合、デフォルトで列名が属性名として使用されます。
その他の場合には、属性は明示的な名前で与えられなければなりません。
従って、以下の例は有効です。
</p><pre class="screen">
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
</pre><p>
<span class="original">
     But these are not:
</span>
しかし、以下の例は有効ではありません。
</p><pre class="screen">
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
</pre><p>
    </p><p>
<span class="original">
     Element content, if specified, will be formatted according to
     its data type.  If the content is itself of type &lt;type&gt;xml&lt;/type&gt;,
     complex XML documents can be constructed.  For example:
</span>
もし要素内容が指定されればそのデータ型に従って書式化されます。
もし内容そのものが<code class="type">xml</code>型であれば、複合XML文書が構築されます。
例をあげます。
</p><pre class="screen">
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
----------------------------------------------
 &lt;foo bar="xyz"&gt;&lt;abc/&gt;&lt;!--test--&gt;&lt;xyz/&gt;&lt;/foo&gt;
</pre><p>

<span class="original">
     Content of other types will be formatted into valid XML character
     data.  This means in particular that the characters &amp;lt;, &amp;gt;,
     and &amp;amp; will be converted to entities.  Binary data (data type
     &lt;type&gt;bytea&lt;/type&gt;) will be represented in base64 or hex
     encoding, depending on the setting of the configuration parameter
     &lt;xref linkend="guc-xmlbinary"/&gt;.  The particular behavior for
     individual data types is expected to evolve in order to align the
     PostgreSQL mappings with those specified in SQL:2006 and later,
     as discussed in &lt;xref linkend="functions-xml-limits-casts"/&gt;.
</span>
そのほかの型の内容は有効なXML文字データにフォーマットされます。
これは特に文字&lt;、&gt;、および&amp;がエンティティに変換されることを意味します。
バイナリデータ（データ型は<code class="type">bytea</code>）は、設定パラメータ<a class="xref" href="runtime-config-client.html#GUC-XMLBINARY">xmlbinary</a>の設定にしたがって、base64もしくは16進符号化方式で表現されます。
個々のデータ型に対する特定の動作は、<a class="xref" href="xml-limits-conformance.html#FUNCTIONS-XML-LIMITS-CASTS" title="D.3.1.3. SQLとXMLのデータ型および値のマッピング">D.3.1.3</a>で説明されているように、SQL:2006以降で指定された型をPostgreSQLデータ型に調整するため発展すると期待されます。
    </p></div><div class="sect3" id="id-1.5.8.23.5.6"><div class="titlepage"><div><div><h4 class="title">9.15.1.4. <code class="literal">xmlforest</code></h4></div></div></div><a id="id-1.5.8.23.5.6.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlforest</code> ( <em class="replaceable"><code>content</code></em> [<span class="optional"> <code class="literal">AS</code> <em class="replaceable"><code>name</code></em> </span>] [<span class="optional">, ...</span>] ) → <code class="returnvalue">xml</code>
</pre><p>
<span class="original">
     The &lt;function&gt;xmlforest&lt;/function&gt; expression produces an XML
     forest (sequence) of elements using the given names and content.
     As for &lt;function&gt;xmlelement&lt;/function&gt;,
     each &lt;replaceable&gt;name&lt;/replaceable&gt; must be a simple identifier, while
     the &lt;replaceable&gt;content&lt;/replaceable&gt; expressions can have any data
     type.
</span>
<code class="function">xmlforest</code>式は与えられた名前と内容を使用し、要素のXMLフォレスト（シーケンス）を生成します。
<code class="function">xmlelement</code>では、各<em class="replaceable"><code>name</code></em>は単純な識別子でなければなりませんが、<em class="replaceable"><code>content</code></em>式はどんな型のデータも持つことができます。
    </p><p>
<span class="original">
     Examples:
</span>
例：
</p><pre class="screen">
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
------------------------------
 &lt;foo&gt;abc&lt;/foo&gt;&lt;bar&gt;123&lt;/bar&gt;


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                xmlforest
------------------------------------​-----------------------------------
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;​&lt;column_name&gt;rolname&lt;/column_name&gt;
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;​&lt;column_name&gt;rolsuper&lt;/column_name&gt;
 ...
</pre><p>

<span class="original">
     As seen in the second example, the element name can be omitted if
     the content value is a column reference, in which case the column
     name is used by default.  Otherwise, a name must be specified.
</span>
第２の例に見られるように、内容の値が列参照の場合、要素名は省略可能です。この時は、列名がデフォルトで使用されます。
そうでない時は、名前が指定されなければなりません。
    </p><p>
<span class="original">
     Element names that are not valid XML names are escaped as shown
     for &lt;function&gt;xmlelement&lt;/function&gt; above.  Similarly, content
     data is escaped to make valid XML content, unless it is already
     of type &lt;type&gt;xml&lt;/type&gt;.
</span>
有効なXML名ではない要素名は上の<code class="function">xmlelement</code>で説明した通りエスケープされます。
同様にして、既に<code class="type">xml</code>型であるものを除き、内容データは有効なXML内容になるようにエスケープされます。
    </p><p>
<span class="original">
     Note that XML forests are not valid XML documents if they consist
     of more than one element, so it might be useful to wrap
     &lt;function&gt;xmlforest&lt;/function&gt; expressions in
     &lt;function&gt;xmlelement&lt;/function&gt;.
</span>
XMLフォレストは２つ以上の要素からなる場合、有効なXML文書ではないことに注意してください。
したがって、<code class="function">xmlelement</code>内に<code class="function">xmlforest</code>式をラップすることが有用なことがあります。
    </p></div><div class="sect3" id="id-1.5.8.23.5.7"><div class="titlepage"><div><div><h4 class="title">9.15.1.5. <code class="literal">xmlpi</code></h4></div></div></div><a id="id-1.5.8.23.5.7.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlpi</code> ( <code class="literal">NAME</code> <em class="replaceable"><code>name</code></em> [<span class="optional">, <em class="replaceable"><code>content</code></em> </span>] ) → <code class="returnvalue">xml</code>
</pre><p>
<span class="original">
     The &lt;function&gt;xmlpi&lt;/function&gt; expression creates an XML
     processing instruction.
     As for &lt;function&gt;xmlelement&lt;/function&gt;,
     the &lt;replaceable&gt;name&lt;/replaceable&gt; must be a simple identifier, while
     the &lt;replaceable&gt;content&lt;/replaceable&gt; expression can have any data type.
     The &lt;replaceable&gt;content&lt;/replaceable&gt;, if present, must not contain the
     character sequence &lt;literal&gt;?&amp;gt;&lt;/literal&gt;.
</span>
<code class="function">xmlpi</code>式はXML処理命令を作成します。
<code class="function">xmlelement</code>では、各<em class="replaceable"><code>name</code></em>は単純な識別子でなければなりませんが、<em class="replaceable"><code>content</code></em>式はどんな型のデータも持つことができます。
<em class="replaceable"><code>content</code></em>が存在するときは、それは<code class="literal">?&gt;</code>という文字シーケンスを含んではいけません。
    </p><p>
<span class="original">
     Example:
</span>
例：
</p><pre class="screen">
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-----------------------------
 &lt;?php echo "hello world";?&gt;
</pre><p>
    </p></div><div class="sect3" id="id-1.5.8.23.5.8"><div class="titlepage"><div><div><h4 class="title">9.15.1.6. <code class="literal">xmlroot</code></h4></div></div></div><a id="id-1.5.8.23.5.8.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlroot</code> ( <code class="type">xml</code>, <code class="literal">VERSION</code> {<code class="type">text</code>|<code class="literal">NO VALUE</code>} [<span class="optional">, <code class="literal">STANDALONE</code> {<code class="literal">YES</code>|<code class="literal">NO</code>|<code class="literal">NO VALUE</code>} </span>] ) → <code class="returnvalue">xml</code>
</pre><p>
<span class="original">
     The &lt;function&gt;xmlroot&lt;/function&gt; expression alters the properties
     of the root node of an XML value.  If a version is specified,
     it replaces the value in the root node's version declaration; if a
     standalone setting is specified, it replaces the value in the
     root node's standalone declaration.
</span>
<code class="function">xmlroot</code>式はXML値のルートノードの属性を変更します。
versionが指定されていると、ルートノードのversion宣言での値を変更し、standalone設定が指定されていると、ルートノードのstandalone宣言での値を変更します。
    </p><p>
</p><pre class="screen">
SELECT xmlroot(xmlparse(document '&lt;?xml version="1.1"?&gt;&lt;content&gt;abc&lt;/content&gt;'),
               version '1.0', standalone yes);

                xmlroot
----------------------------------------
 &lt;?xml version="1.0" standalone="yes"?&gt;
 &lt;content&gt;abc&lt;/content&gt;
</pre><p>
    </p></div><div class="sect3" id="FUNCTIONS-XML-XMLAGG"><div class="titlepage"><div><div><h4 class="title">9.15.1.7. <code class="literal">xmlagg</code></h4></div></div></div><a id="id-1.5.8.23.5.9.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlagg</code> ( <code class="type">xml</code> ) → <code class="returnvalue">xml</code>
</pre><p>
<span class="original">
     The function &lt;function&gt;xmlagg&lt;/function&gt; is, unlike the other
     functions described here, an aggregate function.  It concatenates the
     input values to the aggregate function call,
     much like &lt;function&gt;xmlconcat&lt;/function&gt; does, except that concatenation
     occurs across rows rather than across expressions in a single row.
     See &lt;xref linkend="functions-aggregate"/&gt; for additional information
     about aggregate functions.
</span>
ここで説明している他の関数とは異なり、<code class="function">xmlagg</code>関数は集約関数です。
これは<code class="function">xmlconcat</code>が行うように、入力値を連結する集約関数ですが、単一行内の複数の式にまたがった連結ではなく、複数行にまたがった連結を行います。
集約関数についての追加情報は<a class="xref" href="functions-aggregate.html" title="9.21. 集約関数">9.21</a>を参照してください。
    </p><p>
<span class="original">
     Example:
</span>
例：
</p><pre class="screen">
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '&lt;foo&gt;abc&lt;/foo&gt;');
INSERT INTO test VALUES (2, '&lt;bar/&gt;');
SELECT xmlagg(x) FROM test;
        xmlagg
----------------------
 &lt;foo&gt;abc&lt;/foo&gt;&lt;bar/&gt;
</pre><p>
    </p><p>
<span class="original">
     To determine the order of the concatenation, an &lt;literal&gt;ORDER BY&lt;/literal&gt;
     clause may be added to the aggregate call as described in
     &lt;xref linkend="syntax-aggregates"/&gt;. For example:
</span>
連結の順序を決定するため、<a class="xref" href="sql-expressions.html#SYNTAX-AGGREGATES" title="4.2.7. 集約式">4.2.7</a>に記述されているように<code class="literal">ORDER BY</code>句を集計呼び出しに追加することができます。
以下は例です。

</p><pre class="screen">
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
----------------------
 &lt;bar/&gt;&lt;foo&gt;abc&lt;/foo&gt;
</pre><p>
    </p><p>
<span class="original">
     The following non-standard approach used to be recommended
     in previous versions, and may still be useful in specific
     cases:
</span>
下記は以前のバージョンで推奨されていた、非標準的な方法例です。特定のケースでは依然として有用かもしれません。

</p><pre class="screen">
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
----------------------
 &lt;bar/&gt;&lt;foo&gt;abc&lt;/foo&gt;
</pre><p>
    </p></div></div><div class="sect2" id="FUNCTIONS-XML-PREDICATES"><div class="titlepage"><div><div><h3 class="title">9.15.2. XML述語</h3></div></div></div><span class="original">
    &lt;title&gt;XML Predicates&lt;/title&gt;
</span><p>
<span class="original">
     The expressions described in this section check properties
     of &lt;type&gt;xml&lt;/type&gt; values.
</span>
この節で記述されている式は、<code class="type">xml</code>値の属性をチェックします。
    </p><div class="sect3" id="id-1.5.8.23.6.3"><div class="titlepage"><div><div><h4 class="title">9.15.2.1. <code class="literal">IS DOCUMENT</code></h4></div></div></div><a id="id-1.5.8.23.6.3.2" class="indexterm"></a><pre class="synopsis">
<code class="type">xml</code> <code class="literal">IS DOCUMENT</code> → <code class="returnvalue">boolean</code>
</pre><p>
<span class="original">
     The expression &lt;literal&gt;IS DOCUMENT&lt;/literal&gt; returns true if the
     argument XML value is a proper XML document, false if it is not
     (that is, it is a content fragment), or null if the argument is
     null.  See &lt;xref linkend="datatype-xml"/&gt; about the difference
     between documents and content fragments.
</span>
式<code class="literal">IS DOCUMENT</code>は引数XML値が適切なXML文書であれば真を返し、そうでなければ（つまり、内容の断片）偽を返すか、もしくは引数がNULLであればNULLを返します。
文書と内容の断片の差異については<a class="xref" href="datatype-xml.html" title="8.13. XML型">8.13</a>を参照してください。
    </p></div><div class="sect3" id="id-1.5.8.23.6.4"><div class="titlepage"><div><div><h4 class="title">9.15.2.2. <code class="literal">IS NOT DOCUMENT</code></h4></div></div></div><a id="id-1.5.8.23.6.4.2" class="indexterm"></a><pre class="synopsis">
<code class="type">xml</code> <code class="literal">IS NOT DOCUMENT</code> → <code class="returnvalue">boolean</code>
</pre><p>
<span class="original">
     The expression &lt;literal&gt;IS NOT DOCUMENT&lt;/literal&gt; returns false if the
     argument XML value is a proper XML document, true if it is not (that is,
     it is a content fragment), or null if the argument is null.
</span>
式<code class="literal">IS NOT DOCUMENT</code>は引数XML値が適切なXML文書であれば偽を返し、そうでなければ（つまり、内容の断片）真を返すか、もしくは引数がNULLであればNULLを返します。
    </p></div><div class="sect3" id="XML-EXISTS"><div class="titlepage"><div><div><h4 class="title">9.15.2.3. <code class="literal">XMLEXISTS</code></h4></div></div></div><a id="id-1.5.8.23.6.5.2" class="indexterm"></a><pre class="synopsis">
<code class="function">XMLEXISTS</code> ( <code class="type">text</code> <code class="literal">PASSING</code> [<span class="optional"><code class="literal">BY</code> {<code class="literal">REF</code>|<code class="literal">VALUE</code>}</span>] <code class="type">xml</code> [<span class="optional"><code class="literal">BY</code> {<code class="literal">REF</code>|<code class="literal">VALUE</code>}</span>] ) → <code class="returnvalue">boolean</code>
</pre><p>
<span class="original">
     The function &lt;function&gt;xmlexists&lt;/function&gt; evaluates an XPath 1.0
     expression (the first argument), with the passed XML value as its context
     item.  The function returns false if the result of that evaluation
     yields an empty node-set, true if it yields any other value.  The
     function returns null if any argument is null.  A nonnull value
     passed as the context item must be an XML document, not a content
     fragment or any non-XML value.
</span>
関数<code class="function">xmlexists</code>は渡されたXML値をコンテキスト項目としてXPath 1.0式（第一引数）を評価します。
この関数は評価が空のノード集合を生成する場合には偽を返し、それ以外の値を返すならば真を返します。
もしどれかの引数がNULLであった場合はNULLを返します。
コンテキスト項目として渡される非NULLの値は、内容の断片や非XML値ではなく、XML文書でなければなりません。
    </p><p>
<span class="original">
     Example:
</span>
例:
     </p><pre class="screen">
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY VALUE '&lt;towns&gt;&lt;town&gt;Toronto&lt;/town&gt;&lt;town&gt;Ottawa&lt;/town&gt;&lt;/towns&gt;');

 xmlexists
------------
 t
(1 row)
</pre><p>
    </p><p>
<span class="original">
     The &lt;literal&gt;BY REF&lt;/literal&gt; and &lt;literal&gt;BY VALUE&lt;/literal&gt; clauses
     are accepted in &lt;productname&gt;PostgreSQL&lt;/productname&gt;, but are ignored,
     as discussed in &lt;xref linkend="functions-xml-limits-postgresql"/&gt;.
</span>
<span class="productname">PostgreSQL</span>は<code class="literal">BY REF</code>句と<code class="literal">BY VALUE</code>句を受け付けますが、<a class="xref" href="xml-limits-conformance.html#FUNCTIONS-XML-LIMITS-POSTGRESQL" title="D.3.2. その他の実装の制限">D.3.2</a>で議論されているように無視します。
    </p><p>
<span class="original">
     In the SQL standard, the &lt;function&gt;xmlexists&lt;/function&gt; function
     evaluates an expression in the XML Query language,
     but &lt;productname&gt;PostgreSQL&lt;/productname&gt; allows only an XPath 1.0
     expression, as discussed in
     &lt;xref linkend="functions-xml-limits-xpath1"/&gt;.
</span>
SQL標準では<code class="function">xmlexists</code>関数はXML問い合わせ言語における式を評価しますが、<a class="xref" href="xml-limits-conformance.html#FUNCTIONS-XML-LIMITS-XPATH1" title="D.3.1. 問い合わせはXPath 1.0に限定される">D.3.1</a>で議論されているように、<span class="productname">PostgreSQL</span>はXPath 1.0の式だけを受け付けます。
    </p></div><div class="sect3" id="XML-IS-WELL-FORMED"><div class="titlepage"><div><div><h4 class="title">9.15.2.4. <code class="literal">xml_is_well_formed</code></h4></div></div></div><a id="id-1.5.8.23.6.6.2" class="indexterm"></a><a id="id-1.5.8.23.6.6.3" class="indexterm"></a><a id="id-1.5.8.23.6.6.4" class="indexterm"></a><pre class="synopsis">
<code class="function">xml_is_well_formed</code> ( <code class="type">text</code> ) → <code class="returnvalue">boolean</code>
<code class="function">xml_is_well_formed_document</code> ( <code class="type">text</code> ) → <code class="returnvalue">boolean</code>
<code class="function">xml_is_well_formed_content</code> ( <code class="type">text</code> ) → <code class="returnvalue">boolean</code>
</pre><p>
<span class="original">
     These functions check whether a &lt;type&gt;text&lt;/type&gt; string represents
     well-formed XML, returning a Boolean result.
     &lt;function&gt;xml_is_well_formed_document&lt;/function&gt; checks for a well-formed
     document, while &lt;function&gt;xml_is_well_formed_content&lt;/function&gt; checks
     for well-formed content.  &lt;function&gt;xml_is_well_formed&lt;/function&gt; does
     the former if the &lt;xref linkend="guc-xmloption"/&gt; configuration
     parameter is set to &lt;literal&gt;DOCUMENT&lt;/literal&gt;, or the latter if it is set to
     &lt;literal&gt;CONTENT&lt;/literal&gt;.  This means that
     &lt;function&gt;xml_is_well_formed&lt;/function&gt; is useful for seeing whether
     a simple cast to type &lt;type&gt;xml&lt;/type&gt; will succeed, whereas the other two
     functions are useful for seeing whether the corresponding variants of
     &lt;function&gt;XMLPARSE&lt;/function&gt; will succeed.
</span>
これらの関数は<code class="type">text</code>文字列が整形式かどうかをチェックし、論理値で結果を返します。
<code class="function">xml_is_well_formed_document</code>は文書が整形式かをチェックし、一方<code class="function">xml_is_well_formed_content</code>は内容が整形式かをチェックします。
<code class="function">xml_is_well_formed</code>は、<a class="xref" href="runtime-config-client.html#GUC-XMLOPTION">xmloption</a>パラメータ値が<code class="literal">DOCUMENT</code>に設定されていれば前者を、<code class="literal">CONTENT</code>が設定されていれば後者のチェックを実施します。
これは、<code class="function">xml_is_well_formed</code>は単純な<code class="type">xml</code>型へのキャストが成功するかの判断に有用であり、その他の２つの関数は<code class="function">XMLPARSE</code>の対応による変換が成功するかの判断に有用であることを意味します。
    </p><p>
<span class="original">
     Examples:
</span>
例:

</p><pre class="screen">
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('&lt;&gt;');
 xml_is_well_formed
--------------------
 f
(1 row)

SELECT xml_is_well_formed('&lt;abc/&gt;');
 xml_is_well_formed
--------------------
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed
--------------------
 t
(1 row)

SELECT xml_is_well_formed_document('&lt;pg:foo xmlns:pg="http://postgresql.org/stuff"&gt;bar&lt;/pg:foo&gt;');
 xml_is_well_formed_document
-----------------------------
 t
(1 row)

SELECT xml_is_well_formed_document('&lt;pg:foo xmlns:pg="http://postgresql.org/stuff"&gt;bar&lt;/my:foo&gt;');
 xml_is_well_formed_document
-----------------------------
 f
(1 row)
</pre><p>

<span class="original">
     The last example shows that the checks include whether
     namespaces are correctly matched.
</span>
最後の例は、名前空間が正しく一致しているかのチェックも含むことを示しています。
    </p></div></div><div class="sect2" id="FUNCTIONS-XML-PROCESSING"><div class="titlepage"><div><div><h3 class="title">9.15.3. XMLの処理</h3></div></div></div><span class="original">
   &lt;title&gt;Processing XML&lt;/title&gt;
</span><p>
<span class="original">
    To process values of data type &lt;type&gt;xml&lt;/type&gt;, PostgreSQL offers
    the functions &lt;function&gt;xpath&lt;/function&gt; and
    &lt;function&gt;xpath_exists&lt;/function&gt;, which evaluate XPath 1.0
    expressions, and the &lt;function&gt;XMLTABLE&lt;/function&gt;
    table function.
</span>
データ型<code class="type">xml</code>の値を処理するため、PostgreSQLはXPath 1.0式を評価する関数<code class="function">xpath</code>および<code class="function">xpath_exists</code>と、テーブル関数<code class="function">XMLTABLE</code>を提供しています。
   </p><div class="sect3" id="FUNCTIONS-XML-PROCESSING-XPATH"><div class="titlepage"><div><div><h4 class="title">9.15.3.1. <code class="literal">xpath</code></h4></div></div></div><a id="id-1.5.8.23.7.3.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xpath</code> ( <em class="parameter"><code>xpath</code></em> <code class="type">text</code>, <em class="parameter"><code>xml</code></em> <code class="type">xml</code> [<span class="optional">, <em class="parameter"><code>nsarray</code></em> <code class="type">text[]</code> </span>] ) → <code class="returnvalue">xml[]</code>
</pre><p>
<span class="original">
     The function &lt;function&gt;xpath&lt;/function&gt; evaluates the XPath 1.0
     expression &lt;parameter&gt;xpath&lt;/parameter&gt; (given as text)
     against the XML value
     &lt;parameter&gt;xml&lt;/parameter&gt;.  It returns an array of XML values
     corresponding to the node-set produced by the XPath expression.
     If the XPath expression returns a scalar value rather than a node-set,
     a single-element array is returned.
</span>
関数<code class="function">xpath</code>は、XML値<em class="parameter"><code>xml</code></em>に対し、XPath 1.0式<em class="parameter"><code>xpath</code></em>(テキストとして指定)を評価します。
そして、XPath式で作成されたノード集合に対応するXML値の配列を返します。
もし、XPath式がノード集合ではなくスカラー値を返す場合、単一要素の配列が返されます。
    </p><p>
<span class="original">
     The second argument must be a well formed XML document. In particular,
     it must have a single root node element.
</span>
2番目の引数は整形済XML文書でなければなりません。特に、単一のルートノード要素を持たなければなりません。
    </p><p>
<span class="original">
     The optional third argument of the function is an array of namespace
     mappings.  This array should be a two-dimensional &lt;type&gt;text&lt;/type&gt; array with
     the length of the second axis being equal to 2 (i.e., it should be an
     array of arrays, each of which consists of exactly 2 elements).
     The first element of each array entry is the namespace name (alias), the
     second the namespace URI. It is not required that aliases provided in
     this array be the same as those being used in the XML document itself (in
     other words, both in the XML document and in the &lt;function&gt;xpath&lt;/function&gt;
     function context, aliases are &lt;emphasis&gt;local&lt;/emphasis&gt;).
</span>
オプショナルな関数の３番目の引数は名前空間マッピング配列です。
この配列は、第２軸が２に等しい長さをもつ２次元<code class="type">text</code>配列です（つまり、それは配列の配列で、それぞれは正確に２つの要素からなります）。
それぞれの配列のエントリの最初の要素は名前空間の名前（別名）で、２番目は名前空間のURIです。
この配列内で提供される別名がXML文書自身で使用されるものと同じであることは必要ではありません（言い換えると、XML文書内および<code class="function">xpath</code>関数の両方の文脈の中で、別名は<span class="emphasis"><em>ローカル</em></span>です）。
    </p><p>
<span class="original">
     Example:
</span>
例：
</p><pre class="screen">
SELECT xpath('/my:a/text()', '&lt;my:a xmlns:my="http://example.com"&gt;test&lt;/my:a&gt;',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
</pre><p>
    </p><p>
<span class="original">
     To deal with default (anonymous) namespaces, do something like this:
</span>
デフォルト(匿名)名前空間を取り扱うためには、以下のようなことを実施してください。
</p><pre class="screen">
SELECT xpath('//mydefns:b/text()', '&lt;a xmlns="http://example.com"&gt;&lt;b&gt;test&lt;/b&gt;&lt;/a&gt;',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
</pre><p>
    </p></div><div class="sect3" id="FUNCTIONS-XML-PROCESSING-XPATH-EXISTS"><div class="titlepage"><div><div><h4 class="title">9.15.3.2. <code class="literal">xpath_exists</code></h4></div></div></div><a id="id-1.5.8.23.7.4.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xpath_exists</code> ( <em class="parameter"><code>xpath</code></em> <code class="type">text</code>, <em class="parameter"><code>xml</code></em> <code class="type">xml</code> [<span class="optional">, <em class="parameter"><code>nsarray</code></em> <code class="type">text[]</code> </span>] ) → <code class="returnvalue">boolean</code>
</pre><p>
<span class="original">
     The function &lt;function&gt;xpath_exists&lt;/function&gt; is a specialized form
     of the &lt;function&gt;xpath&lt;/function&gt; function.  Instead of returning the
     individual XML values that satisfy the XPath 1.0 expression, this function
     returns a Boolean indicating whether the query was satisfied or not
     (specifically, whether it produced any value other than an empty node-set).
     This function is equivalent to the &lt;literal&gt;XMLEXISTS&lt;/literal&gt; predicate,
     except that it also offers support for a namespace mapping argument.
</span>
関数<code class="function">xpath_exists</code>は、<code class="function">xpath</code>関数の特別な形式です。
この関数は、XPath 1.0を満足する個別のXML値を返す代わりに、問い合わせがそれを満足するかどうか（具体的には空のノード集合以外の値を返すかどうか）を論理値で返します。
この関数は、名前空間にマッピングされた引数をもサポートする点を除き、標準の<code class="literal">XMLEXISTS</code>述語と同じです。
    </p><p>
<span class="original">
     Example:
</span>
例:
</p><pre class="screen">
SELECT xpath_exists('/my:a/text()', '&lt;my:a xmlns:my="http://example.com"&gt;test&lt;/my:a&gt;',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists
--------------
 t
(1 row)
</pre><p>
    </p></div><div class="sect3" id="FUNCTIONS-XML-PROCESSING-XMLTABLE"><div class="titlepage"><div><div><h4 class="title">9.15.3.3. <code class="literal">xmltable</code></h4></div></div></div><a id="id-1.5.8.23.7.5.2" class="indexterm"></a><a id="id-1.5.8.23.7.5.3" class="indexterm"></a><a id="id-1.5.8.23.7.5.4" class="indexterm"></a><pre class="synopsis">
<code class="function">XMLTABLE</code> (
    [<span class="optional"> <code class="literal">XMLNAMESPACES</code> ( <em class="replaceable"><code>namespace_uri</code></em> <code class="literal">AS</code> <em class="replaceable"><code>namespace_name</code></em> [<span class="optional">, ...</span>] ), </span>]
    <em class="replaceable"><code>row_expression</code></em> <code class="literal">PASSING</code> [<span class="optional"><code class="literal">BY</code> {<code class="literal">REF</code>|<code class="literal">VALUE</code>}</span>] <em class="replaceable"><code>document_expression</code></em> [<span class="optional"><code class="literal">BY</code> {<code class="literal">REF</code>|<code class="literal">VALUE</code>}</span>]
    <code class="literal">COLUMNS</code> <em class="replaceable"><code>name</code></em> { <em class="replaceable"><code>type</code></em> [<span class="optional"><code class="literal">PATH</code> <em class="replaceable"><code>column_expression</code></em></span>] [<span class="optional"><code class="literal">DEFAULT</code> <em class="replaceable"><code>default_expression</code></em></span>] [<span class="optional"><code class="literal">NOT NULL</code> | <code class="literal">NULL</code></span>]
                  | <code class="literal">FOR ORDINALITY</code> }
            [<span class="optional">, ...</span>]
) → <code class="returnvalue">setof record</code>
</pre><p>
<span class="original">
     The &lt;function&gt;xmltable&lt;/function&gt; expression produces a table based
     on an XML value, an XPath filter to extract rows, and a
     set of column definitions.
     Although it syntactically resembles a function, it can only appear
     as a table in a query's &lt;literal&gt;FROM&lt;/literal&gt; clause.
</span>
<code class="function">xmltable</code>式は、与えられたXML値、行を抽出するXPathフィルタ、オプションの列定義の集合に基づいてテーブルを生成します。
関数と構文的に似ていますが、これは問い合わせ中の<code class="literal">FROM</code>句におけるテーブルとしてのみ使用できます。
    </p><p>
<span class="original">
     The optional &lt;literal&gt;XMLNAMESPACES&lt;/literal&gt; clause gives a
     comma-separated list of namespace definitions, where
     each &lt;replaceable&gt;namespace_uri&lt;/replaceable&gt; is a &lt;type&gt;text&lt;/type&gt;
     expression and each &lt;replaceable&gt;namespace_name&lt;/replaceable&gt; is a simple
     identifier.  It specifies the XML namespaces used in the document and
     their aliases. A default namespace specification is not currently
     supported.
</span>
オプションの<code class="literal">XMLNAMESPACES</code>句はカンマで区切られた名前空間のリストを与えます。
各々の<em class="replaceable"><code>namespace_uri</code></em>は<code class="type">text</code>式で、<em class="replaceable"><code>namespace_name</code></em>は単純な識別子です。
これは文書とその別名で使用されるXML名前空間を指定します。
デフォルトの名前空間指定は現在のところサポートされていません。
    </p><p>
<span class="original">
     The required &lt;replaceable&gt;row_expression&lt;/replaceable&gt; argument is an
     XPath 1.0 expression (given as &lt;type&gt;text&lt;/type&gt;) that is evaluated,
     passing the XML value &lt;replaceable&gt;document_expression&lt;/replaceable&gt; as
     its context item, to obtain a set of XML nodes. These nodes are what
     &lt;function&gt;xmltable&lt;/function&gt; transforms into output rows. No rows
     will be produced if the &lt;replaceable&gt;document_expression&lt;/replaceable&gt;
     is null, nor if the &lt;replaceable&gt;row_expression&lt;/replaceable&gt; produces
     an empty node-set or any value other than a node-set.
</span>
必須の<em class="replaceable"><code>row_expression</code></em>引数は評価されるXPath 1.0式(<code class="type">text</code>で与えます)で、XMLノード集合を得るために<em class="replaceable"><code>document_expression</code></em>をそのコンテキスト項目として渡します。
このノードは<code class="function">xmltable</code>が出力行に変換します。
<em class="replaceable"><code>document_expression</code></em>がNULLであるか、<em class="replaceable"><code>row_expression</code></em>が空のノード集合あるいはノード集合以外の値を生成するなら行は出力されません。
    </p><p>
<span class="original">
     &lt;replaceable&gt;document_expression&lt;/replaceable&gt; provides the context
     item for the &lt;replaceable&gt;row_expression&lt;/replaceable&gt;. It must be a
     well-formed XML document; fragments/forests are not accepted.
     The &lt;literal&gt;BY REF&lt;/literal&gt; and &lt;literal&gt;BY VALUE&lt;/literal&gt; clauses
     are accepted but ignored, as discussed in
     &lt;xref linkend="functions-xml-limits-postgresql"/&gt;.
</span>
<em class="replaceable"><code>document_expression</code></em>は<em class="replaceable"><code>row_expression</code></em>のためのコンテキスト項目を提供します。
それは整形式XMLの文書でなければならず、フラグメントやフォレストは受け付けられません。
<a class="xref" href="xml-limits-conformance.html#FUNCTIONS-XML-LIMITS-POSTGRESQL" title="D.3.2. その他の実装の制限">D.3.2</a>で議論されているように、<code class="literal">BY REF</code>句と<code class="literal">BY VALUE</code>句は受け付けられますが、無視されます。
    </p><p>
<span class="original">
     In the SQL standard, the &lt;function&gt;xmltable&lt;/function&gt; function
     evaluates expressions in the XML Query language,
     but &lt;productname&gt;PostgreSQL&lt;/productname&gt; allows only XPath 1.0
     expressions, as discussed in
     &lt;xref linkend="functions-xml-limits-xpath1"/&gt;.
</span>
SQL標準では<code class="function">xmltable</code>関数はXML問い合わせ言語の式を評価しますが、<a class="xref" href="xml-limits-conformance.html#FUNCTIONS-XML-LIMITS-XPATH1" title="D.3.1. 問い合わせはXPath 1.0に限定される">D.3.1</a>で議論されているように<span class="productname">PostgreSQL</span>ではXPath 1.0式だけを受け付けます。
    </p><p>
<span class="original">
     The required &lt;literal&gt;COLUMNS&lt;/literal&gt; clause specifies the
     column(s) that will be produced in the output table.
     See the syntax summary above for the format.
     A name is required for each column, as is a data type
     (unless &lt;literal&gt;FOR ORDINALITY&lt;/literal&gt; is specified, in which case
     type &lt;type&gt;integer&lt;/type&gt; is implicit).  The path, default and
     nullability clauses are optional.
</span>
必須の<code class="literal">COLUMNS</code>句は、出力テーブルに現れる列を指定します。
形式については上記の構文サマリーを参照してください。
各列には名前が必須で、データ型についても同様です。（<code class="literal">FOR ORDINALITY</code>が指定された場合を除きます。その場合は暗黙的に<code class="type">integer</code>が想定されます。）
パス、デフォルト値、NULLを許すかどうかの句は省略できます。
    </p><p>
<span class="original">
     A column marked &lt;literal&gt;FOR ORDINALITY&lt;/literal&gt; will be populated
     with row numbers, starting with 1, in the order of nodes retrieved from
     the &lt;replaceable&gt;row_expression&lt;/replaceable&gt;'s result node-set.
     At most one column may be marked &lt;literal&gt;FOR ORDINALITY&lt;/literal&gt;.
</span>
<code class="literal">FOR ORDINALITY</code>と印がつけられた列には、<em class="replaceable"><code>row_expression</code></em>の結果ノード集合から取得されたノードの順序に対応する1から始まる行番号が入ります。
<code class="literal">FOR ORDINALITY</code>の印が付けられるのは最大でも1列です。
    </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
      XPath 1.0 does not specify an order for nodes in a node-set, so code
      that relies on a particular order of the results will be
      implementation-dependent.  Details can be found in
      &lt;xref linkend="xml-xpath-1-specifics"/&gt;.
</span>
XPath 1.0はノード集合内のノードの順序を指定しません。ですから、結果が特定の順序になっていることに依存するコードは実装依存となります。
詳細は<a class="xref" href="xml-limits-conformance.html#XML-XPATH-1-SPECIFICS" title="D.3.1.2. XPathが1.0であることによる制限">D.3.1.2</a>をご覧ください。
     </p></div><p>
<span class="original">
     The &lt;replaceable&gt;column_expression&lt;/replaceable&gt; for a column is an
     XPath 1.0 expression that is evaluated for each row, with the current
     node from the &lt;replaceable&gt;row_expression&lt;/replaceable&gt; result as its
     context item, to find the value of the column.  If
     no &lt;replaceable&gt;column_expression&lt;/replaceable&gt; is given, then the
     column name is used as an implicit path.
</span>
列の<em class="replaceable"><code>column_expression</code></em>はXPath 1.0式で、<em class="replaceable"><code>row_expression</code></em>の結果における現在のノードをそのコンテキスト項目として<em class="replaceable"><code>row_expression</code></em>の結果に対応する各行について評価されて、列の値を得ます。
<em class="replaceable"><code>column_expression</code></em> が与えられなかった場合は、暗黙的なパスとして列名が使用されます。
    </p><p>
<span class="original">
     If a column's XPath expression returns a non-XML value (which is limited
     to string, boolean, or double in XPath 1.0) and the column has a
     PostgreSQL type other than &lt;type&gt;xml&lt;/type&gt;, the column will be set
     as if by assigning the value's string representation to the PostgreSQL
     type.  (If the value is a boolean, its string representation is taken
     to be &lt;literal&gt;1&lt;/literal&gt; or &lt;literal&gt;0&lt;/literal&gt; if the output
     column's type category is numeric, otherwise &lt;literal&gt;true&lt;/literal&gt; or
     &lt;literal&gt;false&lt;/literal&gt;.)
</span>
列のXPath式が非XML値（XPath 1.0における文字列、論理値、倍精度浮動小数点数に限られます）を返し、その列が<code class="type">xml</code>以外のPostgreSQL型なら、あたかも値の文字列表現をPostgreSQL型にアサインしたように列に値がセットされます。
（値が論理値の場合、出力列型が数値カテゴリに属するならその文字列表現は<code class="literal">1</code>または<code class="literal">0</code>になり、それ外なら<code class="literal">true</code>または<code class="literal">false</code>になります。）
    </p><p>
<span class="original">
     If a column's XPath expression returns a non-empty set of XML nodes
     and the column's PostgreSQL type is &lt;type&gt;xml&lt;/type&gt;, the column will
     be assigned the expression result exactly, if it is of document or
     content form.
</span>
列のXPath表現が空ではないXMLノードの集合を返し、列のPostgreSQL型が<code class="type">xml</code>である場合には、式が文書あるいはフォームの内容なら、列には正確に式の結果がアサインされます。
     <a href="#ftn.id-1.5.8.23.7.5.16.2" class="footnote"><sup class="footnote" id="id-1.5.8.23.7.5.16.2">[8]</sup></a>
    </p><p>
<span class="original">
     A non-XML result assigned to an &lt;type&gt;xml&lt;/type&gt; output column produces
     content, a single text node with the string value of the result.
     An XML result assigned to a column of any other type may not have more than
     one node, or an error is raised. If there is exactly one node, the column
     will be set as if by assigning the node's string
     value (as defined for the XPath 1.0 &lt;function&gt;string&lt;/function&gt; function)
     to the PostgreSQL type.
</span>
<code class="type">xml</code>出力列にアサインされた非XMLの結果は、結果の値が文字列値となる単一のテキストノードであるコンテントを生成します。
それ以外の型の列にアサインされたXMLの結果は複数のノードを持たないかも知れませんし、エラーを生じするかも知れません。
正確に一つのノードだけが存在するなら、列にはあたかもノードの文字列値（XPath 1.0 <code class="function">string</code>関数の定義されているように） がPostgreSQL型にアサインされたように設定されます。
    </p><p>
<span class="original">
     The string value of an XML element is the concatenation, in document order,
     of all text nodes contained in that element and its descendants. The string
     value of an element with no descendant text nodes is an
     empty string (not &lt;literal&gt;NULL&lt;/literal&gt;).
     Any &lt;literal&gt;xsi:nil&lt;/literal&gt; attributes are ignored.
     Note that the whitespace-only &lt;literal&gt;text()&lt;/literal&gt; node between two non-text
     elements is preserved, and that leading whitespace on a &lt;literal&gt;text()&lt;/literal&gt;
     node is not flattened.
     The XPath 1.0 &lt;function&gt;string&lt;/function&gt; function may be consulted for the
     rules defining the string value of other XML node types and non-XML values.
</span>
ある要素と、その子孫に含まれるすべてのテキストノードをドキュメントの順に結合したものがXML要素の文字列値です。
テキストノードの子孫を持たない要素の文字列値は空文字列です。（ <code class="literal">NULL</code>ではありません。）
すべての<code class="literal">xsi:nil</code>属性は無視されます。
非テキスト要素の間にある空白のみからなる<code class="literal">text()</code>2つのノードは保存され、<code class="literal">text()</code>の先頭の空白は平坦化されないことに注意してください。
XPath 1.0 <code class="function">string</code>関数が、他のXMLノード型と非XML値の文字列値を定義するルールのために参照されるかも知れません。
    </p><p>
<span class="original">
     The conversion rules presented here are not exactly those of the SQL
     standard, as discussed in &lt;xref linkend="functions-xml-limits-casts"/&gt;.
</span>
ここで示した変換ルールは、<a class="xref" href="xml-limits-conformance.html#FUNCTIONS-XML-LIMITS-CASTS" title="D.3.1.3. SQLとXMLのデータ型および値のマッピング">D.3.1.3</a>で議論されているように、正確にSQL標準に従っているわけではありません。
    </p><p>
<span class="original">
     If the path expression returns an empty node-set
     (typically, when it does not match)
     for a given row, the column will be set to &lt;literal&gt;NULL&lt;/literal&gt;, unless
     a &lt;replaceable&gt;default_expression&lt;/replaceable&gt; is specified; then the
     value resulting from evaluating that expression is used.
</span>
パス式がある行に対して空のノード集合（典型的にはマッチしなかった場合）を返した時は、<em class="replaceable"><code>default_expression</code></em>が指定されている場合を除き、列には<code class="literal">NULL</code>が設定されます。
そしてその式を評価した結果から生じる値が使用されます。
    </p><p>
<span class="original">
     A &lt;replaceable&gt;default_expression&lt;/replaceable&gt;, rather than being
     evaluated immediately when &lt;function&gt;xmltable&lt;/function&gt; is called,
     is evaluated each time a default is needed for the column.
     If the expression qualifies as stable or immutable, the repeat
     evaluation may be skipped.
     This means that you can usefully use volatile functions like
     &lt;function&gt;nextval&lt;/function&gt; in
     &lt;replaceable&gt;default_expression&lt;/replaceable&gt;.
</span>
<code class="function">xmltable</code>が呼び出されて直ちに評価されるのと異なり、<em class="replaceable"><code>default_expression</code></em>はその列に対してデフォルトが必要になるたびに評価されます。
式が安定（stable）または不変（immutable）とみなされる場合、評価は繰り返し行われないかもしれません。
これは<em class="replaceable"><code>default_expression</code></em>の中で<code class="function">nextval</code>のような揮発性関数を使用できることを意味します。
    </p><p>
<span class="original">
     Columns may be marked &lt;literal&gt;NOT NULL&lt;/literal&gt;. If the
     &lt;replaceable&gt;column_expression&lt;/replaceable&gt; for a &lt;literal&gt;NOT
     NULL&lt;/literal&gt; column does not match anything and there is
     no &lt;literal&gt;DEFAULT&lt;/literal&gt; or
     the &lt;replaceable&gt;default_expression&lt;/replaceable&gt; also evaluates to null,
     an error is reported.
</span>
列には<code class="literal">NOT NULL</code>の印をつけることができます。
<code class="literal">NOT NULL</code>の列の<em class="replaceable"><code>column_expression</code></em>が何にもマッチせず、<code class="literal">DEFAULT</code>がない、あるいは<em class="replaceable"><code>default_expression</code></em>の評価結果もNULLになるという場合はエラーが報告されます。
    </p><p>
<span class="original">
     Examples:
</span>
例:
  </p><pre class="screen">
CREATE TABLE xmldata AS SELECT
xml $$
&lt;ROWS&gt;
  &lt;ROW id="1"&gt;
    &lt;COUNTRY_ID&gt;AU&lt;/COUNTRY_ID&gt;
    &lt;COUNTRY_NAME&gt;Australia&lt;/COUNTRY_NAME&gt;
  &lt;/ROW&gt;
  &lt;ROW id="5"&gt;
    &lt;COUNTRY_ID&gt;JP&lt;/COUNTRY_ID&gt;
    &lt;COUNTRY_NAME&gt;Japan&lt;/COUNTRY_NAME&gt;
    &lt;PREMIER_NAME&gt;Shinzo Abe&lt;/PREMIER_NAME&gt;
    &lt;SIZE unit="sq_mi"&gt;145935&lt;/SIZE&gt;
  &lt;/ROW&gt;
  &lt;ROW id="6"&gt;
    &lt;COUNTRY_ID&gt;SG&lt;/COUNTRY_ID&gt;
    &lt;COUNTRY_NAME&gt;Singapore&lt;/COUNTRY_NAME&gt;
    &lt;SIZE unit="sq_km"&gt;697&lt;/SIZE&gt;
  &lt;/ROW&gt;
&lt;/ROWS&gt;
$$ AS data;

SELECT xmltable.*
  FROM xmldata,
       XMLTABLE('//ROWS/ROW'
                PASSING data
                COLUMNS id int PATH '@id',
                        ordinality FOR ORDINALITY,
                        "COUNTRY_NAME" text,
                        country_id text PATH 'COUNTRY_ID',
                        size_sq_km float PATH 'SIZE[@unit = "sq_km"]',
                        size_other text PATH
                             'concat(SIZE[@unit!="sq_km"], " ", SIZE[@unit!="sq_km"]/@unit)',
                        premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');

 id | ordinality | COUNTRY_NAME | country_id | size_sq_km |  size_other  | premier_name
----+------------+--------------+------------+------------+--------------+---------------
  1 |          1 | Australia    | AU         |            |              | not specified
  5 |          2 | Japan        | JP         |            | 145935 sq_mi | Shinzo Abe
  6 |          3 | Singapore    | SG         |        697 |              | not specified
</pre><p>

<span class="original">
     The following example shows concatenation of multiple text() nodes,
     usage of the column name as XPath filter, and the treatment of whitespace,
     XML comments and processing instructions:
</span>
以下の例では、複数のtext()ノードの結合、列名のXPathフィルターとしての使用、空白文字、XMLコメント、処理命令の取扱いを示します。

  </p><pre class="screen">
CREATE TABLE xmlelements AS SELECT
xml $$
  &lt;root&gt;
   &lt;element&gt;  Hello&lt;!-- xyxxz --&gt;2a2&lt;?aaaaa?&gt; &lt;!--x--&gt;  bbb&lt;x&gt;xxx&lt;/x&gt;CC  &lt;/element&gt;
  &lt;/root&gt;
$$ AS data;

SELECT xmltable.*
  FROM xmlelements, XMLTABLE('/root' PASSING data COLUMNS element text);
         element
-------------------------
   Hello2a2   bbbxxxCC
</pre><p>
    </p><p>
<span class="original">
     The following example illustrates how
     the &lt;literal&gt;XMLNAMESPACES&lt;/literal&gt; clause can be used to specify
     a list of namespaces
     used in the XML document as well as in the XPath expressions:
</span>
以下の例では、<code class="literal">XMLNAMESPACES</code>句を使ってXMLドキュメントやXPath式で使われる追加の名前空間のリストを指定する方法を示します。

  </p><pre class="screen">
WITH xmldata(data) AS (VALUES ('
&lt;example xmlns="http://example.com/myns" xmlns:B="http://example.com/b"&gt;
 &lt;item foo="1" B:bar="2"/&gt;
 &lt;item foo="3" B:bar="4"/&gt;
 &lt;item foo="4" B:bar="5"/&gt;
&lt;/example&gt;'::xml)
)
SELECT xmltable.*
  FROM XMLTABLE(XMLNAMESPACES('http://example.com/myns' AS x,
                              'http://example.com/b' AS "B"),
             '/x:example/x:item'
                PASSING (SELECT data FROM xmldata)
                COLUMNS foo int PATH '@foo',
                  bar int PATH '@B:bar');
 foo | bar
-----+-----
   1 |   2
   3 |   4
   4 |   5
(3 rows)
</pre><p>
    </p></div></div><div class="sect2" id="FUNCTIONS-XML-MAPPING"><div class="titlepage"><div><div><h3 class="title">9.15.4. XMLにテーブルをマップ</h3></div></div></div><span class="original">
   &lt;title&gt;Mapping Tables to XML&lt;/title&gt;
</span><a id="id-1.5.8.23.8.2" class="indexterm"></a><p>
<span class="original">
    The following functions map the contents of relational tables to
    XML values.  They can be thought of as XML export functionality:
</span>
以下の関数はリレーショナルテーブルの内容をXML値にマップします。
これらはXMLエクスポート機能と考えることができます。
</p><pre class="synopsis">
<code class="function">table_to_xml</code> ( <em class="parameter"><code>table</code></em> <code class="type">regclass</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
               <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">query_to_xml</code> ( <em class="parameter"><code>query</code></em> <code class="type">text</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
               <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">cursor_to_xml</code> ( <em class="parameter"><code>cursor</code></em> <code class="type">refcursor</code>, <em class="parameter"><code>count</code></em> <code class="type">integer</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
</pre><p>
   </p><p>
<span class="original">
    &lt;function&gt;table_to_xml&lt;/function&gt; maps the content of the named
    table, passed as parameter &lt;parameter&gt;table&lt;/parameter&gt;.  The
    &lt;type&gt;regclass&lt;/type&gt; type accepts strings identifying tables using the
    usual notation, including optional schema qualification and
    double quotes (see &lt;xref linkend="datatype-oid"/&gt; for details).
    &lt;function&gt;query_to_xml&lt;/function&gt; executes the
    query whose text is passed as parameter
    &lt;parameter&gt;query&lt;/parameter&gt; and maps the result set.
    &lt;function&gt;cursor_to_xml&lt;/function&gt; fetches the indicated number of
    rows from the cursor specified by the parameter
    &lt;parameter&gt;cursor&lt;/parameter&gt;.  This variant is recommended if
    large tables have to be mapped, because the result value is built
    up in memory by each function.
</span>
<code class="function">table_to_xml</code>は、パラメータ<em class="parameter"><code>table</code></em>として渡された名前付きのテーブルの内容をマップします。
<code class="type">regclass</code>型はオプションのスキーマ修飾と二重引用符を含む、通常の表記法を使用しテーブルを特定する文字列を受け付けます。（詳細は<a class="xref" href="datatype-oid.html" title="8.19. オブジェクト識別子データ型">8.19</a>を参照してください。）
<code class="function">query_to_xml</code>は、パラメータ<em class="parameter"><code>query</code></em>としてテキストが渡された問い合わせを実行し、結果セットをマップします。
<code class="function">cursor_to_xml</code>は、パラメータ<em class="parameter"><code>cursor</code></em>で指定されたカーソルから提示された行数を取得します。
それぞれの関数により結果値がメモリーに構築されるため、この異形は巨大なテーブルをマップする必要がある場合推奨されます。
   </p><p>
<span class="original">
    If &lt;parameter&gt;tableforest&lt;/parameter&gt; is false, then the resulting
    XML document looks like this:
</span>
<em class="parameter"><code>tableforest</code></em>が偽であれば、結果のXML文書は以下のようになります。
</p><pre class="screen">
&lt;tablename&gt;
  &lt;row&gt;
    &lt;columnname1&gt;data&lt;/columnname1&gt;
    &lt;columnname2&gt;data&lt;/columnname2&gt;
  &lt;/row&gt;

  &lt;row&gt;
    ...
  &lt;/row&gt;

  ...
&lt;/tablename&gt;
</pre><p>

<span class="original">
    If &lt;parameter&gt;tableforest&lt;/parameter&gt; is true, the result is an
    XML content fragment that looks like this:
</span>
<em class="parameter"><code>tableforest</code></em>が真であれば、結果は以下のようなXML文書の断片です。
</p><pre class="screen">
&lt;tablename&gt;
  &lt;columnname1&gt;data&lt;/columnname1&gt;
  &lt;columnname2&gt;data&lt;/columnname2&gt;
&lt;/tablename&gt;

&lt;tablename&gt;
  ...
&lt;/tablename&gt;

...
</pre><p>

<span class="original">
    If no table name is available, that is, when mapping a query or a
    cursor, the string &lt;literal&gt;table&lt;/literal&gt; is used in the first
    format, &lt;literal&gt;row&lt;/literal&gt; in the second format.
</span>
テーブル名が利用できないとき、つまり、問い合わせ、またはカーソルをマップする時は、最初の書式では文字列<code class="literal">table</code>が使用され、２番目の書式では<code class="literal">row</code>が使用されます。
   </p><p>
<span class="original">
    The choice between these formats is up to the user.  The first
    format is a proper XML document, which will be important in many
    applications.  The second format tends to be more useful in the
    &lt;function&gt;cursor_to_xml&lt;/function&gt; function if the result values are to be
    reassembled into one document later on.  The functions for
    producing XML content discussed above, in particular
    &lt;function&gt;xmlelement&lt;/function&gt;, can be used to alter the results
    to taste.
</span>
これらどの書式を選択するのかはユーザ次第です。
最初の書式は適切なXML文書で、多くのアプリケーションにおいて重要です。
第２の書式は、後に結果値が１つの文書に再び組み立てられる場合、<code class="function">cursor_to_xml</code>関数内でより有用になる傾向があります。
上記で説明したXML内容を作成する関数、特に<code class="function">xmlelement</code>は結果を好みにかえるために使用することができます。
   </p><p>
<span class="original">
    The data values are mapped in the same way as described for the
    function &lt;function&gt;xmlelement&lt;/function&gt; above.
</span>
データの値は上記関数<code class="function">xmlelement</code>で説明したのと同じ方法でマップされます。
   </p><p>
<span class="original">
    The parameter &lt;parameter&gt;nulls&lt;/parameter&gt; determines whether null
    values should be included in the output.  If true, null values in
    columns are represented as:
</span>
パラメータ<em class="parameter"><code>nulls</code></em>は出力にNULL値が含まれる必要があるかを決定します。
もし真であれば列内のNULL値は以下のように表現されます。
</p><pre class="screen">
&lt;columnname xsi:nil="true"/&gt;
</pre><p>
<span class="original">
    where &lt;literal&gt;xsi&lt;/literal&gt; is the XML namespace prefix for XML
    Schema Instance.  An appropriate namespace declaration will be
    added to the result value.  If false, columns containing null
    values are simply omitted from the output.
</span>
ここで<code class="literal">xsi</code>はXMLスキーマインスタンスに対するXML名前空間接頭辞です。
適切な名前空間宣言が結果値に追加されます。
もし偽の場合、NULL値を含む列は単に出力から削除されます。
   </p><p>
<span class="original">
    The parameter &lt;parameter&gt;targetns&lt;/parameter&gt; specifies the
    desired XML namespace of the result.  If no particular namespace
    is wanted, an empty string should be passed.
</span>
パラメータ<em class="parameter"><code>targetns</code></em>は結果の希望するXML名前空間を指定します。
特定の名前空間が必要なければ、空文字列を渡す必要があります。
   </p><p>
<span class="original">
    The following functions return XML Schema documents describing the
    mappings performed by the corresponding functions above:
</span>
以下の関数は、対応する上記関数により行われたマッピングを記述するXMLスキーマ文書を返します。
</p><pre class="synopsis">
<code class="function">table_to_xmlschema</code> ( <em class="parameter"><code>table</code></em> <code class="type">regclass</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                     <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">query_to_xmlschema</code> ( <em class="parameter"><code>query</code></em> <code class="type">text</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                     <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">cursor_to_xmlschema</code> ( <em class="parameter"><code>cursor</code></em> <code class="type">refcursor</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                      <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
</pre><p>
<span class="original">
    It is essential that the same parameters are passed in order to
    obtain matching XML data mappings and XML Schema documents.
</span>
一致するXMLデータマッピングとXMLスキーマ文書を取得するため、同じパラメータが渡されることが不可欠です。
   </p><p>
<span class="original">
    The following functions produce XML data mappings and the
    corresponding XML Schema in one document (or forest), linked
    together.  They can be useful where self-contained and
    self-describing results are wanted:
</span>
以下の関数は、XMLデータマッピングとそれに対応するXMLスキーマがお互いにリンクされた、１つの文書（またはフォレスト）を作成します。
これらは自己完結した、自己記述的な結果を希望する場合に便利です。
</p><pre class="synopsis">
<code class="function">table_to_xml_and_xmlschema</code> ( <em class="parameter"><code>table</code></em> <code class="type">regclass</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                             <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">query_to_xml_and_xmlschema</code> ( <em class="parameter"><code>query</code></em> <code class="type">text</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                             <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
</pre><p>
   </p><p>
<span class="original">
    In addition, the following functions are available to produce
    analogous mappings of entire schemas or the entire current
    database:
</span>
さらに、以下の関数がスキーマ全体、または現在のデータベース全体の類似マッピングを作成するため利用できます。
</p><pre class="synopsis">
<code class="function">schema_to_xml</code> ( <em class="parameter"><code>schema</code></em> <code class="type">name</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">schema_to_xmlschema</code> ( <em class="parameter"><code>schema</code></em> <code class="type">name</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                      <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">schema_to_xml_and_xmlschema</code> ( <em class="parameter"><code>schema</code></em> <code class="type">name</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                              <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>

<code class="function">database_to_xml</code> ( <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                  <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">database_to_xmlschema</code> ( <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                        <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">database_to_xml_and_xmlschema</code> ( <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                                <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
</pre><p>

<span class="original">
    These functions ignore tables that are not readable by the current user.
    The database-wide functions additionally ignore schemas that the current
    user does not have &lt;literal&gt;USAGE&lt;/literal&gt; (lookup) privilege for.
</span>
これらの関数は現在のユーザが読めないテーブルは無視します。
加えてデータベース中全体に渡る関数は現在のユーザが<code class="literal">USAGE</code>（検索）権限を持たないスキーマを無視します。
   </p><p>
<span class="original">
    Note that these potentially produce a lot of data, which needs to
    be built up in memory.  When requesting content mappings of large
    schemas or databases, it might be worthwhile to consider mapping the
    tables separately instead, possibly even through a cursor.
</span>
これらはメモリー内に作成される必要がある、多くのデータを生成する潜在的可能性があることに注意してください。
巨大なスキーマ、またはデータベースの内容マッピングを要求する際は、その代わりにテーブルを別々にマップすること、さらにはカーソル経由とすることさえ、検討することは無駄ではありません。
   </p><p>
<span class="original">
    The result of a schema content mapping looks like this:
</span>
スキーマ内容マッピングの結果は以下のようになります。

</p><pre class="screen">
&lt;schemaname&gt;

table1-mapping

table2-mapping

...

&lt;/schemaname&gt;</pre><p>

<span class="original">
    where the format of a table mapping depends on the
    &lt;parameter&gt;tableforest&lt;/parameter&gt; parameter as explained above.
</span>
ここで、テーブルマッピング書式は上で説明したとおり<em class="parameter"><code>tableforest</code></em>パラメータに依存します。
   </p><p>
<span class="original">
    The result of a database content mapping looks like this:
</span>
データベース内容マッピング書式は以下のようになります。

</p><pre class="screen">
&lt;dbname&gt;

&lt;schema1name&gt;
  ...
&lt;/schema1name&gt;

&lt;schema2name&gt;
  ...
&lt;/schema2name&gt;

...

&lt;/dbname&gt;</pre><p>

<span class="original">
    where the schema mapping is as above.
</span>
ここで、スキーママッピングは上記のとおりです。
   </p><p>
<span class="original">
    As an example of using the output produced by these functions,
    &lt;xref linkend="xslt-xml-html"/&gt; shows an XSLT stylesheet that
    converts the output of
    &lt;function&gt;table_to_xml_and_xmlschema&lt;/function&gt; to an HTML
    document containing a tabular rendition of the table data.  In a
    similar manner, the results from these functions can be
    converted into other XML-based formats.
</span>
これらの関数で作成された出力を使用する１つの例として、<a class="xref" href="functions-xml.html#XSLT-XML-HTML" title="例9.1 SQL/XML出力をHTMLに変換するXSLTスタイルシート">例 9.1</a>は、テーブルデータの表形式への翻訳を含む<code class="function">table_to_xml_and_xmlschema</code>からHTML文書への出力の変換をおこなうXSLTスタイルシートを示します。
同じようにして、これらの関数の結果は他のXML基準書式に変換されます。
   </p><div class="example" id="XSLT-XML-HTML"><p class="title"><strong>例9.1 SQL/XML出力をHTMLに変換するXSLTスタイルシート</strong></p><div class="example-contents"><span class="original">
    &lt;title&gt;XSLT Stylesheet for Converting SQL/XML Output to HTML&lt;/title&gt;
</span><pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
&gt;

  &lt;xsl:output method="xml"
      doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
      doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
      indent="yes"/&gt;

  &lt;xsl:template match="/*"&gt;
    &lt;xsl:variable name="schema" select="//xsd:schema"/&gt;
    &lt;xsl:variable name="tabletypename"
                  select="$schema/xsd:element[@name=name(current())]/@type"/&gt;
    &lt;xsl:variable name="rowtypename"
                  select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name='row']/@type"/&gt;

    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;&lt;xsl:value-of select="name(current())"/&gt;&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;table&gt;
          &lt;tr&gt;
            &lt;xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name"&gt;
              &lt;th&gt;&lt;xsl:value-of select="."/&gt;&lt;/th&gt;
            &lt;/xsl:for-each&gt;
          &lt;/tr&gt;

          &lt;xsl:for-each select="row"&gt;
            &lt;tr&gt;
              &lt;xsl:for-each select="*"&gt;
                &lt;td&gt;&lt;xsl:value-of select="."/&gt;&lt;/td&gt;
              &lt;/xsl:for-each&gt;
            &lt;/tr&gt;
          &lt;/xsl:for-each&gt;
        &lt;/table&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div></div><br class="example-break" /></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.5.8.23.7.5.16.2" class="footnote"><p><a href="#id-1.5.8.23.7.5.16.2" class="para"><sup class="para">[8] </sup></a>
<span class="original">
       A result containing more than one element node at the top level, or
       non-whitespace text outside of an element, is an example of content form.
       An XPath result can be of neither form, for example if it returns an
       attribute node selected from the element that contains it. Such a result
       will be put into content form with each such disallowed node replaced by
       its string value, as defined for the XPath 1.0
       &lt;function&gt;string&lt;/function&gt; function.
</span>
トップレベルにおいて複数の要素ノードを含むか、あるいは要素の外側の非空白テキストであるような結果は、コンテントフォームの例です。
XPathの結果はそのどちらでもないフォームであることがあり得ます。
たとえば、それを含む要素から選択された属性ノードを返す場合です。
XPath 1.0の<code class="function">string</code>関数で定義されているように、そうした結果は、許可されないノードを文字列値で置き換えたコンテントフォームに設定されます。
      </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-uuid.html" title="9.14. UUID関数">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html" title="第9章 関数と演算子">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-json.html" title="9.16. JSON関数と演算子">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">9.14. UUID関数 </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 15.0文書">ホーム</a></td><td width="40%" align="right" valign="top"> 9.16. JSON関数と演算子</td></tr></table></div></body></html>