<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE TYPE</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-createtrigger.html" title="CREATE TRIGGER" /><link rel="next" href="sql-createuser.html" title="CREATE USER" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="other_version"><a href="https://www.postgresql.jp/document/">バージョンごとのドキュメント一覧</a></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 15.0文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="sql-commands.html" title="SQLコマンド">SQLコマンド</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?template=bug_report.yml&amp;what-happened=version 15.0 : sql-createtype.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createtrigger.html" title="CREATE TRIGGER">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">上へ</a></td><td width="60%" align="center">CREATE TYPE</td><td width="20%" align="right"> <a accesskey="n" href="sql-createuser.html" title="CREATE USER">次へ</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATETYPE"><div class="titlepage"></div><a id="id-1.9.3.94.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE TYPE</span></h2><p>CREATE TYPE<span class="original">
  &lt;refpurpose&gt;define a new data type&lt;/refpurpose&gt;
</span> — 新しいデータ型を定義する</p></div><div class="refsynopsisdiv"><h2>概要</h2><pre class="synopsis">
CREATE TYPE <em class="replaceable"><code>name</code></em> AS
    ( [ <em class="replaceable"><code>attribute_name</code></em> <em class="replaceable"><code>data_type</code></em> [ COLLATE <em class="replaceable"><code>collation</code></em> ] [, ... ] ] )

CREATE TYPE <em class="replaceable"><code>name</code></em> AS ENUM
    ( [ '<em class="replaceable"><code>label</code></em>' [, ... ] ] )

CREATE TYPE <em class="replaceable"><code>name</code></em> AS RANGE (
    SUBTYPE = <em class="replaceable"><code>subtype</code></em>
    [ , SUBTYPE_OPCLASS = <em class="replaceable"><code>subtype_operator_class</code></em> ]
    [ , COLLATION = <em class="replaceable"><code>collation</code></em> ]
    [ , CANONICAL = <em class="replaceable"><code>canonical_function</code></em> ]
    [ , SUBTYPE_DIFF = <em class="replaceable"><code>subtype_diff_function</code></em> ]
    [ , MULTIRANGE_TYPE_NAME = <em class="replaceable"><code>multirange_type_name</code></em> ]
)

CREATE TYPE <em class="replaceable"><code>name</code></em> (
    INPUT = <em class="replaceable"><code>input_function</code></em>,
    OUTPUT = <em class="replaceable"><code>output_function</code></em>
    [ , RECEIVE = <em class="replaceable"><code>receive_function</code></em> ]
    [ , SEND = <em class="replaceable"><code>send_function</code></em> ]
    [ , TYPMOD_IN = <em class="replaceable"><code>type_modifier_input_function</code></em> ]
    [ , TYPMOD_OUT = <em class="replaceable"><code>type_modifier_output_function</code></em> ]
    [ , ANALYZE = <em class="replaceable"><code>analyze_function</code></em> ]
    [ , SUBSCRIPT = <em class="replaceable"><code>subscript_function</code></em> ]
    [ , INTERNALLENGTH = { <em class="replaceable"><code>internallength</code></em> | VARIABLE } ]
    [ , PASSEDBYVALUE ]
    [ , ALIGNMENT = <em class="replaceable"><code>alignment</code></em> ]
    [ , STORAGE = <em class="replaceable"><code>storage</code></em> ]
    [ , LIKE = <em class="replaceable"><code>like_type</code></em> ]
    [ , CATEGORY = <em class="replaceable"><code>category</code></em> ]
    [ , PREFERRED = <em class="replaceable"><code>preferred</code></em> ]
    [ , DEFAULT = <em class="replaceable"><code>default</code></em> ]
    [ , ELEMENT = <em class="replaceable"><code>element</code></em> ]
    [ , DELIMITER = <em class="replaceable"><code>delimiter</code></em> ]
    [ , COLLATABLE = <em class="replaceable"><code>collatable</code></em> ]
)

CREATE TYPE <em class="replaceable"><code>name</code></em>
</pre></div><div class="refsect1" id="id-1.9.3.94.5"><h2>説明</h2><span class="original">
  &lt;title&gt;Description&lt;/title&gt;
</span><p>
<span class="original">
   &lt;command&gt;CREATE TYPE&lt;/command&gt; registers a new data type for use in
   the current database.  The user who defines a type becomes its
   owner.
</span>
<code class="command">CREATE TYPE</code>は、現在のデータベースで使用できる新しいデータ型を登録します。
型を定義したユーザがその所有者となります。
  </p><p>
<span class="original">
   If a schema name is given then the type is created in the specified
   schema.  Otherwise it is created in the current schema.  The type
   name must be distinct from the name of any existing type or domain
   in the same schema.  (Because tables have associated data types,
   the type name must also be distinct from the name of any existing
   table in the same schema.)
</span>
スキーマ名が与えられている場合、型は指定されたスキーマに作成されます。
スキーマ名がなければ、その型は現在のスキーマに作成されます。
型名は、同じスキーマにある既存の型もしくはドメインとは、異なる名前にする必要があります
（さらに、テーブルはデータ型と関連しているため、データ型名は同じスキーマのテーブル名とも競合しないようにしてください）。
  </p><p>
<span class="original">
   There are five forms of &lt;command&gt;CREATE TYPE&lt;/command&gt;, as shown in the
   syntax synopsis above.  They respectively create a &lt;firstterm&gt;composite
   type&lt;/firstterm&gt;, an &lt;firstterm&gt;enum type&lt;/firstterm&gt;, a &lt;firstterm&gt;range type&lt;/firstterm&gt;, a
   &lt;firstterm&gt;base type&lt;/firstterm&gt;, or a &lt;firstterm&gt;shell type&lt;/firstterm&gt;.  The first four
   of these are discussed in turn below.  A shell type is simply a placeholder
   for a type to be defined later; it is created by issuing &lt;command&gt;CREATE
   TYPE&lt;/command&gt; with no parameters except for the type name.  Shell types
   are needed as forward references when creating range types and base types,
   as discussed in those sections.
</span>
上の構文概要に示すように、<code class="command">CREATE TYPE</code>には５つの構文があります。
これらはそれぞれ、<em class="firstterm">複合型</em>, <em class="firstterm">列挙型</em>、<em class="firstterm">範囲型</em>、<em class="firstterm">基本型</em>、<em class="firstterm">シェル型</em>を作成します。
これらの内最初の４個についてはここで順番に説明します。
シェル型は、後で定義される型用の単なるプレースホルダで、型名以外のパラメータをつけずに<code class="command">CREATE TYPE</code>を実行することで作成されます。
シェル型は、範囲型と基本型を作成するときの前方参照として必要となるもので、それぞれの節で説明します。
  </p><div class="refsect2" id="id-1.9.3.94.5.5"><h3>複合型</h3><span class="original">
   &lt;title&gt;Composite Types&lt;/title&gt;
</span><p>
<span class="original">
   The first form of &lt;command&gt;CREATE TYPE&lt;/command&gt;
   creates a composite type.
   The composite type is specified by a list of attribute names and data types.
   An attribute's collation can be specified too, if its data type is
   collatable.  A composite type is essentially the same as the row type
   of a table, but using &lt;command&gt;CREATE TYPE&lt;/command&gt; avoids the need to
   create an actual table when all that is wanted is to define a type.
   A stand-alone composite type is useful, for example, as the argument or
   return type of a function.
</span>
<code class="command">CREATE TYPE</code>の最初の構文を使用すると、複合型を作成できます。
複合型は、属性名およびデータ型のリストにより指定されます。
データ型の照合順序が設定可能である場合、属性の照合順序も指定することができます。
複合型は本質的にはテーブルの行型と同じです。
しかし、型を定義することだけが必要なのであれば、<code class="command">CREATE TYPE</code>を使用することで、実際のテーブルを作成する必要がなくなります。
スタンドアローンの複合型は、例えば関数の引数や戻り値の型として有用です。
  </p><p>
<span class="original">
   To be able to create a composite type, you must
   have &lt;literal&gt;USAGE&lt;/literal&gt; privilege on all attribute types.
</span>
複合型を作成するためには、すべての属性型に対して<code class="literal">USAGE</code>権限を持たなければなりません。
  </p></div><div class="refsect2" id="SQL-CREATETYPE-ENUM"><h3>列挙型</h3><span class="original">
   &lt;title&gt;Enumerated Types&lt;/title&gt;
</span><p>
<span class="original">
    The second form of &lt;command&gt;CREATE TYPE&lt;/command&gt; creates an enumerated
    (enum) type, as described in &lt;xref linkend="datatype-enum"/&gt;.
    Enum types take a list of quoted labels, each of which
    must be less than &lt;symbol&gt;NAMEDATALEN&lt;/symbol&gt; bytes long (64 bytes in a
    standard &lt;productname&gt;PostgreSQL&lt;/productname&gt; build).  (It is possible to
    create an enumerated type with zero labels, but such a type cannot be used
    to hold values before at least one label is added using &lt;link
    linkend="sql-altertype"&gt;&lt;command&gt;ALTER TYPE&lt;/command&gt;&lt;/link&gt;.)
</span>
<code class="command">CREATE TYPE</code>の2つ目の構文を使用すると、<a class="xref" href="datatype-enum.html" title="8.7. 列挙型">8.7</a>で説明する列挙型（enum）を作成します。
列挙型は、引用符付きのラベルのリストを取ります。
ラベルは<code class="symbol">NAMEDATALEN</code>（<span class="productname">PostgreSQL</span>の標準のビルドでは64バイト）バイトよりも少ない長さでなければなりません。
(ラベルのない列挙型を作成できますが、<a class="link" href="sql-altertype.html" title="ALTER TYPE"><code class="command">ALTER TYPE</code></a>を使ってラベルを少なくとも1つ追加するまでは、そのような型は値を保持するのに使えません。)
   </p></div><div class="refsect2" id="SQL-CREATETYPE-RANGE"><h3>範囲型</h3><span class="original">
   &lt;title&gt;Range Types&lt;/title&gt;
</span><p>
<span class="original">
    The third form of &lt;command&gt;CREATE TYPE&lt;/command&gt; creates a new
    range type, as described in &lt;xref linkend="rangetypes"/&gt;.
</span>
<code class="command">CREATE TYPE</code>の三番目の構文は、<a class="xref" href="rangetypes.html" title="8.17. 範囲型">8.17</a>で説明する範囲型を新規に作成します。
   </p><p>
<span class="original">
    The range type's &lt;replaceable class="parameter"&gt;subtype&lt;/replaceable&gt; can
    be any type with an associated b-tree operator class (to determine the
    ordering of values for the range type).  Normally the subtype's default
    b-tree operator class is used to determine ordering; to use a non-default
    operator class, specify its name with &lt;replaceable
    class="parameter"&gt;subtype_opclass&lt;/replaceable&gt;.  If the subtype is
    collatable, and you want to use a non-default collation in the range's
    ordering, specify the desired collation with the &lt;replaceable
    class="parameter"&gt;collation&lt;/replaceable&gt; option.
</span>
範囲型の<em class="replaceable"><code>subtype</code></em>は、関連する（範囲型の値を順序を決定するための）b-tree演算子クラスを持つ任意の型を取ることができます。
通常、派生元型のデフォルトのb-tree演算子クラスが順序を決定するために使用されます。
デフォルト以外の演算子クラスを使用するためには、<em class="replaceable"><code>subtype_opclass</code></em>でその名前を指定してください。
派生元型が照合順序変更可能であり、範囲の順序付けでデフォルト以外の照合順序を使用したい場合は、<em class="replaceable"><code>collation</code></em>オプションで使用したい照合順序を指定してください。
   </p><p>
<span class="original">
    The optional &lt;replaceable class="parameter"&gt;canonical&lt;/replaceable&gt;
    function must take one argument of the range type being defined, and
    return a value of the same type.  This is used to convert range values
    to a canonical form, when applicable.  See &lt;xref
    linkend="rangetypes-defining"/&gt; for more information.  Creating a
    &lt;replaceable class="parameter"&gt;canonical&lt;/replaceable&gt; function
    is a bit tricky, since it must be defined before the range type can be
    declared.  To do this, you must first create a shell type, which is a
    placeholder type that has no properties except a name and an
    owner.  This is done by issuing the command &lt;literal&gt;CREATE TYPE
    &lt;replaceable&gt;name&lt;/replaceable&gt;&lt;/literal&gt;, with no additional parameters.  Then
    the function can be declared using the shell type as argument and result,
    and finally the range type can be declared using the same name.  This
    automatically replaces the shell type entry with a valid range type.
</span>
<em class="replaceable"><code>canonical</code></em>関数(省略可能)は、定義する範囲型の引数を１つ取り、同じ型の値を返さなければなりません。
これは適切な時に範囲値を正規形式に変換するために使用されます。
詳細については<a class="xref" href="rangetypes.html#RANGETYPES-DEFINING" title="8.17.8. 新しい範囲型の定義">8.17.8</a>を参照してください。
<em class="replaceable"><code>canonical</code></em>関数を作成することは多少厄介です、というのは、範囲型を定義できるようになる前に定義されている必要があるからです。
このためには、まず、名前と所有者以外の属性を持たないプレースホルダであるシェル型を作成しなければなりません。
これは、他にパラメータをつけずに<code class="literal">CREATE TYPE <em class="replaceable"><code>name</code></em></code>を実行することで行われます。
その後、このシェル型を引数と結果として使用する関数を宣言することができます。
最後に同じ名前を用いて範囲型を宣言することができます。
これは自動的にシェル型の項目を有効な範囲型に置き換えます。
   </p><p>
<span class="original">
    The optional &lt;replaceable class="parameter"&gt;subtype_diff&lt;/replaceable&gt;
    function must take two values of the
    &lt;replaceable class="parameter"&gt;subtype&lt;/replaceable&gt; type as argument,
    and return a &lt;type&gt;double precision&lt;/type&gt; value representing the
    difference between the two given values.  While this is optional,
    providing it allows much greater efficiency of GiST indexes on columns of
    the range type.  See &lt;xref linkend="rangetypes-defining"/&gt; for more
    information.
</span>
<em class="replaceable"><code>subtype_diff</code></em>関数(省略可能)は、<em class="replaceable"><code>subtype</code></em>型の２つの値を引数として取り、与えられた２つの値の差異を表す<code class="type">double precision</code>型を返さなければなりません。
これは省略することができますが、提供することでその範囲型の列に対するGiSTインデックスの効率を大きく向上させることができます。
詳細については<a class="xref" href="rangetypes.html#RANGETYPES-DEFINING" title="8.17.8. 新しい範囲型の定義">8.17.8</a>を参照してください。
   </p><p>
<span class="original">
    The optional &lt;replaceable class="parameter"&gt;multirange_type_name&lt;/replaceable&gt;
    parameter specifies the name of the corresponding multirange type.  If not
    specified, this name is chosen automatically as follows.
    If the range type name contains the substring &lt;literal&gt;range&lt;/literal&gt;, then
    the multirange type name is formed by replacement of the &lt;literal&gt;range&lt;/literal&gt;
    substring with &lt;literal&gt;multirange&lt;/literal&gt; in the range
    type name.  Otherwise, the multirange type name is formed by appending a
    &lt;literal&gt;_multirange&lt;/literal&gt; suffix to the range type name.
</span>
<em class="replaceable"><code>multirange_type_name</code></em>パラメータ(省略可能)は、対応する多重範囲型の名前を指定します。
指定されなければ、この名前は自動的に以下のように選ばれます。
範囲型の名前が部分文字列<code class="literal">range</code>を含んでいれば、多重範囲型の名前は、範囲型の名前における部分文字列<code class="literal">range</code>を<code class="literal">multirange</code>で置き換えることで作られます。
そうでなければ、多重範囲型の名前は範囲型の名前の末尾に<code class="literal">_multirange</code>を追加することで作られます。
   </p></div><div class="refsect2" id="id-1.9.3.94.5.8"><h3>基本型</h3><span class="original">
   &lt;title&gt;Base Types&lt;/title&gt;
</span><p>
<span class="original">
   The fourth form of &lt;command&gt;CREATE TYPE&lt;/command&gt; creates a new base type
   (scalar type).  To create a new base type, you must be a superuser.
   (This restriction is made because an erroneous type definition could
   confuse or even crash the server.)
</span>
<code class="command">CREATE TYPE</code>の４つ目の構文を使用すると、基本型（スカラ型）を新しく作成できます。
新しい基本型を作成するにはスーパーユーザでなければなりません。
（エラーがある型定義が混乱を招き、サーバがクラッシュすることすらあるため、この制限がなされました。）
  </p><p>
<span class="original">
   The parameters can appear in any order, not only that
   illustrated above, and most are optional.  You must register
   two or more functions (using &lt;command&gt;CREATE FUNCTION&lt;/command&gt;) before
   defining the type.  The support functions
   &lt;replaceable class="parameter"&gt;input_function&lt;/replaceable&gt; and
   &lt;replaceable class="parameter"&gt;output_function&lt;/replaceable&gt;
   are required, while the functions
   &lt;replaceable class="parameter"&gt;receive_function&lt;/replaceable&gt;,
   &lt;replaceable class="parameter"&gt;send_function&lt;/replaceable&gt;,
   &lt;replaceable class="parameter"&gt;type_modifier_input_function&lt;/replaceable&gt;,
   &lt;replaceable class="parameter"&gt;type_modifier_output_function&lt;/replaceable&gt;,
   &lt;replaceable class="parameter"&gt;analyze_function&lt;/replaceable&gt;, and
   &lt;replaceable class="parameter"&gt;subscript_function&lt;/replaceable&gt;
   are optional.  Generally these functions have to be coded in C
   or another low-level language.
</span>
パラメータは、上述の順番である必要はなく、任意の順番で指定することができ、多くは省略可能です。
型を定義する前に、（<code class="command">CREATE FUNCTION</code>を用いて）2つ以上の関数を登録しておく必要があります。
サポート関数である<em class="replaceable"><code>input_function</code></em>と<em class="replaceable"><code>output_function</code></em>は必須です。
<em class="replaceable"><code>receive_function</code></em>関数、<em class="replaceable"><code>send_function</code></em>関数、<em class="replaceable"><code>type_modifier_input_function</code></em>関数、<em class="replaceable"><code>type_modifier_output_function</code></em>関数、<em class="replaceable"><code>analyze_function</code></em>関数、および<em class="replaceable"><code>subscript_function</code></em>は省略可能です。
通常、これらの関数は、C言語やその他の低レベル言語で作成されなければなりません。
  </p><p>
<span class="original">
   The &lt;replaceable class="parameter"&gt;input_function&lt;/replaceable&gt;
   converts the type's external textual representation to the internal
   representation used by the operators and functions defined for the type.
   &lt;replaceable class="parameter"&gt;output_function&lt;/replaceable&gt;
   performs the reverse transformation.  The input function can be
   declared as taking one argument of type &lt;type&gt;cstring&lt;/type&gt;,
   or as taking three arguments of types
   &lt;type&gt;cstring&lt;/type&gt;, &lt;type&gt;oid&lt;/type&gt;, &lt;type&gt;integer&lt;/type&gt;.
   The first argument is the input text as a C string, the second
   argument is the type's own OID (except for array types, which instead
   receive their element type's OID),
   and the third is the &lt;literal&gt;typmod&lt;/literal&gt; of the destination column, if known
   (-1 will be passed if not).
   The input function must return a value of the data type itself.
   Usually, an input function should be declared STRICT; if it is not,
   it will be called with a NULL first parameter when reading a NULL
   input value.  The function must still return NULL in this case, unless
   it raises an error.
   (This case is mainly meant to support domain input functions, which
   might need to reject NULL inputs.)
   The output function must be
   declared as taking one argument of the new data type.
   The output function must return type &lt;type&gt;cstring&lt;/type&gt;.
   Output functions are not invoked for NULL values.
</span>
<em class="replaceable"><code>input_function</code></em>は、型のテキストによる外部表現を内部表現形式に変換するものであり、その型用に定義される演算子や関数で使用されます。
<em class="replaceable"><code>output_function</code></em>はこの逆の変換を行うものです。
入力関数は、1つの<code class="type">cstring</code>型の引数、あるいは、<code class="type">cstring</code>型、<code class="type">oid</code>型、<code class="type">integer</code>型という3つの引数を取るように宣言されます。
最初の引数にはC言語文字列の入力テキスト、2番目には型自体のOID（配列型の場合は例外で要素の型のOIDとなります）、3番目は、判明していれば対象列の<code class="literal">typmod</code>を渡します
（不明な場合は-1を渡します）。
この入力関数では、データ型自身の値を返さなければなりません。
通常入力関数はSTRICTとして宣言しなければなりません。
そうしないと、NULLという入力値を読み取った時、NULLという最初のパラメータを持って呼び出されます。
この場合でもエラーを発生させるのでなければ、関数はNULLを返さなければなりません。
（こうした状況はほとんどの場合、ドメイン入力関数をサポートすることを意図しています。ドメイン入力関数ではNULL入力を拒絶しなければならない可能性があります。）
出力関数は、新しいデータ型の引数を1つ取るように宣言しなければなりません。
出力関数は、<code class="type">cstring</code>型を返さなければなりません。
出力関数はNULL値に対して呼び出されることはありません。
  </p><p>
<span class="original">
   The optional &lt;replaceable class="parameter"&gt;receive_function&lt;/replaceable&gt;
   converts the type's external binary representation to the internal
   representation.  If this function is not supplied, the type cannot
   participate in binary input.  The binary representation should be
   chosen to be cheap to convert to internal form, while being reasonably
   portable.  (For example, the standard integer data types use network
   byte order as the external binary representation, while the internal
   representation is in the machine's native byte order.)  The receive
   function should perform adequate checking to ensure that the value is
   valid.
   The receive function can be declared as taking one argument of type
   &lt;type&gt;internal&lt;/type&gt;, or as taking three arguments of types
   &lt;type&gt;internal&lt;/type&gt;, &lt;type&gt;oid&lt;/type&gt;, &lt;type&gt;integer&lt;/type&gt;.
   The first argument is a pointer to a &lt;type&gt;StringInfo&lt;/type&gt; buffer
   holding the received byte string; the optional arguments are the
   same as for the text input function.
   The receive function must return a value of the data type itself.
   Usually, a receive function should be declared STRICT; if it is not,
   it will be called with a NULL first parameter when reading a NULL
   input value.  The function must still return NULL in this case, unless
   it raises an error.
   (This case is mainly meant to support domain receive functions, which
   might need to reject NULL inputs.)
   Similarly, the optional
   &lt;replaceable class="parameter"&gt;send_function&lt;/replaceable&gt; converts
   from the internal representation to the external binary representation.
   If this function is not supplied, the type cannot participate in binary
   output.  The send function must be
   declared as taking one argument of the new data type.
   The send function must return type &lt;type&gt;bytea&lt;/type&gt;.
   Send functions are not invoked for NULL values.
</span>
<em class="replaceable"><code>receive_function</code></em>では、型のバイナリによる外部表現を内部表現に変換します。この関数は省略可能です。
この関数が与えられない場合、この型ではバイナリ入力を行うことができません。
バイナリ表現の方法は、適度な可搬性を保ちつつ、内部表現への変換コストが小さくなるよう選択すべきです
（例えば標準の整数データ型は、外部バイナリ表現としてはネットワークバイトオーダを使用し、内部表現ではマシン固有のバイトオーダを使用します）。
この受信関数では、値が有効かどうかを判定するための適切な検査を行わなければなりません。
受信関数は、<code class="type">internal</code>型の引数1つ、または、<code class="type">internal</code>型と<code class="type">oid</code>、<code class="type">integer</code>型の3つの引数を取るように宣言されます。
最初の引数は受信したバイト文字列を保持する<code class="type">StringInfo</code>バッファへのポインタ、省略可能な引数は、テキスト入力関数の説明と同じです。
受信関数は、データ型自体の値を返す必要があります。
通常受信関数はSTRICTとして宣言しなければなりません。
そうしないと、NULLという入力値を読み取った時、NULLという最初のパラメータを持って呼び出されます。
この場合でも関数はエラーを発生させるのでなければNULLを返さなければなりません。
（こうした状況はほとんどの場合、ドメイン受信関数をサポートすることを意図しています。ドメイン受信関数ではNULL入力を拒絶しなければならない可能性があります。）
同様に、<em class="replaceable"><code>send_function</code></em>は、内部表現からバイナリによる外部表現に変換します。この関数も省略可能です。
この関数が与えられない場合、この型ではバイナリ出力を行うことができません。
この送信関数は、新しいデータ型の引数1つを取るように宣言しなければなりません。
送信関数は<code class="type">bytea</code>型を返さなければなりません。
送信関数はNULL値に対して呼び出されません。
  </p><p>
<span class="original">
   You should at this point be wondering how the input and output functions
   can be declared to have results or arguments of the new type, when they
   have to be created before the new type can be created.  The answer is that
   the type should first be defined as a &lt;firstterm&gt;shell type&lt;/firstterm&gt;, which is a
   placeholder type that has no properties except a name and an owner.  This
   is done by issuing the command &lt;literal&gt;CREATE TYPE
   &lt;replaceable&gt;name&lt;/replaceable&gt;&lt;/literal&gt;, with no additional parameters.  Then the
   C I/O functions can be defined referencing the shell type.  Finally,
   &lt;command&gt;CREATE TYPE&lt;/command&gt; with a full definition replaces the shell entry
   with a complete, valid type definition, after which the new type can be
   used normally.
</span>
ここで、新しいデータ型を作成する前に入力関数と出力関数を作成する必要があるのに、どのようにしてそれらの関数で新しいデータ型を戻り値や入力として宣言できるのか、疑問に思うかもしれません。
その答えは、まず型が最初に<em class="firstterm">シェル型</em>として定義されます。
これは名称と所有者以外の属性を持たないプレースホルダ型です。
これは、コマンド<code class="literal">CREATE TYPE <em class="replaceable"><code>name</code></em></code>を他にパラメータをつけずに発行することで行われます。
この後、Cの入出力関数をこのシェル型を参照するように定義することができます。
最後に完全な定義を持った<code class="command">CREATE TYPE</code>によって、シェル型の項目が完全かつ有効な型定義に置き換わり、新しい型を普通に使用することができるようになります。
  </p><p>
<span class="original">
   The optional
   &lt;replaceable class="parameter"&gt;type_modifier_input_function&lt;/replaceable&gt;
   and &lt;replaceable class="parameter"&gt;type_modifier_output_function&lt;/replaceable&gt;
   are needed if the type supports modifiers, that is optional constraints
   attached to a type declaration, such as &lt;literal&gt;char(5)&lt;/literal&gt; or
   &lt;literal&gt;numeric(30,2)&lt;/literal&gt;.  &lt;productname&gt;PostgreSQL&lt;/productname&gt; allows
   user-defined types to take one or more simple constants or identifiers as
   modifiers.  However, this information must be capable of being packed into a
   single non-negative integer value for storage in the system catalogs.  The
   &lt;replaceable class="parameter"&gt;type_modifier_input_function&lt;/replaceable&gt;
   is passed the declared modifier(s) in the form of a &lt;type&gt;cstring&lt;/type&gt;
   array.  It must check the values for validity (throwing an error if they
   are wrong), and if they are correct, return a single non-negative
   &lt;type&gt;integer&lt;/type&gt; value that will be stored as the column &lt;quote&gt;typmod&lt;/quote&gt;.
   Type modifiers will be rejected if the type does not have a
   &lt;replaceable class="parameter"&gt;type_modifier_input_function&lt;/replaceable&gt;.
   The &lt;replaceable class="parameter"&gt;type_modifier_output_function&lt;/replaceable&gt;
   converts the internal integer typmod value back to the correct form for
   user display.  It must return a &lt;type&gt;cstring&lt;/type&gt; value that is the exact
   string to append to the type name; for example &lt;type&gt;numeric&lt;/type&gt;'s
   function might return &lt;literal&gt;(30,2)&lt;/literal&gt;.
   It is allowed to omit the
   &lt;replaceable class="parameter"&gt;type_modifier_output_function&lt;/replaceable&gt;,
   in which case the default display format is just the stored typmod integer
   value enclosed in parentheses.
</span>
<em class="replaceable"><code>type_modifier_input_function</code></em>と<em class="replaceable"><code>type_modifier_output_function</code></em>は必須ではありませんが、型が修飾子をサポートする場合は必要です。
修飾子とは、<code class="literal">char(5)</code>や<code class="literal">numeric(30,2)</code>などの型宣言に付与されるオプションの制約です。
<span class="productname">PostgreSQL</span>では、ユーザ定義型が1つ以上の整数定数または識別子を修飾子として取ることができます。
しかし、この情報はシステムカタログに格納される時に0以上の整数1つにまとめられるものでなければなりません。
<em class="replaceable"><code>type_modifier_input_function</code></em>には、<code class="type">cstring</code>型配列の形で宣言された修飾子が渡されます。
その値について妥当性を検査しなければなりません（不当な場合はエラーとします）。
そして、正しい場合は、<span class="quote">「<span class="quote">typmod</span>」</span>列として格納される、0以上の<code class="type">integer</code>値を1つ返さなければなりません。
型が<em class="replaceable"><code>type_modifier_input_function</code></em>を持たない場合、型修飾子は拒否されます。
<em class="replaceable"><code>type_modifier_output_function</code></em>は内部的な整数typmod値をユーザ側の表示に合わせて変換します。
この関数は型名に付与する正確な文字列となる<code class="type">cstring</code>値を返さなければなりません。
たとえば<code class="type">numeric</code>用の関数では<code class="literal">(30,2)</code>を返すかもしれません。
デフォルトの表示用書式が保管されたtypmod整数値を括弧で括ったものと一致している場合は、<em class="replaceable"><code>type_modifier_output_function</code></em>を省略することができます。
  </p><p>
<span class="original">
   The optional &lt;replaceable class="parameter"&gt;analyze_function&lt;/replaceable&gt;
   performs type-specific statistics collection for columns of the data type.
   By default, &lt;command&gt;ANALYZE&lt;/command&gt; will attempt to gather statistics using
   the type's &lt;quote&gt;equals&lt;/quote&gt; and &lt;quote&gt;less-than&lt;/quote&gt; operators, if there
   is a default b-tree operator class for the type.  For non-scalar types
   this behavior is likely to be unsuitable, so it can be overridden by
   specifying a custom analysis function.  The analysis function must be
   declared to take a single argument of type &lt;type&gt;internal&lt;/type&gt;, and return
   a &lt;type&gt;boolean&lt;/type&gt; result.  The detailed API for analysis functions appears
   in &lt;filename&gt;src/include/commands/vacuum.h&lt;/filename&gt;.
</span>
オプションの<em class="replaceable"><code>analyze_function</code></em>は、このデータ型の列に対する、型固有の統計情報の収集を行います。
その型用のデフォルトのB-tree演算子クラスがあれば、<code class="command">ANALYZE</code>はデフォルトでは型の<span class="quote">「<span class="quote">等価</span>」</span>演算子と<span class="quote">「<span class="quote">小なり</span>」</span>演算子を使用して統計情報を集めようと試みます。
非スカラ型には、この振舞いはあまり適していません。
そのため、独自の解析関数を指定することで、この振舞いを上書きすることができます。
この解析関数は、<code class="type">internal</code>型の引数を1つ取り、戻り値として<code class="type">boolean</code>を返すように宣言する必要があります。
解析関数用のAPIの詳細は、<code class="filename">src/include/commands/vacuum.h</code>にあります。
  </p><p>
<span class="original">
   The optional &lt;replaceable class="parameter"&gt;subscript_function&lt;/replaceable&gt;
   allows the data type to be subscripted in SQL commands.  Specifying this
   function does not cause the type to be considered a &lt;quote&gt;true&lt;/quote&gt;
   array type; for example, it will not be a candidate for the result type
   of &lt;literal&gt;ARRAY[]&lt;/literal&gt; constructs.  But if subscripting a value
   of the type is a natural notation for extracting data from it, then
   a &lt;replaceable class="parameter"&gt;subscript_function&lt;/replaceable&gt; can
   be written to define what that means.  The subscript function must be
   declared to take a single argument of type &lt;type&gt;internal&lt;/type&gt;, and
   return an &lt;type&gt;internal&lt;/type&gt; result, which is a pointer to a struct
   of methods (functions) that implement subscripting.
   The detailed API for subscript functions appears
   in &lt;filename&gt;src/include/nodes/subscripting.h&lt;/filename&gt;.
   It may also be useful to read the array implementation
   in &lt;filename&gt;src/backend/utils/adt/arraysubs.c&lt;/filename&gt;,
   or the simpler code
   in &lt;filename&gt;contrib/hstore/hstore_subs.c&lt;/filename&gt;.
   Additional information appears in
   &lt;xref linkend="sql-createtype-array"/&gt; below.
</span>
オプションの<em class="replaceable"><code>subscript_function</code></em>は、SQLコマンド内で指定されたデータ型に添字をつけることを許可します。
この関数を指定することで、指定されたデータ型が<span class="quote">「<span class="quote">真の</span>」</span>配列型とみなされる訳ではありません。たとえば、<code class="literal">ARRAY[]</code>生成の結果型の候補にはなりません。
ですが、その型の値に添字をつけることが、そこからデータを取り出す自然な表記法であるなら、その意味を定義するのに<em class="replaceable"><code>subscript_function</code></em>を書くことができます。
添字関数は<code class="type">internal</code>型の引数を1つ取り、添字を実装しているメソッド(関数)の構造体へのポインタである<code class="type">internal</code>の結果を返すよう宣言しなければなりません。
添字関数の詳細なAPIは<code class="filename">src/include/nodes/subscripting.h</code>にあります。
<code class="filename">src/backend/utils/adt/arraysubs.c</code>にある配列の実装や<code class="filename">contrib/hstore/hstore_subs.c</code>にあるより単純なコードを読むのも有用かもしれません。
追加の情報は以下の<a class="xref" href="sql-createtype.html#SQL-CREATETYPE-ARRAY" title="配列型">Array Types</a>にあります。
  </p><p>
<span class="original">
   While the details of the new type's internal representation are only
   known to the I/O functions and other functions you create to work with
   the type, there are several properties of the internal representation
   that must be declared to &lt;productname&gt;PostgreSQL&lt;/productname&gt;.
   Foremost of these is
   &lt;replaceable class="parameter"&gt;internallength&lt;/replaceable&gt;.
   Base data types can be fixed-length, in which case
   &lt;replaceable class="parameter"&gt;internallength&lt;/replaceable&gt; is a
   positive integer, or variable-length, indicated by setting
   &lt;replaceable class="parameter"&gt;internallength&lt;/replaceable&gt;
   to &lt;literal&gt;VARIABLE&lt;/literal&gt;.  (Internally, this is represented
   by setting &lt;literal&gt;typlen&lt;/literal&gt; to -1.)  The internal representation of all
   variable-length types must start with a 4-byte integer giving the total
   length of this value of the type.  (Note that the length field is often
   encoded, as described in &lt;xref linkend="storage-toast"/&gt;; it's unwise
   to access it directly.)
</span>
新しい型の内部表現の詳細を理解しなければならないのは、これらのI/O関数とその型に関連して動作するユーザ定義の関数のみですが、内部表現には、<span class="productname">PostgreSQL</span>に対し宣言しなければならない複数の属性値があります。
属性の中で最も重要なものは<em class="replaceable"><code>internallength</code></em>です。
基本データ型は、<em class="replaceable"><code>internallength</code></em>に正の整数を指定して固定長として作成するだけでなく、<em class="replaceable"><code>internallength</code></em>に<code class="literal">VARIABLE</code>と設定し可変長として作成することもできます
（内部的には、これは<code class="literal">typlen</code>を-1に設定することで表現されます）。
全ての可変長型の内部表現は、型の値の全長を示す4バイトの整数値から始まらなければなりません。
（長さフィールドは多くの場合<a class="xref" href="storage-toast.html" title="73.2. TOAST">73.2</a>に記述されているようにエンコードされており、それに直接アクセスすることは賢明ではないことに注意してください。）
  </p><p>
<span class="original">
   The optional flag &lt;literal&gt;PASSEDBYVALUE&lt;/literal&gt; indicates that
   values of this data type are passed by value, rather than by
   reference.  Types passed by value must be fixed-length, and their internal
   representation cannot be larger than the size of the &lt;type&gt;Datum&lt;/type&gt; type
   (4 bytes on some machines, 8 bytes on others).
</span>
オプションの<code class="literal">PASSEDBYVALUE</code>フラグは、このデータ型の値が参照ではなく値によって渡されることを示します。
値によって渡される型は固定長でなければならず、その内部表現は<code class="type">Datum</code>型のサイズ（4バイトのマシンもあれば8バイトのマシンもあります）を超えてはいけません。
  </p><p>
<span class="original">
   The &lt;replaceable class="parameter"&gt;alignment&lt;/replaceable&gt; parameter
   specifies the storage alignment required for the data type.  The
   allowed values equate to alignment on 1, 2, 4, or 8 byte boundaries.
   Note that variable-length types must have an alignment of at least
   4, since they necessarily contain an &lt;type&gt;int4&lt;/type&gt; as their first component.
</span>
<em class="replaceable"><code>alignment</code></em>パラメータは、そのデータ型の格納の際に必要な整列を指定します。
設定可能な値は、1、2、4、8バイト境界での整列です。
可変長の型は最低でも4の整列を持たなければならないことに注意してください。
最初の要素として<code class="type">int4</code>を持たなければならないからです。
  </p><p>
<span class="original">
   The &lt;replaceable class="parameter"&gt;storage&lt;/replaceable&gt; parameter
   allows selection of storage strategies for variable-length data
   types.  (Only &lt;literal&gt;plain&lt;/literal&gt; is allowed for fixed-length
   types.)  &lt;literal&gt;plain&lt;/literal&gt; specifies that data of the type
   will always be stored in-line and not compressed.
   &lt;literal&gt;extended&lt;/literal&gt; specifies that the system will first
   try to compress a long data value, and will move the value out of
   the main table row if it's still too long.
   &lt;literal&gt;external&lt;/literal&gt; allows the value to be moved out of the
   main table, but the system will not try to compress it.
   &lt;literal&gt;main&lt;/literal&gt; allows compression, but discourages moving
   the value out of the main table.  (Data items with this storage
   strategy might still be moved out of the main table if there is no
   other way to make a row fit, but they will be kept in the main
   table preferentially over &lt;literal&gt;extended&lt;/literal&gt; and
   &lt;literal&gt;external&lt;/literal&gt; items.)
</span>
<em class="replaceable"><code>storage</code></em>パラメータを使用することで、可変長データ型を格納する際の戦略を選択することができます
（固定長の型には<code class="literal">plain</code>のみが使用できます）。
<code class="literal">plain</code>を指定すると、その型のデータは常にインラインで格納され、圧縮されません。
<code class="literal">extended</code>を指定すると、システムはまず長いデータ値を圧縮しようとし、それでもまだ長過ぎる場合は値をメインテーブルの行から削除して移動します。
<code class="literal">external</code>はメインテーブルから値を削除して移動することを許しますが、システムはデータを圧縮しようとしません。
<code class="literal">main</code>はデータの圧縮を許しますが、できるだけ値をメインテーブルから削除しないようにします
（行を収めるために他に方法がない場合にはメインテーブルから削除されてしまう可能性がありますが、<code class="literal">extended</code>や<code class="literal">external</code>が指定されたアイテムよりも優先してメインテーブルに残されます）。
  </p><p>
<span class="original">
   All &lt;replaceable class="parameter"&gt;storage&lt;/replaceable&gt; values other
   than &lt;literal&gt;plain&lt;/literal&gt; imply that the functions of the data type
   can handle values that have been &lt;firstterm&gt;toasted&lt;/firstterm&gt;, as described
   in &lt;xref linkend="storage-toast"/&gt; and &lt;xref linkend="xtypes-toast"/&gt;.
   The specific other value given merely determines the default TOAST
   storage strategy for columns of a toastable data type; users can pick
   other strategies for individual columns using &lt;literal&gt;ALTER TABLE
   SET STORAGE&lt;/literal&gt;.
</span>
<code class="literal">plain</code>を除くすべての<em class="replaceable"><code>storage</code></em>の値は、そのデータ型の関数が、<a class="xref" href="storage-toast.html" title="73.2. TOAST">73.2</a>および<a class="xref" href="xtypes.html#XTYPES-TOAST" title="38.13.1. TOASTの考慮">38.13.1</a>に記述されているように<em class="firstterm">toast</em>された値を処理できることを暗示します。
その他の特定の値を指定するのは、TOAST可能なデータ型の列について、単にデフォルトのTOAST戦略を決めるだけです。
ユーザは個々の列について<code class="literal">ALTER TABLE SET STORAGE</code>を使って他の戦略を選択できます。
  </p><p>
<span class="original">
   The &lt;replaceable class="parameter"&gt;like_type&lt;/replaceable&gt; parameter
   provides an alternative method for specifying the basic representation
   properties of a data type: copy them from some existing type. The values of
   &lt;replaceable class="parameter"&gt;internallength&lt;/replaceable&gt;,
   &lt;replaceable class="parameter"&gt;passedbyvalue&lt;/replaceable&gt;,
   &lt;replaceable class="parameter"&gt;alignment&lt;/replaceable&gt;, and
   &lt;replaceable class="parameter"&gt;storage&lt;/replaceable&gt; are copied from the
   named type.  (It is possible, though usually undesirable, to override
   some of these values by specifying them along with the &lt;literal&gt;LIKE&lt;/literal&gt;
   clause.)  Specifying representation this way is especially useful when
   the low-level implementation of the new type &lt;quote&gt;piggybacks&lt;/quote&gt; on an
   existing type in some fashion.
</span>
<em class="replaceable"><code>like_type</code></em>パラメータは、何らかの既存のデータ型から複製するという、データ型の基本表現プロパティを指定する、別の方法を提供します。
<em class="replaceable"><code>internallength</code></em>、<em class="replaceable"><code>passedbyvalue</code></em>、<em class="replaceable"><code>alignment</code></em>、<em class="replaceable"><code>storage</code></em>の値が指定された型から複製されます。
（通常は望ましくありませんが、<code class="literal">LIKE</code>句と一緒にこれらの値を指定することで、値を上書きすることも可能です。）
新しい型の低レベル実装にある流儀に従った既存の型を<span class="quote">「<span class="quote">移す</span>」</span>時に、この方法で表現を指定することが特に有用です。
  </p><p>
<span class="original">
   The &lt;replaceable class="parameter"&gt;category&lt;/replaceable&gt; and
   &lt;replaceable class="parameter"&gt;preferred&lt;/replaceable&gt; parameters can be
   used to help control which implicit cast will be applied in ambiguous
   situations.  Each data type belongs to a category named by a single ASCII
   character, and each type is either &lt;quote&gt;preferred&lt;/quote&gt; or not within its
   category.  The parser will prefer casting to preferred types (but only from
   other types within the same category) when this rule is helpful in
   resolving overloaded functions or operators.  For more details see &lt;xref
   linkend="typeconv"/&gt;.  For types that have no implicit casts to or from any
   other types, it is sufficient to leave these settings at the defaults.
   However, for a group of related types that have implicit casts, it is often
   helpful to mark them all as belonging to a category and select one or two
   of the &lt;quote&gt;most general&lt;/quote&gt; types as being preferred within the category.
   The &lt;replaceable class="parameter"&gt;category&lt;/replaceable&gt; parameter is
   especially useful when adding a user-defined type to an existing built-in
   category, such as the numeric or string types.  However, it is also
   possible to create new entirely-user-defined type categories.  Select any
   ASCII character other than an upper-case letter to name such a category.
</span>
<em class="replaceable"><code>category</code></em>と<em class="replaceable"><code>preferred</code></em>パラメータは、あいまいな状況でどの暗黙的なキャストが適用されるかについての制御を補助するために使用することができます。
各データ型は単一のASCII文字で命名されるカテゴリに属しており、各型はそのカテゴリ内で<span class="quote">「<span class="quote">優先される（preferred）</span>」</span>か否かです。
オーバーロードされた関数または演算子の解決に、この規則が有用な場合には、パーサは優先される型へのキャストを優先します（ただし、同一のカテゴリ内の他の型からだけです）。
より詳細は<a class="xref" href="typeconv.html" title="第10章 型変換">第10章</a>を参照してください。
他の型への、または、ほかの型からの暗黙的なキャストを持たない型では、これらの設定をデフォルトのままにしておくことで十分です。
しかし、暗黙的なキャストを持つ関連する型のグループでは、それらすべてを1つのカテゴリに属すものとし、<span class="quote">「<span class="quote">最も汎用的な</span>」</span>型の1つまたは2つをカテゴリ内で優先されるものとして選択することが有用となる場合が多くあります。
ユーザ定義型を、数値型や文字列型などの既存の組み込みカテゴリに追加する場合に、<em class="replaceable"><code>category</code></em>パラメータは特に有用です。
しかし、完全にユーザ定義の新しい型カテゴリを作成することもできます。
そのようなカテゴリの命名には大文字以外の任意のASCII文字を選択してください。
  </p><p>
<span class="original">
   A default value can be specified, in case a user wants columns of the
   data type to default to something other than the null value.
   Specify the default with the &lt;literal&gt;DEFAULT&lt;/literal&gt; key word.
   (Such a default can be overridden by an explicit &lt;literal&gt;DEFAULT&lt;/literal&gt;
   clause attached to a particular column.)
</span>
ユーザがそのデータ型の列のデフォルトをNULL以外にしたい場合は、デフォルト値を指定することができます。
デフォルト値は<code class="literal">DEFAULT</code>キーワードで指定してください。
（この方法で指定されたデフォルト値を、特定の列に付与された、明示的な<code class="literal">DEFAULT</code>句によって上書きすることができます。）
  </p><p>
<span class="original">
   To indicate that a type is a fixed-length array type,
   specify the type of the array
   elements using the &lt;literal&gt;ELEMENT&lt;/literal&gt; key word.  For example, to
   define an array of 4-byte integers (&lt;type&gt;int4&lt;/type&gt;), specify
   &lt;literal&gt;ELEMENT = int4&lt;/literal&gt;.  For more details,
   see &lt;xref linkend="sql-createtype-array"/&gt; below.
</span>
データ型が固定長の配列型であることを示すには、<code class="literal">ELEMENT</code>キーワードを使用して配列要素の型を指定してください。
例えば、4バイト整数（<code class="type">int4</code>）の配列を定義するには、<code class="literal">ELEMENT = int4</code>と指定してください。
より詳細は以下の<a class="xref" href="sql-createtype.html#SQL-CREATETYPE-ARRAY" title="配列型">Array Types</a>を参照してください。
  </p><p>
<span class="original">
   To indicate the delimiter to be used between values in the external
   representation of arrays of this type, &lt;replaceable
   class="parameter"&gt;delimiter&lt;/replaceable&gt; can be
   set to a specific character.  The default delimiter is the comma
   (&lt;literal&gt;,&lt;/literal&gt;).  Note that the delimiter is associated
   with the array element type, not the array type itself.
</span>
この型による配列の外部形式における値間の区切り文字を示すために、<em class="replaceable"><code>delimiter</code></em>で特定の文字を設定することができます。
デフォルトの区切り文字はカンマ（'<code class="literal">,</code>'）です。
この区切り文字は、配列要素の型に関係するものであり、配列型自体に関係するものでないことに注意してください。
  </p><p>
<span class="original">
   If the optional Boolean
   parameter &lt;replaceable class="parameter"&gt;collatable&lt;/replaceable&gt;
   is true, column definitions and expressions of the type may carry
   collation information through use of
   the &lt;literal&gt;COLLATE&lt;/literal&gt; clause.  It is up to the
   implementations of the functions operating on the type to actually
   make use of the collation information; this does not happen
   automatically merely by marking the type collatable.
</span>
論理型の<em class="replaceable"><code>collatable</code></em>パラメータ(省略可能)が真の場合、<code class="literal">COLLATE</code>句を使用することによって、型の列定義と式は照合順序情報を持つことができます。
照合順序情報を実際に使用するかどうかは、型に対する操作を行う関数実装に任されています。
照合順序を設定可能な型を作成することにより、これが自動的に行われることはありません。
  </p></div><div class="refsect2" id="SQL-CREATETYPE-ARRAY"><h3>配列型</h3><span class="original">
   &lt;title&gt;Array Types&lt;/title&gt;
</span><p>
<span class="original">
    Whenever a user-defined type is created,
    &lt;productname&gt;PostgreSQL&lt;/productname&gt; automatically creates an
    associated array type, whose name consists of the element type's
    name prepended with an underscore, and truncated if necessary to keep
    it less than &lt;symbol&gt;NAMEDATALEN&lt;/symbol&gt; bytes long.  (If the name
    so generated collides with an existing type name, the process is
    repeated until a non-colliding name is found.)
    This implicitly-created array type is variable length and uses the
    built-in input and output functions &lt;literal&gt;array_in&lt;/literal&gt; and
    &lt;literal&gt;array_out&lt;/literal&gt;.  Furthermore, this type is what the system
    uses for constructs such as &lt;literal&gt;ARRAY[]&lt;/literal&gt; over the
    user-defined type.  The array type tracks any changes in its
    element type's owner or schema, and is dropped if the element type is.
</span>
ユーザ定義型が作成されると、<span class="productname">PostgreSQL</span>は、自動的に関連する配列型を作成します。
その要素型の名前の前にアンダースコアを付け、必要に応じて<code class="symbol">NAMEDATALEN</code>長より短くなるように切り詰められた名前になります。
（こうして付けられた名前が既存の型名と競合する場合、競合する名称がなくなるまでこの処理が繰り返されます。）
この暗黙的に作成される配列型は可変長で、組み込み入出力関数<code class="literal">array_in</code>と<code class="literal">array_out</code>を使用します。
さらに、この型は、ユーザ定義型に対してシステムが<code class="literal">ARRAY[]</code>のように構成時に使うものです。
配列型はその要素となる型の所有者とスキーマのなんらかの変更に追従し、また、要素となる型が削除された場合に削除されます。
   </p><p>
<span class="original">
    You might reasonably ask why there is an &lt;option&gt;ELEMENT&lt;/option&gt;
    option, if the system makes the correct array type automatically.
    The main case where it's useful to use &lt;option&gt;ELEMENT&lt;/option&gt; is when you are
    making a fixed-length type that happens to be internally an array of a number of
    identical things, and you want to allow these things to be accessed
    directly by subscripting, in addition to whatever operations you plan
    to provide for the type as a whole.  For example, type &lt;type&gt;point&lt;/type&gt;
    is represented as just two floating-point numbers, which can be accessed
    using &lt;literal&gt;point[0]&lt;/literal&gt; and &lt;literal&gt;point[1]&lt;/literal&gt;.
    Note that
    this facility only works for fixed-length types whose internal form
    is exactly a sequence of identical fixed-length fields.
    For historical reasons (i.e., this is clearly wrong but it's far too
    late to change it), subscripting of fixed-length array types starts from
    zero, rather than from one as for variable-length arrays.
</span>
「システムが自動的に配列型を正しく作成するのであれば、<code class="option">ELEMENT</code>オプションはどうして存在するのだろう」と疑問に思うのも道理です。
<code class="option">ELEMENT</code>が意味を持つ、主な場合は次のような条件を満たす固定長の型を作成する時です。
その条件とは、内部的に複数の同一の要素からなる配列となっていること、その配列に対して添字を指定して直接アクセスできること、加えて、今後作成する型全体に対する操作がどのようなものであっても、それらから直接アクセスできることです。
例えば、<code class="type">point</code>型は、2つの浮動小数点だけから構成され、それらは<code class="literal">point[0]</code>および<code class="literal">point[1]</code>を用いてアクセスすることができます。
この機能は、その内部形式が同一の固定長フィールドの正確な並びである、固定長の型でのみ動作することに注意してください。
歴史的な理由（明らかに間違いなのですが、変更するには遅すぎたため）により、固定長配列型への要素番号指定は0から始まり、可変長配列の場合は1から始まります。
   </p><p>
<span class="original">
    Specifying the &lt;option&gt;SUBSCRIPT&lt;/option&gt; option allows a data type to
    be subscripted, even though the system does not otherwise regard it as
    an array type.  The behavior just described for fixed-length arrays is
    actually implemented by the &lt;option&gt;SUBSCRIPT&lt;/option&gt; handler
    function &lt;function&gt;raw_array_subscript_handler&lt;/function&gt;, which is
    used automatically if you specify &lt;option&gt;ELEMENT&lt;/option&gt; for a
    fixed-length type without also writing &lt;option&gt;SUBSCRIPT&lt;/option&gt;.
</span>
<code class="option">SUBSCRIPT</code>オプションを指定すると、たとえシステムが配列型とみなさない場合でも、データ型に添字をつけることができるようになります。
固定長の配列について述べた振舞いは、実は<code class="option">SUBSCRIPT</code>ハンドラ関数<code class="function">raw_array_subscript_handler</code>により実装されており、固定長型に対して<code class="option">SUBSCRIPT</code>を書かずに<code class="option">ELEMENT</code>を指定した場合には自動的に、この関数が使われます。
   </p><p>
<span class="original">
    When specifying a custom &lt;option&gt;SUBSCRIPT&lt;/option&gt; function, it is
    not necessary to specify &lt;option&gt;ELEMENT&lt;/option&gt; unless
    the &lt;option&gt;SUBSCRIPT&lt;/option&gt; handler function needs to
    consult &lt;structfield&gt;typelem&lt;/structfield&gt; to find out what to return.
    Be aware that specifying &lt;option&gt;ELEMENT&lt;/option&gt; causes the system to
    assume that the new type contains, or is somehow physically dependent on,
    the element type; thus for example changing properties of the element
    type won't be allowed if there are any columns of the dependent type.
</span>
カスタムの<code class="option">SUBSCRIPT</code>関数を指定した場合には、<code class="option">SUBSCRIPT</code>ハンドラ関数が何を返すべきか見つけるために<code class="structfield">typelem</code>を調べる必要がない限り、<code class="option">ELEMENT</code>を指定することは必要ではありません。
<code class="option">ELEMENT</code>を指定すると、新しい型が要素型を含んでいる、すなわち要素型に何らかの形で物理的に依存しているとシステムが仮定することに注意してください。このため、例えば、依存する型の列があれば要素型の属性を変更することはできません。
   </p></div></div><div class="refsect1" id="id-1.9.3.94.6"><h2>パラメータ</h2><span class="original">
  &lt;title&gt;Parameters&lt;/title&gt;
</span><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>name</code></em></span></dt><dd><p>
<span class="original">
      The name (optionally schema-qualified) of a type to be created.
</span>
作成するデータ型の名前です（スキーマ修飾名も可）。
     </p></dd><dt><span class="term"><em class="replaceable"><code>attribute_name</code></em></span></dt><dd><p>
<span class="original">
      The name of an attribute (column) for the composite type.
</span>
複合型用の属性（列）名です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>data_type</code></em></span></dt><dd><p>
<span class="original">
      The name of an existing data type to become a column of the
      composite type.
</span>
複合型の列となる、既存のデータ型の名前です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>collation</code></em></span></dt><dd><p>
<span class="original">
      The name of an existing collation to be associated with a column of
      a composite type, or with a range type.
</span>
複合型の列または範囲型に関連付けされる、既存の照合順序の名前です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>label</code></em></span></dt><dd><p>
<span class="original">
      A string literal representing the textual label associated with
      one value of an enum type.
</span>
列挙型の1つの値に関連付けられるテキスト形式のラベルを表す、文字列リテラルです。
     </p></dd><dt><span class="term"><em class="replaceable"><code>subtype</code></em></span></dt><dd><p>
<span class="original">
      The name of the element type that the range type will represent ranges
      of.
</span>
範囲型がその範囲の対象として表現する、要素型の名前です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>subtype_operator_class</code></em></span></dt><dd><p>
<span class="original">
      The name of a b-tree operator class for the subtype.
</span>
派生元型のb-tree演算子クラスの名前です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>canonical_function</code></em></span></dt><dd><p>
<span class="original">
      The name of the canonicalization function for the range type.
</span>
範囲型の正規化関数の名前です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>subtype_diff_function</code></em></span></dt><dd><p>
<span class="original">
      The name of a difference function for the subtype.
</span>
派生元型の差異をとる関数の名前です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>multirange_type_name</code></em></span></dt><dd><p>
<span class="original">
      The name of the corresponding multirange type.
</span>
対応する多重範囲型の名前です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>input_function</code></em></span></dt><dd><p>
<span class="original">
      The name of a function that converts data from the type's
      external textual form to its internal form.
</span>
指定された型のテキストによる外部形式のデータを内部形式に変換する関数の名前です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>output_function</code></em></span></dt><dd><p>
<span class="original">
      The name of a function that converts data from the type's
      internal form to its external textual form.
</span>
指定された型の内部形式のデータをテキストによる外部形式に変換する関数の名前です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>receive_function</code></em></span></dt><dd><p>
<span class="original">
      The name of a function that converts data from the type's
      external binary form to its internal form.
</span>
指定された型のバイナリによる外部形式のデータを内部形式に変換する関数の名前です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>send_function</code></em></span></dt><dd><p>
<span class="original">
      The name of a function that converts data from the type's
      internal form to its external binary form.
</span>
指定された型の内部形式のデータをバイナリによる外部形式に変換する関数の名前です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>type_modifier_input_function</code></em></span></dt><dd><p>
<span class="original">
      The name of a function that converts an array of modifier(s) for the type
      into internal form.
</span>
型に関する修飾子の配列を内部形式に変換する関数の名前です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>type_modifier_output_function</code></em></span></dt><dd><p>
<span class="original">
      The name of a function that converts the internal form of the type's
      modifier(s) to external textual form.
</span>
内部形式の型修飾子をテキストの外部形式に変換する関数の名前です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>analyze_function</code></em></span></dt><dd><p>
<span class="original">
      The name of a function that performs statistical analysis for the
      data type.
</span>
指定したデータ型の統計情報解析を行う関数の名前です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>subscript_function</code></em></span></dt><dd><p>
<span class="original">
      The name of a function that defines what subscripting a value of the
      data type does.
</span>
指定したデータ型の値に添字をつけることを定義する関数の名前です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>internallength</code></em></span></dt><dd><p>
<span class="original">
      A numeric constant that specifies the length in bytes of the new
      type's internal representation.  The default assumption is that
      it is variable-length.
</span>
新しいデータ型の内部表現のバイト長を表す数値定数です。
デフォルトでは、可変長であるとみなされます。
     </p></dd><dt><span class="term"><em class="replaceable"><code>alignment</code></em></span></dt><dd><p>
<span class="original">
      The storage alignment requirement of the data type.  If specified,
      it must be &lt;literal&gt;char&lt;/literal&gt;, &lt;literal&gt;int2&lt;/literal&gt;,
      &lt;literal&gt;int4&lt;/literal&gt;, or &lt;literal&gt;double&lt;/literal&gt;; the
      default is &lt;literal&gt;int4&lt;/literal&gt;.
</span>
データ型の格納整列条件です。
このオプションを指定する場合は、<code class="literal">char</code>、<code class="literal">int2</code>、<code class="literal">int4</code>、<code class="literal">double</code>のいずれかでなければなりません。
デフォルトは<code class="literal">int4</code>です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>storage</code></em></span></dt><dd><p>
<span class="original">
      The storage strategy for the data type.  If specified, must be
      &lt;literal&gt;plain&lt;/literal&gt;, &lt;literal&gt;external&lt;/literal&gt;,
      &lt;literal&gt;extended&lt;/literal&gt;, or &lt;literal&gt;main&lt;/literal&gt;; the
      default is &lt;literal&gt;plain&lt;/literal&gt;.
</span>
データ型の格納戦略です。
このオプションを指定する場合は、<code class="literal">plain</code>、<code class="literal">external</code>、<code class="literal">extended</code>、<code class="literal">main</code>のいずれかでなければなりません。
デフォルトは<code class="literal">plain</code>です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>like_type</code></em></span></dt><dd><p>
<span class="original">
      The name of an existing data type that the new type will have the
      same representation as.  The values of
      &lt;replaceable class="parameter"&gt;internallength&lt;/replaceable&gt;,
      &lt;replaceable class="parameter"&gt;passedbyvalue&lt;/replaceable&gt;,
      &lt;replaceable class="parameter"&gt;alignment&lt;/replaceable&gt;, and
      &lt;replaceable class="parameter"&gt;storage&lt;/replaceable&gt;
      are copied from that type, unless overridden by explicit
      specification elsewhere in this &lt;command&gt;CREATE TYPE&lt;/command&gt; command.
</span>
新しい型に同じ表現を持たせる既存のデータ型の名前です。
<em class="replaceable"><code>internallength</code></em>、<em class="replaceable"><code>passedbyvalue</code></em>、<em class="replaceable"><code>alignment</code></em>、<em class="replaceable"><code>storage</code></em>の値が、この<code class="command">CREATE TYPE</code>コマンドのどこかで明示的な指定により上書きされない限り、型から複製されます。
     </p></dd><dt><span class="term"><em class="replaceable"><code>category</code></em></span></dt><dd><p>
<span class="original">
      The category code (a single ASCII character) for this type.
      The default is &lt;literal&gt;'U'&lt;/literal&gt; for &lt;quote&gt;user-defined type&lt;/quote&gt;.
      Other standard category codes can be found in
      &lt;xref linkend="catalog-typcategory-table"/&gt;.  You may also choose
      other ASCII characters in order to create custom categories.
</span>
この型用のカテゴリコード（単一のASCII文字）です。
デフォルトは<span class="quote">「<span class="quote">ユーザ定義型</span>」</span>を表す<code class="literal">'U'</code>です。
他の標準カテゴリコードを<a class="xref" href="catalog-pg-type.html#CATALOG-TYPCATEGORY-TABLE" title="表53.65 typcategoryのコード">表 53.65</a>に示します。
独自のカテゴリを作成するために他のASCII文字を選択することもできます。
     </p></dd><dt><span class="term"><em class="replaceable"><code>preferred</code></em></span></dt><dd><p>
<span class="original">
      True if this type is a preferred type within its type category,
      else false.  The default is false.  Be very careful about creating
      a new preferred type within an existing type category, as this
      could cause surprising changes in behavior.
</span>
この型がカテゴリ内で優先される型である場合に真、さもなくば偽です。
デフォルトは偽です。
動作に予想外の変化を引き起こしますので既存の型カテゴリに新しく優先される型を作成することには十分注意してください。
     </p></dd><dt><span class="term"><em class="replaceable"><code>default</code></em></span></dt><dd><p>
<span class="original">
      The default value for the data type.  If this is omitted, the
      default is null.
</span>
そのデータ型のデフォルト値です。
省略された場合、デフォルトはNULLです。
     </p></dd><dt><span class="term"><em class="replaceable"><code>element</code></em></span></dt><dd><p>
<span class="original">
      The type being created is an array; this specifies the type of
      the array elements.
</span>
配列型を作成する場合、その配列の要素の型を指定します。
     </p></dd><dt><span class="term"><em class="replaceable"><code>delimiter</code></em></span></dt><dd><p>
<span class="original">
      The delimiter character to be used between values in arrays made
      of this type.
</span>
このデータ型による配列で、値間の区切り文字として使われる文字です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>collatable</code></em></span></dt><dd><p>
<span class="original">
      True if this type's operations can use collation information.
      The default is false.
</span>
この型を操作する時に照合順序情報を使用することができる場合に真を取ります。
デフォルトは偽です。
     </p></dd></dl></div></div><div class="refsect1" id="SQL-CREATETYPE-NOTES"><h2>注釈</h2><span class="original">
  &lt;title&gt;Notes&lt;/title&gt;
</span><p>
<span class="original">
   Because there are no restrictions on use of a data type once it's been
   created, creating a base type or range type is tantamount to granting
   public execute permission on the functions mentioned in the type definition.
   This is usually
   not an issue for the sorts of functions that are useful in a type
   definition.  But you might want to think twice before designing a type
   in a way that would require &lt;quote&gt;secret&lt;/quote&gt; information to be used
   while converting it to or from external form.
</span>
一度作成したデータ型の使用には制限はありませんので、基本型または範囲型の作成は型定義で言及した関数の実行権をPUBLICに対して付与することと同じです。
この種の型定義において有用な関数では、これは通常問題になりません。
しかし、外部形式から、または、外部形式への変換を行う時に、その関数が<span class="quote">「<span class="quote">秘密の</span>」</span>情報を必要とする場合、型を設計する前に熟考してください。
  </p><p>
<span class="original">
   Before &lt;productname&gt;PostgreSQL&lt;/productname&gt; version 8.3, the name of
   a generated array type was always exactly the element type's name with one
   underscore character (&lt;literal&gt;_&lt;/literal&gt;) prepended.  (Type names were
   therefore restricted in length to one fewer character than other names.)
   While this is still usually the case, the array type name may vary from
   this in case of maximum-length names or collisions with user type names
   that begin with underscore.  Writing code that depends on this convention
   is therefore deprecated.  Instead, use
   &lt;structname&gt;pg_type&lt;/structname&gt;.&lt;structfield&gt;typarray&lt;/structfield&gt; to locate the array type
   associated with a given type.
</span>
<span class="productname">PostgreSQL</span>バージョン8.3より前のバージョンでは、生成される配列型の名前は常に要素型の名前の前に１つのアンダースコア文字（<code class="literal">_</code>）を付けたものになりました。
（このため型の名前は他の名前よりも1文字短く制限されていました。）
通常はこのように名付けられることは変わりありませんが、最大長の名前の場合やアンダースコアから始まるユーザ定義の型と競合する場合、配列型の名前はこの変換とは変わることがあります。
このため、この規則に依存したコードを書くことは避けてください。
代わりに、<code class="structname">pg_type</code>.<code class="structfield">typarray</code>を使用して、指定した型に関連した配列型を特定してください。
  </p><p>
<span class="original">
   It may be advisable to avoid using type and table names that begin with
   underscore.  While the server will change generated array type names to
   avoid collisions with user-given names, there is still risk of confusion,
   particularly with old client software that may assume that type names
   beginning with underscores always represent arrays.
</span>
アンダースコアから始まる型やテーブル名の使用を避けることが賢明です。
サーバは生成された配列型名称をユーザ指定の名前と競合しないように変更しますが、混乱する危険があります。
特に古いクライアントソフトウェアを使用する場合、名前がアンダースコアから始まる型を常に配列を表すものと想定しているかもしれません。
  </p><p>
<span class="original">
   Before &lt;productname&gt;PostgreSQL&lt;/productname&gt; version 8.2, the shell-type
   creation syntax
   &lt;literal&gt;CREATE TYPE &lt;replaceable&gt;name&lt;/replaceable&gt;&lt;/literal&gt; did not exist.
   The way to create a new base type was to create its input function first.
   In this approach, &lt;productname&gt;PostgreSQL&lt;/productname&gt; will first see
   the name of the new data type as the return type of the input function.
   The shell type is implicitly created in this situation, and then it
   can be referenced in the definitions of the remaining I/O functions.
   This approach still works, but is deprecated and might be disallowed in
   some future release.  Also, to avoid accidentally cluttering
   the catalogs with shell types as a result of simple typos in function
   definitions, a shell type will only be made this way when the input
   function is written in C.
</span>
<span class="productname">PostgreSQL</span>バージョン8.2より前まででは、シェル型を作成する<code class="literal">CREATE TYPE <em class="replaceable"><code>name</code></em></code>構文は存在しません。
新規に基本型を作成する方法は、最初に入力関数を作成することでした。
この方法では、<span class="productname">PostgreSQL</span>は新しいデータ型の名称を、入力関数の戻り値型で初めて見ます。
このときに、シェル型が暗黙的に作成され、残りの入出力関数の定義で参照することができます。
この方法もまだ使用できますが、廃止予定であり、将来のリリースで禁止される可能性があります。
また、関数定義における単純なタイプミスの結果作成されるシェル型によって起こるカタログの混乱を防止するため、入力関数がCで作成された場合にのみこの方法によってシェル型が作成されます。
  </p></div><div class="refsect1" id="id-1.9.3.94.8"><h2>例</h2><span class="original">
  &lt;title&gt;Examples&lt;/title&gt;
</span><p>
<span class="original">
   This example creates a composite type and uses it in
   a function definition:
</span>
次の例では、複合型を作成し、それを関数定義で使用します。
</p><pre class="programlisting">
CREATE TYPE compfoo AS (f1 int, f2 text);

CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$
    SELECT fooid, fooname FROM foo
$$ LANGUAGE SQL;
</pre><p>
  </p><p>
<span class="original">
   This example creates an enumerated type and uses it in
   a table definition:
</span>
次の例では、列挙型を作成し、それをテーブル定義に使用します。
</p><pre class="programlisting">
CREATE TYPE bug_status AS ENUM ('new', 'open', 'closed');

CREATE TABLE bug (
    id serial,
    description text,
    status bug_status
);
</pre><p>
  </p><p>
<span class="original">
   This example creates a range type:
</span>
次の例では、範囲型を作成します。
</p><pre class="programlisting">
CREATE TYPE float8_range AS RANGE (subtype = float8, subtype_diff = float8mi);
</pre><p>
  </p><p>
<span class="original">
   This example creates the base data type &lt;type&gt;box&lt;/type&gt; and then uses the
   type in a table definition:
</span>
次の例では、基本データ型<code class="type">box</code>を作成し、その型をテーブル定義の中で使用しています。
</p><pre class="programlisting">
CREATE TYPE box;

CREATE FUNCTION my_box_in_function(cstring) RETURNS box AS ... ;
CREATE FUNCTION my_box_out_function(box) RETURNS cstring AS ... ;

CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function
);

CREATE TABLE myboxes (
    id integer,
    description box
);
</pre><p>
  </p><p>
<span class="original">
   If the internal structure of &lt;type&gt;box&lt;/type&gt; were an array of four
   &lt;type&gt;float4&lt;/type&gt; elements, we might instead use:
</span>
<code class="type">box</code>型の内部構造が<code class="type">float4</code>型が4つの配列の場合、このように書き換えることもできます。
</p><pre class="programlisting">
CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function,
    ELEMENT = float4
);
</pre><p>
<span class="original">
   which would allow a box value's component numbers to be accessed
   by subscripting.  Otherwise the type behaves the same as before.
</span>
このようにすると、box値の要素に要素番号でアクセスできます。
その他は、上の例と同様の動作をします。
  </p><p>
<span class="original">
   This example creates a large object type and uses it in
   a table definition:
</span>
次の例では、ラージオブジェクト型を作成し、テーブル定義にてそれを使用します。
</p><pre class="programlisting">
CREATE TYPE bigobj (
    INPUT = lo_filein, OUTPUT = lo_fileout,
    INTERNALLENGTH = VARIABLE
);
CREATE TABLE big_objs (
    id integer,
    obj bigobj
);
</pre><p>
  </p><p>
<span class="original">
   More examples, including suitable input and output functions, are
   in &lt;xref linkend="xtypes"/&gt;.
</span>
その他の例は、<a class="xref" href="xtypes.html" title="38.13. ユーザ定義の型">38.13</a>を参照してください。ここには、入力関数、出力関数などを使った例があります。
  </p></div><div class="refsect1" id="SQL-CREATETYPE-COMPATIBILITY"><h2>互換性</h2><span class="original">
  &lt;title&gt;Compatibility&lt;/title&gt;
</span><p>
<span class="original">
   The first form of the &lt;command&gt;CREATE TYPE&lt;/command&gt; command, which
   creates a composite type, conforms to the &lt;acronym&gt;SQL&lt;/acronym&gt; standard.
   The other forms are &lt;productname&gt;PostgreSQL&lt;/productname&gt;
   extensions.  The &lt;command&gt;CREATE TYPE&lt;/command&gt; statement in
   the &lt;acronym&gt;SQL&lt;/acronym&gt; standard also defines other forms that are not
   implemented in &lt;productname&gt;PostgreSQL&lt;/productname&gt;.
</span>
複合型を作成する、最初の<code class="command">CREATE TYPE</code>コマンドの構文は標準<acronym class="acronym">SQL</acronym>に従います。
他の構文は<span class="productname">PostgreSQL</span>の拡張です。
標準<acronym class="acronym">SQL</acronym>ではまた他の<code class="command">CREATE TYPE</code>構文を定義していますが、<span class="productname">PostgreSQL</span>では実装されていません。
  </p><p>
<span class="original">
   The ability to create a composite type with zero attributes is
   a &lt;productname&gt;PostgreSQL&lt;/productname&gt;-specific deviation from the
   standard (analogous to the same case in &lt;command&gt;CREATE TABLE&lt;/command&gt;).
</span>
ゼロ個の要素を持つ複合型を作成する機能は標準から派生した<span class="productname">PostgreSQL</span>固有のもの（<code class="command">CREATE TABLE</code>の場合と同様）です。
  </p></div><div class="refsect1" id="SQL-CREATETYPE-SEE-ALSO"><h2>関連項目</h2><span class="original">
  &lt;title&gt;See Also&lt;/title&gt;
</span><span class="simplelist"><a class="xref" href="sql-altertype.html" title="ALTER TYPE"><span class="refentrytitle">ALTER TYPE</span></a>, <a class="xref" href="sql-createdomain.html" title="CREATE DOMAIN"><span class="refentrytitle">CREATE DOMAIN</span></a>, <a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>, <a class="xref" href="sql-droptype.html" title="DROP TYPE"><span class="refentrytitle">DROP TYPE</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createtrigger.html" title="CREATE TRIGGER">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createuser.html" title="CREATE USER">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE TRIGGER </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 15.0文書">ホーム</a></td><td width="40%" align="right" valign="top"> CREATE USER</td></tr></table></div></body></html>