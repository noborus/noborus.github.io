<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>61.2. インデックスアクセスメソッド関数</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="index-api.html" title="61.1. インデックスの基本的API構造" /><link rel="next" href="index-scanning.html" title="61.3. インデックススキャン" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 11.5文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="indexam.html" title="第61章 インデックスアクセスメソッドのインタフェース定義">第61章 インデックスアクセスメソッドのインタフェース定義</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 11.5 &#10;                      index-functions.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="index-api.html" title="61.1. インデックスの基本的API構造">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="indexam.html" title="第61章 インデックスアクセスメソッドのインタフェース定義">上へ</a></td><td width="60%" align="center">61.2. インデックスアクセスメソッド関数</td><td width="20%" align="right"> <a accesskey="n" href="index-scanning.html" title="61.3. インデックススキャン">次へ</a></td></tr></table><hr /></div><div class="sect1" id="INDEX-FUNCTIONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">61.2. インデックスアクセスメソッド関数</h2></div></div></div><span class="original">
  &lt;title&gt;Index Access Method Functions&lt;/title&gt;
</span><p>
<span class="original">
   The index construction and maintenance functions that an index access
   method must provide in &lt;structname&gt;IndexAmRoutine&lt;/structname&gt; are:
</span>
インデックスアクセスメソッドが<code class="structname">IndexAmRoutine</code>で提供しなければならない、インデックス構築および保守関数を以下に示します。
  </p><p>
</p><pre class="programlisting">
IndexBuildResult *
ambuild (Relation heapRelation,
         Relation indexRelation,
         IndexInfo *indexInfo);
</pre><p>
<span class="original">
   Build a new index.  The index relation has been physically created,
   but is empty.  It must be filled in with whatever fixed data the
   access method requires, plus entries for all tuples already existing
   in the table.  Ordinarily the &lt;function&gt;ambuild&lt;/function&gt; function will call
   &lt;function&gt;IndexBuildHeapScan()&lt;/function&gt; to scan the table for existing tuples
   and compute the keys that need to be inserted into the index.
   The function must return a palloc'd struct containing statistics about
   the new index.
</span>
新しいインデックスを構築します。
空のインデックスリレーションが物理的に作成されます。
これは、アクセスメソッドが必要とする何らかの固定データと、テーブル内に既に存在するすべてのタプルに対応する項目が書き込まれなければなりません。
通常、<code class="function">ambuild</code>関数は<code class="function">IndexBuildHeapScan()</code>を呼び出し、既存のタプルをテーブルからスキャンし、インデックスに挿入しなければならないキーを計算します。
この関数は、新しいインデックスに関する統計情報を含むpallocされた構造体を返さなければなりません。
  </p><p>
</p><pre class="programlisting">
void
ambuildempty (Relation indexRelation);
</pre><p>
<span class="original">
   Build an empty index, and write it to the initialization fork (&lt;symbol&gt;INIT_FORKNUM&lt;/symbol&gt;)
   of the given relation.  This method is called only for unlogged indexes; the
   empty index written to the initialization fork will be copied over the main
   relation fork on each server restart.
</span>
空のインデックスを構築し、それを指定されたリレーションの初期フォーク(<code class="symbol">INIT_FORKNUM</code>)に書き出します。
このメソッドはログを取らないインデックスに対してのみ呼び出されます。
初期フォークに書き出された空のインデックスは、サーバの再起動の度に主リレーションフォークにコピーされます。
  </p><p>
</p><pre class="programlisting">
bool
aminsert (Relation indexRelation,
          Datum *values,
          bool *isnull,
          ItemPointer heap_tid,
          Relation heapRelation,
          IndexUniqueCheck checkUnique,
          IndexInfo *indexInfo);
</pre><p>
<span class="original">
   Insert a new tuple into an existing index.  The &lt;literal&gt;values&lt;/literal&gt; and
   &lt;literal&gt;isnull&lt;/literal&gt; arrays give the key values to be indexed, and
   &lt;literal&gt;heap_tid&lt;/literal&gt; is the TID to be indexed.
   If the access method supports unique indexes (its
   &lt;structfield&gt;amcanunique&lt;/structfield&gt; flag is true) then
   &lt;literal&gt;checkUnique&lt;/literal&gt; indicates the type of uniqueness check to
   perform.  This varies depending on whether the unique constraint is
   deferrable; see &lt;xref linkend="index-unique-checks"/&gt; for details.
   Normally the access method only needs the &lt;literal&gt;heapRelation&lt;/literal&gt;
   parameter when performing uniqueness checking (since then it will have to
   look into the heap to verify tuple liveness).
</span>
既存のインデックスに新しいタプルを挿入します。
<code class="literal">values</code>配列と<code class="literal">isnull</code>配列がインデックスされるキー値を提供するもので、<code class="literal">heap_tid</code>がインデックスされるTIDです。
アクセスメソッドが一意なインデックスをサポートする場合（その<code class="structfield">amcanunique</code>が真の場合）、<code class="literal">checkUnique</code>は実行する一意性検査の種類を示します。
これは一意性制約が遅延可能か否かによって変わります。
<a class="xref" href="index-unique-checks.html" title="61.5. インデックス一意性検査">61.5</a>を参照してください。
通常アクセスメソッドは、一意性検査を行う時に<code class="literal">heapRelation</code>パラメータのみを必要とします
(タプルの有効性を検証するためにヒープ内を検索しなければなりません)。
  </p><p>
<span class="original">
   The function's Boolean result value is significant only when
   &lt;literal&gt;checkUnique&lt;/literal&gt; is &lt;literal&gt;UNIQUE_CHECK_PARTIAL&lt;/literal&gt;.
   In this case a true result means the new entry is known unique, whereas
   false means it might be non-unique (and a deferred uniqueness check must
   be scheduled).  For other cases a constant false result is recommended.
</span>
<code class="literal">checkUnique</code>が<code class="literal">UNIQUE_CHECK_PARTIAL</code>の場合、関数の論理型の結果値で十分です。
この場合、真の結果は新しい項目は一意であることが確認されたことを、一方偽の結果は一意でない可能性があること(遅延一意性検査を予定しなければならないこと)を意味します。
他の場合では、一定の偽という結果が推奨されます。
  </p><p>
<span class="original">
   Some indexes might not index all tuples.  If the tuple is not to be
   indexed, &lt;function&gt;aminsert&lt;/function&gt; should just return without doing anything.
</span>
一部のインデックスではすべてのタプルをインデックス付けしない可能性があります。
タプルがインデックス付けされない場合、<code class="function">aminsert</code>は何も行わずに戻らなければなりません。
  </p><p>
<span class="original">
   If the index AM wishes to cache data across successive index insertions
   within a SQL statement, it can allocate space
   in &lt;literal&gt;indexInfo-&amp;gt;ii_Context&lt;/literal&gt; and store a pointer to the
   data in &lt;literal&gt;indexInfo-&amp;gt;ii_AmCache&lt;/literal&gt; (which will be NULL
   initially).
</span>
SQL文の中で、インデックスAMがインデックスへの連続的な挿入をまたがってデータをキャッシュすることが望ましい場合は、<code class="literal">indexInfo-&gt;ii_Context</code>にメモリを確保し、そのデータへのポインタを<code class="literal">indexInfo-&gt;ii_AmCache</code>（初期値はNULLです)に格納することができます。
  </p><p>
</p><pre class="programlisting">
IndexBulkDeleteResult *
ambulkdelete (IndexVacuumInfo *info,
              IndexBulkDeleteResult *stats,
              IndexBulkDeleteCallback callback,
              void *callback_state);
</pre><p>
<span class="original">
   Delete tuple(s) from the index.  This is a &lt;quote&gt;bulk delete&lt;/quote&gt; operation
   that is intended to be implemented by scanning the whole index and checking
   each entry to see if it should be deleted.
   The passed-in &lt;literal&gt;callback&lt;/literal&gt; function must be called, in the style
   &lt;literal&gt;callback(&lt;replaceable&gt;TID&lt;/replaceable&gt;, callback_state) returns bool&lt;/literal&gt;,
   to determine whether any particular index entry, as identified by its
   referenced TID, is to be deleted.  Must return either NULL or a palloc'd
   struct containing statistics about the effects of the deletion operation.
   It is OK to return NULL if no information needs to be passed on to
   &lt;function&gt;amvacuumcleanup&lt;/function&gt;.
</span>
インデックスからタプル（複数可）を削除します。
これは<span class="quote">「<span class="quote">一括削除</span>」</span>操作を行いますが、インデックス全体をスキャンし、各項目に対して削除すべきかどうか検査を行うように実装されることが想定されています。
渡される<code class="literal">callback</code>関数は、<code class="literal">callback(<em class="replaceable"><code>TID</code></em>, callback_state) returns bool</code>という形で、参照用TIDで識別されるインデックス項目を削除すべきかどうか決定するために呼び出さなければなりません。
NULLまたはpallocした削除操作の影響に関する統計情報を含む構造体を返さなければなりません。
<code class="function">amvacuumcleanup</code>に渡さなければならない情報がなければ、NULLを返しても問題ありません。
  </p><p>
<span class="original">
   Because of limited &lt;varname&gt;maintenance_work_mem&lt;/varname&gt;,
   &lt;function&gt;ambulkdelete&lt;/function&gt; might need to be called more than once when many
   tuples are to be deleted.  The &lt;literal&gt;stats&lt;/literal&gt; argument is the result
   of the previous call for this index (it is NULL for the first call within a
   &lt;command&gt;VACUUM&lt;/command&gt; operation).  This allows the AM to accumulate statistics
   across the whole operation.  Typically, &lt;function&gt;ambulkdelete&lt;/function&gt; will
   modify and return the same struct if the passed &lt;literal&gt;stats&lt;/literal&gt; is not
   null.
</span>
<code class="varname">maintenance_work_mem</code>の制限により、多くのタプルが削除される時、<code class="function">ambulkdelete</code>を複数回呼び出す必要があるかもしれません。
<code class="literal">stats</code>引数は、このインデックスに対する前回の呼び出し結果です。
（<code class="command">VACUUM</code>操作における最初の呼び出しではこれはNULLです。）
これにより、アクセスメソッドは操作全体に跨った統計情報を計算することができます。
典型的に、渡された<code class="literal">stats</code>がNULLでない場合、<code class="function">ambulkdelete</code>は同じ構造体を変更し、返します。
  </p><p>
</p><pre class="programlisting">
IndexBulkDeleteResult *
amvacuumcleanup (IndexVacuumInfo *info,
                 IndexBulkDeleteResult *stats);
</pre><p>
<span class="original">
   Clean up after a &lt;command&gt;VACUUM&lt;/command&gt; operation (zero or more
   &lt;function&gt;ambulkdelete&lt;/function&gt; calls).  This does not have to do anything
   beyond returning index statistics, but it might perform bulk cleanup
   such as reclaiming empty index pages.  &lt;literal&gt;stats&lt;/literal&gt; is whatever the
   last &lt;function&gt;ambulkdelete&lt;/function&gt; call returned, or NULL if
   &lt;function&gt;ambulkdelete&lt;/function&gt; was not called because no tuples needed to be
   deleted.  If the result is not NULL it must be a palloc'd struct.
   The statistics it contains will be used to update &lt;structname&gt;pg_class&lt;/structname&gt;,
   and will be reported by &lt;command&gt;VACUUM&lt;/command&gt; if &lt;literal&gt;VERBOSE&lt;/literal&gt; is given.
   It is OK to return NULL if the index was not changed at all during the
   &lt;command&gt;VACUUM&lt;/command&gt; operation, but otherwise correct stats should
   be returned.
</span>
<code class="command">VACUUM</code>操作（0回以上の<code class="function">ambulkdelete</code>呼び出し）後の整理を行います。
これは、インデックス統計情報を返す以上の処理を行う必要はありません。
しかし、空のインデックスページの回収などの一括整理を行う可能性があります。
<code class="literal">stats</code>は最後の<code class="function">ambulkdelete</code>呼び出しが返したものです。
削除する必要があるタプルが存在しなかったために<code class="function">ambulkdelete</code>が呼び出されなかった場合はNULLとなります。
結果はNULLでなければ、pallocされた構造体でなければなりません。
含まれる統計情報は<code class="structname">pg_class</code>を更新するために使用され、また、<code class="literal">VERBOSE</code>が指定された<code class="command">VACUUM</code>によって報告されます。
<code class="command">VACUUM</code>操作の間にインデックスがまったく変わらなかった場合はNULLを返しても問題ありません。
しかし、そうでなければ正しい統計情報を返さなければなりません。
  </p><p>
<span class="original">
   As of &lt;productname&gt;PostgreSQL&lt;/productname&gt; 8.4,
   &lt;function&gt;amvacuumcleanup&lt;/function&gt; will also be called at completion of an
   &lt;command&gt;ANALYZE&lt;/command&gt; operation.  In this case &lt;literal&gt;stats&lt;/literal&gt; is always
   NULL and any return value will be ignored.  This case can be distinguished
   by checking &lt;literal&gt;info-&amp;gt;analyze_only&lt;/literal&gt;.  It is recommended
   that the access method do nothing except post-insert cleanup in such a
   call, and that only in an autovacuum worker process.
</span>
<span class="productname">PostgreSQL</span> 8.4の時点で、<code class="function">amvacuumcleanup</code>も<code class="command">ANALYZE</code>操作の完了時点にも呼び出されます。
この場合、<code class="literal">stats</code>は常にNULLで、戻り値はまったく無視されます。
この事象は<code class="literal">info-&gt;analyze_only</code>を検査することで識別されます。
アクセスメソッドがそのような呼び出しで挿入後の整理以外何もしないように、そしてそれは自動バキュームワーカプロセスのみであるようにすることを推奨します。
  </p><p>
</p><pre class="programlisting">
bool
amcanreturn (Relation indexRelation, int attno);
</pre><p>
<span class="original">
   Check whether the index can support &lt;link
   linkend="indexes-index-only-scans"&gt;&lt;firstterm&gt;index-only scans&lt;/firstterm&gt;&lt;/link&gt; on
   the given column, by returning the indexed column values for an index entry
   in the form of an &lt;structname&gt;IndexTuple&lt;/structname&gt;.  The attribute number
   is 1-based, i.e. the first column's attno is 1. Returns true if supported,
   else false.  If the access method does not support index-only scans at all,
   the &lt;structfield&gt;amcanreturn&lt;/structfield&gt; field in its &lt;structname&gt;IndexAmRoutine&lt;/structname&gt;
   struct can be set to NULL.
</span>
<code class="structname">IndexTuple</code>形式のインデックスエントリをインデックスが設定された列の値として返すことにより、そのインデックスが指定された列で<a class="link" href="indexes-index-only-scans.html" title="11.9. インデックスオンリースキャンとカバリングインデックス"><em class="firstterm">インデックスオンリースキャン</em></a>をサポートしているかどうかを判断します。
属性番号は1始まり、すなわち最初の列の属性番号は1です。
インデックスオンリースキャンがサポートされている場合は真が返され、サポートされていない場合は偽が返ります。
アクセスメソッドがインデックスオンリースキャンをサポートしていない場合、<code class="structname">IndexAmRoutine</code>構造体の<code class="structfield">amcanreturn</code>フィールドをNULLにセットすることができます。
  </p><p>
</p><pre class="programlisting">
void
amcostestimate (PlannerInfo *root,
                IndexPath *path,
                double loop_count,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation,
                double *indexPages);
</pre><p>
<span class="original">
   Estimate the costs of an index scan.  This function is described fully
   in &lt;xref linkend="index-cost-estimation"/&gt;, below.
</span>
インデックススキャンのコストを推定します。
この関数については後述の<a class="xref" href="index-cost-estimation.html" title="61.6. インデックスコスト推定関数">61.6</a>で説明します。
  </p><p>
</p><pre class="programlisting">
bytea *
amoptions (ArrayType *reloptions,
           bool validate);
</pre><p>
<span class="original">
   Parse and validate the reloptions array for an index.  This is called only
   when a non-null reloptions array exists for the index.
   &lt;parameter&gt;reloptions&lt;/parameter&gt; is a &lt;type&gt;text&lt;/type&gt; array containing entries of the
   form &lt;replaceable&gt;name&lt;/replaceable&gt;&lt;literal&gt;=&lt;/literal&gt;&lt;replaceable&gt;value&lt;/replaceable&gt;.
   The function should construct a &lt;type&gt;bytea&lt;/type&gt; value, which will be copied
   into the &lt;structfield&gt;rd_options&lt;/structfield&gt; field of the index's relcache entry.
   The data contents of the &lt;type&gt;bytea&lt;/type&gt; value are open for the access
   method to define; most of the standard access methods use struct
   &lt;structname&gt;StdRdOptions&lt;/structname&gt;.
   When &lt;parameter&gt;validate&lt;/parameter&gt; is true, the function should report a suitable
   error message if any of the options are unrecognized or have invalid
   values; when &lt;parameter&gt;validate&lt;/parameter&gt; is false, invalid entries should be
   silently ignored.  (&lt;parameter&gt;validate&lt;/parameter&gt; is false when loading options
   already stored in &lt;structname&gt;pg_catalog&lt;/structname&gt;; an invalid entry could only
   be found if the access method has changed its rules for options, and in
   that case ignoring obsolete entries is appropriate.)
   It is OK to return NULL if default behavior is wanted.
</span>
インデックス用のreloptionsの解析と検証を行います。
インデックスに非NULLのreloptions配列が存在する場合にのみ呼び出されます。
<em class="parameter"><code>reloptions</code></em>は、<em class="replaceable"><code>name</code></em><code class="literal">=</code><em class="replaceable"><code>value</code></em>形式の項目からなる、<code class="type">text</code>型の配列です。
この関数は<code class="type">bytea</code>型の値を生成しなければならず、この値はインデックスのrelcache項目の<code class="structfield">rd_options</code>フィールドにコピーされます。
<code class="type">bytea</code>型の値の内容はアクセスメソッドが独自に定義できるように開放されています。
標準のアクセスメソッドのほとんどはすべて<code class="structname">StdRdOptions</code>構造体を使用します。
<em class="parameter"><code>validate</code></em>が真の場合、何らかのオプションが認識できなかった場合や無効な値が存在した場合、この関数は適切なエラーメッセージを報告しなければなりません。
<em class="parameter"><code>validate</code></em>が偽の場合、無効な項目は単に無視されます。
（読み込みオプションが既に<code class="structname">pg_catalog</code>に格納されている場合<em class="parameter"><code>validate</code></em>は偽です。
アクセスメソッドがそのオプション用の規則を変更した場合にのみ、無効な項目が検出されます。
そして、その場合、古い項目を無視することが適切です。）
デフォルトの動作を行わせたい場合はNULLを返しても問題ありません。
  </p><p>
</p><pre class="programlisting">
bool
amproperty (Oid index_oid, int attno,
            IndexAMProperty prop, const char *propname,
            bool *res, bool *isnull);
</pre><p>
<span class="original">
   The &lt;function&gt;amproperty&lt;/function&gt; method allows index access methods to override
   the default behavior of &lt;function&gt;pg_index_column_has_property&lt;/function&gt;
   and related functions.
   If the access method does not have any special behavior for index property
   inquiries, the &lt;structfield&gt;amproperty&lt;/structfield&gt; field in
   its &lt;structname&gt;IndexAmRoutine&lt;/structname&gt; struct can be set to NULL.
   Otherwise, the &lt;function&gt;amproperty&lt;/function&gt; method will be called with
   &lt;parameter&gt;index_oid&lt;/parameter&gt; and &lt;parameter&gt;attno&lt;/parameter&gt; both zero for
   &lt;function&gt;pg_indexam_has_property&lt;/function&gt; calls,
   or with &lt;parameter&gt;index_oid&lt;/parameter&gt; valid and &lt;parameter&gt;attno&lt;/parameter&gt; zero for
   &lt;function&gt;pg_index_has_property&lt;/function&gt; calls,
   or with &lt;parameter&gt;index_oid&lt;/parameter&gt; valid and &lt;parameter&gt;attno&lt;/parameter&gt; greater than
   zero for &lt;function&gt;pg_index_column_has_property&lt;/function&gt; calls.
   &lt;parameter&gt;prop&lt;/parameter&gt; is an enum value identifying the property being tested,
   while &lt;parameter&gt;propname&lt;/parameter&gt; is the original property name string.
   If the core code does not recognize the property name
   then &lt;parameter&gt;prop&lt;/parameter&gt; is &lt;literal&gt;AMPROP_UNKNOWN&lt;/literal&gt;.
   Access methods can define custom property names by
   checking &lt;parameter&gt;propname&lt;/parameter&gt; for a match (use &lt;function&gt;pg_strcasecmp&lt;/function&gt;
   to match, for consistency with the core code); for names known to the core
   code, it's better to inspect &lt;parameter&gt;prop&lt;/parameter&gt;.
   If the &lt;structfield&gt;amproperty&lt;/structfield&gt; method returns &lt;literal&gt;true&lt;/literal&gt; then
   it has determined the property test result: it must set &lt;literal&gt;*res&lt;/literal&gt;
   to the boolean value to return, or set &lt;literal&gt;*isnull&lt;/literal&gt;
   to &lt;literal&gt;true&lt;/literal&gt; to return a NULL.  (Both of the referenced variables
   are initialized to &lt;literal&gt;false&lt;/literal&gt; before the call.)
   If the &lt;structfield&gt;amproperty&lt;/structfield&gt; method returns &lt;literal&gt;false&lt;/literal&gt; then
   the core code will proceed with its normal logic for determining the
   property test result.
</span>
<code class="function">amproperty</code>メソッドにより、インデックスメソッドは<code class="function">pg_index_column_has_property</code>および関連する関数のデフォルトの動作を上書きすることができます。
インデックスアクセスメソッドがインデックスの属性の問い合わせについて特別な動作をしないのなら、<code class="structname">IndexAmRoutine</code>構造体の<code class="structfield">amproperty</code>フィールドはNULLにすることができます。
そうでなければ、<code class="function">amproperty</code>は<code class="function">pg_indexam_has_property</code>の呼び出しに対し、<em class="parameter"><code>index_oid</code></em>と<em class="parameter"><code>attno</code></em>をいずれもゼロにして、<code class="function">pg_index_has_property</code>の呼び出しに対して<em class="parameter"><code>index_oid</code></em>が有効、<em class="parameter"><code>attno</code></em>がゼロで、あるいは<code class="function">pg_index_column_has_property</code>の呼び出しに対して<em class="parameter"><code>index_oid</code></em>が有効、<em class="parameter"><code>attno</code></em>が1以上で呼び出されます。
<em class="parameter"><code>prop</code></em>は検査対象の属性を指定する列挙型の値、<em class="parameter"><code>propname</code></em>は元の属性の名称の文字列です。
コアのコードが属性名を認識しない場合、<em class="parameter"><code>prop</code></em>は<code class="literal">AMPROP_UNKNOWN</code>になります。
アクセスメソッドはカスタム属性名を定義して、マッチするものを<em class="parameter"><code>propname</code></em>で確認する（コアコードとの一貫性のため、<code class="function">pg_strcasecmp</code>を使ってください）ことができます。
コアコードに既知の名前については、<em class="parameter"><code>prop</code></em>を検査する方が良いです。
<code class="structfield">amproperty</code>メソッドが<code class="literal">true</code>を返すなら、それは属性検査の結果が決定したということで、<code class="literal">*res</code>を返すべき論理値にセットするか、NULLを返すために<code class="literal">*isnull</code>を<code class="literal">true</code>にセットするかしなければなりません。
（どちらの参照変数も、呼び出しの前に<code class="literal">false</code>に初期化されます。）
<code class="structfield">amproperty</code>メソッドが<code class="literal">false</code>を返すなら、コアコードは属性検査の結果を決定するために、通常の手続きを進めます。
  </p><p>
<span class="original">
   Access methods that support ordering operators should
   implement &lt;literal&gt;AMPROP_DISTANCE_ORDERABLE&lt;/literal&gt; property testing, as the
   core code does not know how to do that and will return NULL.  It may
   also be advantageous to implement &lt;literal&gt;AMPROP_RETURNABLE&lt;/literal&gt; testing,
   if that can be done more cheaply than by opening the index and calling
   &lt;structfield&gt;amcanreturn&lt;/structfield&gt;, which is the core code's default behavior.
   The default behavior should be satisfactory for all other standard
   properties.
</span>
順序付け演算子をサポートするアクセスメソッドは、<code class="literal">AMPROP_DISTANCE_ORDERABLE</code>の属性検査を実装する必要があります。
なぜなら、コアコードはそれをどうすれば良いか知らないため、NULLを返すからです。
コアコードのデフォルトの動作であるインデックスのオープンと<code class="structfield">amcanreturn</code>の呼び出しよりも安価にできるのであれば、<code class="literal">AMPROP_RETURNABLE</code>の検査を実装するのは利点となります。
その他のすべての標準属性に対しては、デフォルトの動作が満足できるもののはずです。
  </p><p>
</p><pre class="programlisting">
bool
amvalidate (Oid opclassoid);
</pre><p>
<span class="original">
   Validate the catalog entries for the specified operator class, so far as
   the access method can reasonably do that.  For example, this might include
   testing that all required support functions are provided.
   The &lt;function&gt;amvalidate&lt;/function&gt; function must return false if the opclass is
   invalid.  Problems should be reported with &lt;function&gt;ereport&lt;/function&gt; messages.
</span>
指定の演算子クラスについて、アクセスメソッドが合理的にできる限りにおいて、カタログエントリを検証します。
例えば、これには必要なすべてのサポート関数が提供されていることのテストが含まれるかもしれません。
<code class="function">amvalidate</code>関数は演算子クラスが無効なときは偽を返さなければなりません。
問題点は<code class="function">ereport</code>メッセージにより報告されます。
  </p><p>
<span class="original">
   The purpose of an index, of course, is to support scans for tuples matching
   an indexable &lt;literal&gt;WHERE&lt;/literal&gt; condition, often called a
   &lt;firstterm&gt;qualifier&lt;/firstterm&gt; or &lt;firstterm&gt;scan key&lt;/firstterm&gt;.  The semantics of
   index scanning are described more fully in &lt;xref linkend="index-scanning"/&gt;,
   below.  An index access method can support &lt;quote&gt;plain&lt;/quote&gt; index scans,
   &lt;quote&gt;bitmap&lt;/quote&gt; index scans, or both.  The scan-related functions that an
   index access method must or may provide are:
</span>
当然ながらインデックスの目的は、よく<em class="firstterm">修飾子</em>や<em class="firstterm">スキャンキー</em>と呼ばれる、インデックス可能な<code class="literal">WHERE</code>条件を満たすタプルのスキャンをサポートすることです。
インデックススキャンのセマンティクスは後の<a class="xref" href="index-scanning.html" title="61.3. インデックススキャン">61.3</a>でより詳しく説明します。
インデックスアクセスメソッドは<span class="quote">「<span class="quote">単純</span>」</span>インデックススキャン、<span class="quote">「<span class="quote">ビットマップ</span>」</span>インデックススキャン、またはこれら双方を提供します。
インデックスアクセスメソッドが提供しなければならない、もしくは提供する可能性のあるスキャン関連の関数を以下に示します。
  </p><p>
</p><pre class="programlisting">
IndexScanDesc
ambeginscan (Relation indexRelation,
             int nkeys,
             int norderbys);
</pre><p>
<span class="original">
   Prepare for an index scan.  The &lt;literal&gt;nkeys&lt;/literal&gt; and &lt;literal&gt;norderbys&lt;/literal&gt;
   parameters indicate the number of quals and ordering operators that will be
   used in the scan; these may be useful for space allocation purposes.
   Note that the actual values of the scan keys aren't provided yet.
   The result must be a palloc'd struct.
   For implementation reasons the index access method
   &lt;emphasis&gt;must&lt;/emphasis&gt; create this struct by calling
   &lt;function&gt;RelationGetIndexScan()&lt;/function&gt;.  In most cases
   &lt;function&gt;ambeginscan&lt;/function&gt; does little beyond making that call and perhaps
   acquiring locks;
   the interesting parts of index-scan startup are in &lt;function&gt;amrescan&lt;/function&gt;.
</span>
インデックススキャンを準備します。
<code class="literal">nkeys</code>および<code class="literal">norderbys</code>パラメータは、スキャンで使用される等価性演算子と順序付け演算子の個数を表します。
これらは領域を割り当てる目的で便利かもしれません。
スキャンキーの実値がまだ提供されていないことに注意してください。
結果はpallocした構造体でなければなりません。
実装上の理由により、インデックスアクセスメソッドは<code class="function">RelationGetIndexScan()</code>呼び出しによってこの構造体を作成<span class="emphasis"><em>しなければなりません</em></span>。
ほとんどの場合、<code class="function">ambeginscan</code>はこの呼び出しとおそらくロックの獲得の他にはほとんど何も行いません。
インデックススキャンを始める際の興味深い部分は、<code class="function">amrescan</code>にあります。
  </p><p>
</p><pre class="programlisting">
void
amrescan (IndexScanDesc scan,
          ScanKey keys,
          int nkeys,
          ScanKey orderbys,
          int norderbys);
</pre><p>
<span class="original">
   Start or restart an index scan, possibly with new scan keys.  (To restart
   using previously-passed keys, NULL is passed for &lt;literal&gt;keys&lt;/literal&gt; and/or
   &lt;literal&gt;orderbys&lt;/literal&gt;.)  Note that it is not allowed for
   the number of keys or order-by operators to be larger than
   what was passed to &lt;function&gt;ambeginscan&lt;/function&gt;.  In practice the restart
   feature is used when a new outer tuple is selected by a nested-loop join
   and so a new key comparison value is needed, but the scan key structure
   remains the same.
</span>
インデックススキャンを起動または再起動します。
スキャンキーを新しくすることもできます。
（過去に渡されたキーを使用して再起動するには、<code class="literal">key</code>、<code class="literal">orderbys</code>、またはその両方にNULLを渡します。)
<code class="function">ambeginscan</code>に渡したキー演算子、順序付け演算子の個数より多くを使用することはできないことに注意してください。
実際には、ネステッドループ結合によって新しい外部タプルが選択され、同じスキャンキー構造体で新しいキー比較値が必要とされた場合に、この再起動機能は使用されます。
  </p><p>
</p><pre class="programlisting">
boolean
amgettuple (IndexScanDesc scan,
            ScanDirection direction);
</pre><p>
<span class="original">
   Fetch the next tuple in the given scan, moving in the given
   direction (forward or backward in the index).  Returns true if a tuple was
   obtained, false if no matching tuples remain.  In the true case the tuple
   TID is stored into the &lt;literal&gt;scan&lt;/literal&gt; structure.  Note that
   &lt;quote&gt;success&lt;/quote&gt; means only that the index contains an entry that matches
   the scan keys, not that the tuple necessarily still exists in the heap or
   will pass the caller's snapshot test.  On success, &lt;function&gt;amgettuple&lt;/function&gt;
   must also set &lt;literal&gt;scan-&amp;gt;xs_recheck&lt;/literal&gt; to true or false.
   False means it is certain that the index entry matches the scan keys.
   true means this is not certain, and the conditions represented by the
   scan keys must be rechecked against the heap tuple after fetching it.
   This provision supports &lt;quote&gt;lossy&lt;/quote&gt; index operators.
   Note that rechecking will extend only to the scan conditions; a partial
   index predicate (if any) is never rechecked by &lt;function&gt;amgettuple&lt;/function&gt;
   callers.
</span>
指定されたスキャン内から指定された方向（インデックス内の前方または後方）で次のタプルを取り出します。
タプルを取り出した場合は真を返します。
一致するタプルが残っていない場合は偽を返します。
真の場合、そのタプルのTIDが<code class="literal">scan</code>に格納されます。
<span class="quote">「<span class="quote">成功</span>」</span>とは、単にインデックスにスキャンキーに一致する項目があったことを意味しているだけです。
タプルが必ずヒープ内に存在することや、呼び出し元のスナップショットの試験を通過したことを意味してはいません。
成功の暁には、<code class="function">amgettuple</code>は<code class="literal">scan-&gt;xs_recheck</code>を真か偽かに設定しなければなりません。
偽の意味は、インデックス項目が確実にスキャンキーに一致することです。
真の意味は、これが確かなことではなく、スキャンキーで表示された条件がヒープタプルを取り出された後で再検査されなければならないことです。
この対策は<span class="quote">「<span class="quote">非可逆</span>」</span>インデックス演算子をサポートします。
再検査はスキャン条件のみに拡大適用されることに注意してください。
部分インデックス述語（もしあれば）は<code class="function">amgettuple</code>呼び出し元で決して再検査されません。
  </p><p>
<span class="original">
   If the index supports &lt;link linkend="indexes-index-only-scans"&gt;index-only
   scans&lt;/link&gt; (i.e., &lt;function&gt;amcanreturn&lt;/function&gt; returns true for it),
   then on success the AM must also check &lt;literal&gt;scan-&amp;gt;xs_want_itup&lt;/literal&gt;,
   and if that is true it must return the originally indexed data for the
   index entry.  The data can be returned in the form of an
   &lt;structname&gt;IndexTuple&lt;/structname&gt; pointer stored at &lt;literal&gt;scan-&amp;gt;xs_itup&lt;/literal&gt;,
   with tuple descriptor &lt;literal&gt;scan-&amp;gt;xs_itupdesc&lt;/literal&gt;; or in the form of
   a &lt;structname&gt;HeapTuple&lt;/structname&gt; pointer stored at &lt;literal&gt;scan-&amp;gt;xs_hitup&lt;/literal&gt;,
   with tuple descriptor &lt;literal&gt;scan-&amp;gt;xs_hitupdesc&lt;/literal&gt;.  (The latter
   format should be used when reconstructing data that might possibly not fit
   into an &lt;structname&gt;IndexTuple&lt;/structname&gt;.)  In either case,
   management of the data referenced by the pointer is the access method's
   responsibility.  The data must remain good at least until the next
   &lt;function&gt;amgettuple&lt;/function&gt;, &lt;function&gt;amrescan&lt;/function&gt;, or &lt;function&gt;amendscan&lt;/function&gt;
   call for the scan.
</span>
そのインデックスが<a class="link" href="indexes-index-only-scans.html" title="11.9. インデックスオンリースキャンとカバリングインデックス">インデックスオンリースキャン</a>をサポートしている場合(つまり<code class="function">amcanreturn</code>が真を返す場合)、そのアクセスメソッドはスキャンが成功したならば<code class="literal">scan-&gt;xs_want_itup</code>も確認し、それが真の場合、そのインデックスエントリに対応する元のインデックスされたデータを返さなければなりません。
返却されるデータは、<code class="literal">scan-&gt;xs_itupdesc</code>タプルディスクリプタとともに<code class="literal">scan-&gt;xs_itup</code>に格納された<code class="structname">IndexTuple</code>ポインタの形式か、あるいは、<code class="literal">scan-&gt;xs_hitupdesc</code>タプルディスクリプタとともに<code class="literal">scan-&gt;xs_hitup</code>に格納された<code class="structname">HeapTuple</code>ポインタの形式です。
（後者の形式は、再構成されたデータが<code class="structname">IndexTuple</code>に収まらない場合に使用するべきです。）
どちらの場合でも、そのポインタが参照するデータの管理はアクセスメソッドの責任です。
データは少なくとも<code class="function">amgettuple</code>、<code class="function">amrescan</code>または<code class="function">amendscan</code>によってスキャンされるまでよい状態を保たなくてはなりません。
  </p><p>
<span class="original">
   The &lt;function&gt;amgettuple&lt;/function&gt; function need only be provided if the access
   method supports &lt;quote&gt;plain&lt;/quote&gt; index scans.  If it doesn't, the
   &lt;structfield&gt;amgettuple&lt;/structfield&gt; field in its &lt;structname&gt;IndexAmRoutine&lt;/structname&gt;
   struct must be set to NULL.
</span>
<code class="function">amgettuple</code>関数は、アクセスメソッドが<span class="quote">「<span class="quote">単純</span>」</span>インデックススキャンをサポートするときのみ提供される必要があります。
そうでなければ、<code class="structname">IndexAmRoutine</code>構造体の<code class="structfield">amgettuple</code>フィールドはNULLに設定されなければなりません。
  </p><p>
</p><pre class="programlisting">
int64
amgetbitmap (IndexScanDesc scan,
             TIDBitmap *tbm);
</pre><p>
<span class="original">
   Fetch all tuples in the given scan and add them to the caller-supplied
   &lt;type&gt;TIDBitmap&lt;/type&gt; (that is, OR the set of tuple IDs into whatever set is already
   in the bitmap).  The number of tuples fetched is returned (this might be
   just an approximate count, for instance some AMs do not detect duplicates).
   While inserting tuple IDs into the bitmap, &lt;function&gt;amgetbitmap&lt;/function&gt; can
   indicate that rechecking of the scan conditions is required for specific
   tuple IDs.  This is analogous to the &lt;literal&gt;xs_recheck&lt;/literal&gt; output parameter
   of &lt;function&gt;amgettuple&lt;/function&gt;.  Note: in the current implementation, support
   for this feature is conflated with support for lossy storage of the bitmap
   itself, and therefore callers recheck both the scan conditions and the
   partial index predicate (if any) for recheckable tuples.  That might not
   always be true, however.
   &lt;function&gt;amgetbitmap&lt;/function&gt; and
   &lt;function&gt;amgettuple&lt;/function&gt; cannot be used in the same index scan; there
   are other restrictions too when using &lt;function&gt;amgetbitmap&lt;/function&gt;, as explained
   in &lt;xref linkend="index-scanning"/&gt;.
</span>
指定されたスキャンから全てのタプルを取り出し、呼び出し側が提供する<code class="type">TIDBitmap</code>にそれらを付加します
（つまり、既にビットマップ内にある集合とタプルIDの集合とのORを取ります）。
取り出されたタプル数が返されます（例えばいくつかのAMは重複を検出しませんので、これは単なる概算です）。
タプルIDをビットマップに挿入する間、<code class="function">amgetbitmap</code>は特定のタプルIDに必要なスキャン条件の再検査を示すことが可能です。
これは<code class="function">amgettuple</code>の<code class="literal">xs_recheck</code>出力パラメータに類似しています。
注意：現在の実装においてこの機能の提供はビットマップそのものの非可逆格納を提供するのに結びついていて、したがって呼び出し側はスキャン条件と部分インデックスの述部（存在すれば）を再検査可能なタプルに対して再検査します。
とは言っても常に正しいとは限りません。
<code class="function">amgetmulti</code>および<code class="function">amgettuple</code>を同じインデックススキャン内で使用することはできません。
<a class="xref" href="index-scanning.html" title="61.3. インデックススキャン">61.3</a>で説明した通り、<code class="function">amgetbitmap</code>を使用する場合には他にも制限があります。
  </p><p>
<span class="original">
   The &lt;function&gt;amgetbitmap&lt;/function&gt; function need only be provided if the access
   method supports &lt;quote&gt;bitmap&lt;/quote&gt; index scans.  If it doesn't, the
   &lt;structfield&gt;amgetbitmap&lt;/structfield&gt; field in its &lt;structname&gt;IndexAmRoutine&lt;/structname&gt;
   struct must be set to NULL.
</span>
<code class="function">amgetbitmap</code>関数はアクセスメソッドが<span class="quote">「<span class="quote">ビットマップ</span>」</span>インデックススキャンをサポートしている場合のみ必要です。
そうでなければ、<code class="structname">IndexAmRoutine</code>構造体の中の<code class="structfield">amgetbitmap</code>フィールドはNULLに設定されなければなりません。
  </p><p>
</p><pre class="programlisting">
void
amendscan (IndexScanDesc scan);
</pre><p>
<span class="original">
   End a scan and release resources.  The &lt;literal&gt;scan&lt;/literal&gt; struct itself
   should not be freed, but any locks or pins taken internally by the
   access method must be released, as well as any other memory allocated
   by &lt;function&gt;ambeginscan&lt;/function&gt; and other scan-related functions.
</span>
スキャンを停止し、リソースを解放します。
<code class="literal">scan</code>構造体自体は解放すべきではありません。
アクセスメソッドで内部的に取られたロックやピンは、<code class="function">ambeginscan</code>や他のスキャン関連の関数により確保されたメモリと同様に解放しなければなりません。
  </p><p>
</p><pre class="programlisting">
void
ammarkpos (IndexScanDesc scan);
</pre><p>
<span class="original">
   Mark current scan position.  The access method need only support one
   remembered scan position per scan.
</span>
現在のスキャン位置を記録します。
アクセスメソッドは1スキャン当たり1つの記録済みスキャンのみをサポートしなければなりません。
  </p><p>
<span class="original">
   The &lt;function&gt;ammarkpos&lt;/function&gt; function need only be provided if the access
   method supports ordered scans.  If it doesn't,
   the &lt;structfield&gt;ammarkpos&lt;/structfield&gt; field in its &lt;structname&gt;IndexAmRoutine&lt;/structname&gt;
   struct may be set to NULL.
</span>
<code class="function">ammarkpos</code>関数はアクセスメソッドが順序付けされたスキャンをサポートする場合にのみ提供する必要があります。
そうでなければ、その<code class="structname">IndexAmRoutine</code>構造体の<code class="structfield">ammarkpos</code>フィールドはNULLに設定しても構いません。
  </p><p>
</p><pre class="programlisting">
void
amrestrpos (IndexScanDesc scan);
</pre><p>
<span class="original">
   Restore the scan to the most recently marked position.
</span>
もっとも最近に記録された位置にスキャンを戻します。
  </p><p>
<span class="original">
   The &lt;function&gt;amrestrpos&lt;/function&gt; function need only be provided if the access
   method supports ordered scans.  If it doesn't,
   the &lt;structfield&gt;amrestrpos&lt;/structfield&gt; field in its &lt;structname&gt;IndexAmRoutine&lt;/structname&gt;
   struct may be set to NULL.
</span>
<code class="function">amrestrpos</code>関数はアクセスメソッドが順序付けされたスキャンをサポートする場合にのみ提供する必要があります。
そうでなければ、その<code class="structname">IndexAmRoutine</code>構造体の<code class="structfield">amrestrpos</code>フィールドはNULLに設定しても構いません。
  </p><p>
<span class="original">
   In addition to supporting ordinary index scans, some types of index
   may wish to support &lt;firstterm&gt;parallel index scans&lt;/firstterm&gt;, which allow
   multiple backends to cooperate in performing an index scan.  The
   index access method should arrange things so that each cooperating
   process returns a subset of the tuples that would be performed by
   an ordinary, non-parallel index scan, but in such a way that the
   union of those subsets is equal to the set of tuples that would be
   returned by an ordinary, non-parallel index scan.  Furthermore, while
   there need not be any global ordering of tuples returned by a parallel
   scan, the ordering of that subset of tuples returned within each
   cooperating backend must match the requested ordering.  The following
   functions may be implemented to support parallel index scans:
</span>
通常のインデックススキャンのサポートに加え、ある種のインデックスは、複数のバックエンドが協調してインデックススキャンを実行する<em class="firstterm">パラレルインデックススキャン</em>をサポートすることができます。
インデックスアクセスメソッドは、協調するプロセスが、通常の非パラレルインデックススキャンが実行対象とする行のサブセットを返しつつ、しかもそれらのサブセットの合計が、通常の非パラレルインデックススキャンが返すタプルの集合と同じになるように調整しなければなりません。
それだけでなく、パラレルスキャンが返すタプル全体の順序付けが想定されていない場合でも、協調するバックエンドが返すサブセットのタプルの順序付けは、要求された順序付けと一致しなければなりません。
パラレルインデックススキャンをサポートするために、以下の関数を実装することができます。
  </p><p>
</p><pre class="programlisting">
Size
amestimateparallelscan (void);
</pre><p>
<span class="original">
   Estimate and return the number of bytes of dynamic shared memory which
   the access method will be needed to perform a parallel scan.  (This number
   is in addition to, not in lieu of, the amount of space needed for
   AM-independent data in &lt;structname&gt;ParallelIndexScanDescData&lt;/structname&gt;.)
</span>
パラレルスキャンを実行するために、アクセスメソッドによって必要とされる動的共有メモリのバイト数を推測し、返します。
（この数値は、<code class="structname">ParallelIndexScanDescData</code>のAM独立データに必要となる量に追加するための値であり、それを置き換えるものではありません。）
  </p><p>
<span class="original">
   It is not necessary to implement this function for access methods which
   do not support parallel scans or for which the number of additional bytes
   of storage required is zero.
</span>
パラレルスキャンをサポートしない、あるいはメモリ領域への追加のバイト数が0のアクセスメソッドでは、この関数を実装する必要はありません。
  </p><p>
</p><pre class="programlisting">
void
aminitparallelscan (void *target);
</pre><p>
<span class="original">
   This function will be called to initialize dynamic shared memory at the
   beginning of a parallel scan.  &lt;parameter&gt;target&lt;/parameter&gt; will point to at least
   the number of bytes previously returned by
   &lt;function&gt;amestimateparallelscan&lt;/function&gt;, and this function may use that
   amount of space to store whatever data it wishes.
</span>
この関数は、パラレルスキャンの最初に動的共有メモリを初期化するために呼ばれます。
<em class="parameter"><code>target</code></em>は、前もって<code class="function">amestimateparallelscan</code>が返したバイト数を少なくとも持つ領域を指し、この関数はその分だけのスペースを使って必要なデータを保管することができます。
  </p><p>
<span class="original">
   It is not necessary to implement this function for access methods which
   do not support parallel scans or in cases where the shared memory space
   required needs no initialization.
</span>
パラレルスキャンをサポートしない、あるいは共有メモリスペースの初期化が必要ないアクセスメソッドでは、この関数を実装する必要はありません。
  </p><p>
</p><pre class="programlisting">
void
amparallelrescan (IndexScanDesc scan);
</pre><p>
<span class="original">
   This function, if implemented, will be called when a parallel index scan
   must be restarted.  It should reset any shared state set up by
   &lt;function&gt;aminitparallelscan&lt;/function&gt; such that the scan will be restarted from
   the beginning.
</span>
実装された場合、この関数はパラレルインデックススキャンを再起動しなければならない時に呼ばれます。
この関数は、<code class="function">aminitparallelscan</code>が設定した共有状態を初期化し、スキャンが最初から再開できるようにします。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index-api.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="indexam.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="index-scanning.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">61.1. インデックスの基本的API構造 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 61.3. インデックススキャン</td></tr></table></div></body></html>