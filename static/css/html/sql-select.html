<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>SELECT</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-security-label.html" title="SECURITY LABEL" /><link rel="next" href="sql-selectinto.html" title="SELECT INTO" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 11.4文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="sql-commands.html" title="SQLコマンド">SQLコマンド</a></td><td width="20%" align="right"></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-security-label.html" title="SECURITY LABEL">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">上へ</a></td><td width="60%" align="center">SELECT</td><td width="20%" align="right"> <a accesskey="n" href="sql-selectinto.html" title="SELECT INTO">次へ</a></td></tr></table><hr /></div><div class="refentry" id="SQL-SELECT"><div class="titlepage"></div><a id="id-1.9.3.171.1" class="indexterm"></a><a id="id-1.9.3.171.2" class="indexterm"></a><a id="id-1.9.3.171.3" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">SELECT</span></h2><p>SELECT, TABLE, WITH<!--
  <refpurpose>retrieve rows from a table or view</refpurpose>
--> — テーブルもしくはビューから行を検索する</p></div><div class="refsynopsisdiv"><h2>概要</h2><pre class="synopsis">
[ WITH [ RECURSIVE ] <em class="replaceable"><code>with_query</code></em> [, ...] ]
SELECT [ ALL | DISTINCT [ ON ( <em class="replaceable"><code>expression</code></em> [, ...] ) ] ]
    [ * | <em class="replaceable"><code>expression</code></em> [ [ AS ] <em class="replaceable"><code>output_name</code></em> ] [, ...] ]
    [ FROM <em class="replaceable"><code>from_item</code></em> [, ...] ]
    [ WHERE <em class="replaceable"><code>condition</code></em> ]
    [ GROUP BY <em class="replaceable"><code>grouping_element</code></em> [, ...] ]
    [ HAVING <em class="replaceable"><code>condition</code></em> [, ...] ]
    [ WINDOW <em class="replaceable"><code>window_name</code></em> AS ( <em class="replaceable"><code>window_definition</code></em> ) [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] <em class="replaceable"><code>select</code></em> ]
    [ ORDER BY <em class="replaceable"><code>expression</code></em> [ ASC | DESC | USING <em class="replaceable"><code>operator</code></em> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <em class="replaceable"><code>count</code></em> | ALL } ]
    [ OFFSET <em class="replaceable"><code>start</code></em> [ ROW | ROWS ] ]
    [ FETCH { FIRST | NEXT } [ <em class="replaceable"><code>count</code></em> ] { ROW | ROWS } ONLY ]
    [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF <em class="replaceable"><code>table_name</code></em> [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]

<!--
<phrase>where <replaceable class="parameter">from_item</replaceable> can be one of:</phrase>
-->
<span class="phrase">ここで<em class="replaceable"><code>from_item</code></em>は以下のいずれかです。</span>

    [ ONLY ] <em class="replaceable"><code>table_name</code></em> [ * ] [ [ AS ] <em class="replaceable"><code>alias</code></em> [ ( <em class="replaceable"><code>column_alias</code></em> [, ...] ) ] ]
                [ TABLESAMPLE <em class="replaceable"><code>sampling_method</code></em> ( <em class="replaceable"><code>argument</code></em> [, ...] ) [ REPEATABLE ( <em class="replaceable"><code>seed</code></em> ) ] ]
    [ LATERAL ] ( <em class="replaceable"><code>select</code></em> ) [ AS ] <em class="replaceable"><code>alias</code></em> [ ( <em class="replaceable"><code>column_alias</code></em> [, ...] ) ]
    <em class="replaceable"><code>with_query_name</code></em> [ [ AS ] <em class="replaceable"><code>alias</code></em> [ ( <em class="replaceable"><code>column_alias</code></em> [, ...] ) ] ]
    [ LATERAL ] <em class="replaceable"><code>function_name</code></em> ( [ <em class="replaceable"><code>argument</code></em> [, ...] ] )
                [ WITH ORDINALITY ] [ [ AS ] <em class="replaceable"><code>alias</code></em> [ ( <em class="replaceable"><code>column_alias</code></em> [, ...] ) ] ]
    [ LATERAL ] <em class="replaceable"><code>function_name</code></em> ( [ <em class="replaceable"><code>argument</code></em> [, ...] ] ) [ AS ] <em class="replaceable"><code>alias</code></em> ( <em class="replaceable"><code>column_definition</code></em> [, ...] )
    [ LATERAL ] <em class="replaceable"><code>function_name</code></em> ( [ <em class="replaceable"><code>argument</code></em> [, ...] ] ) AS ( <em class="replaceable"><code>column_definition</code></em> [, ...] )
    [ LATERAL ] ROWS FROM( <em class="replaceable"><code>function_name</code></em> ( [ <em class="replaceable"><code>argument</code></em> [, ...] ] ) [ AS ( <em class="replaceable"><code>column_definition</code></em> [, ...] ) ] [, ...] )
                [ WITH ORDINALITY ] [ [ AS ] <em class="replaceable"><code>alias</code></em> [ ( <em class="replaceable"><code>column_alias</code></em> [, ...] ) ] ]
    <em class="replaceable"><code>from_item</code></em> [ NATURAL ] <em class="replaceable"><code>join_type</code></em> <em class="replaceable"><code>from_item</code></em> [ ON <em class="replaceable"><code>join_condition</code></em> | USING ( <em class="replaceable"><code>join_column</code></em> [, ...] ) ]

<!--
<phrase>and <replaceable class="parameter">grouping_element</replaceable> can be one of:</phrase>
-->
<span class="phrase">また<em class="replaceable"><code>grouping_element</code></em>は以下のいずれかです。</span>

    ( )
    <em class="replaceable"><code>expression</code></em>
    ( <em class="replaceable"><code>expression</code></em> [, ...] )
    ROLLUP ( { <em class="replaceable"><code>expression</code></em> | ( <em class="replaceable"><code>expression</code></em> [, ...] ) } [, ...] )
    CUBE ( { <em class="replaceable"><code>expression</code></em> | ( <em class="replaceable"><code>expression</code></em> [, ...] ) } [, ...] )
    GROUPING SETS ( <em class="replaceable"><code>grouping_element</code></em> [, ...] )

<!--
<phrase>and <replaceable class="parameter">with_query</replaceable> is:</phrase>
-->
<span class="phrase">また<em class="replaceable"><code>with_query</code></em>は以下の通りです。</span>

    <em class="replaceable"><code>with_query_name</code></em> [ ( <em class="replaceable"><code>column_name</code></em> [, ...] ) ] AS ( <em class="replaceable"><code>select</code></em> | <em class="replaceable"><code>values</code></em> | <em class="replaceable"><code>insert</code></em> | <em class="replaceable"><code>update</code></em> | <em class="replaceable"><code>delete</code></em> )

TABLE [ ONLY ] <em class="replaceable"><code>table_name</code></em> [ * ]
</pre></div><div class="refsect1" id="id-1.9.3.171.7"><h2>説明</h2><!--
  <title>Description</title>
--><p>
<!--
   <command>SELECT</command> retrieves rows from zero or more tables.
   The general processing of <command>SELECT</command> is as follows:
-->
<code class="command">SELECT</code>は0個以上のテーブルから行を返します。
<code class="command">SELECT</code>の一般的な処理は以下の通りです。

   </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
<!--
      All queries in the <literal>WITH</literal> list are computed.
      These effectively serve as temporary tables that can be referenced
      in the <literal>FROM</literal> list.  A <literal>WITH</literal> query
      that is referenced more than once in <literal>FROM</literal> is
      computed only once.
      (See <xref linkend="sql-with" endterm="sql-with-title"/> below.)
-->
<code class="literal">WITH</code>リスト内のすべての問い合わせが計算されます。
これらは実質的には、<code class="literal">FROM</code>リスト内から参照可能な一時テーブルとして提供されます。
<code class="literal">FROM</code>内で2回以上参照される<code class="literal">WITH</code>問い合わせは一度のみ計算されます。
（後述の<a class="xref" href="sql-select.html#SQL-WITH" title="WITH句"><code class="literal">WITH</code>句</a>を参照してください。）
     </p></li><li class="listitem"><p>
<!--
      All elements in the <literal>FROM</literal> list are computed.
      (Each element in the <literal>FROM</literal> list is a real or
      virtual table.)  If more than one element is specified in the
      <literal>FROM</literal> list, they are cross-joined together.
      (See <xref linkend="sql-from" endterm="sql-from-title"/> below.)
-->
<code class="literal">FROM</code>リストにある全要素が計算されます
（<code class="literal">FROM</code>リストの要素は実テーブルか仮想テーブルのいずれかです）。
<code class="literal">FROM</code>リストに複数の要素が指定された場合、それらはクロス結合されます
（後述の<a class="xref" href="sql-select.html#SQL-FROM" title="FROM句"><code class="literal">FROM</code>句</a>を参照してください）。
     </p></li><li class="listitem"><p>
<!--
      If the <literal>WHERE</literal> clause is specified, all rows
      that do not satisfy the condition are eliminated from the
      output.  (See <xref linkend="sql-where"
      endterm="sql-where-title"/> below.)
-->
<code class="literal">WHERE</code>句が指定された場合、条件を満たさない行は全て出力から取り除かれます
（後述の<a class="xref" href="sql-select.html#SQL-WHERE" title="WHERE句"><code class="literal">WHERE</code>句</a>を参照してください）。
     </p></li><li class="listitem"><p>
<!--
      If the <literal>GROUP BY</literal> clause is specified,
      or if there are aggregate function calls, the
      output is combined into groups of rows that match on one or more
      values, and the results of aggregate functions are computed.
      If the <literal>HAVING</literal> clause is present, it
      eliminates groups that do not satisfy the given condition.  (See
      <xref linkend="sql-groupby" endterm="sql-groupby-title"/> and
      <xref linkend="sql-having" endterm="sql-having-title"/> below.)
-->
<code class="literal">GROUP BY</code>句が指定された場合、および集約関数の呼び出しがある場合は、1つまたは複数の値が条件に合う行ごとにグループに組み合わせて出力され、また集約関数の結果が計算されます。
<code class="literal">HAVING</code>句が指定された場合、指定した条件を満たさないグループは取り除かれます
（後述の<a class="xref" href="sql-select.html#SQL-GROUPBY" title="GROUP BY句"><code class="literal">GROUP BY</code>句</a>と<a class="xref" href="sql-select.html#SQL-HAVING" title="HAVING句"><code class="literal">HAVING</code>句</a>を参照してください）。
     </p></li><li class="listitem"><p>
<!--
      The actual output rows are computed using the
      <command>SELECT</command> output expressions for each selected
      row or row group.  (See
      <xref linkend="sql-select-list" endterm="sql-select-list-title"/>
      below.)
-->
実際には、選択された各行または行グループに対して、<code class="command">SELECT</code>の出力式を使用して計算した結果の行が出力されます
（後述の<a class="xref" href="sql-select.html#SQL-SELECT-LIST" title="SELECTリスト"><code class="command">SELECT</code>リスト</a>を参照してください）。
     </p></li><li class="listitem"><!--
     <para><literal>SELECT DISTINCT</literal> eliminates duplicate rows from the
      result.  <literal>SELECT DISTINCT ON</literal> eliminates rows that
      match on all the specified expressions.  <literal>SELECT ALL</literal>
      (the default) will return all candidate rows, including
      duplicates.  (See <xref linkend="sql-distinct"
      endterm="sql-distinct-title"/> below.)
--><p><code class="literal">SELECT DISTINCT</code>は結果から重複行を取り除きます。
<code class="literal">SELECT DISTINCT ON</code>は指定した全ての式に一致する行を取り除きます。
<code class="literal">SELECT ALL</code>では、重複行も含め、全ての候補行を返します（これがデフォルトです。
詳しくは、後述の<a class="xref" href="sql-select.html#SQL-DISTINCT" title="DISTINCT句"><code class="literal">DISTINCT</code>句</a>を参照してください）。
     </p></li><li class="listitem"><p>
<!--
      Using the operators <literal>UNION</literal>,
      <literal>INTERSECT</literal>, and <literal>EXCEPT</literal>, the
      output of more than one <command>SELECT</command> statement can
      be combined to form a single result set.  The
      <literal>UNION</literal> operator returns all rows that are in
      one or both of the result sets.  The
      <literal>INTERSECT</literal> operator returns all rows that are
      strictly in both result sets.  The <literal>EXCEPT</literal>
      operator returns the rows that are in the first result set but
      not in the second.  In all three cases, duplicate rows are
      eliminated unless <literal>ALL</literal> is specified.  The noise
      word <literal>DISTINCT</literal> can be added to explicitly specify
      eliminating duplicate rows.  Notice that <literal>DISTINCT</literal> is
      the default behavior here, even though <literal>ALL</literal> is
      the default for <command>SELECT</command> itself.  (See
      <xref linkend="sql-union" endterm="sql-union-title"/>, <xref
      linkend="sql-intersect" endterm="sql-intersect-title"/>, and
      <xref linkend="sql-except" endterm="sql-except-title"/> below.)
-->
<code class="literal">UNION</code>、<code class="literal">INTERSECT</code>、<code class="literal">EXCEPT</code>演算子を使用すると、複数の<code class="command">SELECT</code>文の出力を1つの結果集合にまとめることができます。
<code class="literal">UNION</code>演算子は、両方の結果集合に存在する行と、片方の結果集合に存在する行を全て返します。
<code class="literal">INTERSECT</code>演算子は、両方の結果集合に存在する行を返します。
<code class="literal">EXCEPT</code>演算子は、最初の結果集合にあり、2番目の結果集合にない行を返します。
<code class="literal">ALL</code>が指定されない限り、いずれの場合も、重複する行は取り除かれます。
無意味な<code class="literal">DISTINCT</code>という単語を付けて、明示的に重複行を除去することを指定することができます。
<code class="command">SELECT</code>自体は<code class="literal">ALL</code>がデフォルトですが、この場合は<code class="literal">DISTINCT</code>がデフォルトの動作であることに注意してください。
（後述の<a class="xref" href="sql-select.html#SQL-UNION" title="UNION句"><code class="literal">UNION</code>句</a>、<a class="xref" href="sql-select.html#SQL-INTERSECT" title="INTERSECT句"><code class="literal">INTERSECT</code>句</a>、<a class="xref" href="sql-select.html#SQL-EXCEPT" title="EXCEPT句"><code class="literal">EXCEPT</code>句</a>を参照してください。）
     </p></li><li class="listitem"><p>
<!--
      If the <literal>ORDER BY</literal> clause is specified, the
      returned rows are sorted in the specified order.  If
      <literal>ORDER BY</literal> is not given, the rows are returned
      in whatever order the system finds fastest to produce.  (See
      <xref linkend="sql-orderby" endterm="sql-orderby-title"/> below.)
-->
<code class="literal">ORDER BY</code>句が指定された場合、返される行は指定した順番でソートされます。
<code class="literal">ORDER BY</code>が指定されない場合は、システムが計算過程で見つけた順番で行が返されます
（後述の<a class="xref" href="sql-select.html#SQL-ORDERBY" title="ORDER BY句"><code class="literal">ORDER BY</code>句</a>を参照してください）。
     </p></li><li class="listitem"><p>
<!--
      If the <literal>LIMIT</literal> (or <literal>FETCH FIRST</literal>) or <literal>OFFSET</literal>
      clause is specified, the <command>SELECT</command> statement
      only returns a subset of the result rows. (See <xref
      linkend="sql-limit" endterm="sql-limit-title"/> below.)
-->
<code class="literal">LIMIT</code>（または<code class="literal">FETCH FIRST</code>）あるいは<code class="literal">OFFSET</code>句が指定された場合、<code class="command">SELECT</code>文は結果行の一部分のみを返します
（詳しくは、後述の<a class="xref" href="sql-select.html#SQL-LIMIT" title="LIMIT句"><code class="literal">LIMIT</code>句</a>を参照してください）。
     </p></li><li class="listitem"><p>
<!--
      If <literal>FOR UPDATE</literal>, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR SHARE</literal>
      or <literal>FOR KEY SHARE</literal>
      is specified, the
      <command>SELECT</command> statement locks the selected rows
      against concurrent updates.  (See <xref linkend="sql-for-update-share"
      endterm="sql-for-update-share-title"/> below.)
-->
<code class="literal">FOR UPDATE</code>、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR SHARE</code>または<code class="literal">FOR KEY SHARE</code>句を指定すると、<code class="command">SELECT</code>文は引き続き行われる更新に備えて選択行をロックします
（詳しくは、後述の<a class="xref" href="sql-select.html#SQL-FOR-UPDATE-SHARE" title="ロック処理句">ロック処理句</a>を参照してください）。
     </p></li></ol></div><p>
  </p><p>
<!--
   You must have <literal>SELECT</literal> privilege on each column used
   in a <command>SELECT</command> command.  The use of <literal>FOR NO KEY UPDATE</literal>,
   <literal>FOR UPDATE</literal>,
   <literal>FOR SHARE</literal> or <literal>FOR KEY SHARE</literal> requires
   <literal>UPDATE</literal> privilege as well (for at least one column
   of each table so selected).
-->
<code class="command">SELECT</code>コマンド内で使われる列それぞれに対する<code class="literal">SELECT</code>権限が必要です。
<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>または<code class="literal">FOR KEY SHARE</code>を使用するためには、さらに、（選択された各テーブルで少なくとも1列に対する）<code class="literal">UPDATE</code>権限が必要です。

  </p></div><div class="refsect1" id="id-1.9.3.171.8"><h2>パラメータ</h2><!--
  <title>Parameters</title>
--><div class="refsect2" id="SQL-WITH"><h3><code class="literal">WITH</code>句</h3><!--
   <title id="sql-with-title"><literal>WITH</literal> Clause</title>
--><p>
<!--
    The <literal>WITH</literal> clause allows you to specify one or more
    subqueries that can be referenced by name in the primary query.
    The subqueries effectively act as temporary tables or views
    for the duration of the primary query.
    Each subquery can be a <command>SELECT</command>, <command>TABLE</command>, <command>VALUES</command>,
    <command>INSERT</command>, <command>UPDATE</command> or
    <command>DELETE</command> statement.
    When writing a data-modifying statement (<command>INSERT</command>,
    <command>UPDATE</command> or <command>DELETE</command>) in
    <literal>WITH</literal>, it is usual to include a <literal>RETURNING</literal> clause.
    It is the output of <literal>RETURNING</literal>, <emphasis>not</emphasis> the underlying
    table that the statement modifies, that forms the temporary table that is
    read by the primary query.  If <literal>RETURNING</literal> is omitted, the
    statement is still executed, but it produces no output so it cannot be
    referenced as a table by the primary query.
-->
<code class="literal">WITH</code>句により主問い合わせ内で名前により参照可能な、1つ以上の副問い合わせを指定することができます。
副問い合わせは実質的に主問い合わせの間の一時的なテーブルかビューのように動作します。
各副問い合わせは<code class="command">SELECT</code>、<code class="command">TABLE</code>、<code class="command">VALUES</code>、<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>にすることができます。
<code class="literal">WITH</code>内でデータ変更文（<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>）を記述する場合は、<code class="literal">RETURNING</code>句を含めるのが普通です。
主問い合わせで読み取られる一時テーブルを形成するのは、<code class="literal">RETURNING</code>の出力であり、文が変更する背後のテーブルでは<span class="emphasis"><em>ありません</em></span>。
<code class="literal">RETURNING</code>を省いても文は実行されますが、出力を生成しませんので、主問い合わせでテーブルとして参照することができません。
   </p><p>
<!--
    A name (without schema qualification) must be specified for each
    <literal>WITH</literal> query.  Optionally, a list of column names
    can be specified; if this is omitted,
    the column names are inferred from the subquery.
-->
（スキーマ修飾がない）名前を各<code class="literal">WITH</code>問い合わせで指定しなければなりません。
列名のリストをオプションで指定することもできます。
これを省略すると、列名は副問い合わせから推定されます。
   </p><p>
<!--
    If <literal>RECURSIVE</literal> is specified, it allows a
    <command>SELECT</command> subquery to reference itself by name.  Such a
    subquery must have the form
-->
<code class="literal">RECURSIVE</code>が指定されると、<code class="command">SELECT</code>副問い合わせは自身で名前により参照することができます。
こうした副問い合わせは以下のような形式でなければなりません。
</p><pre class="synopsis">
<em class="replaceable"><code>non_recursive_term</code></em> UNION [ ALL | DISTINCT ] <em class="replaceable"><code>recursive_term</code></em>
</pre><p>
<!--
    where the recursive self-reference must appear on the right-hand
    side of the <literal>UNION</literal>.  Only one recursive self-reference
    is permitted per query.  Recursive data-modifying statements are not
    supported, but you can use the results of a recursive
    <command>SELECT</command> query in
    a data-modifying statement.  See <xref linkend="queries-with"/> for
    an example.
-->
ここで再帰的な自己参照は<code class="literal">UNION</code>の右辺に現れなければなりません。
問い合わせ当たり1つの再帰的な自己参照のみが許されます。
再帰的なデータ変更文はサポートされていませんが、データ変更文で再帰的な<code class="command">SELECT</code>の結果を使用することができます。
例は<a class="xref" href="queries-with.html" title="7.8. WITH問い合わせ（共通テーブル式）">7.8</a>を参照してください。
   </p><p>
<!--
    Another effect of <literal>RECURSIVE</literal> is that
    <literal>WITH</literal> queries need not be ordered: a query
    can reference another one that is later in the list.  (However,
    circular references, or mutual recursion, are not implemented.)
    Without <literal>RECURSIVE</literal>, <literal>WITH</literal> queries
    can only reference sibling <literal>WITH</literal> queries
    that are earlier in the <literal>WITH</literal> list.
-->
<code class="literal">RECURSIVE</code>には他にも、<code class="literal">WITH</code>問い合わせが順序通りでなくても構わないという効果があります。
つまり、問い合わせはリストの後にある別のものを参照することができます。
（しかし巡回する参照や相互的な参照は実装されていません。）
<code class="literal">RECURSIVE</code>がないと、<code class="literal">WITH</code>問い合わせは主問い合わせが共通する<code class="literal">WITH</code>問い合わせのうち、<code class="literal">WITH</code>リストの前方にあるもののみを参照することができます。
   </p><p>
<!--
    A key property of <literal>WITH</literal> queries is that they
    are evaluated only once per execution of the primary query,
    even if the primary query refers to them more than once.
    In particular, data-modifying statements are guaranteed to be
    executed once and only once, regardless of whether the primary query
    reads all or any of their output.
-->
<code class="literal">WITH</code>問い合わせの重要な特性は、これらを主問い合わせが複数回参照していたとしても、主問い合わせの実行当たり一度のみ評価される点です。
特にデータ変更文は、主問い合わせがその出力のすべてまたは一部を読み取るかに関係なく、本当に一度のみ実行されることが保証されています。
   </p><p>
<!--
    The primary query and the <literal>WITH</literal> queries are all
    (notionally) executed at the same time.  This implies that the effects of
    a data-modifying statement in <literal>WITH</literal> cannot be seen from
    other parts of the query, other than by reading its <literal>RETURNING</literal>
    output.  If two such data-modifying statements attempt to modify the same
    row, the results are unspecified.
-->
主問い合わせと<code class="literal">WITH</code>問い合わせは（理論上）同時にすべて実行されます。
<code class="literal">WITH</code>内のデータ変更文によりなされた影響は、<code class="literal">RETURNING</code>出力を読み取る以外、問い合わせの他の部分では参照できないことを意味します。
こうしたデータ変更文が２つあり、同じ行を変更しようとした場合、その結果は不定です。
   </p><p>
<!--
    See <xref linkend="queries-with"/> for additional information.
-->
追加情報については<a class="xref" href="queries-with.html" title="7.8. WITH問い合わせ（共通テーブル式）">7.8</a>を参照してください。
   </p></div><div class="refsect2" id="SQL-FROM"><h3><code class="literal">FROM</code>句</h3><!--
   <title id="sql-from-title"><literal>FROM</literal> Clause</title>
--><p>
<!--
    The <literal>FROM</literal> clause specifies one or more source
    tables for the <command>SELECT</command>.  If multiple sources are
    specified, the result is the Cartesian product (cross join) of all
    the sources.  But usually qualification conditions are added (via
    <literal>WHERE</literal>) to restrict the returned rows to a small subset of the
    Cartesian product.
-->
<code class="literal">FROM</code>句には<code class="command">SELECT</code>の対象となるソーステーブルを1つ以上指定します。
複数のソースが指定された場合、結果は全てのソースの直積（クロス結合）となります。
しかし、通常は（<code class="literal">WHERE</code>を介して）制約条件を付けて、直積のごく一部を返すように結果行を限定します。
   </p><p>
<!--
    The <literal>FROM</literal> clause can contain the following
    elements:
-->
<code class="literal">FROM</code>句には以下の要素を指定できます。

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>table_name</code></em></span></dt><dd><p>
<!--
        The name (optionally schema-qualified) of an existing table or view.
        If <literal>ONLY</literal> is specified before the table name, only that
        table is scanned.  If <literal>ONLY</literal> is not specified, the table
        and all its descendant tables (if any) are scanned.  Optionally,
        <literal>*</literal> can be specified after the table name to explicitly
        indicate that descendant tables are included.
-->
既存のテーブルもしくはビューの名前です（スキーマ修飾名も可）。
テーブル名の前に<code class="literal">ONLY</code>が指定された場合、そのテーブルのみがスキャンされます。
<code class="literal">ONLY</code>が指定されない場合、テーブルと（もしあれば）それを継承する全てのテーブルがスキャンされます。
省略することもできますが、テーブル名の後に<code class="literal">*</code>を指定することで、明示的に継承するテーブルも含まれることを示すことができます。
       </p></dd><dt><span class="term"><em class="replaceable"><code>alias</code></em></span></dt><dd><p>
<!--
        A substitute name for the <literal>FROM</literal> item containing the
        alias.  An alias is used for brevity or to eliminate ambiguity
        for self-joins (where the same table is scanned multiple
        times).  When an alias is provided, it completely hides the
        actual name of the table or function; for example given
        <literal>FROM foo AS f</literal>, the remainder of the
        <command>SELECT</command> must refer to this <literal>FROM</literal>
        item as <literal>f</literal> not <literal>foo</literal>.  If an alias is
        written, a column alias list can also be written to provide
        substitute names for one or more columns of the table.
-->
別名を含む<code class="literal">FROM</code>項目の代替名です。
別名は、指定を簡潔にするため、もしくは、自己結合（同じテーブルを複数回スキャンする結合）の曖昧さをなくすために使われます。
別名が指定されている場合は、その別名によって実際のテーブル名または関数名が完全に隠されます。
例えば、<code class="literal">FROM foo AS f</code>と指定されている場合、<code class="command">SELECT</code>文の以降の部分ではこの<code class="literal">FROM</code>項目を<code class="literal">foo</code>ではなく<code class="literal">f</code>として参照する必要があります。
テーブルの別名があれば、そのテーブルの複数の列の名前を置き換える列の別名リストを記述することができます。
       </p></dd><dt><span class="term"><code class="literal">TABLESAMPLE <em class="replaceable"><code>sampling_method</code></em> ( <em class="replaceable"><code>argument</code></em> [, ...] ) [ REPEATABLE ( <em class="replaceable"><code>seed</code></em> ) ]</code></span></dt><dd><p>
<!--
        A <literal>TABLESAMPLE</literal> clause after
        a <replaceable class="parameter">table_name</replaceable> indicates that the
        specified <replaceable class="parameter">sampling_method</replaceable>
        should be used to retrieve a subset of the rows in that table.
        This sampling precedes the application of any other filters such
        as <literal>WHERE</literal> clauses.
        The standard <productname>PostgreSQL</productname> distribution
        includes two sampling methods, <literal>BERNOULLI</literal>
        and <literal>SYSTEM</literal>, and other sampling methods can be
        installed in the database via extensions.
-->
<em class="replaceable"><code>table_name</code></em>の後の<code class="literal">TABLESAMPLE</code>句は、そのテーブルの行の部分集合を取り出すときに、指定した<em class="replaceable"><code>sampling_method</code></em>を使うべきであることを示唆します。
このサンプリングは<code class="literal">WHERE</code>など他のすべてのフィルタの適用に先立って行われます。
<span class="productname">PostgreSQL</span>の標準ディストリビューションには、<code class="literal">BERNOULLI</code>と<code class="literal">SYSTEM</code>の2つのサンプリングメソッドが含まれています。
他のサンプリングメソッドも拡張(extension)によりデータベースにインストールすることができます。
       </p><p>
<!--
        The <literal>BERNOULLI</literal> and <literal>SYSTEM</literal> sampling methods
        each accept a single <replaceable class="parameter">argument</replaceable>
        which is the fraction of the table to sample, expressed as a
        percentage between 0 and 100.  This argument can be
        any <type>real</type>-valued expression.  (Other sampling methods might
        accept more or different arguments.)  These two methods each return
        a randomly-chosen sample of the table that will contain
        approximately the specified percentage of the table's rows.
        The <literal>BERNOULLI</literal> method scans the whole table and
        selects or ignores individual rows independently with the specified
        probability.
        The <literal>SYSTEM</literal> method does block-level sampling with
        each block having the specified chance of being selected; all rows
        in each selected block are returned.
        The <literal>SYSTEM</literal> method is significantly faster than
        the <literal>BERNOULLI</literal> method when small sampling
        percentages are specified, but it may return a less-random sample of
        the table as a result of clustering effects.
-->
サンプリングメソッド<code class="literal">BERNOULLI</code>と<code class="literal">SYSTEM</code>はいずれも1つだけ<em class="replaceable"><code>argument</code></em>を取り、これはテーブルからサンプリングする割合で0から100までのパーセントで表現されます。
この引数は<code class="type">real</code>型の値を取る任意の式にできます。
（他のサンプリングメソッドは、複数の、あるいは異なる引数を受け取るかもしれません。）
これら2つの方法はいずれも、テーブルのうち指定された割合に近い行数を含む、ランダムに選択されたサンプルテーブルを返します。
<code class="literal">BERNOULLI</code>では、テーブル全体を走査し、個々の行を別々に、指定された確率に従って、選択あるいは無視します。
<code class="literal">SYSTEM</code>ではブロックレベルのサンプリングを行います。
各ブロックは指定された確率で選択され、選択されたブロック内のすべての行が返されます。
サンプリングに小さな割合が指定された場合、<code class="literal">SYSTEM</code>は<code class="literal">BERNOULLI</code>よりもかなり高速ですが、クラスタリング効果により、<code class="literal">BERNOULLI</code>に比べてランダムでないサンプルを返すかもしれません。
       </p><p>
<!--
        The optional <literal>REPEATABLE</literal> clause specifies
        a <replaceable class="parameter">seed</replaceable> number or expression to use
        for generating random numbers within the sampling method.  The seed
        value can be any non-null floating-point value.  Two queries that
        specify the same seed and <replaceable class="parameter">argument</replaceable>
        values will select the same sample of the table, if the table has
        not been changed meanwhile.  But different seed values will usually
        produce different samples.
        If <literal>REPEATABLE</literal> is not given then a new random
        sample is selected for each query, based upon a system-generated seed.
        Note that some add-on sampling methods do not
        accept <literal>REPEATABLE</literal>, and will always produce new
        samples on each use.
-->
オプションの<code class="literal">REPEATABLE</code>句では、サンプリングメソッドで乱数を生成するための<em class="replaceable"><code>seed</code></em>の数あるいは式を指定します。
シード値はNULL以外の任意の浮動点小数値とすることができます。
シードと<em class="replaceable"><code>argument</code></em>の値が同じ2つの問い合わせは、その間にテーブルに変更がなければ、同じサンプルテーブルを返します。
しかし、シードの値が異なれば、通常は異なるサンプルが生成されます。
<code class="literal">REPEATABLE</code>が指定されていなければ、システムが生成したシードに基づいて、問い合わせ毎に新しくランダムなサンプルが生成されます。
一部のアドオンのサンプリングメソッドでは<code class="literal">REPEATABLE</code>が利用できず、使用の度に常に新しいサンプルを生成することに注意してください。
       </p></dd><dt><span class="term"><em class="replaceable"><code>select</code></em></span></dt><dd><p>
<!--
        A sub-<command>SELECT</command> can appear in the
        <literal>FROM</literal> clause.  This acts as though its
        output were created as a temporary table for the duration of
        this single <command>SELECT</command> command.  Note that the
        sub-<command>SELECT</command> must be surrounded by
        parentheses, and an alias <emphasis>must</emphasis> be
        provided for it.  A
        <xref linkend="sql-values"/> command
        can also be used here.
-->
<code class="literal">FROM</code>句では、副<code class="command">SELECT</code>を使うことができます。
<code class="command">SELECT</code>コマンドの実行中、副<code class="command">SELECT</code>の出力は一時テーブルであるかのように動作します。
副<code class="command">SELECT</code>は括弧で囲まれなければなりません。また、<span class="emphasis"><em>必ず</em></span>別名を与えなければなりません。
<a class="xref" href="sql-values.html" title="VALUES"><span class="refentrytitle">VALUES</span></a>コマンドをここで使用することもできます。
       </p></dd><dt><span class="term"><em class="replaceable"><code>with_query_name</code></em></span></dt><dd><p>
<!--
        A <literal>WITH</literal> query is referenced by writing its name,
        just as though the query's name were a table name.  (In fact,
        the <literal>WITH</literal> query hides any real table of the same name
        for the purposes of the primary query.  If necessary, you can
        refer to a real table of the same name by schema-qualifying
        the table's name.)
        An alias can be provided in the same way as for a table.
-->
<code class="literal">WITH</code>問い合わせは、問い合わせの名前があたかもテーブル名であるかのように、名前を記述することで参照されます。
（実際には<code class="literal">WITH</code>問い合わせは主問い合わせの対象とするテーブルと同じ名前の実テーブルを隠蔽します。
必要ならばテーブル名をスキーマ修飾することで同じ名前の実テーブルを参照することができます。）
テーブルと同様の方法で別名を提供することができます。
       </p></dd><dt><span class="term"><em class="replaceable"><code>function_name</code></em></span></dt><dd><p>
<!--
        Function calls can appear in the <literal>FROM</literal>
        clause.  (This is especially useful for functions that return
        result sets, but any function can be used.)  This acts as
        though the function's output were created as a temporary table for the
        duration of this single <command>SELECT</command> command.
        When the optional <command>WITH ORDINALITY</command> clause is
        added to the function call, a new column is appended after
        all the function's output columns with numbering for each row.
-->
<code class="literal">FROM</code>句では、関数呼び出しを使用することができます
（これは特に関数が結果セットを返す場合に有用ですが、任意の関数を使用することもできます）。
<code class="command">SELECT</code>コマンドの実行中は、この関数の結果は一時テーブルであるかのように動作します。
関数呼び出しに<code class="command">WITH ORDINALITY</code>句を追加した時は、すべての関数の出力列の後に各行の番号の列が追加されます。
       </p><p>
<!--
        An alias can be provided in the same way as for a table.
        If an alias is written, a column
        alias list can also be written to provide substitute names for
        one or more attributes of the function's composite return
        type, including the column added by <literal>ORDINALITY</literal>
        if present.
-->
テーブルに対するのと同じように、別名を使用することができます。
別名が記述されていれば、列の別名リストを記述して、関数の複合型の戻り値の１つ以上の、<code class="literal">ORDINALITY</code>がある場合はそれが追加する列を含め、属性に対する代替名を提供することもできます。
       </p><p>
<!--
        Multiple function calls can be combined into a
        single <literal>FROM</literal>-clause item by surrounding them
        with <literal>ROWS FROM( ... )</literal>.  The output of such an item is the
        concatenation of the first row from each function, then the second
        row from each function, etc.  If some of the functions produce fewer
        rows than others, null values are substituted for the missing data, so
        that the total number of rows returned is always the same as for the
        function that produced the most rows.
-->
複数の関数呼び出しを<code class="literal">ROWS FROM( ... )</code>で括ることにより、1つの<code class="literal">FROM</code>句の項目にまとめることができます。
このような項目の出力は各関数の最初の行を結合した項目、次いで各関数の2番目の行、といった具合になります。
一部の関数が他の関数より少ない行数を出力した場合は、存在しないデータについてNULL値が代用され、戻される行数はいつでも最大の行数を返した関数と同じになります。
       </p><p>
<!--
        If the function has been defined as returning the
        <type>record</type> data type, then an alias or the key word
        <literal>AS</literal> must be present, followed by a column
        definition list in the form <literal>( <replaceable
        class="parameter">column_name</replaceable> <replaceable
        class="parameter">data_type</replaceable> <optional>, ...
        </optional>)</literal>.  The column definition list must match the
        actual number and types of columns returned by the function.
-->
関数が<code class="type">record</code>データ型を返すと定義されている場合は、別名すなわち<code class="literal">AS</code>キーワードと、それに続く<code class="literal">（<em class="replaceable"><code>column_name</code></em> <em class="replaceable"><code>data_type</code></em> [<span class="optional">, ... </span>]）</code>という形式の列定義リストが必要です。
列定義リストは、関数によって返される実際の列の数およびデータ型に一致していなければなりません。
       </p><p>
<!--
        When using the <literal>ROWS FROM( ... )</literal> syntax, if one of the
        functions requires a column definition list, it's preferred to put
        the column definition list after the function call inside
        <literal>ROWS FROM( ... )</literal>.  A column definition list can be placed
        after the <literal>ROWS FROM( ... )</literal> construct only if there's just
        a single function and no <literal>WITH ORDINALITY</literal> clause.
-->
<code class="literal">ROWS FROM( ... )</code>の構文を使う時、関数の1つが列定義のリストを必要としている場合は、<code class="literal">ROWS FROM( ... )</code>内の関数呼び出しの後に列定義のリストを置くのが望ましいです。
関数が1つだけで、<code class="literal">WITH ORDINALITY</code>句がない場合に限り、列定義のリストを<code class="literal">ROWS FROM( ... )</code>の後に置くことができます。
       </p><p>
<!--
        To use <literal>ORDINALITY</literal> together with a column definition
        list, you must use the <literal>ROWS FROM( ... )</literal> syntax and put the
        column definition list inside <literal>ROWS FROM( ... )</literal>.
-->
<code class="literal">ORDINALITY</code>を列定義のリストと一緒に使うには、<code class="literal">ROWS FROM( ... )</code>構文を使い、列定義のリストを<code class="literal">ROWS FROM( ... )</code>の内側に置かなければなりません。
       </p></dd><dt><span class="term"><em class="replaceable"><code>join_type</code></em></span></dt><dd><p>
<!--
        One of
-->
        以下のいずれかです。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">[ INNER ] JOIN</code></p></li><li class="listitem"><p><code class="literal">LEFT [ OUTER ] JOIN</code></p></li><li class="listitem"><p><code class="literal">RIGHT [ OUTER ] JOIN</code></p></li><li class="listitem"><p><code class="literal">FULL [ OUTER ] JOIN</code></p></li><li class="listitem"><p><code class="literal">CROSS JOIN</code></p></li></ul></div><p>

<!--
        For the <literal>INNER</literal> and <literal>OUTER</literal> join types, a
        join condition must be specified, namely exactly one of
        <literal>NATURAL</literal>, <literal>ON <replaceable
        class="parameter">join_condition</replaceable></literal>, or
        <literal>USING (<replaceable
        class="parameter">join_column</replaceable> [, ...])</literal>.
        See below for the meaning.  For <literal>CROSS JOIN</literal>,
        none of these clauses can appear.
-->
<code class="literal">INNER</code>および<code class="literal">OUTER</code>結合型では、結合条件、すなわち、<code class="literal">NATURAL</code>, <code class="literal">ON <em class="replaceable"><code>join_condition</code></em></code>、<code class="literal">USING (<em class="replaceable"><code>join_column</code></em> [, ...])</code>のいずれか1つのみを指定する必要があります。
それぞれの意味は後述します。
<code class="literal">CROSS JOIN</code>では、これらの句を記述しなくても構いません。
       </p><p>
<!--
        A <literal>JOIN</literal> clause combines two <literal>FROM</literal>
        items, which for convenience we will refer to as <quote>tables</quote>,
        though in reality they can be any type of <literal>FROM</literal> item.
        Use parentheses if necessary to determine the order of nesting.
        In the absence of parentheses, <literal>JOIN</literal>s nest
        left-to-right.  In any case <literal>JOIN</literal> binds more
        tightly than the commas separating <literal>FROM</literal>-list items.
-->
<code class="literal">JOIN</code>句は、2つの<code class="literal">FROM</code>項目を結び付けます。
便宜上<span class="quote">「<span class="quote">テーブル</span>」</span>と呼びますが、実際には任意の種類の<code class="literal">FROM</code>項目とすることができます。
入れ子の順番を決めるために、必要ならば括弧を使用してください。
括弧がないと、<code class="literal">JOIN</code>は左から右へ入れ子にします。
どのような場合でも<code class="literal">JOIN</code>は、カンマで分けられた<code class="literal">FROM</code>項目よりも強い結び付きを持ちます。
       </p><!--
       <para><literal>CROSS JOIN</literal> and <literal>INNER JOIN</literal>
        produce a simple Cartesian product, the same result as you get from
        listing the two tables at the top level of <literal>FROM</literal>,
        but restricted by the join condition (if any).
        <literal>CROSS JOIN</literal> is equivalent to <literal>INNER JOIN ON
        (TRUE)</literal>, that is, no rows are removed by qualification.
        These join types are just a notational convenience, since they
        do nothing you couldn't do with plain <literal>FROM</literal> and
        <literal>WHERE</literal>.
--><p><code class="literal">CROSS JOIN</code>と<code class="literal">INNER JOIN</code>は直積を1つ生成します。これは、<code class="literal">FROM</code>の最上位で2つのテーブルを結合した結果と同一です。
しかし、（指定すれば）結合条件によって制限をかけることができます。
<code class="literal">CROSS JOIN</code>は<code class="literal">INNER JOIN ON (TRUE)</code>と等価であり、条件によって削除される行はありません。
これらの結合型は記述上の便宜のためだけに用意されています。
なぜなら、通常の<code class="literal">FROM</code>と<code class="literal">WHERE</code>でできないことは何もしないからです。
       </p><!--
       <para><literal>LEFT OUTER JOIN</literal> returns all rows in the qualified
        Cartesian product (i.e., all combined rows that pass its join
        condition), plus one copy of each row in the left-hand table
        for which there was no right-hand row that passed the join
        condition.  This left-hand row is extended to the full width
        of the joined table by inserting null values for the
        right-hand columns.  Note that only the <literal>JOIN</literal>
        clause's own condition is considered while deciding which rows
        have matches.  Outer conditions are applied afterwards.
--><p><code class="literal">LEFT OUTER JOIN</code>は、条件に合う直積の全ての行（つまり、その結合条件を満たす全ての組み合わせ）に加え、左側テーブルの中で、右側テーブルには結合条件を満たす行が存在しなかった行のコピーも返します。
この左側テーブルの行を結合結果のテーブルの幅に拡張するために、右側テーブルが入る列にはNULL値が挿入されます。
マッチする行を決める時は、<code class="literal">JOIN</code>句自身の条件のみが考慮されることに注意してください。
外部結合条件は後で適用されます。
       </p><p>
<!--
        Conversely, <literal>RIGHT OUTER JOIN</literal> returns all the
        joined rows, plus one row for each unmatched right-hand row
        (extended with nulls on the left).  This is just a notational
        convenience, since you could convert it to a <literal>LEFT
        OUTER JOIN</literal> by switching the left and right tables.
-->
逆に、<code class="literal">RIGHT OUTER JOIN</code>は、全ての結合行と、左側テーブルに当てはまるものがなかった右側の行（左側はNULLで拡張されています）の1行ずつを返します。
左右のテーブルを入れ替えれば<code class="literal">LEFT OUTER JOIN</code>に変換できるので、<code class="literal">RIGHT OUTER JOIN</code>は記述上の便宜を図るため用意されているに過ぎません。
       </p><!--
       <para><literal>FULL OUTER JOIN</literal> returns all the joined rows, plus
        one row for each unmatched left-hand row (extended with nulls
        on the right), plus one row for each unmatched right-hand row
        (extended with nulls on the left).
--><p><code class="literal">FULL OUTER JOIN</code>は、全ての結合行に加え、一致しなかった左側の行（右側はNULLで拡張）、一致しなかった右側の行（左側はNULLで拡張）を全て返します。
       </p></dd><dt><span class="term"><code class="literal">ON <em class="replaceable"><code>join_condition</code></em></code></span></dt><dd><!--
       <para><replaceable class="parameter">join_condition</replaceable> is
        an expression resulting in a value of type
        <type>boolean</type> (similar to a <literal>WHERE</literal>
        clause) that specifies which rows in a join are considered to
        match.
--><p><em class="replaceable"><code>join_condition</code></em>は、結合においてどの行が一致するかを指定する、<code class="type">boolean</code>型の値を返す式です（<code class="literal">WHERE</code>句に類似しています）。
       </p></dd><dt><span class="term"><code class="literal">USING ( <em class="replaceable"><code>join_column</code></em> [, ...] )</code></span></dt><dd><p>
<!--
        A clause of the form <literal>USING ( a, b, ... )</literal> is
        shorthand for <literal>ON left_table.a = right_table.a AND
        left_table.b = right_table.b ...</literal>.  Also,
        <literal>USING</literal> implies that only one of each pair of
        equivalent columns will be included in the join output, not
        both.
-->
<code class="literal">USING ( a, b, ... )</code>という形式の句は<code class="literal">ON left_table.a = right_table.a AND left_table.b = right_table.b ...</code>の省略形です。
また<code class="literal">USING</code>は等価な列の両方ではなく片方のみが結合の出力に含まれることを意味します。
       </p></dd><dt><span class="term"><code class="literal">NATURAL</code></span></dt><dd><p>
<!--
        <literal>NATURAL</literal> is shorthand for a
        <literal>USING</literal> list that mentions all columns in the two
        tables that have matching names.  If there are no common
        column names, <literal>NATURAL</literal> is equivalent
        to <literal>ON TRUE</literal>.
-->
<code class="literal">NATURAL</code>は、2つのテーブル内の同じ名前を持つ列を全て指定した<code class="literal">USING</code>リストの省略形です。
共通の列名がない場合、<code class="literal">NATURAL</code>は<code class="literal">ON TRUE</code>と同等になります。
       </p></dd><dt><span class="term"><code class="literal">LATERAL</code></span></dt><dd><p>
<!--
        The <literal>LATERAL</literal> key word can precede a
        sub-<command>SELECT</command> <literal>FROM</literal> item.  This allows the
        sub-<command>SELECT</command> to refer to columns of <literal>FROM</literal>
        items that appear before it in the <literal>FROM</literal> list.  (Without
        <literal>LATERAL</literal>, each sub-<command>SELECT</command> is
        evaluated independently and so cannot cross-reference any other
        <literal>FROM</literal> item.)
-->
<code class="literal">LATERAL</code>キーワードを副<code class="command">SELECT</code>の<code class="literal">FROM</code>項目の前に付けることができます。
これにより、副<code class="command">SELECT</code>が<code class="literal">FROM</code>リストの中で前に現れる<code class="literal">FROM</code>項目の列を参照することができます。
（<code class="literal">LATERAL</code>がないと、副<code class="command">SELECT</code>それぞれが個別に評価され、他の<code class="literal">FROM</code>項目とのクロス参照を行うことができません。）
       </p><!--
       <para><literal>LATERAL</literal> can also precede a function-call
        <literal>FROM</literal> item, but in this case it is a noise word, because
        the function expression can refer to earlier <literal>FROM</literal> items
        in any case.
--><p>
<code class="literal">LATERAL</code>を関数を呼び出す<code class="literal">FROM</code>の前に付けることもできます。
しかしこの場合、無意味な単語になります。
関数式はどのような場合でもより前の<code class="literal">FROM</code>項目を参照することができるからです。
       </p><p>
<!--
        A <literal>LATERAL</literal> item can appear at top level in the
        <literal>FROM</literal> list, or within a <literal>JOIN</literal> tree.  In the
        latter case it can also refer to any items that are on the left-hand
        side of a <literal>JOIN</literal> that it is on the right-hand side of.
-->
<code class="literal">LATERAL</code>項目は<code class="literal">FROM</code>の最上位レベルや<code class="literal">JOIN</code>ツリー内に記述することができます。
後者の場合、<code class="literal">JOIN</code>の右辺にあれば、左辺にある任意の項目を参照することができます。
       </p><p>
<!--
        When a <literal>FROM</literal> item contains <literal>LATERAL</literal>
        cross-references, evaluation proceeds as follows: for each row of the
        <literal>FROM</literal> item providing the cross-referenced column(s), or
        set of rows of multiple <literal>FROM</literal> items providing the
        columns, the <literal>LATERAL</literal> item is evaluated using that
        row or row set's values of the columns.  The resulting row(s) are
        joined as usual with the rows they were computed from.  This is
        repeated for each row or set of rows from the column source table(s).
-->
<code class="literal">FROM</code>項目が<code class="literal">LATERAL</code>クロス参照を含む場合、評価は次のように行われます。
クロス参照される列を提供する<code class="literal">FROM</code>項目の各行、または、その列を提供する複数の<code class="literal">FROM</code>項目の行集合に対して、
<code class="literal">LATERAL</code>項目は列の行または行集合を使用して評価されます。
結果となる行は、計算された行と通常通り結合されます。
これが各行または列ソーステーブルからの行集合に対して繰り返されます。
       </p><p>
<!--
        The column source table(s) must be <literal>INNER</literal> or
        <literal>LEFT</literal> joined to the <literal>LATERAL</literal> item, else
        there would not be a well-defined set of rows from which to compute
        each set of rows for the <literal>LATERAL</literal> item.  Thus,
        although a construct such as <literal><replaceable>X</replaceable> RIGHT JOIN
        LATERAL <replaceable>Y</replaceable></literal> is syntactically valid, it is
        not actually allowed for <replaceable>Y</replaceable> to reference
        <replaceable>X</replaceable>.
-->
列ソーステーブルは<code class="literal">LATERAL</code>項目と<code class="literal">INNER</code>または<code class="literal">LEFT</code>結合されていなければなりません。
さもないと、
<code class="literal">LATERAL</code>項目において各行集合を計算するための行集合が完全に定義することができません。
したがって<code class="literal"><em class="replaceable"><code>X</code></em> RIGHT JOIN LATERAL <em class="replaceable"><code>Y</code></em></code>という式は構文としては有効ですが、実際には<em class="replaceable"><code>Y</code></em>では<em class="replaceable"><code>X</code></em>を参照することができません。
       </p></dd></dl></div><p>
   </p></div><div class="refsect2" id="SQL-WHERE"><h3><code class="literal">WHERE</code>句</h3><!--
   <title id="sql-where-title"><literal>WHERE</literal> Clause</title>
--><p>
<!--
    The optional <literal>WHERE</literal> clause has the general form
-->
<code class="literal">WHERE</code>句の一般的な構文は以下の通りです（この句は省略可能です）。
</p><pre class="synopsis">
WHERE <em class="replaceable"><code>condition</code></em>
</pre><p>
<!--
    where <replaceable class="parameter">condition</replaceable> is
    any expression that evaluates to a result of type
    <type>boolean</type>.  Any row that does not satisfy this
    condition will be eliminated from the output.  A row satisfies the
    condition if it returns true when the actual row values are
    substituted for any variable references.
-->
<em class="replaceable"><code>condition</code></em>は、評価の結果として<code class="type">boolean</code>型を返す任意の式です。
この条件を満たさない行は全て出力から取り除かれます。
全ての変数に実際の行の値を代入して、式が真を返す場合、その行は条件を満たすとみなされます。
   </p></div><div class="refsect2" id="SQL-GROUPBY"><h3><code class="literal">GROUP BY</code>句</h3><!--
   <title id="sql-groupby-title"><literal>GROUP BY</literal> Clause</title>
--><p>
<!--
    The optional <literal>GROUP BY</literal> clause has the general form
-->
<code class="literal">GROUP BY</code>句の一般的な構文は以下の通りです（この句は省略可能です）。
</p><pre class="synopsis">
GROUP BY <em class="replaceable"><code>grouping_element</code></em> [, ...]
</pre><p>
   </p><p>
<!--
    <literal>GROUP BY</literal> will condense into a single row all
    selected rows that share the same values for the grouped
    expressions.  An <replaceable
    class="parameter">expression</replaceable> used inside a
    <replaceable class="parameter">grouping_element</replaceable>
    can be an input column name, or the name or ordinal number of an
    output column (<command>SELECT</command> list item), or an arbitrary
    expression formed from input-column values.  In case of ambiguity,
    a <literal>GROUP BY</literal> name will be interpreted as an
    input-column name rather than an output column name.
-->
<code class="literal">GROUP BY</code>は、グループ化のために与えられた式を評価し、結果が同じ値になった行を1つの行にまとめる機能を持ちます。
<em class="replaceable"><code>grouping_element</code></em>の内側で使われる<em class="replaceable"><code>expression</code></em>には、入力列の名前、出力列（<code class="command">SELECT</code>リスト項目）の名前/序数、あるいは入力列の値から計算される任意の式を取ることができます。
判断がつかない時は、<code class="literal">GROUP BY</code>の名前は出力列名ではなく入力列名として解釈されます。
   </p><p>
<!--
    If any of <literal>GROUPING SETS</literal>, <literal>ROLLUP</literal> or
    <literal>CUBE</literal> are present as grouping elements, then the
    <literal>GROUP BY</literal> clause as a whole defines some number of
    independent <replaceable>grouping sets</replaceable>.  The effect of this is
    equivalent to constructing a <literal>UNION ALL</literal> between
    subqueries with the individual grouping sets as their
    <literal>GROUP BY</literal> clauses.  For further details on the handling
    of grouping sets see <xref linkend="queries-grouping-sets"/>.
-->
グループ化の要素として<code class="literal">GROUPING SETS</code>、<code class="literal">ROLLUP</code>、<code class="literal">CUBE</code>のいずれかが指定されている場合、<code class="literal">GROUP BY</code>句は全体でいくつかの独立した<em class="firstterm">グループ化セット</em>を定義します。
この効果は、個々のグループ化セットを<code class="literal">GROUP BY</code>句で定義する副問い合わせを<code class="literal">UNION ALL</code>するのと同等です。
グループ化セットの処理の詳細については、<a class="xref" href="queries-table-expressions.html#QUERIES-GROUPING-SETS" title="7.2.4. GROUPING SETS、CUBE、ROLLUP">7.2.4</a>を参照してください。
   </p><p>
<!--
    Aggregate functions, if any are used, are computed across all rows
    making up each group, producing a separate value for each group.
    (If there are aggregate functions but no <literal>GROUP BY</literal>
    clause, the query is treated as having a single group comprising all
    the selected rows.)
    The set of rows fed to each aggregate function can be further filtered by
    attaching a <literal>FILTER</literal> clause to the aggregate function
    call; see <xref linkend="syntax-aggregates"/> for more information.  When
    a <literal>FILTER</literal> clause is present, only those rows matching it
    are included in the input to that aggregate function.
-->
集約関数が使用された場合、各グループ内の全ての行を対象に計算が行われ、グループごとに別々の値が生成されます
（集約関数が使われていて<code class="literal">GROUP BY</code>がない場合、その問い合わせは選択された全ての行からなる1つのグループを持つものとして扱われます）。
集約関数の入力となる行の集合は、集約関数の呼び出しに<code class="literal">FILTER</code>句を付けることで、さらに絞り込むことができます。
詳しくは<a class="xref" href="sql-expressions.html#SYNTAX-AGGREGATES" title="4.2.7. 集約式">4.2.7</a>を参照してください。
<code class="literal">FILTER</code>句があると、その条件に適合する行だけが集約関数の入力行に取り込まれます。
   </p><p>
<!--
    When <literal>GROUP BY</literal> is present,
    or any aggregate functions are present, it is not valid for
    the <command>SELECT</command> list expressions to refer to
    ungrouped columns except within aggregate functions or when the
    ungrouped column is functionally dependent on the grouped columns,
    since there would otherwise be more than one possible value to
    return for an ungrouped column.  A functional dependency exists if
    the grouped columns (or a subset thereof) are the primary key of
    the table containing the ungrouped column.
-->
<code class="literal">GROUP BY</code>が存在する場合、あるいは集約関数が存在する場合、集約関数内部以外で、グループ化されていない列を参照する、あるいはグループ化されていない列がグループ化された列に関数依存する<code class="command">SELECT</code>リストの式は無効になります。
こうしないとグループ化されていない列について返される値は複数の値になってしまう可能性があるからです。
グループ化された列(またはその部分集合)がグループ化されていない列を含むテーブルの主キーである場合、関数従属性が存在します。
   </p><p>
<!--
    Keep in mind that all aggregate functions are evaluated before
    evaluating any <quote>scalar</quote> expressions in the <literal>HAVING</literal>
    clause or <literal>SELECT</literal> list.  This means that, for example,
    a <literal>CASE</literal> expression cannot be used to skip evaluation of
    an aggregate function; see <xref linkend="syntax-express-eval"/>.
-->
すべての集約関数は、<code class="literal">HAVING</code>句や<code class="literal">SELECT</code>リストのどの<span class="quote">「<span class="quote">スカラー</span>」</span>式よりも先に評価されることに注意してください。
これは例えば、<code class="literal">CASE</code>式を集約関数の評価をスキップするために使うことはできない、ということを意味します。
<a class="xref" href="sql-expressions.html#SYNTAX-EXPRESS-EVAL" title="4.2.14. 式の評価規則">4.2.14</a>を参照してください。
   </p><p>
<!--
    Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal> and <literal>FOR KEY SHARE</literal> cannot be
    specified with <literal>GROUP BY</literal>.
-->
現在は、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>を<code class="literal">GROUP BY</code>と合わせて使うことはできません。
   </p></div><div class="refsect2" id="SQL-HAVING"><h3><code class="literal">HAVING</code>句</h3><!--
   <title id="sql-having-title"><literal>HAVING</literal> Clause</title>
--><p>
<!--
    The optional <literal>HAVING</literal> clause has the general form
-->
<code class="literal">HAVING</code>句の一般的な構文は以下の通りです（この句は省略可能です）。
</p><pre class="synopsis">
HAVING <em class="replaceable"><code>condition</code></em>
</pre><p>
<!--
    where <replaceable class="parameter">condition</replaceable> is
    the same as specified for the <literal>WHERE</literal> clause.
-->
<em class="replaceable"><code>condition</code></em>は<code class="literal">WHERE</code>句で指定するものと同じです。
   </p><p>
<!--
    <literal>HAVING</literal> eliminates group rows that do not
    satisfy the condition.  <literal>HAVING</literal> is different
    from <literal>WHERE</literal>: <literal>WHERE</literal> filters
    individual rows before the application of <literal>GROUP
    BY</literal>, while <literal>HAVING</literal> filters group rows
    created by <literal>GROUP BY</literal>.  Each column referenced in
    <replaceable class="parameter">condition</replaceable> must
    unambiguously reference a grouping column, unless the reference
    appears within an aggregate function or the ungrouped column is
    functionally dependent on the grouping columns.
-->
<code class="literal">HAVING</code>は、グループ化された行の中で、条件を満たさない行を取り除く機能を持ちます。
<code class="literal">HAVING</code>と<code class="literal">WHERE</code>は次の点が異なります。
<code class="literal">WHERE</code>が、<code class="literal">GROUP BY</code>の適用前に個々の行に対してフィルタを掛けるのに対し、<code class="literal">HAVING</code>は、<code class="literal">GROUP BY</code>の適用後に生成されたグループ化された行に対してフィルタをかけます。
<em class="replaceable"><code>condition</code></em>内で使用する列は、集約関数内で使用される場合とグループ化されない列がグループ化される列に関数依存する場合を除き、グループ化された列を一意に参照するものでなければなりません。
   </p><p>
<!--
    The presence of <literal>HAVING</literal> turns a query into a grouped
    query even if there is no <literal>GROUP BY</literal> clause.  This is the
    same as what happens when the query contains aggregate functions but
    no <literal>GROUP BY</literal> clause.  All the selected rows are considered to
    form a single group, and the <command>SELECT</command> list and
    <literal>HAVING</literal> clause can only reference table columns from
    within aggregate functions.  Such a query will emit a single row if the
    <literal>HAVING</literal> condition is true, zero rows if it is not true.
-->
<code class="literal">HAVING</code>句があると、<code class="literal">GROUP BY</code>句がなかったとしても問い合わせはグループ化された問い合わせになります。
<code class="literal">GROUP BY</code>句を持たない問い合わせが集約関数を含む場合と同様です。
選択された行はすべて、1つのグループを形成するものとみなされます。また、<code class="command">SELECT</code>リストと<code class="literal">HAVING</code>句では、集約関数が出力するテーブル列しか参照することができません。
こうした問い合わせでは、<code class="literal">HAVING</code>が真の場合には単一の行を、真以外の場合は0行を出力します。
   </p><p>
<!--
    Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal> and <literal>FOR KEY SHARE</literal> cannot be
    specified with <literal>HAVING</literal>.
-->
現在は、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>を<code class="literal">HAVING</code>と合わせて使うことはできません。
   </p></div><div class="refsect2" id="SQL-WINDOW"><h3><code class="literal">WINDOW</code>句</h3><!--
   <title id="sql-window-title"><literal>WINDOW</literal> Clause</title>
--><p>
<!--
    The optional <literal>WINDOW</literal> clause has the general form
-->
<code class="literal">WINDOW</code>句(省略可能)の一般的な構文は以下の通りです。
</p><pre class="synopsis">
WINDOW <em class="replaceable"><code>window_name</code></em> AS ( <em class="replaceable"><code>window_definition</code></em> ) [, ...]
</pre><p>
<!--
    where <replaceable class="parameter">window_name</replaceable> is
    a name that can be referenced from <literal>OVER</literal> clauses or
    subsequent window definitions, and
    <replaceable class="parameter">window_definition</replaceable> is
-->
ここで<em class="replaceable"><code>window_name</code></em>は、<code class="literal">OVER</code>句やこの後のウィンドウ定義で参照することができる名前です。
また、<em class="replaceable"><code>window_definition</code></em>は以下の通りです。
</p><pre class="synopsis">
[ <em class="replaceable"><code>existing_window_name</code></em> ]
[ PARTITION BY <em class="replaceable"><code>expression</code></em> [, ...] ]
[ ORDER BY <em class="replaceable"><code>expression</code></em> [ ASC | DESC | USING <em class="replaceable"><code>operator</code></em> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <em class="replaceable"><code>frame_clause</code></em> ]
</pre><p>
   </p><p>
<!--
    If an <replaceable class="parameter">existing_window_name</replaceable>
    is specified it must refer to an earlier entry in the <literal>WINDOW</literal>
    list; the new window copies its partitioning clause from that entry,
    as well as its ordering clause if any.  In this case the new window cannot
    specify its own <literal>PARTITION BY</literal> clause, and it can specify
    <literal>ORDER BY</literal> only if the copied window does not have one.
    The new window always uses its own frame clause; the copied window
    must not specify a frame clause.
-->
<em class="replaceable"><code>existing_window_name</code></em>を指定する場合、それは<code class="literal">WINDOW</code>リスト内のそれより前にある項目を参照しなければなりません。
新しいウィンドウはその<code class="literal">PARTITION BY</code>句をその項目からコピーします。
<code class="literal">ORDER BY</code>句があった場合も同様です。
この場合、新しいウィンドウでは独自の<code class="literal">PARTITION BY</code>句を指定することはできません。
また、コピーされたウィンドウが<code class="literal">ORDER BY</code>を持たない場合のみ<code class="literal">ORDER BY</code>を指定することができます。
新しいウィンドウは常に独自のフレーム句を使用します。
コピーされたウィンドウはフレーム句を指定してはなりません。
   </p><p>
<!--
    The elements of the <literal>PARTITION BY</literal> list are interpreted in
    much the same fashion as elements of a
    <xref linkend="sql-groupby" endterm="sql-groupby-title"/>, except that
    they are always simple expressions and never the name or number of an
    output column.
    Another difference is that these expressions can contain aggregate
    function calls, which are not allowed in a regular <literal>GROUP BY</literal>
    clause.  They are allowed here because windowing occurs after grouping
    and aggregation.
-->
<code class="literal">PARTITION BY</code>リストの要素は<a class="xref" href="sql-select.html#SQL-GROUPBY" title="GROUP BY句"><code class="literal">GROUP BY</code>句</a>の要素とほとんど同じように解釈されます。
ただし、こちらは常に単純な式であり、出力列の名前や番号ではないことが異なります。
他にも違いがあり、これらの式は、通常の<code class="literal">GROUP BY</code>句では許されない、集約関数を含めることができるという点です。
グループ化および集約処理の後にウィンドウ処理が動作するため、これらでは許されています。
   </p><p>
<!--
    Similarly, the elements of the <literal>ORDER BY</literal> list are interpreted
    in much the same fashion as elements of an
    <xref linkend="sql-orderby" endterm="sql-orderby-title"/>, except that
    the expressions are always taken as simple expressions and never the name
    or number of an output column.
-->
同様に、<code class="literal">ORDER BY</code>リストの要素は<a class="xref" href="sql-select.html#SQL-ORDERBY" title="ORDER BY句"><code class="literal">ORDER BY</code>句</a>の要素とほとんど同じように解釈されます。
ただし、この式は常に単純な式であり、出力列の名前や番号ではないことが異なります。
   </p><p>
<!--
    The optional <replaceable class="parameter">frame_clause</replaceable> defines
    the <firstterm>window frame</firstterm> for window functions that depend on the
    frame (not all do).  The window frame is a set of related rows for
    each row of the query (called the <firstterm>current row</firstterm>).
    The <replaceable class="parameter">frame_clause</replaceable> can be one of
-->
<em class="replaceable"><code>frame_clause</code></em>を指定すると、（すべてではありませんが）フレームに依存するウィンドウ関数用の<em class="firstterm">ウィンドウフレーム</em>を定義できます。
ウィンドウフレームは、問い合わせの各行(<em class="firstterm">現在の行</em>と呼ばれます)に関連する行の集合です。
<em class="replaceable"><code>frame_clause</code></em>は以下のいずれかを取ることができます。

</p><pre class="synopsis">
{ RANGE | ROWS | GROUPS } <em class="replaceable"><code>frame_start</code></em> [ <em class="replaceable"><code>frame_exclusion</code></em> ]
{ RANGE | ROWS | GROUPS } BETWEEN <em class="replaceable"><code>frame_start</code></em> AND <em class="replaceable"><code>frame_end</code></em> [ <em class="replaceable"><code>frame_exclusion</code></em> ]
</pre><p>

<!--
    where <replaceable>frame_start</replaceable>
    and <replaceable>frame_end</replaceable> can be one of
-->
ここで<em class="replaceable"><code>frame_start</code></em>と<em class="replaceable"><code>frame_end</code></em>は以下のいずれかを取ることができます。

</p><pre class="synopsis">
UNBOUNDED PRECEDING
<em class="replaceable"><code>offset</code></em> PRECEDING
CURRENT ROW
<em class="replaceable"><code>offset</code></em> FOLLOWING
UNBOUNDED FOLLOWING
</pre><p>

<!--
    and <replaceable>frame_exclusion</replaceable> can be one of
-->
また、<em class="replaceable"><code>frame_exclusion</code></em>には以下のいずれかを取ることができます。

</p><pre class="synopsis">
EXCLUDE CURRENT ROW
EXCLUDE GROUP
EXCLUDE TIES
EXCLUDE NO OTHERS
</pre><p>

<!--
    If <replaceable>frame_end</replaceable> is omitted it defaults to <literal>CURRENT
    ROW</literal>.  Restrictions are that
    <replaceable>frame_start</replaceable> cannot be <literal>UNBOUNDED FOLLOWING</literal>,
    <replaceable>frame_end</replaceable> cannot be <literal>UNBOUNDED PRECEDING</literal>,
    and the <replaceable>frame_end</replaceable> choice cannot appear earlier in the
    above list of <replaceable>frame_start</replaceable>
    and <replaceable>frame_end</replaceable> options than
    the <replaceable>frame_start</replaceable> choice does &mdash; for example
    <literal>RANGE BETWEEN CURRENT ROW AND <replaceable>offset</replaceable>
    PRECEDING</literal> is not allowed.
-->
<em class="replaceable"><code>frame_end</code></em>が省略された場合、デフォルトで<code class="literal">CURRENT ROW</code>となります。
<em class="replaceable"><code>frame_start</code></em>は<code class="literal">UNBOUNDED FOLLOWING</code>とすることができない、<em class="replaceable"><code>frame_end</code></em>は<code class="literal">UNBOUNDED PRECEDING</code>とすることができない、また、<em class="replaceable"><code>frame_start</code></em>と<em class="replaceable"><code>frame_end</code></em>のオプションの上記リストで<em class="replaceable"><code>frame_end</code></em>の選択を<em class="replaceable"><code>frame_start</code></em>の選択よりも手前に現れるものにはできない、という制限があります。
例えば<code class="literal">RANGE BETWEEN CURRENT ROW AND <em class="replaceable"><code>offset</code></em> PRECEDING</code>は許されません。
   </p><p>
<!--
    The default framing option is <literal>RANGE UNBOUNDED PRECEDING</literal>,
    which is the same as <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND
    CURRENT ROW</literal>; it sets the frame to be all rows from the partition start
    up through the current row's last <firstterm>peer</firstterm> (a row
    that the window's <literal>ORDER BY</literal> clause considers
    equivalent to the current row; all rows are peers if there
    is no <literal>ORDER BY</literal>).
    In general, <literal>UNBOUNDED PRECEDING</literal> means that the frame
    starts with the first row of the partition, and similarly
    <literal>UNBOUNDED FOLLOWING</literal> means that the frame ends with the last
    row of the partition, regardless
    of <literal>RANGE</literal>, <literal>ROWS</literal>
    or <literal>GROUPS</literal> mode.
    In <literal>ROWS</literal> mode, <literal>CURRENT ROW</literal> means
    that the frame starts or ends with the current row; but
    in <literal>RANGE</literal> or <literal>GROUPS</literal> mode it means
    that the frame starts or ends with the current row's first or last peer
    in the <literal>ORDER BY</literal> ordering.
    The <replaceable>offset</replaceable> <literal>PRECEDING</literal> and
    <replaceable>offset</replaceable> <literal>FOLLOWING</literal> options
    vary in meaning depending on the frame mode.
    In <literal>ROWS</literal> mode, the <replaceable>offset</replaceable>
    is an integer indicating that the frame starts or ends that many rows
    before or after the current row.
    In <literal>GROUPS</literal> mode, the <replaceable>offset</replaceable>
    is an integer indicating that the frame starts or ends that many peer
    groups before or after the current row's peer group, where
    a <firstterm>peer group</firstterm> is a group of rows that are
    equivalent according to the window's <literal>ORDER BY</literal> clause.
    In <literal>RANGE</literal> mode, use of
    an <replaceable>offset</replaceable> option requires that there be
    exactly one <literal>ORDER BY</literal> column in the window definition.
    Then the frame contains those rows whose ordering column value is no
    more than <replaceable>offset</replaceable> less than
    (for <literal>PRECEDING</literal>) or more than
    (for <literal>FOLLOWING</literal>) the current row's ordering column
    value.  In these cases the data type of
    the <replaceable>offset</replaceable> expression depends on the data
    type of the ordering column.  For numeric ordering columns it is
    typically of the same type as the ordering column, but for datetime
    ordering columns it is an <type>interval</type>.
    In all these cases, the value of the <replaceable>offset</replaceable>
    must be non-null and non-negative.  Also, while
    the <replaceable>offset</replaceable> does not have to be a simple
    constant, it cannot contain variables, aggregate functions, or window
    functions.
-->
デフォルトのフレーム化オプションは<code class="literal">RANGE UNBOUNDED PRECEDING</code>です。
これは<code class="literal">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>と同じで、
パーティションの先頭から現在の行の最後の<em class="firstterm">ピア</em>（ウィンドウの<code class="literal">ORDER BY</code>句が現在行と同等とみなす行、<code class="literal">ORDER BY</code>が無ければ全ての行がピア）までのすべての行をフレームとします。
一般的に、<code class="literal">RANGE</code>や<code class="literal">ROWS</code>、<code class="literal">GROUPS</code>のモードにかかわらず、<code class="literal">UNBOUNDED PRECEDING</code>はフレームがパーティションの先頭行から開始することを意味し、同様に<code class="literal">UNBOUNDED FOLLOWING</code>はフレームがパーティションの最終行で終了することを意味します。
<code class="literal">ROWS</code>モードでは<code class="literal">CURRENT ROW</code>はフレームが現在の行で開始または終了することを意味しますが、<code class="literal">RANGE</code>あるいは<code class="literal">GROUPS</code>モードではフレームが<code class="literal">ORDER BY</code>順序における現在行の最初または最後のピアで開始または終了することを意味します。
<em class="replaceable"><code>offset</code></em> <code class="literal">PRECEDING</code>および<em class="replaceable"><code>offset</code></em> <code class="literal">FOLLOWING</code>オプションの意味はフレームのモードによって異なります。
<code class="literal">ROWS</code>モードでは、<em class="replaceable"><code>offset</code></em>はフレームが現在行の何行前または何行後に開始または終了するかを示す整数です。
<code class="literal">GROUPS</code>モードでは、<em class="replaceable"><code>offset</code></em>はフレームが現在行のピアグループからピアグループ何個、前または後で開始または終了するかを示す整数です。
ここで<em class="firstterm">ピアグループ</em>とはウィンドウの<code class="literal">ORDER BY</code>句において等価の行のグループです。
<code class="literal">RANGE</code>モードでは、<em class="replaceable"><code>offset</code></em>オプションを使うには、ウィンドウ定義に一つだけ<code class="literal">ORDER BY</code>列があることが必要です。
それで、整列する列の値が<em class="replaceable"><code>offset</code></em>を超えないだけ、現在行の整列する列の値より小さい（<code class="literal">PRECEDING</code>に対して）、あるいは、より大きい（<code class="literal">FOLLOWING</code>に対して）行がフレームに含まれます。
この場合、<em class="replaceable"><code>offset</code></em>式のデータ型は整列する列のデータ型によって決まります。
数値の整列する列に対する<em class="replaceable"><code>offset</code></em>は一般的に整列する列と同じ型ですが、日付時刻の整列する列に対しては<code class="type">interval</code>になります。
これら全ての場合で、<em class="replaceable"><code>offset</code></em>の値は非NULLかつ非負でなければなりません。
また、<em class="replaceable"><code>offset</code></em>が単純な定数である必要はありませんが、変数や集約関数、ウィンドウ関数を含めることはできません。
   </p><p>
<!--
    The <replaceable>frame_exclusion</replaceable> option allows rows around
    the current row to be excluded from the frame, even if they would be
    included according to the frame start and frame end options.
    <literal>EXCLUDE CURRENT ROW</literal> excludes the current row from the
    frame.
    <literal>EXCLUDE GROUP</literal> excludes the current row and its
    ordering peers from the frame.
    <literal>EXCLUDE TIES</literal> excludes any peers of the current
    row from the frame, but not the current row itself.
    <literal>EXCLUDE NO OTHERS</literal> simply specifies explicitly the
    default behavior of not excluding the current row or its peers.
-->
<em class="replaceable"><code>frame_exclusion</code></em>オブションは現在行の周辺の行を、フレーム開始とフレーム終了のオプションにより含まれるものであっても、フレームから除外することができます。
<code class="literal">EXCLUDE CURRENT ROW</code>はフレームから現在行を除外します。
<code class="literal">EXCLUDE GROUP</code>はフレームから現在行とその整列ピアを除外します。
<code class="literal">EXCLUDE TIES</code>は現在行自身を除いた現在行のピアをフレームから除外します。
<code class="literal">EXCLUDE NO OTHERS</code>は単に、現在行もそのピアも除外しないというデフォルトの振る舞いを明示的に指定します。
   </p><p>
<!--
    Beware that the <literal>ROWS</literal> mode can produce unpredictable
    results if the <literal>ORDER BY</literal> ordering does not order the rows
    uniquely.  The <literal>RANGE</literal> and <literal>GROUPS</literal>
    modes are designed to ensure that rows that are peers in
    the <literal>ORDER BY</literal> ordering are treated alike: all rows of
    a given peer group will be in the frame or excluded from it.
-->
<code class="literal">ORDER BY</code>順序によりその行を一意に順序付けできない場合、<code class="literal">ROWS</code>モードが予期できない結果をもたらす可能性があることに注意して下さい。
<code class="literal">RANGE</code>および<code class="literal">GROUPS</code>モードは、<code class="literal">ORDER BY</code>順序におけるピアとなる行が同等に扱われる、すなわち、与えられたピアグループの全行がフレームに入るか除外されるように設計されています。
   </p><p>
<!--
    The purpose of a <literal>WINDOW</literal> clause is to specify the
    behavior of <firstterm>window functions</firstterm> appearing in the query's
    <xref linkend="sql-select-list" endterm="sql-select-list-title"/> or
    <xref linkend="sql-orderby" endterm="sql-orderby-title"/>.  These functions
    can reference the <literal>WINDOW</literal> clause entries by name
    in their <literal>OVER</literal> clauses.  A <literal>WINDOW</literal> clause
    entry does not have to be referenced anywhere, however; if it is not
    used in the query it is simply ignored.  It is possible to use window
    functions without any <literal>WINDOW</literal> clause at all, since
    a window function call can specify its window definition directly in
    its <literal>OVER</literal> clause.  However, the <literal>WINDOW</literal>
    clause saves typing when the same window definition is needed for more
    than one window function.
-->
<code class="literal">WINDOW</code>句の目的は、問い合わせの<a class="xref" href="sql-select.html#SQL-SELECT-LIST" title="SELECTリスト"><code class="command">SELECT</code>リスト</a>または<a class="xref" href="sql-select.html#SQL-ORDERBY" title="ORDER BY句"><code class="literal">ORDER BY</code>句</a>に記載される<em class="firstterm">ウィンドウ関数</em>の動作を規定することです。
これらの関数はその<code class="literal">OVER</code>句において名前で<code class="literal">WINDOW</code>句の項目を参照することができます。
しかし<code class="literal">WINDOW</code>句の項目は他で参照される必要はありません。
問い合わせ内で使用されなかったものは、単に無視されます。
ウィンドウ関数呼び出しは<code class="literal">OVER</code>句でウィンドウ定義を直接規定することができますので、<code class="literal">WINDOW</code>句を全く使わずにウィンドウ関数を使用することができます。
しかし<code class="literal">WINDOW</code>句は、同じウィンドウ定義が複数のウィンドウ関数で必要とされる場合に入力量を省くことができます。
   </p><p>
<!--
    Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal> and <literal>FOR KEY SHARE</literal> cannot be
    specified with <literal>WINDOW</literal>.
-->
現在は、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>を<code class="literal">WINDOW</code>と合わせて使うことはできません。
   </p><p>
<!--
    Window functions are described in detail in
    <xref linkend="tutorial-window"/>,
    <xref linkend="syntax-window-functions"/>, and
    <xref linkend="queries-window"/>.
-->
ウィンドウ関数に関する詳細については<a class="xref" href="tutorial-window.html" title="3.5. ウィンドウ関数">3.5</a>、<a class="xref" href="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS" title="4.2.8. ウィンドウ関数呼び出し">4.2.8</a>、<a class="xref" href="queries-table-expressions.html#QUERIES-WINDOW" title="7.2.5. ウィンドウ関数処理">7.2.5</a>を参照してください。
   </p></div><div class="refsect2" id="SQL-SELECT-LIST"><h3><code class="command">SELECT</code>リスト</h3><!--
   <title id="sql-select-list-title"><command>SELECT</command> List</title>
--><p>
<!--
    The <command>SELECT</command> list (between the key words
    <literal>SELECT</literal> and <literal>FROM</literal>) specifies expressions
    that form the output rows of the <command>SELECT</command>
    statement.  The expressions can (and usually do) refer to columns
    computed in the <literal>FROM</literal> clause.
-->
<code class="command">SELECT</code>リスト（<code class="literal">SELECT</code>キーワードと<code class="literal">FROM</code>キーワードの間にあるもの）は、<code class="command">SELECT</code>文の出力行を形成する式を指定するものです。
この式では、<code class="literal">FROM</code>句で処理後の列を参照することができます（通常は実際に参照します）。
   </p><p>
<!--
    Just as in a table, every output column of a <command>SELECT</command>
    has a name.  In a simple <command>SELECT</command> this name is just
    used to label the column for display, but when the <command>SELECT</command>
    is a sub-query of a larger query, the name is seen by the larger query
    as the column name of the virtual table produced by the sub-query.
    To specify the name to use for an output column, write
    <literal>AS</literal> <replaceable class="parameter">output_name</replaceable>
    after the column's expression.  (You can omit <literal>AS</literal>,
    but only if the desired output name does not match any
    <productname>PostgreSQL</productname> keyword (see <xref
    linkend="sql-keywords-appendix"/>).  For protection against possible
    future keyword additions, it is recommended that you always either
    write <literal>AS</literal> or double-quote the output name.)
    If you do not specify a column name, a name is chosen automatically
    by <productname>PostgreSQL</productname>.  If the column's expression
    is a simple column reference then the chosen name is the same as that
    column's name.  In more complex cases a function or type name may be
    used, or the system may fall back on a generated name such as
    <literal>?column?</literal>.
-->
テーブルの場合と同様に、<code class="command">SELECT</code>の出力列はすべて名前を持ちます。
簡単な<code class="command">SELECT</code>では、この名前は列に表示用のラベルを付けるために使用されるだけです。
しかし<code class="command">SELECT</code>が大規模な問い合わせの副問い合わせである場合、大規模な問い合わせ側で副問い合わせで生成された仮想のテーブルの列名としてこの名前が参照されます。
出力列として使用するための名前を指定するためには、列式の後に<code class="literal">AS</code> <em class="replaceable"><code>output_name</code></em>と記述してください。
（希望する列名が<span class="productname">PostgreSQL</span>のキーワード（<a class="xref" href="sql-keywords-appendix.html" title="付録C SQLキーワード">付録C</a>を参照）に一致しない場合にのみ<code class="literal">AS</code>を省略することができます。
将来あり得るキーワードの追加に備えるために、常に<code class="literal">AS</code>を記述する、あるいは、出力名を二重引用符で括ることを推奨します。）
列名を指定しない場合、名前は<span class="productname">PostgreSQL</span>により自動的に付けられます。
列式が単純な列参照であれば、つけられる名前はその列の名前と同じものです。
より複雑な場合では、関数名または型名が使用されるかもしれません。さもなければ<code class="literal">?column?</code>のように生成される名前になるかもしれません。
   </p><p>
<!--
    An output column's name can be used to refer to the column's value in
    <literal>ORDER BY</literal> and <literal>GROUP BY</literal> clauses, but not in the
    <literal>WHERE</literal> or <literal>HAVING</literal> clauses; there you must write
    out the expression instead.
-->
<code class="literal">ORDER BY</code>句と<code class="literal">GROUP BY</code>句内で列の値を参照する時も、出力列名を使用できます。
しかし、<code class="literal">WHERE</code>や<code class="literal">HAVING</code>句では使用できません。これらでは式を書かなければなりません。
   </p><p>
<!--
    Instead of an expression, <literal>*</literal> can be written in
    the output list as a shorthand for all the columns of the selected
    rows.  Also, you can write <literal><replaceable
    class="parameter">table_name</replaceable>.*</literal> as a
    shorthand for the columns coming from just that table.  In these
    cases it is not possible to specify new names with <literal>AS</literal>;
    the output column names will be the same as the table columns' names.
-->
リストには、選択された行の全ての列を表す省略形として、式ではなく<code class="literal">*</code>と書くことができます。
また、そのテーブルに由来する列のみを表す省略形として、<code class="literal"><em class="replaceable"><code>table_name</code></em>.*</code>と書くこともできます。
このような場合、<code class="literal">AS</code>により新しい名前を指定することはできません。
出力列名はテーブルの列名と同一になります。
   </p><p>
<!--
    According to the SQL standard, the expressions in the output list should
    be computed before applying <literal>DISTINCT</literal>, <literal>ORDER
    BY</literal>, or <literal>LIMIT</literal>.  This is obviously necessary
    when using <literal>DISTINCT</literal>, since otherwise it's not clear
    what values are being made distinct.  However, in many cases it is
    convenient if output expressions are computed after <literal>ORDER
    BY</literal> and <literal>LIMIT</literal>; particularly if the output list
    contains any volatile or expensive functions.  With that behavior, the
    order of function evaluations is more intuitive and there will not be
    evaluations corresponding to rows that never appear in the output.
    <productname>PostgreSQL</productname> will effectively evaluate output expressions
    after sorting and limiting, so long as those expressions are not
    referenced in <literal>DISTINCT</literal>, <literal>ORDER BY</literal>
    or <literal>GROUP BY</literal>.  (As a counterexample, <literal>SELECT
    f(x) FROM tab ORDER BY 1</literal> clearly must evaluate <function>f(x)</function>
    before sorting.)  Output expressions that contain set-returning functions
    are effectively evaluated after sorting and before limiting, so
    that <literal>LIMIT</literal> will act to cut off the output from a
    set-returning function.
-->
標準SQLによれば、出力リスト内の式は、<code class="literal">DISTINCT</code>、<code class="literal">ORDER BY</code>、<code class="literal">LIMIT</code>を適用する前に計算することになっています。
<code class="literal">DISTINCT</code>を使う場合は、これは明らかに必要です。
なぜなら、そうしなければどの値がDISTINCTであるかわからないからです。
しかし、多くの場合、<code class="literal">ORDER BY</code>や<code class="literal">LIMIT</code>の後で出力式を計算する方が便利です。
特に出力式が揮発性(volatile)あるいは高価な式を含んでいる場合はそうです。
この動作により、関数の評価順序はより直感的になり、出力に現れない行については評価されなくなります。
<span class="productname">PostgreSQL</span>では、式が<code class="literal">DISTINCT</code>、<code class="literal">ORDER BY</code>、<code class="literal">GROUP BY</code>の中で参照されていない限り、ソートと制限(limit)の後にそれらの式を実際に評価します。
（この反例として、<code class="literal">SELECT f(x) FROM tab ORDER BY 1</code> では明らかに<code class="function">f(x)</code>をソートの前に評価しなければなりません。）
集合を返す関数を含む出力式は、ソートの後、制限の前に実際の評価が行われ、これにより<code class="literal">LIMIT</code>が集合を返す関数の出力を制限することになります。
   </p><div class="note"><h3 class="title">注記</h3><p>
<!--
     <productname>PostgreSQL</productname> versions before 9.6 did not provide any
     guarantees about the timing of evaluation of output expressions versus
     sorting and limiting; it depended on the form of the chosen query plan.
-->
<span class="productname">PostgreSQL</span>のバージョン9.6より前では、出力式がソートや制限に対して評価されるタイミングについて何の保証もしていませんでした。
それは選択された問い合わせの計画の形式に依存します。
    </p></div></div><div class="refsect2" id="SQL-DISTINCT"><h3><code class="literal">DISTINCT</code>句</h3><!--
   <title id="sql-distinct-title"><literal>DISTINCT</literal> Clause</title>
--><p>
<!--
    If <literal>SELECT DISTINCT</literal> is specified, all duplicate rows are
    removed from the result set (one row is kept from each group of
    duplicates).  <literal>SELECT ALL</literal> specifies the opposite: all rows are
    kept; that is the default.
-->
<code class="literal">SELECT DISTINCT</code>が指定されると、重複する行は全て結果セットから削除されます
（重複するグループの中で1行が保持されます）。
<code class="literal">SELECT ALL</code>はこの反対で、全ての行が保持されます。
デフォルトはこちらです。
   </p><p>
<!--
    <literal>SELECT DISTINCT ON ( <replaceable
    class="parameter">expression</replaceable> [, ...] )</literal>
    keeps only the first row of each set of rows where the given
    expressions evaluate to equal.  The <literal>DISTINCT ON</literal>
    expressions are interpreted using the same rules as for
    <literal>ORDER BY</literal> (see above).  Note that the <quote>first
    row</quote> of each set is unpredictable unless <literal>ORDER
    BY</literal> is used to ensure that the desired row appears first.  For
    example:
-->
<code class="literal">SELECT DISTINCT ON ( <em class="replaceable"><code>expression</code></em> [, ...] )</code>は指定した式が等しいと評価した各行集合の中で、最初の行のみを保持します。
<code class="literal">DISTINCT ON</code>式は、<code class="literal">ORDER BY</code>（上述）と同じ規則で扱われます。
各集合の<span class="quote">「<span class="quote">最初の行</span>」</span>は、<code class="literal">ORDER BY</code>を使用して目的の行が確実に最初に現れるようにしない限り予測することはできないことに注意してください。
例えば、次の例は各地点の最新の気象情報を取り出します。
</p><pre class="programlisting">
SELECT DISTINCT ON (location) location, time, report
    FROM weather_reports
    ORDER BY location, time DESC;
</pre><p>
<!--
    retrieves the most recent weather report for each location.  But
    if we had not used <literal>ORDER BY</literal> to force descending order
    of time values for each location, we'd have gotten a report from
    an unpredictable time for each location.
-->
しかし<code class="literal">ORDER BY</code>を使用して各地点を時間によって降順にソートしなければ、各地点について得られる情報がいつのものかはわかりません。
   </p><p>
<!--
    The <literal>DISTINCT ON</literal> expression(s) must match the leftmost
    <literal>ORDER BY</literal> expression(s).  The <literal>ORDER BY</literal> clause
    will normally contain additional expression(s) that determine the
    desired precedence of rows within each <literal>DISTINCT ON</literal> group.
-->
<code class="literal">DISTINCT ON</code>に指定する式は<code class="literal">ORDER BY</code>の最も左側の式と一致しなければなりません。
<code class="literal">ORDER BY</code>句は、通常、各<code class="literal">DISTINCT ON</code>グループの中での行の優先順位を決定する追加的な式を含みます。
   </p><p>
<!--
    Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal> and <literal>FOR KEY SHARE</literal> cannot be
    specified with <literal>DISTINCT</literal>.
-->
現在は、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>を<code class="literal">DISTINCT</code>と合わせて使うことはできません。
   </p></div><div class="refsect2" id="SQL-UNION"><h3><code class="literal">UNION</code>句</h3><!--
   <title id="sql-union-title"><literal>UNION</literal> Clause</title>
--><p>
<!--
    The <literal>UNION</literal> clause has this general form:
-->
<code class="literal">UNION</code>句の一般的な構文は以下の通りです。
</p><pre class="synopsis">
<em class="replaceable"><code>select_statement</code></em> UNION [ ALL | DISTINCT ] <em class="replaceable"><code>select_statement</code></em>
<!--
</synopsis><replaceable class="parameter">select_statement</replaceable> is
    any <command>SELECT</command> statement without an <literal>ORDER
    BY</literal>, <literal>LIMIT</literal>, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal>, or <literal>FOR KEY SHARE</literal> clause.
    (<literal>ORDER BY</literal> and <literal>LIMIT</literal> can be attached to a
    subexpression if it is enclosed in parentheses.  Without
    parentheses, these clauses will be taken to apply to the result of
    the <literal>UNION</literal>, not to its right-hand input
    expression.)
-->
</pre><p><em class="replaceable"><code>select_statement</code></em>には、<code class="literal">ORDER BY</code>、<code class="literal">LIMIT</code>、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>句を持たない任意の<code class="command">SELECT</code>文が入ります
（<code class="literal">ORDER BY</code>と<code class="literal">LIMIT</code>は、括弧で囲めば副式として付与することができます。
括弧がない場合、これらの句は右側に置かれた入力式ではなく、<code class="literal">UNION</code>の結果に対して適用されてしまいます）。
   </p><p>
<!--
    The <literal>UNION</literal> operator computes the set union of
    the rows returned by the involved <command>SELECT</command>
    statements.  A row is in the set union of two result sets if it
    appears in at least one of the result sets.  The two
    <command>SELECT</command> statements that represent the direct
    operands of the <literal>UNION</literal> must produce the same
    number of columns, and corresponding columns must be of compatible
    data types.
-->
<code class="literal">UNION</code>演算子は、2つの<code class="command">SELECT</code>文が返す行の和集合を作成します。
この和集合には、2つの<code class="command">SELECT</code>文の結果集合のいずれか（または両方）に存在する行が全て含まれています。
<code class="literal">UNION</code>の直接のオペランドとなる2つの<code class="command">SELECT</code>文が返す列数は、同じでなければなりません。また、対応する列のデータ型には互換性が存在する必要があります。
   </p><p>
<!--
    The result of <literal>UNION</literal> does not contain any duplicate
    rows unless the <literal>ALL</literal> option is specified.
    <literal>ALL</literal> prevents elimination of duplicates.  (Therefore,
    <literal>UNION ALL</literal> is usually significantly quicker than
    <literal>UNION</literal>; use <literal>ALL</literal> when you can.)
    <literal>DISTINCT</literal> can be written to explicitly specify the
    default behavior of eliminating duplicate rows.
-->
<code class="literal">ALL</code>オプションが指定されていない限り、<code class="literal">UNION</code>の結果には重複行は含まれません。
<code class="literal">ALL</code>を指定するとこのような重複除去が行われません
（したがって、通常<code class="literal">UNION ALL</code>は<code class="literal">UNION</code>よりかなり高速です。
できれば<code class="literal">ALL</code>を使用してください）。
重複行を除去するデフォルトの動作を明示的に指定するために<code class="literal">DISTINCT</code>を記述することができます。
   </p><p>
<!--
    Multiple <literal>UNION</literal> operators in the same
    <command>SELECT</command> statement are evaluated left to right,
    unless otherwise indicated by parentheses.
-->
1つの<code class="command">SELECT</code>文に複数の<code class="literal">UNION</code>演算子がある場合、括弧がない限り、それらは左から右に評価されます。
   </p><p>
<!--
    Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal> and
    <literal>FOR KEY SHARE</literal> cannot be
    specified either for a <literal>UNION</literal> result or for any input of a
    <literal>UNION</literal>.
-->
現時点では、<code class="literal">UNION</code>の結果や<code class="literal">UNION</code>に対する入力に、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>を指定することはできません。
   </p></div><div class="refsect2" id="SQL-INTERSECT"><h3><code class="literal">INTERSECT</code>句</h3><!--
   <title id="sql-intersect-title"><literal>INTERSECT</literal> Clause</title>
--><p>
<!--
    The <literal>INTERSECT</literal> clause has this general form:
-->
<code class="literal">INTERSECT</code>句の一般的な構文は以下の通りです。
</p><pre class="synopsis">
<em class="replaceable"><code>select_statement</code></em> INTERSECT [ ALL | DISTINCT ] <em class="replaceable"><code>select_statement</code></em>
<!--
</synopsis><replaceable class="parameter">select_statement</replaceable> is
    any <command>SELECT</command> statement without an <literal>ORDER
    BY</literal>, <literal>LIMIT</literal>, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal>, or <literal>FOR KEY SHARE</literal> clause.
-->
</pre><p><em class="replaceable"><code>select_statement</code></em>には、<code class="literal">ORDER BY</code>、<code class="literal">LIMIT</code>、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>句を持たない、任意の<code class="command">SELECT</code>文が入ります。
   </p><p>
<!--
    The <literal>INTERSECT</literal> operator computes the set
    intersection of the rows returned by the involved
    <command>SELECT</command> statements.  A row is in the
    intersection of two result sets if it appears in both result sets.
-->
<code class="literal">INTERSECT</code>は、2つの<code class="command">SELECT</code>文が返す行の積集合を計算します。
この積集合に含まれるのは、2つの<code class="command">SELECT</code>文の結果集合の両方に存在する行です。
   </p><p>
<!--
    The result of <literal>INTERSECT</literal> does not contain any
    duplicate rows unless the <literal>ALL</literal> option is specified.
    With <literal>ALL</literal>, a row that has <replaceable>m</replaceable> duplicates in the
    left table and <replaceable>n</replaceable> duplicates in the right table will appear
    min(<replaceable>m</replaceable>,<replaceable>n</replaceable>) times in the result set.
    <literal>DISTINCT</literal> can be written to explicitly specify the
    default behavior of eliminating duplicate rows.
-->
<code class="literal">ALL</code>オプションを指定しない限り、<code class="literal">INTERSECT</code>の結果に重複行は含まれません。
<code class="literal">ALL</code>が指定された場合、左側テーブルに<em class="replaceable"><code>m</code></em>個、右側テーブルに<em class="replaceable"><code>n</code></em>個の重複がある行は、結果集合ではmin(<em class="replaceable"><code>m</code></em>,<em class="replaceable"><code>n</code></em>)個出現します。
重複行を除去するデフォルトの動作を明示的に指定するために<code class="literal">DISTINCT</code>を記述することができます。
   </p><p>
<!--
    Multiple <literal>INTERSECT</literal> operators in the same
    <command>SELECT</command> statement are evaluated left to right,
    unless parentheses dictate otherwise.
    <literal>INTERSECT</literal> binds more tightly than
    <literal>UNION</literal>.  That is, <literal>A UNION B INTERSECT
    C</literal> will be read as <literal>A UNION (B INTERSECT
    C)</literal>.
-->
1つの<code class="command">SELECT</code>文に複数の<code class="literal">INTERSECT</code>演算子がある場合、括弧がない限り、それらは左から右に評価されます。
<code class="literal">INTERSECT</code>は<code class="literal">UNION</code>よりも強い結び付きを持ちます。
つまり、<code class="literal">A UNION B INTERSECT C</code> は<code class="literal">A UNION (B INTERSECT C)</code>と解釈されます。
   </p><p>
<!--
    Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal> and
    <literal>FOR KEY SHARE</literal> cannot be
    specified either for an <literal>INTERSECT</literal> result or for any input of
    an <literal>INTERSECT</literal>.
-->
現時点では、<code class="literal">INTERSECT</code>の結果や<code class="literal">INTERSECT</code>に対する入力に、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>または<code class="literal">FOR KEY SHARE</code>を指定することはできません。
   </p></div><div class="refsect2" id="SQL-EXCEPT"><h3><code class="literal">EXCEPT</code>句</h3><!--
   <title id="sql-except-title"><literal>EXCEPT</literal> Clause</title>
--><p>
<!--
    The <literal>EXCEPT</literal> clause has this general form:
-->
<code class="literal">EXCEPT</code>句の一般的な構文は以下の通りです。
</p><pre class="synopsis">
<em class="replaceable"><code>select_statement</code></em> EXCEPT [ ALL | DISTINCT ] <em class="replaceable"><code>select_statement</code></em>
<!--
</synopsis><replaceable class="parameter">select_statement</replaceable> is
    any <command>SELECT</command> statement without an <literal>ORDER
    BY</literal>, <literal>LIMIT</literal>, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal>, or <literal>FOR KEY SHARE</literal> clause.
-->
</pre><p><em class="replaceable"><code>select_statement</code></em>には、<code class="literal">ORDER BY</code>、<code class="literal">LIMIT</code>、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>句を持たない、任意の<code class="command">SELECT</code>文が入ります。
   </p><p>
<!--
    The <literal>EXCEPT</literal> operator computes the set of rows
    that are in the result of the left <command>SELECT</command>
    statement but not in the result of the right one.
-->
<code class="literal">EXCEPT</code>は、左側の<code class="command">SELECT</code>文の結果には存在し、右側の<code class="command">SELECT</code>文の結果には存在しない行の集合を生成します。
   </p><p>
<!--
    The result of <literal>EXCEPT</literal> does not contain any
    duplicate rows unless the <literal>ALL</literal> option is specified.
    With <literal>ALL</literal>, a row that has <replaceable>m</replaceable> duplicates in the
    left table and <replaceable>n</replaceable> duplicates in the right table will appear
    max(<replaceable>m</replaceable>-<replaceable>n</replaceable>,0) times in the result set.
    <literal>DISTINCT</literal> can be written to explicitly specify the
    default behavior of eliminating duplicate rows.
-->
<code class="literal">ALL</code>オプションが指定されていない限り、<code class="literal">EXCEPT</code>の結果には重複行は含まれません。
<code class="literal">ALL</code>がある場合、左側テーブルに<em class="replaceable"><code>m</code></em>個、右側テーブルに<em class="replaceable"><code>n</code></em>個の重複がある行は、結果集合ではmax(<em class="replaceable"><code>m</code></em>-<em class="replaceable"><code>n</code></em>,0)個出現します。
重複行を除去するデフォルトの動作を明示的に指定するために<code class="literal">DISTINCT</code>を記述することができます。
   </p><p>
<!--
    Multiple <literal>EXCEPT</literal> operators in the same
    <command>SELECT</command> statement are evaluated left to right,
    unless parentheses dictate otherwise.  <literal>EXCEPT</literal> binds at
    the same level as <literal>UNION</literal>.
-->
1つの<code class="command">SELECT</code>文に複数の<code class="literal">EXCEPT</code>演算子がある場合、括弧がない限り、それらは左から右に評価されます。
<code class="literal">EXCEPT</code>の結び付きの強さは<code class="literal">UNION</code>と同じです。
   </p><p>
<!--
    Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal> and
    <literal>FOR KEY SHARE</literal> cannot be
    specified either for an <literal>EXCEPT</literal> result or for any input of
    an <literal>EXCEPT</literal>.
-->
現時点では、<code class="literal">EXCEPT</code>の結果や<code class="literal">EXCEPT</code>に対する入力に、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>または<code class="literal">FOR KEY SHARE</code>を指定することはできません。
   </p></div><div class="refsect2" id="SQL-ORDERBY"><h3><code class="literal">ORDER BY</code>句</h3><!--
   <title id="sql-orderby-title"><literal>ORDER BY</literal> Clause</title>
--><p>
<!--
    The optional <literal>ORDER BY</literal> clause has this general form:
-->
<code class="literal">ORDER BY</code>句の一般的な構文は以下の通りです（この句は省略可能です）。

</p><pre class="synopsis">
ORDER BY <em class="replaceable"><code>expression</code></em> [ ASC | DESC | USING <em class="replaceable"><code>operator</code></em> ] [ NULLS { FIRST | LAST } ] [, ...]
</pre><p>
<!--
    The <literal>ORDER BY</literal> clause causes the result rows to
    be sorted according to the specified expression(s).  If two rows are
    equal according to the leftmost expression, they are compared
    according to the next expression and so on.  If they are equal
    according to all specified expressions, they are returned in
    an implementation-dependent order.
-->
<code class="literal">ORDER BY</code>句を使うと、結果行を指定した式（複数可）に従ってソートすることができます。
最も左側の式を使って比較した結果、2つの行が等しいと判断された場合は、1つ右側の式を使って比較します。その結果も等しければ、さらに次の式に進みます。
指定した全ての式で等しいと判断された場合は、実装に依存した順番で返されます。
   </p><p>
<!--
    Each <replaceable class="parameter">expression</replaceable> can be the
    name or ordinal number of an output column
    (<command>SELECT</command> list item), or it can be an arbitrary
    expression formed from input-column values.
-->
<em class="replaceable"><code>expression</code></em>には、出力列（<code class="command">SELECT</code>リスト項目）の名前または序数、あるいは入力列値から形成される任意の式を取ることができます。
   </p><p>
<!--
    The ordinal number refers to the ordinal (left-to-right) position
    of the output column. This feature makes it possible to define an
    ordering on the basis of a column that does not have a unique
    name.  This is never absolutely necessary because it is always
    possible to assign a name to an output column using the
    <literal>AS</literal> clause.
-->
序数は、出力列の位置（左から右に割り当てられます）を示します。
これを使うと、一意な名前を持たない列の順序を定義することができます。
<code class="literal">AS</code>句を使用すれば出力列に名前を割り当てることができるので、これはどうしても必要な機能というわけではありません。
   </p><p>
<!--
    It is also possible to use arbitrary expressions in the
    <literal>ORDER BY</literal> clause, including columns that do not
    appear in the <command>SELECT</command> output list.  Thus the
    following statement is valid:
-->
また、<code class="literal">ORDER BY</code>句には、<code class="command">SELECT</code>出力リストに出現しない列を含む、任意の式を使用できます。
したがって、以下の文は有効です。
</p><pre class="programlisting">
SELECT name FROM distributors ORDER BY code;
</pre><p>
<!--
    A limitation of this feature is that an <literal>ORDER BY</literal>
    clause applying to the result of a <literal>UNION</literal>,
    <literal>INTERSECT</literal>, or <literal>EXCEPT</literal> clause can only
    specify an output column name or number, not an expression.
-->
ただし、<code class="literal">UNION</code>、<code class="literal">INTERSECT</code>、<code class="literal">EXCEPT</code>の結果に<code class="literal">ORDER BY</code>を適用する場合は、式は使用できず、出力列の名前か序数のみを指定できるという制限があります。
   </p><p>
<!--
    If an <literal>ORDER BY</literal> expression is a simple name that
    matches both an output column name and an input column name,
    <literal>ORDER BY</literal> will interpret it as the output column name.
    This is the opposite of the choice that <literal>GROUP BY</literal> will
    make in the same situation.  This inconsistency is made to be
    compatible with the SQL standard.
-->
<code class="literal">ORDER BY</code>の式として出力列名と入力列名の両方に一致する単なる名前が与えられた場合、<code class="literal">ORDER BY</code>はそれを出力列名として扱います。
これは、同じ状況における<code class="literal">GROUP BY</code>の選択とは反対です。
この不整合は、標準SQLとの互換性を保持するために発生しています。
   </p><p>
<!--
    Optionally one can add the key word <literal>ASC</literal> (ascending) or
    <literal>DESC</literal> (descending) after any expression in the
    <literal>ORDER BY</literal> clause.  If not specified, <literal>ASC</literal> is
    assumed by default.  Alternatively, a specific ordering operator
    name can be specified in the <literal>USING</literal> clause.
    An ordering operator must be a less-than or greater-than
    member of some B-tree operator family.
    <literal>ASC</literal> is usually equivalent to <literal>USING &lt;</literal> and
    <literal>DESC</literal> is usually equivalent to <literal>USING &gt;</literal>.
    (But the creator of a user-defined data type can define exactly what the
    default sort ordering is, and it might correspond to operators with other
    names.)
-->
<code class="literal">ORDER BY</code>中の任意の式の後に、キーワード<code class="literal">ASC</code>（昇順）、<code class="literal">DESC</code>（降順）を付加することができます(省略可能)。
指定がなければ、デフォルトで<code class="literal">ASC</code>があるものとして扱われます。
その他、順序を指定する演算子名を<code class="literal">USING</code>句に指定する方法もあります。
順序指定演算子は何らかのB-Tree演算子族の小なりまたは大なり演算子でなければなりません。
通常、<code class="literal">ASC</code>は<code class="literal">USING &lt;</code>と、<code class="literal">DESC</code>は<code class="literal">USING &gt;</code>と同じです
（ただし、ユーザ定義データ型の作成時には、デフォルトのソート順を定義することができます。また、異なる名前の演算子と対応付けすることもできます）。
   </p><p>
<!--
    If <literal>NULLS LAST</literal> is specified, null values sort after all
    non-null values; if <literal>NULLS FIRST</literal> is specified, null values
    sort before all non-null values.  If neither is specified, the default
    behavior is <literal>NULLS LAST</literal> when <literal>ASC</literal> is specified
    or implied, and <literal>NULLS FIRST</literal> when <literal>DESC</literal> is specified
    (thus, the default is to act as though nulls are larger than non-nulls).
    When <literal>USING</literal> is specified, the default nulls ordering depends
    on whether the operator is a less-than or greater-than operator.
-->
<code class="literal">NULLS LAST</code>が指定されると、NULL値はすべての非NULL値の後にソートされます。
<code class="literal">NULLS FIRST</code>が指定されると、NULL値はすべての非NULL値の前にソートされます。
どちらも指定されない場合のデフォルト動作は、明示的あるいは暗黙的な<code class="literal">ASC</code>の場合は<code class="literal">NULLS LAST</code>、<code class="literal">DESC</code>が指定された場合は<code class="literal">NULLS FIRST</code>です。
（したがって、デフォルトでは、NULLが非NULLよりも大きい値であるかのように動作します。）
<code class="literal">USING</code>が指定されると、デフォルトのNULLの順序は、演算子が小なり演算子か大なり演算子によって変わります。
   </p><p>
<!--
    Note that ordering options apply only to the expression they follow;
    for example <literal>ORDER BY x, y DESC</literal> does not mean
    the same thing as <literal>ORDER BY x DESC, y DESC</literal>.
-->
順序付けオプションは直前の演算子にのみ適用されます。
たとえば、<code class="literal">ORDER BY x, y DESC</code>は<code class="literal">ORDER BY x DESC, y DESC</code>と同一の意味ではありません。
   </p><p>
<!--
    Character-string data is sorted according to the collation that applies
    to the column being sorted.  That can be overridden at need by including
    a <literal>COLLATE</literal> clause in the
    <replaceable class="parameter">expression</replaceable>, for example
    <literal>ORDER BY mycolumn COLLATE "en_US"</literal>.
    For more information see <xref linkend="sql-syntax-collate-exprs"/> and
    <xref linkend="collation"/>.
-->
文字型データでは、格納する列に適用された照合順序に従ってソートされます。
これは必要に応じて<em class="replaceable"><code>expression</code></em>内に<code class="literal">COLLATE</code>句を含めることで上書きできます。
例えば<code class="literal">ORDER BY mycolumn COLLATE "en_US"</code>です。
より詳細については<a class="xref" href="sql-expressions.html#SQL-SYNTAX-COLLATE-EXPRS" title="4.2.10. 照合順序式">4.2.10</a>および<a class="xref" href="collation.html" title="23.2. 照合順序サポート">23.2</a>を参照してください。
   </p></div><div class="refsect2" id="SQL-LIMIT"><h3><code class="literal">LIMIT</code>句</h3><!--
   <title id="sql-limit-title"><literal>LIMIT</literal> Clause</title>
--><p>
<!--
    The <literal>LIMIT</literal> clause consists of two independent
    sub-clauses:
-->
<code class="literal">LIMIT</code>句は2つの独立した副句から構成されます。
</p><pre class="synopsis">
LIMIT { <em class="replaceable"><code>count</code></em> | ALL }
OFFSET <em class="replaceable"><code>start</code></em>
</pre><p>
<!--
    <replaceable class="parameter">count</replaceable> specifies the
    maximum number of rows to return, while <replaceable
    class="parameter">start</replaceable> specifies the number of rows
    to skip before starting to return rows.  When both are specified,
    <replaceable class="parameter">start</replaceable> rows are skipped
    before starting to count the <replaceable
    class="parameter">count</replaceable> rows to be returned.
-->
<em class="replaceable"><code>count</code></em>には返される行の最大数を、一方、<em class="replaceable"><code>start</code></em>には行を返し始める前に飛ばす行数を指定します。
両方とも指定された場合、<em class="replaceable"><code>start</code></em>行分が飛ばされ、そこから数えて<em class="replaceable"><code>count</code></em>行が返されます。
   </p><p>
<!--
    If the <replaceable class="parameter">count</replaceable> expression
    evaluates to NULL, it is treated as <literal>LIMIT ALL</literal>, i.e., no
    limit.  If <replaceable class="parameter">start</replaceable> evaluates
    to NULL, it is treated the same as <literal>OFFSET 0</literal>.
-->
<em class="replaceable"><code>count</code></em>式がNULLと評価された場合、<code class="literal">LIMIT ALL</code>として、つまり制限無しとして扱われます。
<em class="replaceable"><code>start</code></em>がNULLと評価された場合、<code class="literal">OFFSET 0</code>と同様に扱われます。
   </p><p>
<!--
    SQL:2008 introduced a different syntax to achieve the same result,
    which <productname>PostgreSQL</productname> also supports.  It is:
-->
SQL:2008では同じ結果を実現する異なる構文が導入されました。
<span class="productname">PostgreSQL</span>でもサポートしています。
以下の構文です。
</p><pre class="synopsis">
OFFSET <em class="replaceable"><code>start</code></em> { ROW | ROWS }
FETCH { FIRST | NEXT } [ <em class="replaceable"><code>count</code></em> ] { ROW | ROWS } ONLY
</pre><p>
<!--
    In this syntax, the <replaceable class="parameter">start</replaceable>
    or <replaceable class="parameter">count</replaceable> value is required by
    the standard to be a literal constant, a parameter, or a variable name;
    as a <productname>PostgreSQL</productname> extension, other expressions
    are allowed, but will generally need to be enclosed in parentheses to avoid
    ambiguity.
    If <replaceable class="parameter">count</replaceable> is
    omitted in a <literal>FETCH</literal> clause, it defaults to 1.
    <literal>ROW</literal>
    and <literal>ROWS</literal> as well as <literal>FIRST</literal>
    and <literal>NEXT</literal> are noise words that don't influence
    the effects of these clauses.
    According to the standard, the <literal>OFFSET</literal> clause must come
    before the <literal>FETCH</literal> clause if both are present; but
    <productname>PostgreSQL</productname> is laxer and allows either order.
-->
この構文において、<em class="replaceable"><code>start</code></em>または<em class="replaceable"><code>count</code></em>の値は標準SQLでは、リテラル定数、パラメータもしくは変数名を要求します。
<span class="productname">PostgreSQL</span>の拡張では他の表現が許容されていますが、曖昧さを防ぐために通常は括弧で囲まれる必要があるでしょう。
<em class="replaceable"><code>count</code></em>を<code class="literal">FETCH</code>句で省略した場合、そのデフォルトは１です。
<code class="literal">ROW</code>および<code class="literal">ROWS</code>、そして<code class="literal">FIRST</code>および<code class="literal">NEXT</code>は意味がない単語で、この句に影響を与えることはありません。
SQL標準では<code class="literal">OFFSET</code>句は、<code class="literal">FETCH</code>句と同時に使用する場合、これより前に存在しなければなりません。
しかし<span class="productname">PostgreSQL</span>は厳密ではなく、どちらが先でも許されます。
   </p><p>
<!--
    When using <literal>LIMIT</literal>, it is a good idea to use an
    <literal>ORDER BY</literal> clause that constrains the result rows into a
    unique order.  Otherwise you will get an unpredictable subset of
    the query's rows &mdash; you might be asking for the tenth through
    twentieth rows, but tenth through twentieth in what ordering?  You
    don't know what ordering unless you specify <literal>ORDER BY</literal>.
-->
<code class="literal">LIMIT</code>を使う時は、結果行を一意な順番に強制する<code class="literal">ORDER BY</code>句を使うとよいでしょう。
そうしないと、問い合わせ結果のどの部分が返されるのかがわかりません。
10〜20行目までを出力するとしても、どの順番で並べた時の10〜20行目なのでしょうか。
<code class="literal">ORDER BY</code>を指定しない限り、行が返される順番は不明です。
   </p><p>
<!--
    The query planner takes <literal>LIMIT</literal> into account when
    generating a query plan, so you are very likely to get different
    plans (yielding different row orders) depending on what you use
    for <literal>LIMIT</literal> and <literal>OFFSET</literal>.  Thus, using
    different <literal>LIMIT</literal>/<literal>OFFSET</literal> values to select
    different subsets of a query result <emphasis>will give
    inconsistent results</emphasis> unless you enforce a predictable
    result ordering with <literal>ORDER BY</literal>.  This is not a bug; it
    is an inherent consequence of the fact that SQL does not promise
    to deliver the results of a query in any particular order unless
    <literal>ORDER BY</literal> is used to constrain the order.
-->
問い合わせプランナは問い合わせ計画を作成する時に<code class="literal">LIMIT</code>を考慮するので、<code class="literal">LIMIT</code>と<code class="literal">OFFSET</code>の指定によって異なった計画を得ることになるでしょう。計画が異なれば、異なる順番で行が返ります。
したがって、<code class="literal">LIMIT</code>/<code class="literal">OFFSET</code>値の変更によって異なる結果行を選択しようとすると、<code class="literal">ORDER BY</code>で順序を並び替えない限り、<span class="emphasis"><em>矛盾した結果を返すことになります</em></span>。
これはバグではありません。
「SQLは、<code class="literal">ORDER BY</code>で順序を制御されない限り、問い合わせ結果が返す順序を約束しない」という事実の当然の帰結なのです。
   </p><p>
<!--
    It is even possible for repeated executions of the same <literal>LIMIT</literal>
    query to return different subsets of the rows of a table, if there
    is not an <literal>ORDER BY</literal> to enforce selection of a deterministic
    subset.  Again, this is not a bug; determinism of the results is
    simply not guaranteed in such a case.
-->
厳密的に部分集合の選択を強制する<code class="literal">ORDER BY</code>がなければ、同じ<code class="literal">LIMIT</code>問い合わせを繰り返し実行してもテーブル行から異なる部分集合が取り出される可能性すらあります。
繰り返しますが、これは不具合ではありません。
こうした場合に確定した結果は単に保証されていないのです。
   </p></div><div class="refsect2" id="SQL-FOR-UPDATE-SHARE"><h3>ロック処理句</h3><!--
   <title id="sql-for-update-share-title">The Locking Clause</title>
--><p>
<!--
    <literal>FOR UPDATE</literal>, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR SHARE</literal>
    and <literal>FOR KEY SHARE</literal>
    are <firstterm>locking clauses</firstterm>; they affect how <literal>SELECT</literal>
    locks rows as they are obtained from the table.
-->
<code class="literal">FOR UPDATE</code>、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR SHARE</code>および<code class="literal">FOR KEY SHARE</code>は<em class="firstterm">ロック処理句</em>です。
これらはテーブルから行を入手する時にどのように<code class="literal">SELECT</code>がその行をロックするかに影響します。
   </p><p>
<!--
    The locking clause has the general form
-->
ロック処理句の一般的な構文は以下の通りです。

</p><pre class="synopsis">
FOR <em class="replaceable"><code>lock_strength</code></em> [ OF <em class="replaceable"><code>table_name</code></em> [, ...] ] [ NOWAIT | SKIP LOCKED ]
</pre><p>

<!--
    where <replaceable>lock_strength</replaceable> can be one of
-->
ここで<em class="replaceable"><code>lock_strength</code></em>は以下のいずれかを取ることができます。

</p><pre class="synopsis">
UPDATE
NO KEY UPDATE
SHARE
KEY SHARE
</pre><p>
   </p><p>
<!--
    For more information on each row-level lock mode, refer to
    <xref linkend="locking-rows"/>.
-->
それぞれの行レベルロックモードについての詳しい説明は<a class="xref" href="explicit-locking.html#LOCKING-ROWS" title="13.3.2. 行レベルロック">13.3.2</a>を参照してください。
   </p><p>
<!--
    To prevent the operation from waiting for other transactions to commit,
    use either the <literal>NOWAIT</literal> or <literal>SKIP LOCKED</literal>
    option.  With <literal>NOWAIT</literal>, the statement reports an error, rather
    than waiting, if a selected row cannot be locked immediately.
    With <literal>SKIP LOCKED</literal>, any selected rows that cannot be
    immediately locked are skipped.  Skipping locked rows provides an
    inconsistent view of the data, so this is not suitable for general purpose
    work, but can be used to avoid lock contention with multiple consumers
    accessing a queue-like table.
    Note that <literal>NOWAIT</literal> and <literal>SKIP LOCKED</literal> apply only
    to the row-level lock(s) &mdash; the required <literal>ROW SHARE</literal>
    table-level lock is still taken in the ordinary way (see
    <xref linkend="mvcc"/>).  You can use
    <xref linkend="sql-lock"/>
    with the <literal>NOWAIT</literal> option first,
    if you need to acquire the table-level lock without waiting.
-->
他のトランザクションのコミットを待機することなく操作を進めるには、<code class="literal">NOWAIT</code>あるいは<code class="literal">SKIP LOCKED</code>オプションを使用してください。
<code class="literal">NOWAIT</code>では、選択行のロックを即座に獲得できない時、文は待機せずに、エラーを報告します。
<code class="literal">SKIP LOCKED</code>では、即座にロックできない行はすべてスキップされます。
行のロックをスキップすると、一貫性のないデータが見えることになるので、一般的な目的の作業のためには適しませんが、複数の消費者がキューのようなテーブルにアクセスするときのロック競合の回避などに利用できます。
<code class="literal">NOWAIT</code>および<code class="literal">SKIP LOCKED</code>は行レベルロックにのみに適用される点に注意してください。
つまり、必要な<code class="literal">ROW SHARE</code>テーブルレベルロックは通常通りの方法（ <a class="xref" href="mvcc.html" title="第13章 同時実行制御">第13章</a>を参照）で獲得されます。
もし、テーブルレベルのロックを待機せずに獲得しなければならないのであれば、最初に<a class="xref" href="sql-lock.html" title="LOCK"><span class="refentrytitle">LOCK</span></a>の<code class="literal">NOWAIT</code>オプションを使用してください。
   </p><p>
<!--
    If specific tables are named in a locking clause,
    then only rows coming from those tables are locked; any other
    tables used in the <command>SELECT</command> are simply read as
    usual.  A locking
    clause without a table list affects all tables used in the statement.
    If a locking clause is
    applied to a view or sub-query, it affects all tables used in
    the view or sub-query.
    However, these clauses
    do not apply to <literal>WITH</literal> queries referenced by the primary query.
    If you want row locking to occur within a <literal>WITH</literal> query, specify
    a locking clause within the <literal>WITH</literal> query.
-->
ロック処理句内に特定のテーブルが指定されている場合は、そのテーブルの行のみがロックされます。
<code class="command">SELECT</code>内の他のテーブルは通常通りに読み込まれます。
テーブルリストを持たないロック処理句は、その文で使用されるすべてのテーブルに影響を与えます。
ロック処理句がビューまたは副問い合わせで使用された場合、そのビューや副問い合わせで使用されるすべてのテーブルに影響を与えます。
しかしこれらの句は主問い合わせで参照される<code class="literal">WITH</code>問い合わせには適用されません。
<code class="literal">WITH</code>問い合わせ内での行ロックを行いたい場合は、<code class="literal">WITH</code>問い合わせ内でロック処理句を指定してください。
   </p><p>
<!--
    Multiple locking
    clauses can be written if it is necessary to specify different locking
    behavior for different tables.  If the same table is mentioned (or
    implicitly affected) by more than one locking clause,
    then it is processed as if it was only specified by the strongest one.
    Similarly, a table is processed
    as <literal>NOWAIT</literal> if that is specified in any of the clauses
    affecting it.  Otherwise, it is processed
    as <literal>SKIP LOCKED</literal> if that is specified in any of the
    clauses affecting it.
-->
異なるロック方式を異なるテーブルに指定する必要があれば、複数のロック処理句を記述することができます。
複数のロック処理句で同一のテーブルを記述した（または暗黙的に影響が与えられた）場合、最も強いものだけが指定されたかのように処理されます。
同様に、あるテーブルに影響を与える句のいずれかで<code class="literal">NOWAIT</code>が指定された場合、そのテーブルは<code class="literal">NOWAIT</code>として処理されます。
それ以外の場合、あるテーブルに影響を与える句のいずれかで<code class="literal">SKIP LOCKED</code>が指定されていれば、そのテーブルは<code class="literal">SKIP LOCKED</code>として処理されます。
   </p><p>
<!--
    The locking clauses cannot be
    used in contexts where returned rows cannot be clearly identified with
    individual table rows; for example they cannot be used with aggregation.
-->
ロック処理句は、返される行がテーブルのどの行に対応するのかが明確に識別できない場合には使用することができません。
例えば、集約には使用できません。
   </p><p>
<!--
    When a locking clause
    appears at the top level of a <command>SELECT</command> query, the rows that
    are locked are exactly those that are returned by the query; in the
    case of a join query, the rows locked are those that contribute to
    returned join rows.  In addition, rows that satisfied the query
    conditions as of the query snapshot will be locked, although they
    will not be returned if they were updated after the snapshot
    and no longer satisfy the query conditions.  If a
    <literal>LIMIT</literal> is used, locking stops
    once enough rows have been returned to satisfy the limit (but note that
    rows skipped over by <literal>OFFSET</literal> will get locked).  Similarly,
    if a locking clause
    is used in a cursor's query, only rows actually fetched or stepped past
    by the cursor will be locked.
-->
ロック処理句が<code class="command">SELECT</code>問い合わせの最上位レベルに存在する場合、ロック対象行は問い合わせが返す行に正確に一致します。
結合問い合わせ内の場合、ロック対象行は返される結合行に関連する行となります。
さらに、スナップショットを更新した後に問い合わせ条件を満たさなくなった場合は返されなくなりますが、問い合わせのスナップショット時点で問い合わせ条件を満たす行もロックされます。
<code class="literal">LIMIT</code>が使用された場合、制限を満たす行が返されるとロック処理は止まります。
（しかし、<code class="literal">OFFSET</code>により飛ばされた行はロックされることに注意してください。）
同様に、ロック処理句がカーソル問い合わせで使用された場合、カーソルにより実際に取り込んだ行または通り過ぎた行のみがロックされます。
   </p><p>
<!--
    When a locking clause
    appears in a sub-<command>SELECT</command>, the rows locked are those
    returned to the outer query by the sub-query.  This might involve
    fewer rows than inspection of the sub-query alone would suggest,
    since conditions from the outer query might be used to optimize
    execution of the sub-query.  For example,
-->
ロック処理句が副<code class="command">SELECT</code>に存在する場合、ロック対象行は副問い合わせの外側の問い合わせに返される行となります。
外側の問い合わせからの条件が副問い合わせ実行の最適化に使用される可能性がありますので、これには副問い合わせ自体の検査が提示する行より少なくなるかもしれません。
例えば、
</p><pre class="programlisting">
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;
</pre><p>
<!--
    will lock only rows having <literal>col1 = 5</literal>, even though that
    condition is not textually within the sub-query.
-->
は、副問い合わせ内では文字として条件が記載されていなくても、<code class="literal">col1 = 5</code>を持つ行のみがロックされます。
   </p><p>
<!--
   Previous releases failed to preserve a lock which is upgraded by a later
   savepoint.  For example, this code:
-->
以前のリリースでは、セーブポイント以降に更新されるロックの保持は失敗しました。
例えば以下のコードです。
</p><pre class="programlisting">
BEGIN;
SELECT * FROM mytable WHERE key = 1 FOR UPDATE;
SAVEPOINT s;
UPDATE mytable SET ... WHERE key = 1;
ROLLBACK TO s;
</pre><p>
<!--
   would fail to preserve the <literal>FOR UPDATE</literal> lock after the
   <command>ROLLBACK TO</command>.  This has been fixed in release 9.3.
-->
<code class="command">ROLLBACK TO</code>後の<code class="literal">FOR UPDATE</code>ロックの保持に失敗します。
これはリリース9.3で修正されました。
  </p><div class="caution"><h3 class="title">注意</h3><p>
<!--
    It is possible for a <command>SELECT</command> command running at the <literal>READ
    COMMITTED</literal> transaction isolation level and using <literal>ORDER
    BY</literal> and a locking clause to return rows out of
    order.  This is because <literal>ORDER BY</literal> is applied first.
    The command sorts the result, but might then block trying to obtain a lock
    on one or more of the rows.  Once the <literal>SELECT</literal> unblocks, some
    of the ordering column values might have been modified, leading to those
    rows appearing to be out of order (though they are in order in terms
    of the original column values).  This can be worked around at need by
    placing the <literal>FOR UPDATE/SHARE</literal> clause in a sub-query,
    for example
-->
<code class="literal">ORDER BY</code>句とロック処理句を使用した、<code class="literal">READ COMMITTED</code>トランザクション隔離レベルで実行する<code class="command">SELECT</code>コマンドでは、順序通りにならない行を返す可能性があります。
<code class="literal">ORDER BY</code>が最初に適用されるためです。
このコマンドは結果をソートしますが、その後、1行または複数の行のロック獲得がブロックされる可能性があります。
この<code class="literal">SELECT</code>のブロックが解除された時点で、順序付け対象の列値の一部が変更されているかもしれません。
これによりこうした行が（元の列値という観点では順序通りではありますが、）順序通りに現れません。
必要に応じて、これは以下のように副問い合わせ内に<code class="literal">FOR UPDATE/SHARE</code>句を記述することで、回避することができます。
</p><pre class="programlisting">
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;
</pre><p>
<!--
    Note that this will result in locking all rows of <structname>mytable</structname>,
    whereas <literal>FOR UPDATE</literal> at the top level would lock only the
    actually returned rows.  This can make for a significant performance
    difference, particularly if the <literal>ORDER BY</literal> is combined with
    <literal>LIMIT</literal> or other restrictions.  So this technique is recommended
    only if concurrent updates of the ordering columns are expected and a
    strictly sorted result is required.
-->
最上位レベルにおける<code class="literal">FOR UPDATE</code>は実際に返される行のみをロックするのに対して、これは結果として<code class="structname">mytable</code>のすべての行をロックすることに注意してください。
これは、特に<code class="literal">ORDER BY</code>が<code class="literal">LIMIT</code>やその他の制限と組み合わせている場合、性能上大きな違いを生み出す可能性があります。
このため、この技法は、順序付け対象の列に対する同時実行の更新が想定され、かつ、厳密にソートされた結果が要求される場合にのみ推奨されます。
   </p><p>
<!--
    At the <literal>REPEATABLE READ</literal> or <literal>SERIALIZABLE</literal>
    transaction isolation level this would cause a serialization failure (with
    a <literal>SQLSTATE</literal> of <literal>'40001'</literal>), so there is
    no possibility of receiving rows out of order under these isolation levels.
-->
<code class="literal">REPEATABLE READ</code>または<code class="literal">SERIALIZABLE</code>トランザクション隔離レベルでは、（<code class="literal">'40001'</code>という<code class="literal">SQLSTATE</code>を持つ）シリアライゼーション失敗が発生します。
このためこれらの隔離レベルでは順序通りでない行を受け取る可能性はありません。
   </p></div></div><div class="refsect2" id="SQL-TABLE"><h3><code class="literal">TABLE</code>コマンド</h3><!--
   <title><literal>TABLE</literal> Command</title>
--><p>
<!--
    The command
-->
</p><pre class="programlisting">
TABLE <em class="replaceable"><code>name</code></em>
</pre><p>
<!--
    is equivalent to
-->
というコマンドは以下と同じです。
</p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>name</code></em>
</pre><p>
<!--
    It can be used as a top-level command or as a space-saving syntax
    variant in parts of complex queries. Only the <literal>WITH</literal>,
    <literal>UNION</literal>, <literal>INTERSECT</literal>, <literal>EXCEPT</literal>,
    <literal>ORDER BY</literal>, <literal>LIMIT</literal>, <literal>OFFSET</literal>,
    <literal>FETCH</literal> and <literal>FOR</literal> locking clauses can be used
    with <command>TABLE</command>; the <literal>WHERE</literal> clause and any form of
    aggregation cannot
    be used.
-->
これは、最上位のコマンドとして、あるいは複雑な問い合わせの一部として、入力を省略する構文の一種としても使用することができます。
<code class="literal">WITH</code>、<code class="literal">UNION</code>、<code class="literal">INTERSECT</code>、<code class="literal">EXCEPT</code>、<code class="literal">ORDER BY</code>、<code class="literal">LIMIT</code>、<code class="literal">OFFSET</code>、<code class="literal">FETCH</code>、<code class="literal">FOR</code>のロック句だけを<code class="command">TABLE</code>と一緒に使うことができます。
<code class="literal">WHERE</code>句およびいかなる形式の集約も使うことはできません。
   </p></div></div><div class="refsect1" id="id-1.9.3.171.9"><h2>例</h2><!--
  <title>Examples</title>
--><p>
<!--
   To join the table <literal>films</literal> with the table
   <literal>distributors</literal>:
-->
<code class="literal">films</code>テーブルを<code class="literal">distributors</code>テーブルと結合します。

</p><pre class="programlisting">
SELECT f.title, f.did, d.name, f.date_prod, f.kind
    FROM distributors d, films f
    WHERE f.did = d.did

       title       | did |     name     | date_prod  |   kind
-------------------+-----+--------------+------------+----------
 The Third Man     | 101 | British Lion | 1949-12-23 | Drama
 The African Queen | 101 | British Lion | 1951-08-11 | Romantic
 ...
</pre><p>
  </p><p>
<!--
   To sum the column <literal>len</literal> of all films and group
   the results by <literal>kind</literal>:
-->
全ての映画の<code class="literal">len</code>列を合計し<code class="literal">kind</code>列によって結果をグループ化します。

</p><pre class="programlisting">
SELECT kind, sum(len) AS total FROM films GROUP BY kind;

   kind   | total
----------+-------
 Action   | 07:34
 Comedy   | 02:58
 Drama    | 14:28
 Musical  | 06:42
 Romantic | 04:38
</pre><p>
  </p><p>
<!--
   To sum the column <literal>len</literal> of all films, group
   the results by <literal>kind</literal> and show those group totals
   that are less than 5 hours:
-->
全ての映画の<code class="literal">len</code>列を合計し<code class="literal">kind</code>列によって結果をグループ化し、合計が5時間より少ないグループの合計を表示します。

</p><pre class="programlisting">
SELECT kind, sum(len) AS total
    FROM films
    GROUP BY kind
    HAVING sum(len) &lt; interval '5 hours';

   kind   | total
----------+-------
 Comedy   | 02:58
 Romantic | 04:38
</pre><p>
  </p><p>
<!--
   The following two examples are identical ways of sorting the individual
   results according to the contents of the second column
   (<literal>name</literal>):
-->
次に、結果を2番目の列（<code class="literal">name</code>）の内容に基づいてソートする方法を2つ例示します。

</p><pre class="programlisting">
SELECT * FROM distributors ORDER BY name;
SELECT * FROM distributors ORDER BY 2;

 did |       name
-----+------------------
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward
</pre><p>
  </p><p>
<!--
   The next example shows how to obtain the union of the tables
   <literal>distributors</literal> and
   <literal>actors</literal>, restricting the results to those that begin
   with the letter W in each table.  Only distinct rows are wanted, so the
   key word <literal>ALL</literal> is omitted.
-->
次の例は、<code class="literal">distributors</code>テーブルと<code class="literal">actors</code>テーブルの和集合を取得する方法を示しています。さらに、両方のテーブルで結果をWという文字で始まる行のみに限定しています。
重複しない行のみが必要なので、<code class="literal">ALL</code>キーワードは省略されています。

</p><pre class="programlisting">
distributors:               actors:
 did |     name              id |     name
-----+--------------        ----+----------------
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributors.name
    FROM distributors
    WHERE distributors.name LIKE 'W%'
UNION
SELECT actors.name
    FROM actors
    WHERE actors.name LIKE 'W%';

      name
----------------
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen
</pre><p>
  </p><p>
<!--
   This example shows how to use a function in the <literal>FROM</literal>
   clause, both with and without a column definition list:
-->
次に、<code class="literal">FROM</code>句内での関数の使用方法について、列定義リストがある場合とない場合の両方の例を示します。

</p><pre class="programlisting">
CREATE FUNCTION distributors(int) RETURNS SETOF distributors AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors(111);
 did |    name
-----+-------------
 111 | Walt Disney

CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors_2(111) AS (f1 int, f2 text);
 f1  |     f2
-----+-------------
 111 | Walt Disney
</pre><p>
  </p><p>
<!--
   Here is an example of a function with an ordinality column added:
-->
以下は序数列が追加された関数の例です。

</p><pre class="programlisting">
SELECT * FROM unnest(ARRAY['a','b','c','d','e','f']) WITH ORDINALITY;
 unnest | ordinality
--------+----------
 a      |        1
 b      |        2
 c      |        3
 d      |        4
 e      |        5
 f      |        6
(6 rows)
</pre><p>
  </p><p>
<!--
   This example shows how to use a simple <literal>WITH</literal> clause:
-->
以下の例では簡単な<code class="literal">WITH</code>句の使用方法を示します。

</p><pre class="programlisting">
WITH t AS (
    SELECT random() as x FROM generate_series(1, 3)
  )
SELECT * FROM t
UNION ALL
SELECT * FROM t

         x          
--------------------
  0.534150459803641
  0.520092216785997
 0.0735620250925422
  0.534150459803641
  0.520092216785997
 0.0735620250925422
</pre><p>

<!--
   Notice that the <literal>WITH</literal> query was evaluated only once,
   so that we got two sets of the same three random values.
-->
<code class="literal">WITH</code>問い合わせが一度だけ評価されることに注意してください。
このため3つのランダムな値の同じ集合2組を得ることになります。
  </p><p>
<!--
   This example uses <literal>WITH RECURSIVE</literal> to find all
   subordinates (direct or indirect) of the employee Mary, and their
   level of indirectness, from a table that shows only direct
   subordinates:
-->
以下の例では<code class="literal">WITH RECURSIVE</code>を使用して、直接の部下しか表示しないテーブルから、従業員Maryの（直接または間接的な）部下とその間接度を見つけ出します。

</p><pre class="programlisting">
WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (
    SELECT 1, employee_name, manager_name
    FROM employee
    WHERE manager_name = 'Mary'
  UNION ALL
    SELECT er.distance + 1, e.employee_name, e.manager_name
    FROM employee_recursive er, employee e
    WHERE er.employee_name = e.manager_name
  )
SELECT distance, employee_name FROM employee_recursive;
</pre><p>

<!--
   Notice the typical form of recursive queries:
   an initial condition, followed by <literal>UNION</literal>,
   followed by the recursive part of the query. Be sure that the
   recursive part of the query will eventually return no tuples, or
   else the query will loop indefinitely.  (See <xref linkend="queries-with"/>
   for more examples.)
-->
初期条件、続いて<code class="literal">UNION</code>、さらに問い合わせの再帰部分という再帰問い合わせの典型的な構文に注意してください。
問い合わせの再帰部分は最終的にはタプルを返さないことを確実にしてください。
さもないと問い合わせは無限にループします。
（より多くの例については<a class="xref" href="queries-with.html" title="7.8. WITH問い合わせ（共通テーブル式）">7.8</a>を参照してください。）
  </p><p>
<!--
   This example uses <literal>LATERAL</literal> to apply a set-returning function
   <function>get_product_names()</function> for each row of the
   <structname>manufacturers</structname> table:
-->
以下の例では、<code class="structname">manufacturers</code>テーブルの各行に対して集合を返す<code class="function">get_product_names()</code>関数を適用するために<code class="literal">LATERAL</code>を使用します。

</p><pre class="programlisting">
SELECT m.name AS mname, pname
FROM manufacturers m, LATERAL get_product_names(m.id) pname;
</pre><p>

<!--
    Manufacturers not currently having any products would not appear in the
    result, since it is an inner join.  If we wished to include the names of
    such manufacturers in the result, we could do:
-->
これは内部結合ですので、現時点で製品をまったく持たないメーカは結果に現れません。
こうしたメーカの名前も結果に含めたければ以下のようにします。

</p><pre class="programlisting">
SELECT m.name AS mname, pname
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;
</pre></div><div class="refsect1" id="id-1.9.3.171.10"><h2>互換性</h2><!--
  <title>Compatibility</title>
--><p>
<!--
   Of course, the <command>SELECT</command> statement is compatible
   with the SQL standard.  But there are some extensions and some
   missing features.
-->
当然ながら、<code class="command">SELECT</code>文は標準SQLと互換性があります。
しかし、拡張機能や実現されていない機能もいくつかあります。
  </p><div class="refsect2" id="id-1.9.3.171.10.3"><h3><code class="literal">FROM</code>句の省略</h3><!--
   <title>Omitted <literal>FROM</literal> Clauses</title>
--><p>
<!--
    <productname>PostgreSQL</productname> allows one to omit the
    <literal>FROM</literal> clause.  It has a straightforward use to
    compute the results of simple expressions:
-->
<span class="productname">PostgreSQL</span>では、<code class="literal">FROM</code>句を省略することができます。
これによって、以下のように単純な式を計算させることができます。
</p><pre class="programlisting">
SELECT 2+2;

 ?column?
----------
        4
</pre><p>
<!--
    Some other <acronym>SQL</acronym> databases cannot do this except
    by introducing a dummy one-row table from which to do the
    <command>SELECT</command>.
-->
他の<acronym class="acronym">SQL</acronym>データベースでは、このような<code class="command">SELECT</code>を行うためにはダミーの1行テーブルを使わなければならないものもあります。
   </p><p>
<!--
    Note that if a <literal>FROM</literal> clause is not specified,
    the query cannot reference any database tables. For example, the
    following query is invalid:
-->
<code class="literal">FROM</code>句の指定がない場合、問い合わせではデータベーステーブルを参照することができません。
例えば、以下の問い合わせは無効です。
</p><pre class="programlisting">
SELECT distributors.* WHERE distributors.name = 'Westward';
</pre><p>
<!--
    <productname>PostgreSQL</productname> releases prior to
    8.1 would accept queries of this form, and add an implicit entry
    to the query's <literal>FROM</literal> clause for each table
    referenced by the query. This is no longer allowed.
-->
<span class="productname">PostgreSQL</span>リリース8.1より前まででは、こうした形の問い合わせを受け付け、問い合わせで参照する各テーブルに対する暗黙的な項目を問い合わせの<code class="literal">FROM</code>句に追加していました。
これは許されなくなりました。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.4"><h3>空の<code class="literal">SELECT</code>リスト</h3><!--
   <title>Empty <literal>SELECT</literal> Lists</title>
--><p>
<!--
    The list of output expressions after <literal>SELECT</literal> can be
    empty, producing a zero-column result table.
    This is not valid syntax according to the SQL standard.
    <productname>PostgreSQL</productname> allows it to be consistent with
    allowing zero-column tables.
    However, an empty list is not allowed when <literal>DISTINCT</literal> is used.
-->
<code class="literal">SELECT</code>の後の出力式のリストは空でも良く、このとき列数がゼロの結果テーブルが生成されます。
これは標準SQLでは有効な構文ではありませんが、<span class="productname">PostgreSQL</span>は列数がゼロのテーブルを許すので、それと整合性を保つために許しています。
しかし、<code class="literal">DISTINCT</code>を使う時は、空のリストを使うことはできません。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.5"><h3><code class="literal">AS</code>キーワードの省略</h3><!--
   <title>Omitting the <literal>AS</literal> Key Word</title>
--><p>
<!--
    In the SQL standard, the optional key word <literal>AS</literal> can be
    omitted before an output column name whenever the new column name
    is a valid column name (that is, not the same as any reserved
    keyword).  <productname>PostgreSQL</productname> is slightly more
    restrictive: <literal>AS</literal> is required if the new column name
    matches any keyword at all, reserved or not.  Recommended practice is
    to use <literal>AS</literal> or double-quote output column names, to prevent
    any possible conflict against future keyword additions.
-->
標準SQLでは、キーワード<code class="literal">AS</code>(省略可能)は、新しい列名が有効な列名（つまり予約済みのどのキーワードとも異なるもの）である場合は常に、出力列名の前から省くことができます。
<span class="productname">PostgreSQL</span>には多少より強い制限があります。
新しい列名が予約済みか否かに関わらず何らかのキーワードに一致する場合は<code class="literal">AS</code>が必要です。
推奨する実践方法は、今後のキーワードの追加と競合する可能性に備え、<code class="literal">AS</code>を使用する、または出力列名を二重引用符で括ることです。
   </p><p>
<!--
    In <literal>FROM</literal> items, both the standard and
    <productname>PostgreSQL</productname> allow <literal>AS</literal> to
    be omitted before an alias that is an unreserved keyword.  But
    this is impractical for output column names, because of syntactic
    ambiguities.
-->
<code class="literal">FROM</code>項目において標準および<span class="productname">PostgreSQL</span>では、未予約のキーワードである別名の前の<code class="literal">AS</code>を省略することができます。
しかし、構文があいまいになるため、出力名では実践的ではありません。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.6"><h3><code class="literal">ONLY</code>と継承関係</h3><!--
   <title><literal>ONLY</literal> and Inheritance</title>
--><p>
<!--
    The SQL standard requires parentheses around the table name when
    writing <literal>ONLY</literal>, for example <literal>SELECT * FROM ONLY
    (tab1), ONLY (tab2) WHERE ...</literal>.  <productname>PostgreSQL</productname>
    considers these parentheses to be optional.
-->
標準SQLでは、<code class="literal">SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...</code>のように、<code class="literal">ONLY</code>を記述する時にテーブル名の前後を括弧でくくることを要求します。
<span class="productname">PostgreSQL</span>ではこの括弧を省略可能であるとみなしています。
   </p><p>
<!--
    <productname>PostgreSQL</productname> allows a trailing <literal>*</literal> to be written to
    explicitly specify the non-<literal>ONLY</literal> behavior of including
    child tables.  The standard does not allow this.
-->
<span class="productname">PostgreSQL</span>では最後に<code class="literal">*</code>を付けることで
明示的に子テーブルを含めるという<code class="literal">ONLY</code>ではない動作を指定することができます。
標準ではこれを許していません。
   </p><p>
<!--
    (These points apply equally to all SQL commands supporting the
    <literal>ONLY</literal> option.)
-->
（これらの点は<code class="literal">ONLY</code>オプションをサポートするすべてのSQLコマンドで同様に適用されます。）
   </p></div><div class="refsect2" id="id-1.9.3.171.10.7"><h3><code class="literal">TABLESAMPLE</code>句の制限</h3><!--
   <title><literal>TABLESAMPLE</literal> Clause Restrictions</title>
--><p>
<!--
    The <literal>TABLESAMPLE</literal> clause is currently accepted only on
    regular tables and materialized views.  According to the SQL standard
    it should be possible to apply it to any <literal>FROM</literal> item.
-->
現在のところ、<code class="literal">TABLESAMPLE</code>句は通常のテーブルとマテリアライズドビューでのみ受け付けられます。
SQL標準では、<code class="literal">FROM</code>句の任意の要素について適用可能であるべきとされています。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.8"><h3><code class="literal">FROM</code>内の関数呼び出し</h3><!--
   <title>Function Calls in <literal>FROM</literal></title>
--><p>
<!--
    <productname>PostgreSQL</productname> allows a function call to be
    written directly as a member of the <literal>FROM</literal> list.  In the SQL
    standard it would be necessary to wrap such a function call in a
    sub-<command>SELECT</command>; that is, the syntax
    <literal>FROM <replaceable>func</replaceable>(...) <replaceable>alias</replaceable></literal>
    is approximately equivalent to
    <literal>FROM LATERAL (SELECT <replaceable>func</replaceable>(...)) <replaceable>alias</replaceable></literal>.
    Note that <literal>LATERAL</literal> is considered to be implicit; this is
    because the standard requires <literal>LATERAL</literal> semantics for an
    <literal>UNNEST()</literal> item in <literal>FROM</literal>.
    <productname>PostgreSQL</productname> treats <literal>UNNEST()</literal> the
    same as other set-returning functions.
-->
<span class="productname">PostgreSQL</span>では、<code class="literal">FROM</code>リストのメンバとして直接関数呼び出しを記述することができます。
標準SQLではこうした関数呼び出しを副<code class="command">SELECT</code>内に囲む必要があります。
つまり<code class="literal">FROM <em class="replaceable"><code>func</code></em>(...) <em class="replaceable"><code>alias</code></em></code>はおおよそ<code class="literal">FROM LATERAL (SELECT <em class="replaceable"><code>func</code></em>(...)) <em class="replaceable"><code>alias</code></em></code>と同じです。
暗黙的に<code class="literal">LATERAL</code>であるとみなされることに注意してください。
標準では<code class="literal">FROM</code>内の<code class="literal">UNNEST()</code>項目には<code class="literal">LATERAL</code>構文を必要とするためです。
<span class="productname">PostgreSQL</span>では<code class="literal">UNNEST()</code>を他の集合を返す関数と同じものとして扱います。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.9"><h3><code class="literal">GROUP BY</code>と<code class="literal">ORDER BY</code>における利用可能な名前空間</h3><!--
   <title>Namespace Available to <literal>GROUP BY</literal> and <literal>ORDER BY</literal></title>
--><p>
<!--
    In the SQL-92 standard, an <literal>ORDER BY</literal> clause can
    only use output column names or numbers, while a <literal>GROUP
    BY</literal> clause can only use expressions based on input column
    names.  <productname>PostgreSQL</productname> extends each of
    these clauses to allow the other choice as well (but it uses the
    standard's interpretation if there is ambiguity).
    <productname>PostgreSQL</productname> also allows both clauses to
    specify arbitrary expressions.  Note that names appearing in an
    expression will always be taken as input-column names, not as
    output-column names.
-->
標準SQL-92では、<code class="literal">ORDER BY</code>句で使用できるのは、出力列名か序数のみであり、<code class="literal">GROUP BY</code>句で使用できるのは、入力列名からなる式のみです。
<span class="productname">PostgreSQL</span>は、これらの句で両方が指定できるように拡張されています
（ただし、不明瞭さがある場合は標準の解釈が使用されます）。
さらに、<span class="productname">PostgreSQL</span>ではどちらの句にも任意の式を指定できます。
式で使われる名前は、常に出力列名ではなく入力列の名前とみなされることに注意してください。
   </p><p>
<!--
    SQL:1999 and later use a slightly different definition which is not
    entirely upward compatible with SQL-92.
    In most cases, however, <productname>PostgreSQL</productname>
    will interpret an <literal>ORDER BY</literal> or <literal>GROUP
    BY</literal> expression the same way SQL:1999 does.
-->
SQL:1999以降では、SQL-92と完全には上位互換でない、多少異なる定義が採用されています。
しかし、ほとんどの場合、<span class="productname">PostgreSQL</span>はSQL:1999と同じ方法で<code class="literal">ORDER BY</code>や<code class="literal">GROUP BY</code>を解釈します。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.10"><h3>関数従属性</h3><!--
   <title>Functional Dependencies</title>
--><p>
<!--
    <productname>PostgreSQL</productname> recognizes functional dependency
    (allowing columns to be omitted from <literal>GROUP BY</literal>) only when
    a table's primary key is included in the <literal>GROUP BY</literal> list.
    The SQL standard specifies additional conditions that should be
    recognized.
-->
テーブルの主キーが<code class="literal">GROUP BY</code>リストに含まれる場合に限り、<span class="productname">PostgreSQL</span>は（<code class="literal">GROUP BY</code>で列を省くことができる）関数従属性を認識します。
標準SQLでは、認識しなければならない追加の条件を規定しています。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.11"><h3><code class="literal">LIMIT</code>および<code class="literal">OFFSET</code></h3><!--
   <title><literal>LIMIT</literal> and <literal>OFFSET</literal></title>
--><p>
<!--
    The clauses <literal>LIMIT</literal> and <literal>OFFSET</literal>
    are <productname>PostgreSQL</productname>-specific syntax, also
    used by <productname>MySQL</productname>.  The SQL:2008 standard
    has introduced the clauses <literal>OFFSET ... FETCH {FIRST|NEXT}
    ...</literal> for the same functionality, as shown above
    in <xref linkend="sql-limit" endterm="sql-limit-title"/>.  This
    syntax is also used by <productname>IBM DB2</productname>.
    (Applications written for <productname>Oracle</productname>
    frequently use a workaround involving the automatically
    generated <literal>rownum</literal> column, which is not available in
    PostgreSQL, to implement the effects of these clauses.)
-->
<code class="literal">LIMIT</code>および<code class="literal">OFFSET</code>句は<span class="productname">PostgreSQL</span>独自の構文ですが、<span class="productname">MySQL</span>でも使用されています。
<a class="xref" href="sql-select.html#SQL-LIMIT" title="LIMIT句"><code class="literal">LIMIT</code>句</a>で説明したように、標準SQL:2008にて同じ機能の<code class="literal">OFFSET ... FETCH {FIRST|NEXT} ...</code>が導入されました。
この構文は<span class="productname">IBM DB2</span>でも使用されています。
（<span class="productname">Oracle</span>用に開発されたアプリケーションでは、これらの句の機能を実装するために自動生成される<code class="literal">rownum</code>列を含めるという回避策を使用することが多いですが、PostgreSQLでは利用できません。）
   </p></div><div class="refsect2" id="id-1.9.3.171.10.12"><h3><code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code></h3><!--
   <title><literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal>, <literal>FOR KEY SHARE</literal></title>
--><p>
<!--
    Although <literal>FOR UPDATE</literal> appears in the SQL standard, the
    standard allows it only as an option of <command>DECLARE CURSOR</command>.
    <productname>PostgreSQL</productname> allows it in any <command>SELECT</command>
    query as well as in sub-<command>SELECT</command>s, but this is an extension.
    The <literal>FOR NO KEY UPDATE</literal>, <literal>FOR SHARE</literal> and
    <literal>FOR KEY SHARE</literal> variants, as well as the <literal>NOWAIT</literal>
    and <literal>SKIP LOCKED</literal> options, do not appear in the
    standard.
-->
<code class="literal">FOR UPDATE</code>は標準SQLに存在しますが、標準では、<code class="command">DECLARE CURSOR</code>のオプションとしてしか許されていません。
<span class="productname">PostgreSQL</span>では、副<code class="command">SELECT</code>など任意の<code class="command">SELECT</code>で許されます。
これは拡張です。
<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>の亜種、および<code class="literal">NOWAIT</code>と<code class="literal">SKIP LOCKED</code>オプションは標準にはありません。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.13"><h3><code class="literal">WITH</code>内のデータ変更文</h3><!--
   <title>Data-Modifying Statements in <literal>WITH</literal></title>
--><p>
<!--
    <productname>PostgreSQL</productname> allows <command>INSERT</command>,
    <command>UPDATE</command>, and <command>DELETE</command> to be used as <literal>WITH</literal>
    queries.  This is not found in the SQL standard.
-->
<span class="productname">PostgreSQL</span>では<code class="literal">WITH</code>問い合わせとして<code class="command">INSERT</code>、<code class="command">UPDATE</code>および<code class="command">DELETE</code>を使用することができます。
これは標準SQLにはありません。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.14"><h3>非標準句</h3><!--
   <title>Nonstandard Clauses</title>
--><p>
<!--
    <literal>DISTINCT ON ( ... )</literal> is an extension of the
    SQL standard.
-->
<code class="literal">DISTINCT ON ( ... )</code>は標準SQLの拡張です。
   </p><p>
<!--
    <literal>ROWS FROM( ... )</literal> is an extension of the SQL standard.
-->
<code class="literal">ROWS FROM( ... )</code>は標準SQLの拡張です。
   </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-security-label.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-selectinto.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">SECURITY LABEL </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> SELECT INTO</td></tr></table></div></body></html>