<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>27.4. ホットスタンバイ</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="warm-standby-failover.html" title="27.3. フェイルオーバー" /><link rel="next" href="monitoring.html" title="第28章 データベース活動状況の監視" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 15rc2文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="high-availability.html" title="第27章 高可用性、負荷分散およびレプリケーション">第27章 高可用性、負荷分散およびレプリケーション</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?template=bug_report.yml&amp;what-happened=version 15rc2 : hot-standby.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="warm-standby-failover.html" title="27.3. フェイルオーバー">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="high-availability.html" title="第27章 高可用性、負荷分散およびレプリケーション">上へ</a></td><td width="60%" align="center">27.4. ホットスタンバイ</td><td width="20%" align="right"> <a accesskey="n" href="monitoring.html" title="第28章 データベース活動状況の監視">次へ</a></td></tr></table><hr /></div><div class="sect1" id="HOT-STANDBY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">27.4. ホットスタンバイ</h2></div></div></div><span class="original">
  &lt;title&gt;Hot Standby&lt;/title&gt;
</span><a id="id-1.6.14.24.2" class="indexterm"></a><p>
<span class="original">
    Hot standby is the term used to describe the ability to connect to
    the server and run read-only queries while the server is in archive
    recovery or standby mode. This
    is useful both for replication purposes and for restoring a backup
    to a desired state with great precision.
    The term hot standby also refers to the ability of the server to move
    from recovery through to normal operation while users continue running
    queries and/or keep their connections open.
</span>
《マッチ度[92.358079]》ホットスタンバイという単語は、サーバがアーカイブリカバリを実行している最中にサーバに接続し読み取り専用の問い合わせを実行することができる機能を説明するために使われます。
これは、レプリケーションという目的およびバックアップからのリストアの両方で高い精度で好ましい状態にするために有用です。
ホットスタンバイという単語はまた、ユーザが問い合わせを実行しながら、または、開いている接続を維持しながら、またはその両方で、サーバをリカバリ状態から通常の動作に移すことができる機能も示すものです。
   </p><p>
<span class="original">
    Running queries in hot standby mode is similar to normal query operation,
    though there are several usage and administrative differences
    explained below.
</span>
ホットスタンバイモードにおける問い合わせは、通常の問い合わせに類似していますが、利用上および管理上の差異が多少あり、以下に説明します。
   </p><div class="sect2" id="HOT-STANDBY-USERS"><div class="titlepage"><div><div><h3 class="title">27.4.1. ユーザのための概説</h3></div></div></div><span class="original">
   &lt;title&gt;User's Overview&lt;/title&gt;
</span><p>
<span class="original">
    When the &lt;xref linkend="guc-hot-standby"/&gt; parameter is set to true on a
    standby server, it will begin accepting connections once the recovery has
    brought the system to a consistent state.  All such connections are
    strictly read-only; not even temporary tables may be written.
</span>
スタンバイサーバで<a class="xref" href="runtime-config-replication.html#GUC-HOT-STANDBY">hot_standby</a>パラメータが真に設定されている場合、リカバリによりシステムが一貫性を持つようになった後接続を受け付け始めます。
こうした接続はすべて読み取り専用に限定されます。
一時テーブルであっても書き込むことはできません。
   </p><p>
<span class="original">
    The data on the standby takes some time to arrive from the primary server
    so there will be a measurable delay between primary and standby. Running the
    same query nearly simultaneously on both primary and standby might therefore
    return differing results. We say that data on the standby is
    &lt;firstterm&gt;eventually consistent&lt;/firstterm&gt; with the primary.  Once the
    commit record for a transaction is replayed on the standby, the changes
    made by that transaction will be visible to any new snapshots taken on
    the standby.  Snapshots may be taken at the start of each query or at the
    start of each transaction, depending on the current transaction isolation
    level.  For more details, see &lt;xref linkend="transaction-iso"/&gt;.
</span>
スタンバイ上のデータはプライマリサーバから届くまでに多少の時間がかかります。
このため、プライマリとスタンバイの間にはある程度の遅延があります。
したがって、同じ問い合わせをほとんど同時にプライマリとスタンバイに対して実行すると、異なる結果が返る可能性があります。
スタンバイ上のデータはプライマリに対して<em class="firstterm">最後には一貫性を持つ</em>といいます。
あるトランザクションのコミットレコードがスタンバイ上で再生されると、そのトランザクションでなされた変更はスタンバイで獲得されるすべての新規スナップショットで可視になります。
現在のトランザクション分離レベルに応じて、スナップショットは各問い合わせの開始時または各トランザクションの開始時に獲得されます。
詳細については<a class="xref" href="transaction-iso.html" title="13.2. トランザクションの分離">13.2</a>を参照してください。
   </p><p>
<span class="original">
    Transactions started during hot standby may issue the following commands:
</span>
ホットスタンバイ中に開始されたトランザクションは以下のコマンドを発行することができます。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
       Query access: &lt;command&gt;SELECT&lt;/command&gt;, &lt;command&gt;COPY TO&lt;/command&gt;
</span>
問い合わせによるアクセス: <code class="command">SELECT</code>および<code class="command">COPY TO</code>
      </p></li><li class="listitem"><p>
<span class="original">
       Cursor commands: &lt;command&gt;DECLARE&lt;/command&gt;, &lt;command&gt;FETCH&lt;/command&gt;, &lt;command&gt;CLOSE&lt;/command&gt;
</span>
カーソルコマンド: <code class="command">DECLARE</code>と<code class="command">FETCH</code>と<code class="command">CLOSE</code>
      </p></li><li class="listitem"><p>
<span class="original">
       Settings: &lt;command&gt;SHOW&lt;/command&gt;, &lt;command&gt;SET&lt;/command&gt;, &lt;command&gt;RESET&lt;/command&gt;
</span>
設定の操作: <code class="command">SHOW</code>と<code class="command">SET</code>と<code class="command">RESET</code>
      </p></li><li class="listitem"><p>
<span class="original">
       Transaction management commands:
</span>
トランザクション管理コマンド:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
<span class="original">
           &lt;command&gt;BEGIN&lt;/command&gt;, &lt;command&gt;END&lt;/command&gt;, &lt;command&gt;ABORT&lt;/command&gt;, &lt;command&gt;START TRANSACTION&lt;/command&gt;
</span>
<code class="command">BEGIN</code>と<code class="command">END</code>と<code class="command">ABORT</code>と<code class="command">START TRANSACTION</code>
          </p></li><li class="listitem"><p>
<span class="original">
           &lt;command&gt;SAVEPOINT&lt;/command&gt;, &lt;command&gt;RELEASE&lt;/command&gt;, &lt;command&gt;ROLLBACK TO SAVEPOINT&lt;/command&gt;
</span>
<code class="command">SAVEPOINT</code>と<code class="command">RELEASE</code>と<code class="command">ROLLBACK TO SAVEPOINT</code>
          </p></li><li class="listitem"><p>
<span class="original">
           &lt;command&gt;EXCEPTION&lt;/command&gt; blocks and other internal subtransactions
</span>
<code class="command">EXCEPTION</code>ブロックおよびこの他の内部サブトランザクション
          </p></li></ul></div><p>
      </p></li><li class="listitem"><p>
<span class="original">
       &lt;command&gt;LOCK TABLE&lt;/command&gt;, though only when explicitly in one of these modes:
       &lt;literal&gt;ACCESS SHARE&lt;/literal&gt;, &lt;literal&gt;ROW SHARE&lt;/literal&gt; or &lt;literal&gt;ROW EXCLUSIVE&lt;/literal&gt;.
</span>
<code class="command">LOCK TABLE</code>。
なお、以下のモードが明示された場合に限ります。
<code class="literal">ACCESS SHARE</code>または<code class="literal">ROW SHARE</code>または<code class="literal">ROW EXCLUSIVE</code>
      </p></li><li class="listitem"><p>
<span class="original">
       Plans and resources: &lt;command&gt;PREPARE&lt;/command&gt;, &lt;command&gt;EXECUTE&lt;/command&gt;,
       &lt;command&gt;DEALLOCATE&lt;/command&gt;, &lt;command&gt;DISCARD&lt;/command&gt;
</span>
計画と資源: <code class="command">PREPARE</code>と<code class="command">EXECUTE</code>と<code class="command">DEALLOCATE</code>と<code class="command">DISCARD</code>
      </p></li><li class="listitem"><p>
<span class="original">
       Plugins and extensions: &lt;command&gt;LOAD&lt;/command&gt;
</span>
プラグインと拡張: <code class="command">LOAD</code>
      </p></li><li class="listitem"><p>
       <code class="command">UNLISTEN</code>
      </p></li></ul></div><p>
   </p><p>
<span class="original">
    Transactions started during hot standby will never be assigned a
    transaction ID and cannot write to the system write-ahead log.
    Therefore, the following actions will produce error messages:
</span>
ホットスタンバイ中に開始したトランザクションではトランザクションIDを割り当てられません。
また、システムのログ先行書き込みに書き出すことができません。
このため、以下の動作はエラーメッセージを生成します。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
       Data Manipulation Language (DML): <code class="command">INSERT</code>,
       <code class="command">UPDATE</code>, <code class="command">DELETE</code>, <code class="command">COPY FROM</code>,
       <code class="command">TRUNCATE</code>.
       Note that there are no allowed actions that result in a trigger
       being executed during recovery.  This restriction applies even to
       temporary tables, because table rows cannot be read or written without
       assigning a transaction ID, which is currently not possible in a
       hot standby environment.
      </p></li><li class="listitem"><p>
<span class="original">
       Data Definition Language (DDL): &lt;command&gt;CREATE&lt;/command&gt;,
       &lt;command&gt;DROP&lt;/command&gt;, &lt;command&gt;ALTER&lt;/command&gt;, &lt;command&gt;COMMENT&lt;/command&gt;.
       This restriction applies even to temporary tables, because carrying
       out these operations would require updating the system catalog tables.
</span>
データ定義言語（DDL）:
<code class="command">CREATE</code>、<code class="command">DROP</code>、<code class="command">ALTER</code>および<code class="command">COMMENT</code>。
この制約は一時テーブルに対しても適用されます。
これらの操作の実行がシステムカタログテーブルの更新を必要とするためです。
      </p></li><li class="listitem"><p>
<span class="original">
       &lt;command&gt;SELECT ... FOR SHARE | UPDATE&lt;/command&gt;, because row locks cannot be
       taken without updating the underlying data files.
</span>
<code class="command">SELECT ... FOR SHARE | UPDATE</code>。
背後のデータファイルを更新することなく行ロックを獲得することはできないためです。
      </p></li><li class="listitem"><p>
<span class="original">
       Rules on &lt;command&gt;SELECT&lt;/command&gt; statements that generate DML commands.
</span>
データ操作言語のコマンドを生成する<code class="command">SELECT</code>文のルール
      </p></li><li class="listitem"><p>
<span class="original">
       &lt;command&gt;LOCK&lt;/command&gt; that explicitly requests a mode higher than &lt;literal&gt;ROW EXCLUSIVE MODE&lt;/literal&gt;.
</span>
<code class="literal">ROW EXCLUSIVE MODE</code>より高いモードを明示的に要求する<code class="command">LOCK</code>
      </p></li><li class="listitem"><p>
<span class="original">
       &lt;command&gt;LOCK&lt;/command&gt; in short default form, since it requests &lt;literal&gt;ACCESS EXCLUSIVE MODE&lt;/literal&gt;.
</span>
短いデフォルト構文の<code class="command">LOCK</code>。
これは<code class="literal">ACCESS EXCLUSIVE MODE</code>を要求するためです。
      </p></li><li class="listitem"><p>
<span class="original">
       Transaction management commands that explicitly set non-read-only state:
</span>
読み取り専用でない状態を明示的に設定するトランザクション処理コマンド
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
<span class="original">
            &lt;command&gt;BEGIN READ WRITE&lt;/command&gt;,
            &lt;command&gt;START TRANSACTION READ WRITE&lt;/command&gt;
</span>
<code class="command">BEGIN READ WRITE</code>と<code class="command">START TRANSACTION READ WRITE</code>
          </p></li><li class="listitem"><p>
<span class="original">
            &lt;command&gt;SET TRANSACTION READ WRITE&lt;/command&gt;,
            &lt;command&gt;SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE&lt;/command&gt;
</span>
<code class="command">SET TRANSACTION READ WRITE</code>と<code class="command">SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE</code>
          </p></li><li class="listitem"><p>
<span class="original">
           &lt;command&gt;SET transaction_read_only = off&lt;/command&gt;
</span>
<code class="command">SET transaction_read_only = off</code>
          </p></li></ul></div><p>
      </p></li><li class="listitem"><p>
<span class="original">
       Two-phase commit commands: &lt;command&gt;PREPARE TRANSACTION&lt;/command&gt;,
       &lt;command&gt;COMMIT PREPARED&lt;/command&gt;, &lt;command&gt;ROLLBACK PREPARED&lt;/command&gt;
       because even read-only transactions need to write WAL in the
       prepare phase (the first phase of two phase commit).
</span>
二相コミットコマンド: <code class="command">PREPARE TRANSACTION</code>、<code class="command">COMMIT PREPARED</code>および<code class="command">ROLLBACK PREPARED</code>。
読み取り専用トランザクションでも、プリペア相（二相コミットの第1相）においてWALの書き込みが必要だからです。
      </p></li><li class="listitem"><p>
<span class="original">
       Sequence updates: &lt;function&gt;nextval()&lt;/function&gt;, &lt;function&gt;setval()&lt;/function&gt;
</span>
シーケンス更新の関数: <code class="function">nextval()</code>と<code class="function">setval()</code>
      </p></li><li class="listitem"><p>
<span class="original">
       &lt;command&gt;LISTEN&lt;/command&gt;, &lt;command&gt;NOTIFY&lt;/command&gt;
</span>
<code class="command">LISTEN</code>、<code class="command">NOTIFY</code>
      </p></li></ul></div><p>
   </p><p>
<span class="original">
    In normal operation, &lt;quote&gt;read-only&lt;/quote&gt; transactions are allowed to
    use &lt;command&gt;LISTEN&lt;/command&gt; and &lt;command&gt;NOTIFY&lt;/command&gt;,
    so hot standby sessions operate under slightly tighter
    restrictions than ordinary read-only sessions.  It is possible that some
    of these restrictions might be loosened in a future release.
</span>
《マッチ度[92.857143]》通常の操作では、<span class="quote">「<span class="quote">読み取り専用</span>」</span>トランザクションには<code class="command">LISTEN</code>と<code class="command">NOTIFY</code>の使用が許可されています。
ホットスタンバイセッションの操作では、通常の読み取り専用セッションよりも少し厳しい制約を受けます。
将来のリリースではこの制約の一部が緩和されるかもしれません。
   </p><p>
<span class="original">
    During hot standby, the parameter &lt;varname&gt;transaction_read_only&lt;/varname&gt; is always
    true and may not be changed.  But as long as no attempt is made to modify
    the database, connections during hot standby will act much like any other
    database connection.  If failover or switchover occurs, the database will
    switch to normal processing mode.  Sessions will remain connected while the
    server changes mode.  Once hot standby finishes, it will be possible to
    initiate read-write transactions (even from a session begun during
    hot standby).
</span>
ホットスタンバイ中は、<code class="varname">transaction_read_only</code>パラメータは常に真であり、変更することはできません。
しかし、データベースを変更するような試行がない限り、ホットスタンバイ中の接続は他のデータベース接続とほとんど同じように動作します。
もし、フェイルオーバーまたはスイッチオーバーが発生すると、データベースは通常処理モードに切り替わります。
サーバのモードが変わってもセッションは接続を保持します。
ホットスタンバイが完了すると、読み書き可能なトランザクションを（ホットスタンバイ中に始まったセッションからであっても）始められるようになります。
   </p><p>
<span class="original">
    Users can determine whether hot standby is currently active for their
    session by issuing &lt;command&gt;SHOW in_hot_standby&lt;/command&gt;.
    (In server versions before 14, the &lt;varname&gt;in_hot_standby&lt;/varname&gt;
    parameter did not exist; a workable substitute method for older servers
    is &lt;command&gt;SHOW transaction_read_only&lt;/command&gt;.)  In addition, a set of
    functions (&lt;xref linkend="functions-recovery-info-table"/&gt;) allow users to
    access information about the standby server. These allow you to write
    programs that are aware of the current state of the database. These
    can be used to monitor the progress of recovery, or to allow you to
    write complex programs that restore the database to particular states.
</span>
ユーザは<code class="command">SHOW in_hot_standby</code>を発行することで、そのセッションが読み取り専用かどうかを調べることができます。
（サーババージョンが14より前では<code class="varname">in_hot_standby</code>パラメータは存在しませんでした。古いバージョンでの可能な代替方法は、<code class="command">SHOW transaction_read_only</code>です。）
さらに、ユーザがスタンバイサーバに関する情報にアクセスできる関数群(<a class="xref" href="functions-admin.html#FUNCTIONS-RECOVERY-INFO-TABLE" title="表9.89 リカバリ情報関数">表 9.89</a>)があります。
これらによりデータベースの現状認識を行うプログラムを作成することができます。
これらを使用して、リカバリの進行状況を監視するために使用したり、データベースを特定の状態にリストアする複雑なプログラムを作成したりすることができます。
   </p></div><div class="sect2" id="HOT-STANDBY-CONFLICT"><div class="titlepage"><div><div><h3 class="title">27.4.2. 問い合わせコンフリクトの処理</h3></div></div></div><span class="original">
   &lt;title&gt;Handling Query Conflicts&lt;/title&gt;
</span><p>
<span class="original">
    The primary and standby servers are in many ways loosely connected. Actions
    on the primary will have an effect on the standby. As a result, there is
    potential for negative interactions or conflicts between them. The easiest
    conflict to understand is performance: if a huge data load is taking place
    on the primary then this will generate a similar stream of WAL records on the
    standby, so standby queries may contend for system resources, such as I/O.
</span>
プライマリサーバとスタンバイサーバは、多方面でゆるく結合しています。
プライマリサーバの動作はスタンバイサーバに影響します。
その結果、負の相互作用またはコンフリクトの可能性があります。
最も分かりやすいコンフリクトは性能です。
プライマリサーバで巨大なデータがロードされた場合、スタンバイサーバにおいて同様に巨大なWALレコードが生成されるので、スタンバイサーバにおける問い合わせは互いにI/Oなどのシステム資源を奪い合います。
   </p><p>
    There are also additional types of conflict that can occur with hot standby.
    These conflicts are <span class="emphasis"><em>hard conflicts</em></span> in the sense that queries
    might need to be canceled and, in some cases, sessions disconnected to resolve them.
    The user is provided with several ways to handle these
    conflicts. Conflict cases include:

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
         Access Exclusive locks taken on the primary server, including both
         explicit &lt;command&gt;LOCK&lt;/command&gt; commands and various &lt;acronym&gt;DDL&lt;/acronym&gt;
         actions, conflict with table accesses in standby queries.
</span>
プライマリサーバで獲得されたアクセス排他ロックは、スタンバイの問い合わせにおけるテーブルアクセスとコンフリクトします。
明示的な<code class="command">LOCK</code>コマンドおよび各種<acronym class="acronym">DDL</acronym>操作を含みます。
        </p></li><li class="listitem"><p>
<span class="original">
         Dropping a tablespace on the primary conflicts with standby queries
         using that tablespace for temporary work files.
</span>
プライマリでテーブル空間を削除することは、一時作業ファイル用にそのテーブル空間を使用するスタンバイ側の問い合わせとコンフリクトします。
        </p></li><li class="listitem"><p>
<span class="original">
         Dropping a database on the primary conflicts with sessions connected
         to that database on the standby.
</span>
プライマリでデータベースを削除することは、スタンバイ側でそのデータベースに接続するセッションとコンフリクトします。
        </p></li><li class="listitem"><p>
<span class="original">
         Application of a vacuum cleanup record from WAL conflicts with
         standby transactions whose snapshots can still &lt;quote&gt;see&lt;/quote&gt; any of
         the rows to be removed.
</span>
WALからのバキュームクリーンアップレコードの適用は、その適用により削除される行のどれか1つでも<span class="quote">「<span class="quote">見る</span>」</span>ことができるスナップショットを持つスタンバイでのトランザクションとコンフリクトします。
        </p></li><li class="listitem"><p>
<span class="original">
         Application of a vacuum cleanup record from WAL conflicts with
         queries accessing the target page on the standby, whether or not
         the data to be removed is visible.
</span>
WALからのバキュームクリーンアップレコードは、消去されるデータが可視か否かに関係なく、スタンバイで対象ページにアクセスする問い合わせとコンフリクトします。
        </p></li></ul></div><p>
   </p><p>
<span class="original">
    On the primary server, these cases simply result in waiting; and the
    user might choose to cancel either of the conflicting actions.  However,
    on the standby there is no choice: the WAL-logged action already occurred
    on the primary so the standby must not fail to apply it.  Furthermore,
    allowing WAL application to wait indefinitely may be very undesirable,
    because the standby's state will become increasingly far behind the
    primary's.  Therefore, a mechanism is provided to forcibly cancel standby
    queries that conflict with to-be-applied WAL records.
</span>
プライマリサーバでは、こうした状況は単に待たされるだけです。
ユーザはコンフリクトする操作をキャンセルすることを選ぶことができます。
しかし、スタンバイ側には選択肢がありません。
WALに記録された操作はすでにプライマリで発生したものですので、スタンバイではその適用に失敗してはなりません。
さらに、適用したいWALを無制限に待機させることを許すことは、まったく望まない結果になってしまうかもしれません。
なぜなら、スタンバイの状態がプライマリの状態とだんだんとかけ離れてしまうからです。
したがって適用すべきWALレコードとコンフリクトするスタンバイの問い合わせを強制的に取り消す仕組みが用意されています。
   </p><p>
<span class="original">
    An example of the problem situation is an administrator on the primary
    server running &lt;command&gt;DROP TABLE&lt;/command&gt; on a table that is currently being
    queried on the standby server.  Clearly the standby query cannot continue
    if the &lt;command&gt;DROP TABLE&lt;/command&gt; is applied on the standby. If this situation
    occurred on the primary, the &lt;command&gt;DROP TABLE&lt;/command&gt; would wait until the
    other query had finished. But when &lt;command&gt;DROP TABLE&lt;/command&gt; is run on the
    primary, the primary doesn't have information about what queries are
    running on the standby, so it will not wait for any such standby
    queries. The WAL change records come through to the standby while the
    standby query is still running, causing a conflict.  The standby server
    must either delay application of the WAL records (and everything after
    them, too) or else cancel the conflicting query so that the &lt;command&gt;DROP
    TABLE&lt;/command&gt; can be applied.
</span>
この問題の例として、スタンバイサーバで現在問い合わせ対象となっているテーブルをプライマリサーバで<code class="command">DROP TABLE</code>を行う管理者を考えてみます。
スタンバイで<code class="command">DROP TABLE</code>が適用されたら問い合わせを継続できないことは明確です。
プライマリ上でこうした状況が発生した場合は、他の問い合わせが終わるまで<code class="command">DROP TABLE</code>は待機させられます。
しかし、<code class="command">DROP TABLE</code>がプライマリで実行された時、プライマリ側でスタンバイで稼動する問い合わせに関する情報がありませんので、スタンバイ側のこうした問い合わせを待機させることはできません。
スタンバイ側で問い合わせが実行している時にWALの変更レコードがスタンバイに届けば、コンフリクトが発生します。
スタンバイサーバはWALレコードの適用を遅延させる（およびその後の適用すべても遅延させる）か、<code class="command">DROP TABLE</code>を適用できるようにコンフリクトする問い合わせを取り消すかのいずれかを行わなければなりません。
   </p><p>
<span class="original">
    When a conflicting query is short, it's typically desirable to allow it to
    complete by delaying WAL application for a little bit; but a long delay in
    WAL application is usually not desirable.  So the cancel mechanism has
    parameters, &lt;xref linkend="guc-max-standby-archive-delay"/&gt; and &lt;xref
    linkend="guc-max-standby-streaming-delay"/&gt;, that define the maximum
    allowed delay in WAL application.  Conflicting queries will be canceled
    once it has taken longer than the relevant delay setting to apply any
    newly-received WAL data.  There are two parameters so that different delay
    values can be specified for the case of reading WAL data from an archive
    (i.e., initial recovery from a base backup or &lt;quote&gt;catching up&lt;/quote&gt; a
    standby server that has fallen far behind) versus reading WAL data via
    streaming replication.
</span>
コンフリクトする問い合わせが短ければ、適用したいWALを多少遅延させることで、問い合わせを完了させることが通常望まれます。
しかし、WALの適用が長く遅延することはたいていは望まれません。
したがって、取り消し機能は<a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-ARCHIVE-DELAY">max_standby_archive_delay</a>と<a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-STREAMING-DELAY">max_standby_streaming_delay</a>というパラメータを持ちます。
これらはWAL適用に許される遅延を定義するものです。
コンフリクトする問い合わせは、何らかの新しく受信したWALデータを適用するための各種遅延設定を超えたら取り消されます。
アーカイブからWALデータを読み取る場合（つまりベースバックアップからの初期リカバリや大きく遅延したスタンバイサーバの<span class="quote">「<span class="quote">追従</span>」</span>）とストリーミングレプリケーションとで異なる遅延値を指定することができるように2つのパラメータが存在します。
   </p><p>
<span class="original">
    In a standby server that exists primarily for high availability, it's
    best to set the delay parameters relatively short, so that the server
    cannot fall far behind the primary due to delays caused by standby
    queries.  However, if the standby server is meant for executing
    long-running queries, then a high or even infinite delay value may be
    preferable.  Keep in mind however that a long-running query could
    cause other sessions on the standby server to not see recent changes
    on the primary, if it delays application of WAL records.
</span>
主に高可用性のために存在するスタンバイサーバでは、スタンバイ側の問い合わせによって発生する遅延のためにプライマリと大きく遅延が発生することがないように、遅延パラメータを相対的に短く設定することが最善です。
しかし、スタンバイサーバが長時間かかる問い合わせを実行するためのものであれば、長い遅延もしくは制限を設けないことが好まれるかもしれません。
しかし、長時間かかる問い合わせがWALレコードの適用を遅延させてしまう場合、スタンバイサーバ上の他のセッションがプライマリにおける最近の変更を参照することができなくなることは覚えておいてください。
   </p><p>
<span class="original">
    Once the delay specified by &lt;varname&gt;max_standby_archive_delay&lt;/varname&gt; or
    &lt;varname&gt;max_standby_streaming_delay&lt;/varname&gt; has been exceeded, conflicting
    queries will be canceled.  This usually results just in a cancellation
    error, although in the case of replaying a &lt;command&gt;DROP DATABASE&lt;/command&gt;
    the entire conflicting session will be terminated.  Also, if the conflict
    is over a lock held by an idle transaction, the conflicting session is
    terminated (this behavior might change in the future).
</span>
<code class="varname">max_standby_archive_delay</code>または<code class="varname">max_standby_streaming_delay</code>で指定した遅延を超えると、コンフリクトする問い合わせは取り消されます。
通常これは単なる取り消しエラーという結果となりますが、<code class="command">DROP DATABASE</code>を再生する場合では、コンフリクトするセッション全体が終了します。
また、コンフリクトが待機中のトランザクションで保持されるロックについてのものであれば、そのコンフリクトするセッションが終了します（この動作は将来変更されるかもしれません）。
   </p><p>
<span class="original">
    Canceled queries may be retried immediately (after beginning a new
    transaction, of course).  Since query cancellation depends on
    the nature of the WAL records being replayed, a query that was
    canceled may well succeed if it is executed again.
</span>
ユーザは取り消された問い合わせをすぐに再試行するかもしれません（もちろん新規のトランザクション開始後に）。
問い合わせの取り消しは、再生されるWALレコードの性質に依存するので、取り消された問い合わせが再度実行された場合には正常に動作するかもしれません。
   </p><p>
<span class="original">
    Keep in mind that the delay parameters are compared to the elapsed time
    since the WAL data was received by the standby server.  Thus, the grace
    period allowed to any one query on the standby is never more than the
    delay parameter, and could be considerably less if the standby has already
    fallen behind as a result of waiting for previous queries to complete, or
    as a result of being unable to keep up with a heavy update load.
</span>
遅延パラメータはスタンバイサーバでWALデータを受信してからの経過時間と比べられることに注意してください。
したがって、スタンバイ上で任意の問い合わせに許される猶予期間は、この遅延パラメータよりも大きくなることは決してありません。
これまでの問い合わせを完了させるために待機した結果、あるいは、大量の更新負荷に追従することができなくなった結果、スタンバイがすでに遅延している場合は相当小さくなります。
   </p><p>
<span class="original">
    The most common reason for conflict between standby queries and WAL replay
    is &lt;quote&gt;early cleanup&lt;/quote&gt;.  Normally, &lt;productname&gt;PostgreSQL&lt;/productname&gt; allows
    cleanup of old row versions when there are no transactions that need to
    see them to ensure correct visibility of data according to MVCC rules.
    However, this rule can only be applied for transactions executing on the
    primary.  So it is possible that cleanup on the primary will remove row
    versions that are still visible to a transaction on the standby.
</span>
スタンバイ側の問い合わせとWAL再生の間でもっともよくあるコンフリクト理由は<span class="quote">「<span class="quote">早すぎる消去</span>」</span>です。
通常<span class="productname">PostgreSQL</span>はMVCC規則にしたがって正確なデータの可視性を確実にするために、古い行バージョンを参照するトランザクションが存在しない場合それらを消去することが許されています。
しかし、この規則はプライマリ上で実行するトランザクションのみに適用させることができます。
したがって、スタンバイ上のトランザクションでまだ可視である行バージョンを、プライマリ上の消去処理が削除してしまう可能性があります。
   </p><p>
<span class="original">
    Experienced users should note that both row version cleanup and row version
    freezing will potentially conflict with standby queries. Running a manual
    &lt;command&gt;VACUUM FREEZE&lt;/command&gt; is likely to cause conflicts even on tables with
    no updated or deleted rows.
</span>
熟練したユーザは、行バージョンの消去と行バージョンの凍結の両方ともスタンバイ側の問い合わせとコンフリクトする可能性があることに気づくはずです。
手作業での<code class="command">VACUUM FREEZE</code>は、更新または削除された行がないテーブルであったとしてもコンフリクトを発生し易いものです。
   </p><p>
<span class="original">
    Users should be clear that tables that are regularly and heavily updated
    on the primary server will quickly cause cancellation of longer running
    queries on the standby. In such cases the setting of a finite value for
    &lt;varname&gt;max_standby_archive_delay&lt;/varname&gt; or
    &lt;varname&gt;max_standby_streaming_delay&lt;/varname&gt; can be considered similar to
    setting &lt;varname&gt;statement_timeout&lt;/varname&gt;.
</span>
プライマリサーバにおいて規則的かつ頻繁に更新されるテーブルは、スタンバイサーバにおける問い合わせの取り消しの原因になりやすいことを利用者は理解するべきです。
そのような場合、<code class="varname">max_standby_archive_delay</code>または<code class="varname">max_standby_streaming_delay</code>の設定値は<code class="varname">statement_timeout</code>の設定と同様に考えることができます。
   </p><p>
<span class="original">
    Remedial possibilities exist if the number of standby-query cancellations
    is found to be unacceptable.  The first option is to set the parameter
    &lt;varname&gt;hot_standby_feedback&lt;/varname&gt;, which prevents &lt;command&gt;VACUUM&lt;/command&gt; from
    removing recently-dead rows and so cleanup conflicts do not occur.
    If you do this, you
    should note that this will delay cleanup of dead rows on the primary,
    which may result in undesirable table bloat. However, the cleanup
    situation will be no worse than if the standby queries were running
    directly on the primary server, and you are still getting the benefit of
    off-loading execution onto the standby.
    If standby servers connect and disconnect frequently, you
    might want to make adjustments to handle the period when
    &lt;varname&gt;hot_standby_feedback&lt;/varname&gt; feedback is not being provided.
    For example, consider increasing &lt;varname&gt;max_standby_archive_delay&lt;/varname&gt;
    so that queries are not rapidly canceled by conflicts in WAL archive
    files during disconnected periods.  You should also consider increasing
    &lt;varname&gt;max_standby_streaming_delay&lt;/varname&gt; to avoid rapid cancellations
    by newly-arrived streaming WAL entries after reconnection.
</span>
スタンバイにおける問い合わせの中断が受け入れがたいほど多い場合、この問題を改善する方法が用意されています。
１つ目の選択肢は、<code class="varname">hot_standby_feedback</code>パラメータを設定することです。
これは<code class="command">VACUUM</code>による最近不要になった行の削除を防止しますので、消去によるコンフリクトが発生しません。
これを行う場合、プライマリで不要になった行の消去が遅延することに注意が必要です。望まないテーブルの膨張が発生してしまうかもしれません。
しかし、スタンバイ側で行うべき問い合わせをプライマリサーバ上で直接実行することと比べ、こうした消去に関する問題を優先する価値はありません。
また、スタンバイに実行負荷を分散できるという利点があります。
スタンバイサーバが接続、切断を頻繁に繰り返す場合、<code class="varname">hot_standby_feedback</code>によるフィードバックが提供されていなければ、その値を調整したいと思うでしょう。
例えば、<code class="varname">max_standby_archive_delay</code>が増大し、切断している期間WALアーカイブのコンフリクト発生による問い合わせの中断が速やかに行われないことを考えてみてください。また、再接続後に速やかに問い合わせが中断されることを避けるために<code class="varname">max_standby_streaming_delay</code>を大きくすることを考えてみてください。
   </p><p>
<span class="original">
    Another option is to increase &lt;xref linkend="guc-vacuum-defer-cleanup-age"/&gt;
    on the primary server, so that dead rows will not be cleaned up as quickly
    as they normally would be.  This will allow more time for queries to
    execute before they are canceled on the standby, without having to set
    a high &lt;varname&gt;max_standby_streaming_delay&lt;/varname&gt;.  However it is
    difficult to guarantee any specific execution-time window with this
    approach, since &lt;varname&gt;vacuum_defer_cleanup_age&lt;/varname&gt; is measured in
    transactions executed on the primary server.
</span>
他の選択肢は、不要になった行が通常よりも早く消去されないようにプライマリサーバで<a class="xref" href="runtime-config-replication.html#GUC-VACUUM-DEFER-CLEANUP-AGE">vacuum_defer_cleanup_age</a>を増やすことです。
これにより、<code class="varname">max_standby_streaming_delay</code>を長くすることなく、スタンバイでキャンセルが起こるようになる前により多くの時間、問い合わせを実行することができます。
しかし、<code class="varname">vacuum_defer_cleanup_age</code>はプライマリサーバ上で実行されたトランザクションを単位に測定されますので、この方法では特定の実行期間を保証することは困難です。
   </p><p>
<span class="original">
    The number of query cancels and the reason for them can be viewed using
    the &lt;structname&gt;pg_stat_database_conflicts&lt;/structname&gt; system view on the standby
    server. The &lt;structname&gt;pg_stat_database&lt;/structname&gt; system view also contains
    summary information.
</span>
問い合わせキャンセルの個数とその原因はスタンバイサーバ上の<code class="structname">pg_stat_database_conflicts</code>システムビューを用いて参照することができます。
また<code class="structname">pg_stat_database</code>システムビューには要約された情報が含まれます。
   </p><p>
<span class="original">
    Users can control whether a log message is produced when WAL replay is waiting
    longer than &lt;varname&gt;deadlock_timeout&lt;/varname&gt; for conflicts. This
    is controlled by the &lt;xref linkend="guc-log-recovery-conflict-waits"/&gt; parameter.
</span>
コンフリクトのためにWAL再生が<code class="varname">deadlock_timeout</code>より長くかかる場合にログメッセージを出力するかどうかをユーザは制御できます。
<a class="xref" href="runtime-config-logging.html#GUC-LOG-RECOVERY-CONFLICT-WAITS">log_recovery_conflict_waits</a>パラメータで制御します。
   </p></div><div class="sect2" id="HOT-STANDBY-ADMIN"><div class="titlepage"><div><div><h3 class="title">27.4.3. 管理者のための概説</h3></div></div></div><span class="original">
   &lt;title&gt;Administrator's Overview&lt;/title&gt;
</span><p>
    If <code class="varname">hot_standby</code> is <code class="literal">on</code> in <code class="filename">postgresql.conf</code>
    (the default value) and there is a
    <a class="link" href="warm-standby.html#FILE-STANDBY-SIGNAL"><code class="filename">standby.signal</code></a><a id="id-1.6.14.24.7.2.5" class="indexterm"></a>
    file present, the server will run in hot standby mode.
    However, it may take some time for hot standby connections to be allowed,
    because the server will not accept connections until it has completed
    sufficient recovery to provide a consistent state against which queries
    can run.  During this period,
    clients that attempt to connect will be refused with an error message.
    To confirm the server has come up, either loop trying to connect from
    the application, or look for these messages in the server logs:

</p><pre class="programlisting">
LOG:  entering standby mode

<span class="original">
... then some time later ...
</span>
... 多少時間が経過して ...

LOG:  consistent recovery state reached
LOG:  database system is ready to accept read-only connections
</pre><p>

<span class="original">
    Consistency information is recorded once per checkpoint on the primary.
    It is not possible to enable hot standby when reading WAL
    written during a period when &lt;varname&gt;wal_level&lt;/varname&gt; was not set to
    &lt;literal&gt;replica&lt;/literal&gt; or &lt;literal&gt;logical&lt;/literal&gt; on the primary.  Reaching
    a consistent state can also be delayed in the presence of both of these
    conditions:
</span>
一貫性に関する情報はプライマリでチェックポイント毎に一回記録されます。
プライマリで<code class="varname">wal_level</code>が<code class="literal">replica</code>もしくは<code class="literal">logical</code>に設定されていなかった期間に書き込まれたWALを読み取っている間は、ホットスタンバイを有効にすることはできません。
また、一貫性のある状態への到達は、以下の両方が存在する間遅延することがあります。

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
         A write transaction has more than 64 subtransactions
</span>
サブトランザクション数が64を超える書き込みトランザクション
        </p></li><li class="listitem"><p>
<span class="original">
         Very long-lived write transactions
</span>
非常に長く実行される書き込みトランザクション
        </p></li></ul></div><p>

<span class="original">
    If you are running file-based log shipping ("warm standby"), you might need
    to wait until the next WAL file arrives, which could be as long as the
    &lt;varname&gt;archive_timeout&lt;/varname&gt; setting on the primary.
</span>
ファイルベースのログシッピング(「ウォームスタンバイ」)を実行しているのであれば、次のWALファイルが届く、長くともプライマリの<code class="varname">archive_timeout</code>設定まで待機しなければなりません。
   </p><p>
<span class="original">
    The settings of some parameters determine the size of shared memory for
    tracking transaction IDs, locks, and prepared transactions.  These shared
    memory structures must be no smaller on a standby than on the primary in
    order to ensure that the standby does not run out of shared memory during
    recovery.  For example, if the primary had used a prepared transaction but
    the standby had not allocated any shared memory for tracking prepared
    transactions, then recovery could not continue until the standby's
    configuration is changed.  The parameters affected are:
</span>
いくつかのパラメータの設定により、トランザクションID、ロック、準備されたトランザクションを追跡するための共有メモリのサイズが決まります。
リカバリ中に共有メモリを使い尽くすことがないことを確実にするために、スタンバイサーバにおける設定値は、プライマリサーバにおける設定値以上でなければなりません。
たとえばプライマリが準備されたトランザクションを実行していてスタンバイが準備されたトランザクションを追跡するための共有メモリを獲得していなければ、スタンバイは設定が変更されるまではリカバリを続けることができません。
影響があるパラメータは以下です。

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
         <code class="varname">max_connections</code>
        </p></li><li class="listitem"><p>
         <code class="varname">max_prepared_transactions</code>
        </p></li><li class="listitem"><p>
         <code class="varname">max_locks_per_transaction</code>
        </p></li><li class="listitem"><p>
         <code class="varname">max_wal_senders</code>
        </p></li><li class="listitem"><p>
         <code class="varname">max_worker_processes</code>
        </p></li></ul></div><p>

<span class="original">
    The easiest way to ensure this does not become a problem is to have these
    parameters set on the standbys to values equal to or greater than on the
    primary.  Therefore, if you want to increase these values, you should do
    so on all standby servers first, before applying the changes to the
    primary server.  Conversely, if you want to decrease these values, you
    should do so on the primary server first, before applying the changes to
    all standby servers.  Keep in mind that when a standby is promoted, it
    becomes the new reference for the required parameter settings for the
    standbys that follow it.  Therefore, to avoid this becoming a problem
    during a switchover or failover, it is recommended to keep these settings
    the same on all standby servers.
</span>
これが問題にならないようにする確実な方法は、スタンバイにおけるこれらのパラメータの値をプライマリでの値以上にすることです。
ですから、これらの値を増やしたいなら、プライマリで設定を変更する前に、まずスタンバイで設定変更するべきです。
逆にこれらの値を減らしたいなら、スタンバイで設定を変更する前に、まずプライマリで設定変更するべきです。
スタンバイが昇格したときは、それが追従するスタンバイにとって必要なパラメータ設定の新しい基準になるということを覚えておいてください。
ですから、スイッチオーバーやフェイルオーバー中にこれが問題にならないようにするために、これらの設定値をすべてのスタンバイで同じにしておくことをお勧めします。
   </p><p>
<span class="original">
    The WAL tracks changes to these parameters on the
    primary.  If a hot standby processes WAL that indicates that the current
    value on the primary is higher than its own value, it will log a warning
    and pause recovery, for example:
</span>
プライマリでWALはこれらのパラメータの変更を追跡します。
ホットスタンバイが現在のプライマリの値がスタンバイの値よりも大きいことを示すWALを処理すると、警告をログし、リカバリを中断します。
例を示します。
</p><pre class="screen">
WARNING:  hot standby is not possible because of insufficient parameter settings
DETAIL:  max_connections = 80 is a lower setting than on the primary server, where its value was 100.
LOG:  recovery has paused
DETAIL:  If recovery is unpaused, the server will shut down.
HINT:  You can then restart the server after making the necessary configuration changes.
</pre><p>
<span class="original">
    At that point, the settings on the standby need to be updated and the
    instance restarted before recovery can continue.  If the standby is not a
    hot standby, then when it encounters the incompatible parameter change, it
    will shut down immediately without pausing, since there is then no value
    in keeping it up.
</span>
この時点で、スタンバイの設定を変更し、リカバリを継続するためにインスタンスを再起動する必要があります。
スタンバイがホットスタンバイでない場合は、整合性のないパラメータの変更があると、休止することなく直ちにシャットダウンします。起動し続ける意味がないからです。
   </p><p>
<span class="original">
    It is important that the administrator select appropriate settings for
    &lt;xref linkend="guc-max-standby-archive-delay"/&gt; and &lt;xref
    linkend="guc-max-standby-streaming-delay"/&gt;.  The best choices vary
    depending on business priorities.  For example if the server is primarily
    tasked as a High Availability server, then you will want low delay
    settings, perhaps even zero, though that is a very aggressive setting. If
    the standby server is tasked as an additional server for decision support
    queries then it might be acceptable to set the maximum delay values to
    many hours, or even -1 which means wait forever for queries to complete.
</span>
<a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-ARCHIVE-DELAY">max_standby_archive_delay</a>および<a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-STREAMING-DELAY">max_standby_streaming_delay</a>の値が適切であるように管理者が選択することが重要です。
最善の選択は業務上の優先順位によって変化します。
例えば、サーバが主に高可用性を目的としたサーバとして作業するものであれば、短い遅延を設定したいでしょう。
非常に積極的な設定ですが、ゼロにしたいかもしれません。
スタンバイサーバが意思決定支援のための問い合わせ用の追加サーバとして作業するものであれば、数時間程度の最大の遅延値の設定、あるいは問い合わせの完了を永遠に待つことを意味する-1という設定でさえ、許容範囲であるかもしれません。
   </p><p>
<span class="original">
    Transaction status "hint bits" written on the primary are not WAL-logged,
    so data on the standby will likely re-write the hints again on the standby.
    Thus, the standby server will still perform disk writes even though
    all users are read-only; no changes occur to the data values
    themselves.  Users will still write large sort temporary files and
    re-generate relcache info files, so no part of the database
    is truly read-only during hot standby mode.
    Note also that writes to remote databases using
    &lt;application&gt;dblink&lt;/application&gt; module, and other operations outside the
    database using PL functions will still be possible, even though the
    transaction is read-only locally.
</span>
プライマリ側で「ヒントビット」として書き出されたトランザクション状態はWALに記録されません。
このためスタンバイ側のデータはスタンバイ側でヒントを再度書き出すことになります。
ユーザは大規模なソート用の一時ファイルを書き出し、relcache情報ファイルを再作成します。
したがって、ホットスタンバイモードではデータベースのすべてが本当に読み取り専用ではありません。
また、ローカルでは読み取り専用のトランザクションであっても<span class="application">dblink</span>モジュールを使用したリモートデータベースへの書き出しや、その他のPL関数を使用したデータベース外部への操作が可能であることに注意してください。
   </p><p>
<span class="original">
    The following types of administration commands are not accepted
    during recovery mode:
</span>
リカバリモードの間、下記の管理者用コマンドは受理されません。

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
         Data Definition Language (DDL): e.g., &lt;command&gt;CREATE INDEX&lt;/command&gt;
</span>
データ定義言語: 例えば<code class="command">CREATE INDEX</code>
        </p></li><li class="listitem"><p>
<span class="original">
         Privilege and Ownership: &lt;command&gt;GRANT&lt;/command&gt;, &lt;command&gt;REVOKE&lt;/command&gt;,
         &lt;command&gt;REASSIGN&lt;/command&gt;
</span>
権限および所有権: <code class="command">GRANT</code>と<code class="command">REVOKE</code>と<code class="command">REASSIGN</code>
        </p></li><li class="listitem"><p>
<span class="original">
         Maintenance commands: &lt;command&gt;ANALYZE&lt;/command&gt;, &lt;command&gt;VACUUM&lt;/command&gt;,
         &lt;command&gt;CLUSTER&lt;/command&gt;, &lt;command&gt;REINDEX&lt;/command&gt;
</span>
保守コマンド: <code class="command">ANALYZE</code>と<code class="command">VACUUM</code>と<code class="command">CLUSTER</code>と<code class="command">REINDEX</code>
        </p></li></ul></div><p>
   </p><p>
<span class="original">
    Again, note that some of these commands are actually allowed during
    "read only" mode transactions on the primary.
</span>
繰り返しますが、これらのコマンドの一部は、プライマリサーバにおける「読み取り専用」モードのトランザクションで実際に許可されていることに注意してください。
   </p><p>
<span class="original">
    As a result, you cannot create additional indexes that exist solely
    on the standby, nor statistics that exist solely on the standby.
    If these administration commands are needed, they should be executed
    on the primary, and eventually those changes will propagate to the
    standby.
</span>
その結果、スタンバイ側にのみ存在する追加のインデックスやスタンバイ側にのみ存在する統計情報を作成することはできません。
これらの管理者用コマンドが必要な場合、プライマリ側で実行しなければなりません。
最終的にこの変更はスタンバイ側に伝播します。
   </p><p>
<span class="original">
    &lt;function&gt;pg_cancel_backend()&lt;/function&gt;
    and &lt;function&gt;pg_terminate_backend()&lt;/function&gt; will work on user backends,
    but not the startup process, which performs
    recovery. &lt;structname&gt;pg_stat_activity&lt;/structname&gt; does not show
    recovering transactions as active. As a result,
    &lt;structname&gt;pg_prepared_xacts&lt;/structname&gt; is always empty during
    recovery. If you wish to resolve in-doubt prepared transactions, view
    &lt;literal&gt;pg_prepared_xacts&lt;/literal&gt; on the primary and issue commands to
    resolve transactions there or resolve them after the end of recovery.
</span>
《マッチ度[93.321300]》<code class="function">pg_cancel_backend()</code>と<code class="function">pg_terminate_backend()</code>は利用者のバックエンドでは実行できますが、リカバリを実行する起動プロセスでは実行できません。
<code class="structname">pg_stat_activity</code>はリカバリ中のトランザクションをアクティブとして表示しません。
その結果、リカバリの間<code class="structname">pg_prepared_xacts</code>は常に空となります。
調査が必要な準備されたトランザクションがある場合は、プライマリサーバにおいて<code class="literal">pg_prepared_xacts</code>を表示し、その場でトランザクションを解決するか、リカバリが終わるのを待ってからトランザクションを解決します。
   </p><p>
<span class="original">
    &lt;structname&gt;pg_locks&lt;/structname&gt; will show locks held by backends,
    as normal. &lt;structname&gt;pg_locks&lt;/structname&gt; also shows
    a virtual transaction managed by the startup process that owns all
    &lt;literal&gt;AccessExclusiveLocks&lt;/literal&gt; held by transactions being replayed by recovery.
    Note that the startup process does not acquire locks to
    make database changes, and thus locks other than &lt;literal&gt;AccessExclusiveLocks&lt;/literal&gt;
    do not show in &lt;structname&gt;pg_locks&lt;/structname&gt; for the Startup
    process; they are just presumed to exist.
</span>
《マッチ度[93.596987]》<code class="structname">pg_locks</code>は通常通りバックエンドで保持されるロックを示します。
<code class="structname">pg_locks</code>はまた、リカバリによって再生されているトランザクションで保持される<code class="literal">AccessExclusiveLocks</code>のすべてを所有する、起動プロセスで管理される仮想トランザクションも表示します。
起動プロセスはデータベースの変更を行うためのロックを獲得しません。
このため起動プロセスにおいて<code class="literal">AccessExclusiveLocks</code>以外のロックは<code class="structname">pg_locks</code>では表示されません。
これらは存在することを想定されているだけです。
   </p><p>
<span class="original">
    The &lt;productname&gt;Nagios&lt;/productname&gt; plugin &lt;productname&gt;check_pgsql&lt;/productname&gt; will
    work, because the simple information it checks for exists.
    The &lt;productname&gt;check_postgres&lt;/productname&gt; monitoring script will also work,
    though some reported values could give different or confusing results.
    For example, last vacuum time will not be maintained, since no
    vacuum occurs on the standby.  Vacuums running on the primary
    do still send their changes to the standby.
</span>
存在を検知する情報が単純なので、<span class="productname">Nagios</span>プラグイン<span class="productname">check_pgsql</span>は稼動します。
一部の報告値が異なった、混乱を招く結果となりますが、<span class="productname">check_postgres</span>の監視スクリプトも動作します。
たとえば、スタンバイではバキュームが発生しないため、最終バキューム時刻は維持されません。
それでも、プライマリで行われるバキュームはその変更をスタンバイに送信します。
   </p><p>
<span class="original">
    WAL file control commands will not work during recovery,
    e.g., &lt;function&gt;pg_backup_start&lt;/function&gt;, &lt;function&gt;pg_switch_wal&lt;/function&gt; etc.
</span>
《マッチ度[85.714286]》リカバリの間WALの制御コマンドは稼動しません。
例えば、<code class="function">pg_start_backup</code>や<code class="function">pg_switch_wal</code>などです。
   </p><p>
<span class="original">
    Dynamically loadable modules work, including &lt;structname&gt;pg_stat_statements&lt;/structname&gt;.
</span>
<code class="structname">pg_stat_statements</code>も含み、動的に読み込み可能なモジュールは稼動します。
   </p><p>
<span class="original">
    Advisory locks work normally in recovery, including deadlock detection.
    Note that advisory locks are never WAL logged, so it is impossible for
    an advisory lock on either the primary or the standby to conflict with WAL
    replay. Nor is it possible to acquire an advisory lock on the primary
    and have it initiate a similar advisory lock on the standby. Advisory
    locks relate only to the server on which they are acquired.
</span>
デッドロック検出を含むアドバイザリロックは、通常リカバリにおいて稼動します。
アドバイザリロックはWALに決して記録されないので、プライマリサーバでもスタンバイサーバでもWALの再実行においてコンフリクトが起こらないことに注意してください。
プライマリサーバでアドバイザリロックを取得して、スタンバイサーバで同様のアドバイザリロックを掛けることはできません。
アドバイザリロックは取得したサーバだけに関係するものです。
   </p><p>
<span class="original">
    Trigger-based replication systems such as &lt;productname&gt;Slony&lt;/productname&gt;,
    &lt;productname&gt;Londiste&lt;/productname&gt; and &lt;productname&gt;Bucardo&lt;/productname&gt; won't run on the
    standby at all, though they will run happily on the primary server as
    long as the changes are not sent to standby servers to be applied.
    WAL replay is not trigger-based so you cannot relay from the
    standby to any system that requires additional database writes or
    relies on the use of triggers.
</span>
<span class="productname">Slony</span>や<span class="productname">Londiste</span>や<span class="productname">Bucardo</span>のようにトリガに基づいたレプリケーションシステムは、スタンバイサーバで全く稼動しません。
しかし、それによる変更がスタンバイサーバに送られるまでは、プライマリサーバにおいて問題なく稼動します。
WALの再実行はトリガに基づいたものではありません。
したがって、データベースへの付加的な書き込みを必要とするか、トリガの使用に依存するものを、スタンバイサーバを中継して他のシステムへ送ることはできません。
   </p><p>
<span class="original">
    New OIDs cannot be assigned, though some &lt;acronym&gt;UUID&lt;/acronym&gt; generators may still
    work as long as they do not rely on writing new status to the database.
</span>
一部の<acronym class="acronym">UUID</acronym>ジェネレータは、データベースに新しい状態を書き出すことに依存していない限り動作可能ですが、新しいOIDを割り当てることはできません。
   </p><p>
<span class="original">
    Currently, temporary table creation is not allowed during read-only
    transactions, so in some cases existing scripts will not run correctly.
    This restriction might be relaxed in a later release. This is
    both an SQL standard compliance issue and a technical issue.
</span>
現時点では、読み取り専用のトランザクションでは一時テーブルの作成は許されません。
このため既存のスクリプトが正しく動作しない場合があります。
この制限は将来のリリースで緩和されるかもしれません。
これは、標準SQLとの互換性の問題でもあり、技術的な問題でもあります。
   </p><p>
<span class="original">
    &lt;command&gt;DROP TABLESPACE&lt;/command&gt; can only succeed if the tablespace is empty.
    Some standby users may be actively using the tablespace via their
    &lt;varname&gt;temp_tablespaces&lt;/varname&gt; parameter. If there are temporary files in the
    tablespace, all active queries are canceled to ensure that temporary
    files are removed, so the tablespace can be removed and WAL replay
    can continue.
</span>
テーブル空間が空の場合だけ、<code class="command">DROP TABLESPACE</code>が成功します。
一部のスタンバイ側のユーザは<code class="varname">temp_tablespaces</code>パラメータを介してテーブル空間を活発に使用しているかもしれません。
テーブル空間に一時ファイルが存在する場合、一時ファイルを確実に削除するためすべての問い合わせが取り消されます。
このため、WAL再生を続けながらテーブル空間を削除することができます。
   </p><p>
<span class="original">
    Running &lt;command&gt;DROP DATABASE&lt;/command&gt; or &lt;command&gt;ALTER DATABASE ... SET
    TABLESPACE&lt;/command&gt; on the primary
    will generate a WAL entry that will cause all users connected to that
    database on the standby to be forcibly disconnected. This action occurs
    immediately, whatever the setting of
    &lt;varname&gt;max_standby_streaming_delay&lt;/varname&gt;. Note that
    &lt;command&gt;ALTER DATABASE ... RENAME&lt;/command&gt; does not disconnect users, which
    in most cases will go unnoticed, though might in some cases cause a
    program confusion if it depends in some way upon database name.
</span>
プライマリサーバにおける<code class="command">DROP DATABASE</code>または<code class="command">ALTER DATABASE ... SET TABLESPACE</code>の実行により、スタンバイサーバのデータベースに接続するすべてのユーザを強制的に接続を切断させることになるWALエントリを生成します。
これは<code class="varname">max_standby_streaming_delay</code>の設定にかかわらず、直ちに起こります。
<code class="command">ALTER DATABASE ... RENAME</code>はユーザを切断しないので大部分の場合は気がつきませんが、プログラムがデータベースの名称に依存するときは混乱の原因となることに注意してください。
   </p><p>
<span class="original">
    In normal (non-recovery) mode, if you issue &lt;command&gt;DROP USER&lt;/command&gt; or &lt;command&gt;DROP ROLE&lt;/command&gt;
    for a role with login capability while that user is still connected then
    nothing happens to the connected user &amp;mdash; they remain connected. The user cannot
    reconnect however. This behavior applies in recovery also, so a
    &lt;command&gt;DROP USER&lt;/command&gt; on the primary does not disconnect that user on the standby.
</span>
通常の(リカバリ以外の)モードで、ログイン権限を持つロールが接続している間にそのロールに<code class="command">DROP USER</code>または<code class="command">DROP ROLE</code>を発行した場合、接続中のユーザには何も起こらず、接続し続けます。
しかし、そのユーザは再接続できません。
この振舞いはリカバリモードでも適用されます。
このためプライマリ側で<code class="command">DROP USER</code>されたとしても、スタンバイ側のユーザの接続は切断されません。
   </p><p>
<span class="original">
    The cumulative statistics system is active during recovery. All scans,
    reads, blocks, index usage, etc., will be recorded normally on the
    standby. However, WAL replay will not increment relation and database
    specific counters. I.e. replay will not increment pg_stat_all_tables
    columns (like n_tup_ins), nor will reads or writes performed by the
    startup process be tracked in the pg_statio views, nor will associated
    pg_stat_database columns be incremented.
</span>
《機械翻訳》累積統計システムはリカバリ中にアクティブになります。
すべてのスキャン、読み取り、ブロック、インデックスの使用状況などは、スタンバイ側で通常どおり記録されます。
しかし、WAL再生はリレーションやデータベース固有のカウンタを増加させません。
つまり、再生はpg_stat_all_tables列(n_tup_insなど)を増加させませんし、起動プロセスによって実行された読み取りや書き込みもpg_statioビューで追跡されませんし、関連するpg_stat_database列も増加されません。
   </p><p>
<span class="original">
    Autovacuum is not active during recovery.  It will start normally at the
    end of recovery.
</span>
リカバリの間は自動バキュームは稼動しません。
リカバリが終わると正常に起動します。
   </p><p>
<span class="original">
    The checkpointer process and the background writer process are active during
    recovery. The checkpointer process will perform restartpoints (similar to
    checkpoints on the primary) and the background writer process will perform
    normal block cleaning activities. This can include updates of the hint bit
    information stored on the standby server.
    The &lt;command&gt;CHECKPOINT&lt;/command&gt; command is accepted during recovery,
    though it performs a restartpoint rather than a new checkpoint.
</span>
リカバリの間、チェックポイントプロセスとバックグラウンドライタプロセスは稼動しています。
チェックポイントプロセスは（プライマリサーバにおけるチェックポイントに類似した）リスタートポイントを設定し、通常のブロック消去を行います。
これはスタンバイサーバに保存されるヒントビット情報の更新を含むことができます。
リカバリの間<code class="command">CHECKPOINT</code>コマンドは受理されますが、新規のチェックポイントではなくてリスタートポイントが設定されます。
   </p></div><div class="sect2" id="HOT-STANDBY-PARAMETERS"><div class="titlepage"><div><div><h3 class="title">27.4.4. ホットスタンバイパラメータリファレンス</h3></div></div></div><span class="original">
   &lt;title&gt;Hot Standby Parameter Reference&lt;/title&gt;
</span><p>
<span class="original">
    Various parameters have been mentioned above in
    &lt;xref linkend="hot-standby-conflict"/&gt; and
    &lt;xref linkend="hot-standby-admin"/&gt;.
</span>
種々のパラメータが上記<a class="xref" href="hot-standby.html#HOT-STANDBY-CONFLICT" title="27.4.2. 問い合わせコンフリクトの処理">27.4.2</a>および<a class="xref" href="hot-standby.html#HOT-STANDBY-ADMIN" title="27.4.3. 管理者のための概説">27.4.3</a>で述べられています。
   </p><p>
<span class="original">
    On the primary, parameters &lt;xref linkend="guc-wal-level"/&gt; and
    &lt;xref linkend="guc-vacuum-defer-cleanup-age"/&gt; can be used.
    &lt;xref linkend="guc-max-standby-archive-delay"/&gt; and
    &lt;xref linkend="guc-max-standby-streaming-delay"/&gt; have no effect if set on
    the primary.
</span>
プライマリサーバでは、<a class="xref" href="runtime-config-wal.html#GUC-WAL-LEVEL">wal_level</a>および<a class="xref" href="runtime-config-replication.html#GUC-VACUUM-DEFER-CLEANUP-AGE">vacuum_defer_cleanup_age</a>のパラメータを使用できます。
プライマリサーバに<a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-ARCHIVE-DELAY">max_standby_archive_delay</a>および<a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-STREAMING-DELAY">max_standby_streaming_delay</a>を設定しても無効です。
   </p><p>
<span class="original">
    On the standby, parameters &lt;xref linkend="guc-hot-standby"/&gt;,
    &lt;xref linkend="guc-max-standby-archive-delay"/&gt; and
    &lt;xref linkend="guc-max-standby-streaming-delay"/&gt; can be used.
    &lt;xref linkend="guc-vacuum-defer-cleanup-age"/&gt; has no effect
    as long as the server remains in standby mode, though it will
    become relevant if the standby becomes primary.
</span>
スタンバイサーバでは<a class="xref" href="runtime-config-replication.html#GUC-HOT-STANDBY">hot_standby</a>と<a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-ARCHIVE-DELAY">max_standby_archive_delay</a>と<a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-STREAMING-DELAY">max_standby_streaming_delay</a>のパラメータを使用できます。
サーバがスタンバイモードの間<a class="xref" href="runtime-config-replication.html#GUC-VACUUM-DEFER-CLEANUP-AGE">vacuum_defer_cleanup_age</a>を設定しても無効です。
しかし、スタンバイサーバがプライマリサーバになった場合、意味を持つようになります。
   </p></div><div class="sect2" id="HOT-STANDBY-CAVEATS"><div class="titlepage"><div><div><h3 class="title">27.4.5. 警告</h3></div></div></div><span class="original">
   &lt;title&gt;Caveats&lt;/title&gt;
</span><p>
    There are several limitations of hot standby.
    These can and probably will be fixed in future releases:

  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
     Full knowledge of running transactions is required before snapshots
     can be taken. Transactions that use large numbers of subtransactions
     (currently greater than 64) will delay the start of read-only
     connections until the completion of the longest running write transaction.
     If this situation occurs, explanatory messages will be sent to the server log.
</span>
スナップショットを取ることができるようになる前に、実行中のトランザクションについての完全な知識が要求されます。
(現時点では64を超える)多くのサブトランザクションを使用するトランザクションでは、実行中の最長の書き込みトランザクションが完了するまで、読み取り専用の接続の開始は遅延されます。
この状況が起こると、それを説明するメッセージがサーバログに記録されます。
    </p></li><li class="listitem"><p>
<span class="original">
     Valid starting points for standby queries are generated at each
     checkpoint on the primary. If the standby is shut down while the primary
     is in a shutdown state, it might not be possible to re-enter hot standby
     until the primary is started up, so that it generates further starting
     points in the WAL logs.  This situation isn't a problem in the most
     common situations where it might happen. Generally, if the primary is
     shut down and not available anymore, that's likely due to a serious
     failure that requires the standby being converted to operate as
     the new primary anyway.  And in situations where the primary is
     being intentionally taken down, coordinating to make sure the standby
     becomes the new primary smoothly is also standard procedure.
</span>
《マッチ度[92.059219]》スタンバイ問い合わせ用の有効な起動ポイントは、プライマリにおけるチェックポイント毎に生成されます。
プライマリが停止状態にある時にスタンバイが停止した場合、プライマリが起動し、さらに起動ポイントをWALログに生成するまで再度ホットスタンバイになることができないことがあります。
この状況は、通常考えられる状態では問題ではありません。
一般的に、プライマリが停止し利用できなくなった場合、それはスタンバイに対して新しいプライマリに切り替わることを要求するような深刻な失敗が原因であることが多いはずです。
また、プライマリを意図的に停止させるような状況では、それに伴いスタンバイが新しいプライマリになめらかに切り替わることも普通の手順です。
    </p></li><li class="listitem"><p>
<span class="original">
     At the end of recovery, &lt;literal&gt;AccessExclusiveLocks&lt;/literal&gt; held by prepared transactions
     will require twice the normal number of lock table entries. If you plan
     on running either a large number of concurrent prepared transactions
     that normally take &lt;literal&gt;AccessExclusiveLocks&lt;/literal&gt;, or you plan on having one
     large transaction that takes many &lt;literal&gt;AccessExclusiveLocks&lt;/literal&gt;, you are
     advised to select a larger value of &lt;varname&gt;max_locks_per_transaction&lt;/varname&gt;,
     perhaps as much as twice the value of the parameter on
     the primary server. You need not consider this at all if
     your setting of &lt;varname&gt;max_prepared_transactions&lt;/varname&gt; is 0.
</span>
リカバリの終了において、準備されたトランザクションが保持する<code class="literal">AccessExclusiveLocks</code>には、通常の2倍のロックテーブルへのエントリ数が必要です。
通常<code class="literal">AccessExclusiveLocks</code>を取るプリペアドトランザクションを大量に同時実行させる、または、多くの<code class="literal">AccessExclusiveLocks</code>を取る大規模なトランザクションを1つ実行させることを考えている場合、<code class="varname">max_locks_per_transaction</code>の値を、おそらくプライマリサーバのパラメータ値の倍程度に大きくすることを勧めます。
<code class="varname">max_prepared_transactions</code>の設定が0ならば、これを検討する必要はまったくありません。
    </p></li><li class="listitem"><p>
<span class="original">
     The Serializable transaction isolation level is not yet available in hot
     standby.  (See &lt;xref linkend="xact-serializable"/&gt; and
     &lt;xref linkend="serializable-consistency"/&gt; for details.)
     An attempt to set a transaction to the serializable isolation level in
     hot standby mode will generate an error.
</span>
シリアライザブルトランザクション分離レベルはまだホットスタンバイでは利用できません。
（<a class="xref" href="transaction-iso.html#XACT-SERIALIZABLE" title="13.2.3. シリアライザブル分離レベル">13.2.3</a>および<a class="xref" href="applevel-consistency.html#SERIALIZABLE-CONSISTENCY" title="13.4.1. シリアライザブルトランザクションを用いた一貫性の強化">13.4.1</a>参照）
ホットスタンバイにおいてトランザクションをシリアライザブルトランザクション分離レベルに設定しようとすると、エラーになります。
    </p></li></ul></div><p>

   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="warm-standby-failover.html" title="27.3. フェイルオーバー">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="high-availability.html" title="第27章 高可用性、負荷分散およびレプリケーション">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="monitoring.html" title="第28章 データベース活動状況の監視">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">27.3. フェイルオーバー </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 15rc2文書">ホーム</a></td><td width="40%" align="right" valign="top"> 第28章 データベース活動状況の監視</td></tr></table></div></body></html>