<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>38.16. インデックス拡張機能へのインタフェース</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="xoper-optimization.html" title="38.15. 演算子最適化に関する情報" /><link rel="next" href="extend-extensions.html" title="38.17. 関連するオブジェクトを拡張としてパッケージ化" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 15rc1文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="extend.html" title="第38章 SQLの拡張">第38章 <acronym class="acronym">SQL</acronym>の拡張</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?template=bug_report.yml&amp;what-happened=version 15rc1 : xindex.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="xoper-optimization.html" title="38.15. 演算子最適化に関する情報">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="extend.html" title="第38章 SQLの拡張">上へ</a></td><td width="60%" align="center">38.16. インデックス拡張機能へのインタフェース</td><td width="20%" align="right"> <a accesskey="n" href="extend-extensions.html" title="38.17. 関連するオブジェクトを拡張としてパッケージ化">次へ</a></td></tr></table><hr /></div><div class="sect1" id="XINDEX"><div class="titlepage"><div><div><h2 class="title" style="clear: both">38.16. インデックス拡張機能へのインタフェース</h2></div></div></div><span class="original">
 &lt;title&gt;Interfacing Extensions to Indexes&lt;/title&gt;
</span><a id="id-1.8.3.20.2" class="indexterm"></a><a id="id-1.8.3.20.3" class="indexterm"></a><p>
<span class="original">
   The procedures described thus far let you define new types, new
   functions, and new operators. However, we cannot yet define an
   index on a column of a new data type.  To do this, we must define an
   &lt;firstterm&gt;operator class&lt;/firstterm&gt; for the new data type.  Later in this
   section, we will illustrate this concept in an example: a new
   operator class for the B-tree index method that stores and sorts
   complex numbers in ascending absolute value order.
</span>
これまでのところでは、新しい型や新しい関数、および新しい演算子をどの様に定義するかについて説明してきました。
しかしながら、新しい型の列に対するインデックスをまだ作成することができません。
このためには、新しいデータ型に対する<em class="firstterm">演算子クラス</em>を定義する必要があります。
本節では、複素数を値の絶対値の昇順にソートし格納するB-treeインデックスメソッドを使った新しい演算子クラスについての実行例を用いて、演算子クラスの概念を説明します。
  </p><p>
<span class="original">
   Operator classes can be grouped into &lt;firstterm&gt;operator families&lt;/firstterm&gt;
   to show the relationships between semantically compatible classes.
   When only a single data type is involved, an operator class is sufficient,
   so we'll focus on that case first and then return to operator families.
</span>
演算子クラスを<em class="firstterm">演算子族</em>にまとめ、意味的に互換性を持つクラス間の関係を表すことができます。
1つのデータ型のみが含まれる場合、演算子クラスで十分です。
そこでまずこうした状況に注目し、その後で演算子族に戻ります。
  </p><div class="sect2" id="XINDEX-OPCLASS"><div class="titlepage"><div><div><h3 class="title">38.16.1. インデックスメソッドと演算子クラス</h3></div></div></div><span class="original">
  &lt;title&gt;Index Methods and Operator Classes&lt;/title&gt;
</span><p>
<span class="original">
   The &lt;classname&gt;pg_am&lt;/classname&gt; table contains one row for every
   index method (internally known as access method).  Support for
   regular access to tables is built into
   &lt;productname&gt;PostgreSQL&lt;/productname&gt;, but all index methods are
   described in &lt;classname&gt;pg_am&lt;/classname&gt;.  It is possible to add a
   new index access method by writing the necessary code and
   then creating an entry in &lt;classname&gt;pg_am&lt;/classname&gt; &amp;mdash; but that is
   beyond the scope of this chapter (see &lt;xref linkend="indexam"/&gt;).
</span>
<code class="classname">pg_am</code>テーブルには各インデックスメソッド（内部ではアクセスメソッドとして知られています）に対して1つの行が含まれています。
テーブルへの通常のアクセスのサポートは<span class="productname">PostgreSQL</span>に組み込まれていますが、すべてのインデックスメソッドは、<code class="classname">pg_am</code>で記述されています。
必要なコードを書いた後、<code class="classname">pg_am</code>にエントリを作成することによって、新しいインデックスアクセスメソッドを追加することができます。
しかし、この方法についての説明は本章での範囲を超えています（<a class="xref" href="indexam.html" title="第64章 インデックスアクセスメソッドのインタフェース定義">第64章</a>を参照してください）。
  </p><p>
<span class="original">
   The routines for an index method do not directly know anything
   about the data types that the index method will operate on.
   Instead, an &lt;firstterm&gt;operator
   class&lt;/firstterm&gt;&lt;indexterm&gt;&lt;primary&gt;operator class&lt;/primary&gt;&lt;/indexterm&gt;
   identifies the set of operations that the index method needs to use
   to work with a particular data type.  Operator classes are so
   called because one thing they specify is the set of
   &lt;literal&gt;WHERE&lt;/literal&gt;-clause operators that can be used with an index
   (i.e., can be converted into an index-scan qualification).  An
   operator class can also specify some &lt;firstterm&gt;support
   function&lt;/firstterm&gt; that are needed by the internal operations of the
   index method, but do not directly correspond to any
   &lt;literal&gt;WHERE&lt;/literal&gt;-clause operator that can be used with the index.
</span>
インデックスメソッドのルーチンには、直接的にインデックスメソッドが演算するデータ型の情報は何も与えられていません。
代わりに、<em class="firstterm">演算子クラス</em>が、特定のデータ型の操作においてインデックスメソッドを使用する必要がある演算の集合を識別します。
<a id="id-1.8.3.20.6.3.2" class="indexterm"></a>
演算子クラスという名前の由来は、それらが指定するものの1つにインデックスで使用できる（つまり、インデックススキャン条件に変換できる）<code class="literal">WHERE</code>句演算子の集合があるからです。
また、演算子クラスは、インデックスメソッドの内部演算で必要な、しかしインデックスで使用できる<code class="literal">WHERE</code>句演算子には直接的には対応しない、<em class="firstterm">サポート関数</em>をいくつか指定することができます。
  </p><p>
<span class="original">
   It is possible to define multiple operator classes for the same
   data type and index method.  By doing this, multiple
   sets of indexing semantics can be defined for a single data type.
   For example, a B-tree index requires a sort ordering to be defined
   for each data type it works on.
   It might be useful for a complex-number data type
   to have one B-tree operator class that sorts the data by complex
   absolute value, another that sorts by real part, and so on.
   Typically, one of the operator classes will be deemed most commonly
   useful and will be marked as the default operator class for that
   data type and index method.
</span>
同じ入力データ型およびインデックスメソッドに対して複数の演算子クラスを定義することが可能です。
これにより、1つのデータ型に対して、複数のインデックス付けセマンティクスの集合を定義することができます。
例えば、B-treeインデックスでは、処理するデータ型ごとにソート順を定義する必要があります。
複素数データ型では、複素数の絶対値によりデータをソートするB-tree演算子クラスと、実部の数値によりソートするB-tree演算子クラスを持つといった方法は、有用かもしれません。
通常は演算子クラスの1つが一般的に最も有用であると判断され、そのデータ型およびインデックスメソッドに対するデフォルトの演算子クラスとして設定されます。
  </p><p>
<span class="original">
   The same operator class name
   can be used for several different index methods (for example, both B-tree
   and hash index methods have operator classes named
   &lt;literal&gt;int4_ops&lt;/literal&gt;), but each such class is an independent
   entity and must be defined separately.
</span>
複数の異なるインデックスメソッドに、同一の演算子クラス名を使用することができます（例えば、B-treeとハッシュインデックスメソッドは、両方とも<code class="literal">int4_ops</code>という名前の演算子クラスを持つことができます）。
ただし、そのような各クラスは独立した実体であり、別々に定義される必要があります。
  </p></div><div class="sect2" id="XINDEX-STRATEGIES"><div class="titlepage"><div><div><h3 class="title">38.16.2. インデックスメソッドのストラテジ</h3></div></div></div><span class="original">
  &lt;title&gt;Index Method Strategies&lt;/title&gt;
</span><p>
<span class="original">
   The operators associated with an operator class are identified by
   &lt;quote&gt;strategy numbers&lt;/quote&gt;, which serve to identify the semantics of
   each operator within the context of its operator class.
   For example, B-trees impose a strict ordering on keys, lesser to greater,
   and so operators like &lt;quote&gt;less than&lt;/quote&gt; and &lt;quote&gt;greater than or equal
   to&lt;/quote&gt; are interesting with respect to a B-tree.
   Because
   &lt;productname&gt;PostgreSQL&lt;/productname&gt; allows the user to define operators,
   &lt;productname&gt;PostgreSQL&lt;/productname&gt; cannot look at the name of an operator
   (e.g., &lt;literal&gt;&amp;lt;&lt;/literal&gt; or &lt;literal&gt;&amp;gt;=&lt;/literal&gt;) and tell what kind of
   comparison it is.  Instead, the index method defines a set of
   &lt;quote&gt;strategies&lt;/quote&gt;, which can be thought of as generalized operators.
   Each operator class specifies which actual operator corresponds to each
   strategy for a particular data type and interpretation of the index
   semantics.
</span>
演算子クラスに関連付けられている演算子は、<span class="quote">「<span class="quote">ストラテジ番号</span>」</span>により識別されます。
<span class="quote">「<span class="quote">ストラテジ番号</span>」</span>は、演算子クラスのコンテキスト内における各演算子のセマンティクスを識別するためのものです。
例えば、B-treeの場合、キーが小さい方から大きい方へ厳密に並んでいなければなりません。
したがって、B-treeに関しては、<span class="quote">「<span class="quote">より小さい</span>」</span>および<span class="quote">「<span class="quote">以上</span>」</span>のような演算子は興味深いと言えます。
<span class="productname">PostgreSQL</span>ではユーザが演算子を定義できるため、<span class="productname">PostgreSQL</span>は演算子の名前（例えば<code class="literal">&lt;</code>や<code class="literal">&gt;=</code>）を見つけても、その演算子がどのような比較を行うかを判断することはできません。
その代わり、インデックスメソッドは<span class="quote">「<span class="quote">ストラテジ</span>」</span>の集合を定義します。
<span class="quote">「<span class="quote">ストラテジ</span>」</span>は汎用演算子と考えることができます。
各演算子クラスは、特定のデータ型およびインデックスセマンティクスの解釈において、実際のどの演算子が各ストラテジに対応しているかを指定します。
  </p><p>
<span class="original">
   The B-tree index method defines five strategies, shown in &lt;xref
   linkend="xindex-btree-strat-table"/&gt;.
</span>
<a class="xref" href="xindex.html#XINDEX-BTREE-STRAT-TABLE" title="表38.3 B-treeストラテジ">表 38.3</a>に示すように、B-treeインデックスメソッドではストラテジを5つ定義します。
  </p><div class="table" id="XINDEX-BTREE-STRAT-TABLE"><p class="title"><strong>表38.3 B-treeストラテジ</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;B-Tree Strategies&lt;/title&gt;
</span><table class="table" summary="B-treeストラテジ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>演算</th><th>ストラテジ番号</th></tr></thead><tbody><tr><td>小なり</td><td>1</td></tr><tr><td>以下</td><td>2</td></tr><tr><td>等しい</td><td>3</td></tr><tr><td>以上</td><td>4</td></tr><tr><td>大なり</td><td>5</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
   Hash indexes support only equality comparisons, and so they use only one
   strategy, shown in &lt;xref linkend="xindex-hash-strat-table"/&gt;.
</span>
ハッシュインデックスは等価性のみをサポートします。
したがって、<a class="xref" href="xindex.html#XINDEX-HASH-STRAT-TABLE" title="表38.4 ハッシュストラテジ">表 38.4</a>に示すように、ストラテジを1つのみ定義します。
  </p><div class="table" id="XINDEX-HASH-STRAT-TABLE"><p class="title"><strong>表38.4 ハッシュストラテジ</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;Hash Strategies&lt;/title&gt;
</span><table class="table" summary="ハッシュストラテジ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>演算</th><th>ストラテジ番号</th></tr></thead><tbody><tr><td>等しい</td><td>1</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
   GiST indexes are more flexible: they do not have a fixed set of
   strategies at all.  Instead, the &lt;quote&gt;consistency&lt;/quote&gt; support routine
   of each particular GiST operator class interprets the strategy numbers
   however it likes.  As an example, several of the built-in GiST index
   operator classes index two-dimensional geometric objects, providing
   the &lt;quote&gt;R-tree&lt;/quote&gt; strategies shown in
   &lt;xref linkend="xindex-rtree-strat-table"/&gt;.  Four of these are true
   two-dimensional tests (overlaps, same, contains, contained by);
   four of them consider only the X direction; and the other four
   provide the same tests in the Y direction.
</span>
GiSTインデックスはより柔軟です。
固定のストラテジの集合をまったく持ちません。
代わりに、特定のGiST演算子クラスの<span class="quote">「<span class="quote">consistent</span>」</span>サポートルーチンが、ストラテジ番号が何を意味するかを解釈します。
<span class="original"> 訳注:consistencyは意図的に関数名consistentに変更 </span>
例として、2次元幾何オブジェクトをインデックス付けし、<span class="quote">「<span class="quote">R-tree</span>」</span>ストラテジを提供する組み込みのGiSTインデックス演算子クラスのいくつかを<a class="xref" href="xindex.html#XINDEX-RTREE-STRAT-TABLE" title="表38.5 GiSTによる2次元の「R-tree」ストラテジ">表 38.5</a>に示します。
この内4個は2次元に対する（重複、合同、包含、被包含）試験です。
残りの内4個はX方向のみに対する、残り4個はY方向のみに対する同一の試験を提供します。
  </p><div class="table" id="XINDEX-RTREE-STRAT-TABLE"><p class="title"><strong>表38.5 GiSTによる2次元の<span class="quote">「<span class="quote">R-tree</span>」</span>ストラテジ</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;GiST Two-Dimensional &lt;quote&gt;R-tree&lt;/quote&gt; Strategies&lt;/title&gt;
</span><table class="table" summary="GiSTによる2次元のR-treeストラテジ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>演算</th><th>ストラテジ番号</th></tr></thead><tbody><tr><td>完全に左側</td><td>1</td></tr><tr><td>右側にはみ出さない</td><td>2</td></tr><tr><td>重なる</td><td>3</td></tr><tr><td>左側にはみ出さない</td><td>4</td></tr><tr><td>完全に右側</td><td>5</td></tr><tr><td>同じ</td><td>6</td></tr><tr><td>含む</td><td>7</td></tr><tr><td>含まれる</td><td>8</td></tr><tr><td>上側にはみ出さない</td><td>9</td></tr><tr><td>完全に下側</td><td>10</td></tr><tr><td>完全に上側</td><td>11</td></tr><tr><td>下側にはみ出さない</td><td>12</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
   SP-GiST indexes are similar to GiST indexes in flexibility: they don't have
   a fixed set of strategies. Instead the support routines of each operator
   class interpret the strategy numbers according to the operator class's
   definition. As an example, the strategy numbers used by the built-in
   operator classes for points are shown in &lt;xref
   linkend="xindex-spgist-point-strat-table"/&gt;.
</span>
SP-GiSTインデックスは柔軟性という点でGiSTと似ており、固定のストラテジ群を持ちません。
その代わりに、各演算子クラスのサポートルーチンが演算子クラスの定義に従ってストラテジ番号を解釈します。
例として、点に対する組み込みの演算子クラスで使用されるストラテジ番号を<a class="xref" href="xindex.html#XINDEX-SPGIST-POINT-STRAT-TABLE" title="表38.6 SP-GiSTの点に関するストラテジ">表 38.6</a>に示します。
  </p><div class="table" id="XINDEX-SPGIST-POINT-STRAT-TABLE"><p class="title"><strong>表38.6 SP-GiSTの点に関するストラテジ</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;SP-GiST Point Strategies&lt;/title&gt;
</span><table class="table" summary="SP-GiSTの点に関するストラテジ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>演算</th><th>ストラテジ番号</th></tr></thead><tbody><tr><td>厳密に左側</td><td>1</td></tr><tr><td>厳密に右側</td><td>5</td></tr><tr><td>同一</td><td>6</td></tr><tr><td>包含される</td><td>8</td></tr><tr><td>厳密に下</td><td>10</td></tr><tr><td>厳密に上</td><td>11</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
   GIN indexes are similar to GiST and SP-GiST indexes, in that they don't
   have a fixed set of strategies either. Instead the support routines of
   each operator class interpret the strategy numbers according to the
   operator class's definition. As an example, the strategy numbers used by
   the built-in operator class for arrays are shown in
   &lt;xref linkend="xindex-gin-array-strat-table"/&gt;.
</span>
GINインデックスは、いずれも固定のストラテジ群を持たないという点で、GiSTおよびSP-GiSTインデックスと似ています。
その代わりに、各演算子クラスのサポートルーチンが演算子クラスの定義に従ってストラテジ番号を解釈します。
例として、配列に対する組み込みの演算子クラスで使用されるストラテジ番号を<a class="xref" href="xindex.html#XINDEX-GIN-ARRAY-STRAT-TABLE" title="表38.7 GIN 配列のストラテジ">表 38.7</a>に示します。
  </p><div class="table" id="XINDEX-GIN-ARRAY-STRAT-TABLE"><p class="title"><strong>表38.7 GIN 配列のストラテジ</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;GIN Array Strategies&lt;/title&gt;
</span><table class="table" summary="GIN 配列のストラテジ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>演算</th><th>ストラテジ番号</th></tr></thead><tbody><tr><td>重複</td><td>1</td></tr><tr><td>包含</td><td>2</td></tr><tr><td>包含される</td><td>3</td></tr><tr><td>等しい</td><td>4</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
   BRIN indexes are similar to GiST, SP-GiST and GIN indexes in that they
   don't have a fixed set of strategies either.  Instead the support routines
   of each operator class interpret the strategy numbers according to the
   operator class's definition. As an example, the strategy numbers used by
   the built-in &lt;literal&gt;Minmax&lt;/literal&gt; operator classes are shown in
   &lt;xref linkend="xindex-brin-minmax-strat-table"/&gt;.
</span>
BRINインデックスは、いずれも固定のストラテジ群を持たないという点で、GiST、SP-GiSTおよびGINインデックスと似ています。
その代わりに、各演算子クラスのサポートルーチンが演算子クラスの定義に従ってストラテジ番号を解釈します。
例として、組み込みの<code class="literal">Minmax</code>演算子クラスで使用されるストラテジ番号を<a class="xref" href="xindex.html#XINDEX-BRIN-MINMAX-STRAT-TABLE" title="表38.8 BRIN Minmaxストラテジ">表 38.8</a>に示します。
  </p><div class="table" id="XINDEX-BRIN-MINMAX-STRAT-TABLE"><p class="title"><strong>表38.8 BRIN Minmaxストラテジ</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;BRIN Minmax Strategies&lt;/title&gt;
</span><table class="table" summary="BRIN Minmaxストラテジ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>演算</th><th>ストラテジ番号</th></tr></thead><tbody><tr><td>小なり</td><td>1</td></tr><tr><td>以下</td><td>2</td></tr><tr><td>等しい</td><td>3</td></tr><tr><td>以上</td><td>4</td></tr><tr><td>大なり</td><td>5</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
   Notice that all the operators listed above return Boolean values.  In
   practice, all operators defined as index method search operators must
   return type &lt;type&gt;boolean&lt;/type&gt;, since they must appear at the top
   level of a &lt;literal&gt;WHERE&lt;/literal&gt; clause to be used with an index.
   (Some index access methods also support &lt;firstterm&gt;ordering operators&lt;/firstterm&gt;,
   which typically don't return Boolean values; that feature is discussed
   in &lt;xref linkend="xindex-ordering-ops"/&gt;.)
</span>
上記の演算子はすべて論理値を返すことに注意してください。
実際、インデックスで使用されるために<code class="literal">WHERE</code>の最上位レベルで現れなければなりませんので、インデックスメソッド検索演算子として定義された、すべての演算子の戻り値の型は<code class="type">boolean</code>でなければなりません。
（一部のインデックスアクセスメソッドは、通常論理型の値を返さない<em class="firstterm">順序付け演算子</em>もサポートします。
この機能については<a class="xref" href="xindex.html#XINDEX-ORDERING-OPS" title="38.16.7. 順序付け演算子">38.16.7</a>で説明します。）
  </p></div><div class="sect2" id="XINDEX-SUPPORT"><div class="titlepage"><div><div><h3 class="title">38.16.3. インデックスメソッドのサポートルーチン</h3></div></div></div><span class="original">
  &lt;title&gt;Index Method Support Routines&lt;/title&gt;
</span><p>
<span class="original">
   Strategies aren't usually enough information for the system to figure
   out how to use an index.  In practice, the index methods require
   additional support routines in order to work. For example, the B-tree
   index method must be able to compare two keys and determine whether one
   is greater than, equal to, or less than the other.  Similarly, the
   hash index method must be able to compute hash codes for key values.
   These operations do not correspond to operators used in qualifications in
   SQL commands;  they are administrative routines used by
   the index methods, internally.
</span>
ストラテジは通常、システムがインデックスを使う方法を判断するために十分な情報ではありません。
実際には、インデックスメソッドが動作するためには、さらにサポートルーチンを必要とします。
例えばB-treeインデックスメソッドは、2つのキーを比較し、より大きいのか、等しいのか、より小さいのかを決定できなければなりません。
同様に、ハッシュインデックスは、キー値のハッシュコードを計算できなければなりません。
これらの操作はSQLコマンドの条件内で使用される演算子とは対応しません。
これらはインデックスメソッドで内部的に使用される管理用ルーチンです。
  </p><p>
<span class="original">
   Just as with strategies, the operator class identifies which specific
   functions should play each of these roles for a given data type and
   semantic interpretation.  The index method defines the set
   of functions it needs, and the operator class identifies the correct
   functions to use by assigning them to the &lt;quote&gt;support function numbers&lt;/quote&gt;
   specified by the index method.
</span>
ストラテジと同じように、演算子クラスにより、与えられたデータ型およびセマンティクス解釈に対して、どの特定の関数がこれらの各役割を果たすべきであるかが識別されます。
インデックスメソッドは必要な関数の集合を定義し、演算子クラスは、これらをインデックスメソッドで指定された<span class="quote">「<span class="quote">サポート関数番号</span>」</span>に代入することによって、使用すべき正しい関数を識別します。
  </p><p>
<span class="original">
   Additionally, some opclasses allow users to specify parameters which
   control their behavior.  Each builtin index access method has an optional
   &lt;function&gt;options&lt;/function&gt; support function, which defines a set of
   opclass-specific parameters.
</span>
さらに、演算子クラスの中には、ユーザがその振る舞いを制御するパラメータを指定できるものもあります。
各組み込みインデックスアクセスメソッドには省略可能な<code class="function">options</code>サポート関数があり、演算子クラスに固有のパラメータの集合を定義しています。
  </p><p>
<span class="original">
   B-trees require a comparison support function,
   and allow four additional support functions to be
   supplied at the operator class author's option, as shown in &lt;xref
   linkend="xindex-btree-support-table"/&gt;.
   The requirements for these support functions are explained further in
   &lt;xref linkend="btree-support-funcs"/&gt;.
</span>
<a class="xref" href="xindex.html#XINDEX-BTREE-SUPPORT-TABLE" title="表38.9 B-treeサポート関数">表 38.9</a>に示すように、B-treeは比較サポート関数を必須とし、演算子クラスの作者が望めば4つの追加サポート関数を与えることができます。
これらのサポート関数の要件は<a class="xref" href="btree-support-funcs.html" title="67.3. B-Treeサポート関数">67.3</a>でさらに詳しく解説されています。
  </p><div class="table" id="XINDEX-BTREE-SUPPORT-TABLE"><p class="title"><strong>表38.9 B-treeサポート関数</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;B-Tree Support Functions&lt;/title&gt;
</span><table class="table" summary="B-treeサポート関数" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th>関数</th><th>サポート番号</th></tr></thead><tbody><tr><td>
<span class="original">
        Compare two keys and return an integer less than zero, zero, or
        greater than zero, indicating whether the first key is less than,
        equal to, or greater than the second
</span>
2つのキーを比較し、最初のキーが2番目のキーより小さいか、等しいか、大きいかを示す、0未満、0、もしくは0より大きい整数を返します
       </td><td>1</td></tr><tr><td>
<span class="original">
        Return the addresses of C-callable sort support function(s)
        (optional)
</span>
C言語から呼び出し可能なソートサポート関数のアドレスを返します（省略可能）
       </td><td>2</td></tr><tr><td>
<span class="original">
        Compare a test value to a base value plus/minus an offset, and return
        true or false according to the comparison result (optional)
</span>
テスト値をベース値にオフセットを加減算したものと比較して、比較結果に従って真または偽を返します（省略可能）
       </td><td>3</td></tr><tr><td>
<span class="original">
        Determine if it is safe for indexes that use the operator
        class to apply the btree deduplication optimization (optional)
</span>
演算子クラスを使うインデックスがB-tree重複排除最適化を安全に適用できるかどうかを決定します（省略可能）
       </td><td>4</td></tr><tr><td>
<span class="original">
        Define options that are specific to this operator class
        (optional)
</span>
この演算子クラスに固有のオプションを定義します（省略可能）
       </td><td>5</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
   Hash indexes require one support function, and allow two additional ones to
   be supplied at the operator class author's option, as shown in &lt;xref
   linkend="xindex-hash-support-table"/&gt;.
</span>
<a class="xref" href="xindex.html#XINDEX-HASH-SUPPORT-TABLE" title="表38.10 ハッシュサポート関数">表 38.10</a>に示すようにハッシュインデックスでは一つのサポート関数が必須で、演算子クラス作者が望むなら、さらに2つのサポート関数を与えることができます。
  </p><div class="table" id="XINDEX-HASH-SUPPORT-TABLE"><p class="title"><strong>表38.10 ハッシュサポート関数</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;Hash Support Functions&lt;/title&gt;
</span><table class="table" summary="ハッシュサポート関数" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th>関数</th><th>サポート番号</th></tr></thead><tbody><tr><td>キーの32ビットハッシュ値を計算</td><td>1</td></tr><tr><td>
<span class="original">
         Compute the 64-bit hash value for a key given a 64-bit salt; if
         the salt is 0, the low 32 bits of the result must match the value
         that would have been computed by function 1
         (optional)
</span>
64bitソルトが与えられたキーに対する64ビットハッシュ値を計算します。
ソルトが0なら結果の下位32ビットは関数1で計算された値と一致しなければなりません（省略可能）
       </td><td>2</td></tr><tr><td>
<span class="original">
        Define options that are specific to this operator class
        (optional)
</span>
この演算子クラスに固有のオプションを定義します（省略可能）
       </td><td>3</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
   GiST indexes have eleven support functions, six of which are optional,
   as shown in &lt;xref linkend="xindex-gist-support-table"/&gt;.
   (For more information see &lt;xref linkend="gist"/&gt;.)
</span>
<a class="xref" href="xindex.html#XINDEX-GIST-SUPPORT-TABLE" title="表38.11 GiSTサポート関数">表 38.11</a>に示すように、GiSTインデックスには11のサポート関数があり、また、そのうち6つは省略可能です。
(詳細については<a class="xref" href="gist.html" title="第68章 GiSTインデックス">第68章</a>を参照してください。)
  </p><div class="table" id="XINDEX-GIST-SUPPORT-TABLE"><p class="title"><strong>表38.11 GiSTサポート関数</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;GiST Support Functions&lt;/title&gt;
</span><table class="table" summary="GiSTサポート関数" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>関数</th><th>説明</th><th>サポート番号</th></tr></thead><tbody><tr><td><code class="function">consistent</code></td><td>キーが問い合わせ条件を満たすかどうかを決定します</td><td>1</td></tr><tr><td><code class="function">union</code></td><td>キー集合の和集合を計算します</td><td>2</td></tr><tr><td><code class="function">compress</code></td><td>キーまたはインデックス付けされる値の圧縮表現を計算します（省略可能）</td><td>3</td></tr><tr><td><code class="function">decompress</code></td><td>圧縮されたキーを伸張した表現を計算します（省略可能）</td><td>4</td></tr><tr><td><code class="function">penalty</code></td><td>指定された副ツリーキーを持つ副ツリーに新しいキーを挿入する時のペナルティを計算します</td><td>5</td></tr><tr><td><code class="function">picksplit</code></td><td>ページのどのエントリを新しいページに移動させるかを決定し、結果ページ用の統合キーを計算します</td><td>6</td></tr><tr><td><code class="function">same</code></td><td>2つのキーを比較し、等しければ真を返します</td><td>7</td></tr><tr><td><code class="function">distance</code></td><td>キーと問い合わせ値との間の距離を決定します（省略可能）</td><td>8</td></tr><tr><td><code class="function">fetch</code></td><td>インデックスオンリースキャンのために圧縮されたキーの元の表現を計算します（省略可能）</td><td>9</td></tr><tr><td><code class="function">options</code></td><td>この演算子クラスに固有のオプションを定義します（省略可能）</td><td>10</td></tr><tr><td><code class="function">sortsupport</code></td><td>高速インデックス構築で使用されるソート比較を提供する（省略可能）</td><td>11</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
   SP-GiST indexes have six support functions, one of which is optional, as
   shown in &lt;xref linkend="xindex-spgist-support-table"/&gt;.
   (For more information see &lt;xref linkend="spgist"/&gt;.)
</span>
<a class="xref" href="xindex.html#XINDEX-SPGIST-SUPPORT-TABLE" title="表38.12 SP-GiSTサポート関数">表 38.12</a>に示すように、SP-GiSTインデックスでは6つのサポート関数があり、また、そのうち1つは省略可能です。
(詳細については<a class="xref" href="spgist.html" title="第69章 SP-GiSTインデックス">第69章</a>を参照してください。)
  </p><div class="table" id="XINDEX-SPGIST-SUPPORT-TABLE"><p class="title"><strong>表38.12 SP-GiSTサポート関数</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;SP-GiST Support Functions&lt;/title&gt;
</span><table class="table" summary="SP-GiSTサポート関数" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>関数</th><th>説明</th><th>サポート番号</th></tr></thead><tbody><tr><td><code class="function">config</code></td><td>演算子クラスに関する基本情報を提供します</td><td>1</td></tr><tr><td><code class="function">choose</code></td><td>新しい値を内部タプルに挿入する方法を決定します</td><td>2</td></tr><tr><td><code class="function">picksplit</code></td><td>値集合を分割する方法を決定します</td><td>3</td></tr><tr><td><code class="function">inner_consistent</code></td><td>ある問い合わせでサブパーティションの検索が必要かどうか決定します</td><td>4</td></tr><tr><td><code class="function">leaf_consistent</code></td><td>キーが問い合わせ修飾子を満たすかどうか決定します</td><td>5</td></tr><tr><td><code class="function">options</code></td><td>この演算子クラスに固有のオプションの集合を定義します（省略可能）</td><td>6</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
   GIN indexes have seven support functions, four of which are optional,
   as shown in &lt;xref linkend="xindex-gin-support-table"/&gt;.
   (For more information see &lt;xref linkend="gin"/&gt;.)
</span>
<a class="xref" href="xindex.html#XINDEX-GIN-SUPPORT-TABLE" title="表38.13 GINサポート関数">表 38.13</a>に示すように、GINインデックスには、7つのサポート関数があり、また、そのうち4つは省略可能です。
(詳細については<a class="xref" href="gin.html" title="第70章 GINインデックス">第70章</a>を参照してください。)
  </p><div class="table" id="XINDEX-GIN-SUPPORT-TABLE"><p class="title"><strong>表38.13 GINサポート関数</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;GIN Support Functions&lt;/title&gt;
</span><table class="table" summary="GINサポート関数" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>関数</th><th>説明</th><th>サポート番号</th></tr></thead><tbody><tr><td><code class="function">compare</code></td><td>
<span class="original">
        compare two keys and return an integer less than zero, zero,
        or greater than zero, indicating whether the first key is less than,
        equal to, or greater than the second
</span>
2つのキーを比較し、0未満、0、0より大きな整数を返します。
それぞれ最初のキーの方が大きい、等しい、小さいを示します
       </td><td>1</td></tr><tr><td><code class="function">extractValue</code></td><td>インデックス付けされる値からキーを抽出します</td><td>2</td></tr><tr><td><code class="function">extractQuery</code></td><td>問い合わせ条件からキーを抽出します</td><td>3</td></tr><tr><td><code class="function">consistent</code></td><td>
<span class="original">
        determine whether value matches query condition (Boolean variant)
        (optional if support function 6 is present)
</span>
問い合わせ条件に一致する値かどうかを決定します(2値の亜種)。
(サポート関数6があれば、省略可能)
       </td><td>4</td></tr><tr><td><code class="function">comparePartial</code></td><td>
<span class="original">
        compare partial key from
        query and key from index, and return an integer less than zero, zero,
        or greater than zero, indicating whether GIN should ignore this index
        entry, treat the entry as a match, or stop the index scan (optional)
</span>
問い合わせからの部分キーとインデックスからのキーを比較し、それぞれ、GINがこのインデックス項目を無視しなければならないか、一致する項目として扱わなければならないか、インデックススキャンを中止しなければならないかを示す、ゼロより小さい、ゼロ、ゼロより大きい整数値のいずれかを返します（省略可能）
       </td><td>5</td></tr><tr><td><code class="function">triConsistent</code></td><td>
<span class="original">
        determine whether value matches query condition (ternary variant)
        (optional if support function 4 is present)
</span>
問い合わせ条件に一致する値かどうかを決定します(3値の亜種)。
(サポート関数4があれば、省略可能)
       </td><td>6</td></tr><tr><td><code class="function">options</code></td><td>
<span class="original">
        define options that are specific to this operator class
        (optional)
</span>
この演算子クラスに固有のオプションの集合を定義します（省略可能）
       </td><td>7</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
   BRIN indexes have five basic support functions, one of which is optional,
   as shown in &lt;xref linkend="xindex-brin-support-table"/&gt;.  Some versions of
   the basic functions require additional support functions to be provided.
   (For more information see &lt;xref linkend="brin-extensibility"/&gt;.)
</span>
<a class="xref" href="xindex.html#XINDEX-BRIN-SUPPORT-TABLE" title="表38.14 BRINサポート関数">表 38.14</a>に示すようにBRINインデックスには、5つの基本サポート関数があり、また、そのうち1つは省略可能です。
基本関数の版には追加のサポート関数の提供を要求するものもあります。
(詳細については<a class="xref" href="brin-extensibility.html" title="71.3. 拡張性">71.3</a>を参照してください。)
  </p><div class="table" id="XINDEX-BRIN-SUPPORT-TABLE"><p class="title"><strong>表38.14 BRINサポート関数</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;BRIN Support Functions&lt;/title&gt;
</span><table class="table" summary="BRINサポート関数" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>関数</th><th>説明</th><th>サポート番号</th></tr></thead><tbody><tr><td><code class="function">opcInfo</code></td><td>
<span class="original">
        return internal information describing the indexed columns'
        summary data
</span>
インデックスが貼られた列の要約データを記述する内部情報を返します
       </td><td>1</td></tr><tr><td><code class="function">add_value</code></td><td>既存のサマリーインデックスタプルに新しい値を足します</td><td>2</td></tr><tr><td><code class="function">consistent</code></td><td>値が問い合わせ条件に一致するかどうかを決めます</td><td>3</td></tr><tr><td><code class="function">union</code></td><td>
<span class="original">
        compute union of two summary tuples
</span>
2つのサマリータプルの結合を計算します
       </td><td>4</td></tr><tr><td><code class="function">options</code></td><td>
<span class="original">
        define options that are specific to this operator class
        (optional)
</span>
この演算子クラスに固有のオプションの集合を定義します（省略可能）
       </td><td>5</td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
   Unlike search operators, support functions return whichever data
   type the particular index method expects; for example in the case
   of the comparison function for B-trees, a signed integer.  The number
   and types of the arguments to each support function are likewise
   dependent on the index method.  For B-tree and hash the comparison and
   hashing support functions take the same input data types as do the
   operators included in the operator class, but this is not the case for
   most GiST, SP-GiST, GIN, and BRIN support functions.
</span>
検索演算子と異なり、サポート関数は特定のインデックスメソッドが想定するデータ型、例えばB-tree用の比較関数の場合、符号付き整数を返します。
同様に各サポート関数に渡す引数の数と型はインデックスメソッドに依存します。
B-treeとハッシュでは、比較関数とハッシュ処理サポート関数はその演算子クラスに含まれる演算子と同じ入力データ型を取りますが、GIN、SP-GiST、GiST、およびBRINサポート関数のほとんどはそうではありません。
  </p></div><div class="sect2" id="XINDEX-EXAMPLE"><div class="titlepage"><div><div><h3 class="title">38.16.4. 例</h3></div></div></div><span class="original">
  &lt;title&gt;An Example&lt;/title&gt;
</span><p>
<span class="original">
   Now that we have seen the ideas, here is the promised example of
   creating a new operator class.
   (You can find a working copy of this example in
   &lt;filename&gt;src/tutorial/complex.c&lt;/filename&gt; and
   &lt;filename&gt;src/tutorial/complex.sql&lt;/filename&gt; in the source
   distribution.)
   The operator class encapsulates
   operators that sort complex numbers in absolute value order, so we
   choose the name &lt;literal&gt;complex_abs_ops&lt;/literal&gt;.  First, we need
   a set of operators.  The procedure for defining operators was
   discussed in &lt;xref linkend="xoper"/&gt;.  For an operator class on
   B-trees, the operators we require are:
</span>
ここまでで概念について説明してきました。
ここで、新しい演算子クラスを作成する有用な例を紹介します。
（この例を作業できるように、ソース配布物内の<code class="filename">src/tutorial/complex.c</code>と<code class="filename">src/tutorial/complex.sql</code>にコピーがあります。）
この演算子クラスは、複素数をその絶対値による順番でソートする演算子をカプセル化します。
ですので、その名前に<code class="literal">complex_abs_ops</code>を選びました。
最初に演算子の集合が必要になります。
演算子を定義する処理は<a class="xref" href="xoper.html" title="38.14. ユーザ定義の演算子">38.14</a>で説明しました。
B-tree上の演算子クラスでは、以下の演算子が必要です。

   </p><div class="itemizedlist"><span class="original">
    &lt;listitem&gt;&lt;simpara&gt;absolute-value less-than (strategy 1)&lt;/simpara&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;simpara&gt;absolute-value less-than-or-equal (strategy 2)&lt;/simpara&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;simpara&gt;absolute-value equal (strategy 3)&lt;/simpara&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;simpara&gt;absolute-value greater-than-or-equal (strategy 4)&lt;/simpara&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;simpara&gt;absolute-value greater-than (strategy 5)&lt;/simpara&gt;&lt;/listitem&gt;
</span><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem">絶対値による、小なり（ストラテジ1）</li><li class="listitem">絶対値による、以下（ストラテジ2）</li><li class="listitem">絶対値による、等しい（ストラテジ3）</li><li class="listitem">絶対値による、以上（ストラテジ4）</li><li class="listitem">絶対値による、大なり（ストラテジ5）</li></ul></div><p>
  </p><p>
<span class="original">
   The least error-prone way to define a related set of comparison operators
   is to write the B-tree comparison support function first, and then write the
   other functions as one-line wrappers around the support function.  This
   reduces the odds of getting inconsistent results for corner cases.
   Following this approach, we first write:
</span>
比較演算子の関連する集合を定義する時にエラーの発生を最小にする方法は、まず、B-tree比較サポート関数を作成し、その後に、他の関数をサポート関数に対する1行のラッパとして作成することです。
これにより、境界となる条件で一貫性のない結果を得る確率が減少します。
この手法に従って、まず以下を作成します。

</p><pre class="programlisting">
#define Mag(c)  ((c)-&gt;x*(c)-&gt;x + (c)-&gt;y*(c)-&gt;y)

static int
complex_abs_cmp_internal(Complex *a, Complex *b)
{
    double      amag = Mag(a),
                bmag = Mag(b);

    if (amag &lt; bmag)
        return -1;
    if (amag &gt; bmag)
        return 1;
    return 0;
}

</pre><p>

<span class="original">
   Now the less-than function looks like:
</span>
これで、小なり関数は以下のようになります。

</p><pre class="programlisting">
PG_FUNCTION_INFO_V1(complex_abs_lt);

Datum
complex_abs_lt(PG_FUNCTION_ARGS)
{
    Complex    *a = (Complex *) PG_GETARG_POINTER(0);
    Complex    *b = (Complex *) PG_GETARG_POINTER(1);

    PG_RETURN_BOOL(complex_abs_cmp_internal(a, b) &lt; 0);
}

</pre><p>

<span class="original">
   The other four functions differ only in how they compare the internal
   function's result to zero.
</span>
他の4関数での違いは、内部関数の結果とゼロとをどのように比べるかだけです。
  </p><p>
<span class="original">
   Next we declare the functions and the operators based on the functions
   to SQL:
</span>
次に、関数と、この関数に基づく演算子をSQLで宣言します。

</p><pre class="programlisting">
CREATE FUNCTION complex_abs_lt(complex, complex) RETURNS bool
    AS '<em class="replaceable"><code>filename</code></em>', 'complex_abs_lt'
    LANGUAGE C IMMUTABLE STRICT;

CREATE OPERATOR &lt; (
   leftarg = complex, rightarg = complex, procedure = complex_abs_lt,
   commutator = &gt; , negator = &gt;= ,
   restrict = scalarltsel, join = scalarltjoinsel
);
</pre><p>
<span class="original">
   It is important to specify the correct commutator and negator operators,
   as well as suitable restriction and join selectivity
   functions, otherwise the optimizer will be unable to make effective
   use of the index.
</span>
正しく交代演算子と否定演算子を指定する他、適切な制限選択性関数と結合関数を指定することが重要です。さもないと、オプティマイザはインデックスを効率的に使用することができません。
  </p><p>
<span class="original">
   Other things worth noting are happening here:
</span>
他にも注意すべきことがここで発生します。

  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
     There can only be one operator named, say, &lt;literal&gt;=&lt;/literal&gt;
     and taking type &lt;type&gt;complex&lt;/type&gt; for both operands.  In this
     case we don't have any other operator &lt;literal&gt;=&lt;/literal&gt; for
     &lt;type&gt;complex&lt;/type&gt;, but if we were building a practical data
     type we'd probably want &lt;literal&gt;=&lt;/literal&gt; to be the ordinary
     equality operation for complex numbers (and not the equality of
     the absolute values).  In that case, we'd need to use some other
     operator name for &lt;function&gt;complex_abs_eq&lt;/function&gt;.
</span>
例えば、<code class="type">complex</code>型を両オペランドに取る<code class="literal">=</code>という名前の演算子を1つしか作成できません。
この場合、<code class="type">complex</code>用の他の<code class="literal">=</code>演算子を持てません。
しかし、実際にデータ型を作成しているとしたら、おそらく、複素数の（絶対値の等価性ではない）通常の等価性演算を行う<code class="literal">=</code>を欲するでしょう。
この場合、<code class="function">complex_abs_eq</code>用の演算子名に別の名前を使用しなければなりません。
    </p></li><li class="listitem"><p>
<span class="original">
     Although &lt;productname&gt;PostgreSQL&lt;/productname&gt; can cope with
     functions having the same SQL name as long as they have different
     argument data types, C can only cope with one global function
     having a given name.  So we shouldn't name the C function
     something simple like &lt;filename&gt;abs_eq&lt;/filename&gt;.  Usually it's
     a good practice to include the data type name in the C function
     name, so as not to conflict with functions for other data types.
</span>
<span class="productname">PostgreSQL</span>では異なる引数のデータ型であれば同じSQL名の演算子を使うことができますが、Cでは1つの名前で1つのグローバル関数が使えるだけです。
ですから、C関数は<code class="filename">abs_eq</code>のような単純な名前にするべきではありません。
通常は、他のデータ型の関数と衝突しないように、C関数名にデータ型名を入れておくことを勧めます。
    </p></li><li class="listitem"><p>
<span class="original">
     We could have made the SQL name
     of the function &lt;filename&gt;abs_eq&lt;/filename&gt;, relying on
     &lt;productname&gt;PostgreSQL&lt;/productname&gt; to distinguish it by
     argument data types from any other SQL function of the same name.
     To keep the example simple, we make the function have the same
     names at the C level and SQL level.
</span>
<code class="filename">abs_eq</code>関数のSQL名は、<span class="productname">PostgreSQL</span>が引数のデータ型によって同じ名前を持つ他のSQL関数から区別してくれることを期待して作ることができます。
ここでは例を簡単にするために、関数にCレベルとSQLレベルで同じ名前を与えています。
    </p></li></ul></div><p>
  </p><p>
<span class="original">
   The next step is the registration of the support routine required
   by B-trees.  The example C code that implements this is in the same
   file that contains the operator functions.  This is how we declare
   the function:
</span>
次のステップは、B-treeに必要なサポートルーチンの登録です。
これを実装するCコードは、演算子関数と同じファイルに入っています。
以下は、関数をどのように宣言するかを示します。

</p><pre class="programlisting">
CREATE FUNCTION complex_abs_cmp(complex, complex)
    RETURNS integer
    AS '<em class="replaceable"><code>filename</code></em>'
    LANGUAGE C IMMUTABLE STRICT;
</pre><p>
  </p><p>
<span class="original">
   Now that we have the required operators and support routine,
   we can finally create the operator class:
</span>
これまでで、必要な演算子およびサポートルーチンを持つようになりました。
最後に演算子クラスを作成することができます。

</p><pre class="programlisting">
CREATE OPERATOR CLASS complex_abs_ops
    DEFAULT FOR TYPE complex USING btree AS
        OPERATOR        1       &lt; ,
        OPERATOR        2       &lt;= ,
        OPERATOR        3       = ,
        OPERATOR        4       &gt;= ,
        OPERATOR        5       &gt; ,
        FUNCTION        1       complex_abs_cmp(complex, complex);

</pre><p>
  </p><p>
<span class="original">
   And we're done!  It should now be possible to create
   and use B-tree indexes on &lt;type&gt;complex&lt;/type&gt; columns.
</span>
これで終わりです！
これで<code class="type">complex</code>列にB-treeインデックスを作って使用することが可能になったはずです。
  </p><p>
<span class="original">
   We could have written the operator entries more verbosely, as in:
</span>
以下のように、演算子エントリをより冗長に記述することができます。
</p><pre class="programlisting">
        OPERATOR        1       &lt; (complex, complex) ,
</pre><p>
<span class="original">
   but there is no need to do so when the operators take the same data type
   we are defining the operator class for.
</span>
しかし、演算子が、演算子クラスの定義と同一のデータ型を取る場合、このような記述をする必要はありません。
  </p><p>
<span class="original">
   The above example assumes that you want to make this new operator class the
   default B-tree operator class for the &lt;type&gt;complex&lt;/type&gt; data type.
   If you don't, just leave out the word &lt;literal&gt;DEFAULT&lt;/literal&gt;.
</span>
上記の例は、ユーザがこの新しい演算子クラスを<code class="type">complex</code>データ型のデフォルトのB-tree演算子クラスにしようとしていると仮定しています。
このようにしない場合、<code class="literal">DEFAULT</code>という単語を取り除いてください。
  </p></div><div class="sect2" id="XINDEX-OPFAMILY"><div class="titlepage"><div><div><h3 class="title">38.16.5. 演算子クラスと演算子族</h3></div></div></div><span class="original">
  &lt;title&gt;Operator Classes and Operator Families&lt;/title&gt;
</span><p>
<span class="original">
   So far we have implicitly assumed that an operator class deals with
   only one data type.  While there certainly can be only one data type in
   a particular index column, it is often useful to index operations that
   compare an indexed column to a value of a different data type.  Also,
   if there is use for a cross-data-type operator in connection with an
   operator class, it is often the case that the other data type has a
   related operator class of its own.  It is helpful to make the connections
   between related classes explicit, because this can aid the planner in
   optimizing SQL queries (particularly for B-tree operator classes, since
   the planner contains a great deal of knowledge about how to work with them).
</span>
これまでは暗黙的に、演算子クラスは1つのデータ型のみを扱うものと仮定してきました。
確かに特定のインデックス列にはたった1つのデータ型しかあり得ませんが、異なるデータ型の値とインデックス列の比較を行うインデックス操作はよく役に立ちます。
また、演算子クラスと関連したデータ型を跨る演算子を使用できる場合、他のデータ型は独自の関連した演算子クラスを持つことがよくあります。
SQL問い合わせを最適化する際にプランナを補助することができますので、関連したクラスを明示的に関連付けることは（どのように動作するかに関する知識をプランナは多く持ちますので、特にB-tree演算子クラスで）有用です。
  </p><p>
<span class="original">
   To handle these needs, &lt;productname&gt;PostgreSQL&lt;/productname&gt;
   uses the concept of an &lt;firstterm&gt;operator
   family&lt;/firstterm&gt;&lt;indexterm&gt;&lt;primary&gt;operator family&lt;/primary&gt;&lt;/indexterm&gt;.
   An operator family contains one or more operator classes, and can also
   contain indexable operators and corresponding support functions that
   belong to the family as a whole but not to any single class within the
   family.  We say that such operators and functions are &lt;quote&gt;loose&lt;/quote&gt;
   within the family, as opposed to being bound into a specific class.
   Typically each operator class contains single-data-type operators
   while cross-data-type operators are loose in the family.
</span>
こうした要望に応えるために<span class="productname">PostgreSQL</span>は<em class="firstterm">演算子族</em>という概念を使用します。<a id="id-1.8.3.20.10.3.3" class="indexterm"></a>
演算子族は1つ以上の演算子クラスから構成されます。
また、演算子族全体に属するが、演算子族内の個々のクラスには属さないインデックス可能演算子や対応するサポート関数を含めることもできます。
こうした演算子や関数を、特定のクラスに束縛されていないことから、演算子族内で<span class="quote">「<span class="quote">自由</span>」</span>であると呼びます。
通常、各演算子クラスは1つのデータ型演算子を持ちますが、データ型を跨る演算子は演算子族内で自由になります。
  </p><p>
<span class="original">
   All the operators and functions in an operator family must have compatible
   semantics, where the compatibility requirements are set by the index
   method.  You might therefore wonder why bother to single out particular
   subsets of the family as operator classes; and indeed for many purposes
   the class divisions are irrelevant and the family is the only interesting
   grouping.  The reason for defining operator classes is that they specify
   how much of the family is needed to support any particular index.
   If there is an index using an operator class, then that operator class
   cannot be dropped without dropping the index &amp;mdash; but other parts of
   the operator family, namely other operator classes and loose operators,
   could be dropped.  Thus, an operator class should be specified to contain
   the minimum set of operators and functions that are reasonably needed
   to work with an index on a specific data type, and then related but
   non-essential operators can be added as loose members of the operator
   family.
</span>
演算子族内の演算子と関数はすべて、意味的な互換性を持たなければなりません。
この互換性についての必要条件はインデックスメソッドによって設定されます。
このため、演算子族の特定の部分集合を演算子クラスとして選び出す方法に疑問を持つかもしれません。
実際多くの目的では、クラスの分類は不適切で、演算子族が唯一の興味深いグループ化です。
演算子クラスを定義する理由は、どれだけ多くの演算子族が何らかのインデックスをサポートするために必要かを指定することです。
ある演算子クラスを使用するインデックスが存在する場合、演算子クラスはそのインデックスを削除しない限り削除することができません。
しかし、演算子族の他の部分、すなわち、他の演算子クラスや自由な演算子を削除することができます。
したがって、演算子クラスは、特定のデータ型に対するインデックスを操作する上で理論上必要となる最少の演算子と関数の集合を含むように指定すべきです。
そして、関連するが基本的なものではない演算子を演算子族の自由なメンバとして追加することができます。
  </p><p>
<span class="original">
   As an example, &lt;productname&gt;PostgreSQL&lt;/productname&gt; has a built-in
   B-tree operator family &lt;literal&gt;integer_ops&lt;/literal&gt;, which includes operator
   classes &lt;literal&gt;int8_ops&lt;/literal&gt;, &lt;literal&gt;int4_ops&lt;/literal&gt;, and
   &lt;literal&gt;int2_ops&lt;/literal&gt; for indexes on &lt;type&gt;bigint&lt;/type&gt; (&lt;type&gt;int8&lt;/type&gt;),
   &lt;type&gt;integer&lt;/type&gt; (&lt;type&gt;int4&lt;/type&gt;), and &lt;type&gt;smallint&lt;/type&gt; (&lt;type&gt;int2&lt;/type&gt;)
   columns respectively.  The family also contains cross-data-type comparison
   operators allowing any two of these types to be compared, so that an index
   on one of these types can be searched using a comparison value of another
   type.  The family could be duplicated by these definitions:
</span>
例えば<span class="productname">PostgreSQL</span>には<code class="literal">integer_ops</code>という組み込みのB-tree演算子族があります。
ここには<code class="type">bigint</code> (<code class="type">int8</code>)、<code class="type">integer</code> (<code class="type">int4</code>)、<code class="type">smallint</code> (<code class="type">int2</code>)型の列上へのインデックスにそれぞれ対応した<code class="literal">int8_ops</code>、<code class="literal">int4_ops</code>、<code class="literal">int2_ops</code>という演算子クラスが含まれています。
また、上記の型の内任意の2つの型を比較できるように、この演算子族にはデータ型を跨る比較演算子も含まれます。
このため、上記の型のいずれかに対するインデックスを他の型の値との比較の際に使用することができます。
この演算子族は以下の定義により多重化されています。

</p><pre class="programlisting">
CREATE OPERATOR FAMILY integer_ops USING btree;

CREATE OPERATOR CLASS int8_ops
DEFAULT FOR TYPE int8 USING btree FAMILY integer_ops AS
<span class="original">
  &amp;#45;- standard int8 comparisons
</span>
  -- 標準int8比較
  OPERATOR 1 &lt; ,
  OPERATOR 2 &lt;= ,
  OPERATOR 3 = ,
  OPERATOR 4 &gt;= ,
  OPERATOR 5 &gt; ,
  FUNCTION 1 btint8cmp(int8, int8) ,
  FUNCTION 2 btint8sortsupport(internal) ,
  FUNCTION 3 in_range(int8, int8, int8, boolean, boolean) ,
  FUNCTION 4 btequalimage(oid) ;

CREATE OPERATOR CLASS int4_ops
DEFAULT FOR TYPE int4 USING btree FAMILY integer_ops AS
<span class="original">
  &amp;#45;- standard int4 comparisons
</span>
  -- 標準int4比較
  OPERATOR 1 &lt; ,
  OPERATOR 2 &lt;= ,
  OPERATOR 3 = ,
  OPERATOR 4 &gt;= ,
  OPERATOR 5 &gt; ,
  FUNCTION 1 btint4cmp(int4, int4) ,
  FUNCTION 2 btint4sortsupport(internal) ,
  FUNCTION 3 in_range(int4, int4, int4, boolean, boolean) ,
  FUNCTION 4 btequalimage(oid) ;

CREATE OPERATOR CLASS int2_ops
DEFAULT FOR TYPE int2 USING btree FAMILY integer_ops AS
<span class="original">
  &amp;#45;- standard int2 comparisons
</span>
  -- 標準int2比較
  OPERATOR 1 &lt; ,
  OPERATOR 2 &lt;= ,
  OPERATOR 3 = ,
  OPERATOR 4 &gt;= ,
  OPERATOR 5 &gt; ,
  FUNCTION 1 btint2cmp(int2, int2) ,
  FUNCTION 2 btint2sortsupport(internal) ,
  FUNCTION 3 in_range(int2, int2, int2, boolean, boolean) ,
  FUNCTION 4 btequalimage(oid) ;

ALTER OPERATOR FAMILY integer_ops USING btree ADD
<span class="original">
  &amp;#45;- cross-type comparisons int8 vs int2
</span>
  -- 型を跨ぐ比較 int8対int2
  OPERATOR 1 &lt; (int8, int2) ,
  OPERATOR 2 &lt;= (int8, int2) ,
  OPERATOR 3 = (int8, int2) ,
  OPERATOR 4 &gt;= (int8, int2) ,
  OPERATOR 5 &gt; (int8, int2) ,
  FUNCTION 1 btint82cmp(int8, int2) ,

<span class="original">
  &amp;#45;- cross-type comparisons int8 vs int4
</span>
  -- 型を跨ぐ比較 int8対int4
  OPERATOR 1 &lt; (int8, int4) ,
  OPERATOR 2 &lt;= (int8, int4) ,
  OPERATOR 3 = (int8, int4) ,
  OPERATOR 4 &gt;= (int8, int4) ,
  OPERATOR 5 &gt; (int8, int4) ,
  FUNCTION 1 btint84cmp(int8, int4) ,

<span class="original">
  &amp;#45;- cross-type comparisons int4 vs int2
</span>
  -- 型を跨ぐ比較 int4対int2
  OPERATOR 1 &lt; (int4, int2) ,
  OPERATOR 2 &lt;= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 &gt;= (int4, int2) ,
  OPERATOR 5 &gt; (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2) ,

<span class="original">
  &amp;#45;- cross-type comparisons int4 vs int8
</span>
  -- 型を跨ぐ比較 int4対int8
  OPERATOR 1 &lt; (int4, int8) ,
  OPERATOR 2 &lt;= (int4, int8) ,
  OPERATOR 3 = (int4, int8) ,
  OPERATOR 4 &gt;= (int4, int8) ,
  OPERATOR 5 &gt; (int4, int8) ,
  FUNCTION 1 btint48cmp(int4, int8) ,

<span class="original">
  &amp;#45;- cross-type comparisons int2 vs int8
</span>
  -- 型を跨ぐ比較 int2対int8
  OPERATOR 1 &lt; (int2, int8) ,
  OPERATOR 2 &lt;= (int2, int8) ,
  OPERATOR 3 = (int2, int8) ,
  OPERATOR 4 &gt;= (int2, int8) ,
  OPERATOR 5 &gt; (int2, int8) ,
  FUNCTION 1 btint28cmp(int2, int8) ,

<span class="original">
  &amp;#45;- cross-type comparisons int2 vs int4
</span>
  -- 型を跨ぐ比較 int2対int4
  OPERATOR 1 &lt; (int2, int4) ,
  OPERATOR 2 &lt;= (int2, int4) ,
  OPERATOR 3 = (int2, int4) ,
  OPERATOR 4 &gt;= (int2, int4) ,
  OPERATOR 5 &gt; (int2, int4) ,
  FUNCTION 1 btint24cmp(int2, int4) ,

  -- cross-type in_range functions
  FUNCTION 3 in_range(int4, int4, int8, boolean, boolean) ,
  FUNCTION 3 in_range(int4, int4, int2, boolean, boolean) ,
  FUNCTION 3 in_range(int2, int2, int8, boolean, boolean) ,
  FUNCTION 3 in_range(int2, int2, int4, boolean, boolean) ;

</pre><p>

<span class="original">
   Notice that this definition &lt;quote&gt;overloads&lt;/quote&gt; the operator strategy and
   support function numbers: each number occurs multiple times within the
   family.  This is allowed so long as each instance of a
   particular number has distinct input data types.  The instances that have
   both input types equal to an operator class's input type are the
   primary operators and support functions for that operator class,
   and in most cases should be declared as part of the operator class rather
   than as loose members of the family.
</span>
 この定義は演算子ストラテジ関数番号とサポート関数番号を<span class="quote">「<span class="quote">上書き</span>」</span>していることに注意してください。
各番号は演算子族内で複数回現れます。
特定番号のインスタンスがそれぞれ異なる入力データ型を持つ限り、これは許されます。
入力型の両方が演算子クラスの入力型と同じインスタンスは、演算子クラスの主演算子および主サポート関数であり、ほとんどの場合、演算子族の自由メンバではなく演算子クラスの一部として宣言しなければなりません。
  </p><p>
<span class="original">
   In a B-tree operator family, all the operators in the family must sort
   compatibly, as is specified in detail in &lt;xref linkend="btree-behavior"/&gt;.
   For each
   operator in the family there must be a support function having the same
   two input data types as the operator.  It is recommended that a family be
   complete, i.e., for each combination of data types, all operators are
   included.  Each operator class should include just the non-cross-type
   operators and support function for its data type.
</span>
詳細が<a class="xref" href="btree-behavior.html" title="67.2. B-Tree演算子クラスの振る舞い">67.2</a>で示されている通り、B-tree演算子族では演算子族内のすべての演算子は互換性をもってソートしなければなりません。
演算子族内の各演算子では、演算子と同じデータ型の2つのデータ型を取るサポート関数が存在しなければなりません。
演算子族を完結させること、つまり、データ型の組み合わせそれぞれに対する演算子をすべて含めることを推奨します。
各演算子クラスは、自身のデータ型に対してデータ型を跨らない演算子とサポート関数だけを含めなければなりません。
  </p><p>
<span class="original">
   To build a multiple-data-type hash operator family, compatible hash
   support functions must be created for each data type supported by the
   family.  Here compatibility means that the functions are guaranteed to
   return the same hash code for any two values that are considered equal
   by the family's equality operators, even when the values are of different
   types.  This is usually difficult to accomplish when the types have
   different physical representations, but it can be done in some cases.
   Furthermore, casting a value from one data type represented in the operator
   family to another data type also represented in the operator family via
   an implicit or binary coercion cast must not change the computed hash value.
   Notice that there is only one support function per data type, not one
   per equality operator.  It is recommended that a family be complete, i.e.,
   provide an equality operator for each combination of data types.
   Each operator class should include just the non-cross-type equality
   operator and the support function for its data type.
</span>
複数データ型のハッシュ演算子族を構築するには、演算子族でサポートされるデータ型それぞれに対する互換性を持つハッシュサポート関数を作成しなければなりません。
ここで、互換性とは、関数がその演算子族の等価性演算子で等価であるとみなされる任意の2つの値では同一のハッシュコードが生成されることを保証することを意味します。
通常、型が異なる物理表現を持つ場合、これを実現することは困難ですが、実現可能な場合もあります。
さらに、暗黙的またはバイナリ変換により、ある演算子族で表現されるデータ型から同じ演算子族で表現されるデータ型に値をキャストしても、計算されたハッシュ値を変更してはいけません。
データ型1つに対してサポート関数が1つしか存在しないことに注意してください。
等価性演算子ごとに１つではありません。
演算子族を完結させること、つまり、データ型の組み合わせそれぞれに対する等価性演算子をすべて含めることを推奨します。
各演算子クラスは、自身のデータ型に対してデータ型を跨らない演算子とサポート関数だけを含めなければなりません。
  </p><p>
<span class="original">
   GiST, SP-GiST, and GIN indexes do not have any explicit notion of
   cross-data-type operations.  The set of operators supported is just
   whatever the primary support functions for a given operator class can
   handle.
</span>
GiST、SP-GiST、GINインデックスではデータ型を跨る操作についての明示的な記法はありません。
サポートされる演算子群は単に指定演算子クラスの主サポート関数が扱うことができるものです。
  </p><p>
<span class="original">
   In BRIN, the requirements depends on the framework that provides the
   operator classes.  For operator classes based on &lt;literal&gt;minmax&lt;/literal&gt;,
   the behavior required is the same as for B-tree operator families:
   all the operators in the family must sort compatibly, and casts must
   not change the associated sort ordering.
</span>
BRINでは、要求は演算子クラスを提供するフレームワークに依存します。
<code class="literal">minmax</code>に基づく演算子クラスに対しては、求められる振る舞いはB-tree演算子クラスに対するものと同じです。族内のすべての演算子はソート互換でなければならず、キャストは関連するソート順序を変更してはいけません。
  </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
    Prior to &lt;productname&gt;PostgreSQL&lt;/productname&gt; 8.3, there was no concept
    of operator families, and so any cross-data-type operators intended to be
    used with an index had to be bound directly into the index's operator
    class.  While this approach still works, it is deprecated because it
    makes an index's dependencies too broad, and because the planner can
    handle cross-data-type comparisons more effectively when both data types
    have operators in the same operator family.
</span>
<span class="productname">PostgreSQL</span>8.3より前のバージョンでは演算子族という概念はありませんでした。
そのため、インデックスで使用する予定のデータ型を跨る演算子はすべて、インデックスの演算子クラスに結びつけなければなりませんでした。
この手法もまだ使用できますが、インデックスの依存性を広げる点、および、両データ型が同一演算子族内で演算子を持つ場合、プランナがデータ型を跨った比較をより効率的に扱うことができる点より、廃止予定です。
   </p></div></div><div class="sect2" id="XINDEX-OPCLASS-DEPENDENCIES"><div class="titlepage"><div><div><h3 class="title">38.16.6. システムの演算子クラスに対する依存性</h3></div></div></div><span class="original">
  &lt;title&gt;System Dependencies on Operator Classes&lt;/title&gt;
</span><a id="id-1.8.3.20.11.2" class="indexterm"></a><a id="id-1.8.3.20.11.3" class="indexterm"></a><p>
<span class="original">
   &lt;productname&gt;PostgreSQL&lt;/productname&gt; uses operator classes to infer the
   properties of operators in more ways than just whether they can be used
   with indexes.  Therefore, you might want to create operator classes
   even if you have no intention of indexing any columns of your data type.
</span>
<span class="productname">PostgreSQL</span>は演算子クラスを、単にインデックスで使用できるかどうかだけではなく、多くの方式で演算子の性質を推定するために使用します。
したがって、データ型の列をインデックス付けするつもりがなくても、演算子クラスを作成した方が良い可能性があります。
  </p><p>
<span class="original">
   In particular, there are SQL features such as &lt;literal&gt;ORDER BY&lt;/literal&gt; and
   &lt;literal&gt;DISTINCT&lt;/literal&gt; that require comparison and sorting of values.
   To implement these features on a user-defined data type,
   &lt;productname&gt;PostgreSQL&lt;/productname&gt; looks for the default B-tree operator
   class for the data type.  The &lt;quote&gt;equals&lt;/quote&gt; member of this operator
   class defines the system's notion of equality of values for
   &lt;literal&gt;GROUP BY&lt;/literal&gt; and &lt;literal&gt;DISTINCT&lt;/literal&gt;, and the sort ordering
   imposed by the operator class defines the default &lt;literal&gt;ORDER BY&lt;/literal&gt;
   ordering.
</span>
具体的には、<code class="literal">ORDER BY</code>や<code class="literal">DISTINCT</code>など、値の比較とソートを必要とするSQL機能があります。
ユーザ定義のデータ型に対してこの機能を実装するために、<span class="productname">PostgreSQL</span>はそのデータ型用のデフォルトのB-tree演算子クラスを検索します。
この演算子クラスの<span class="quote">「<span class="quote">等価判定</span>」</span>メンバが、<code class="literal">GROUP BY</code>や<code class="literal">DISTINCT</code>用の値の等価性についてのシステムの意向を定義し、この演算子クラスによって強制されるソート順序が、デフォルトの<code class="literal">ORDER BY</code>順序を定義します。
  </p><p>
<span class="original">
   If there is no default B-tree operator class for a data type, the system
   will look for a default hash operator class.  But since that kind of
   operator class only provides equality, it is only able to support grouping
   not sorting.
</span>
データ型用のデフォルトのB-tree演算子クラスが存在しないと、システムはデフォルトのハッシュ演算子クラスを検索します。
しかし、この種類の演算子クラスは等価性のみを提供しますので、ソートではなくグループ化のみサポートできます。
  </p><p>
<span class="original">
   When there is no default operator class for a data type, you will get
   errors like &lt;quote&gt;could not identify an ordering operator&lt;/quote&gt; if you
   try to use these SQL features with the data type.
</span>
データ型用のデフォルトの演算子クラスが存在しない場合に、こうしたSQL機能をデータ型に使用しようとすると、<span class="quote">「<span class="quote">順序付け演算子を識別できなかった</span>」</span>といったエラーとなります。
  </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
     In &lt;productname&gt;PostgreSQL&lt;/productname&gt; versions before 7.4,
     sorting and grouping operations would implicitly use operators named
     &lt;literal&gt;=&lt;/literal&gt;, &lt;literal&gt;&amp;lt;&lt;/literal&gt;, and &lt;literal&gt;&amp;gt;&lt;/literal&gt;.  The new
     behavior of relying on default operator classes avoids having to make
     any assumption about the behavior of operators with particular names.
</span>
<span class="productname">PostgreSQL</span>バージョン7.4より前まででは、ソートやグループ化演算は暗黙的に<code class="literal">=</code>、<code class="literal">&lt;</code>、<code class="literal">&gt;</code>という名前の演算子を使用していました。
この新しい、デフォルトの演算子クラスに依存する振舞いによって、特定の名前を持つ演算子の振舞いについて何らかの仮定を立てることを防止しています。
    </p></div><p>
<span class="original">
   Sorting by a non-default B-tree operator class is possible by specifying
   the class's less-than operator in a &lt;literal&gt;USING&lt;/literal&gt; option,
   for example
</span>
演算子クラスの小なり演算子を<code class="literal">USING</code>オプションに指定することで、デフォルトでないB-tree演算子クラスによるソートが可能です。
以下に例を示します。
</p><pre class="programlisting">
SELECT * FROM mytable ORDER BY somecol USING ~&lt;~;
</pre><p>
<span class="original">
   Alternatively, specifying the class's greater-than operator
   in &lt;literal&gt;USING&lt;/literal&gt; selects a descending-order sort.
</span>
代わりに<code class="literal">USING</code>で演算子クラスの大なり演算子を指定すると降順ソートが行われます。
  </p><p>
<span class="original">
   Comparison of arrays of a user-defined type also relies on the semantics
   defined by the type's default B-tree operator class.  If there is no
   default B-tree operator class, but there is a default hash operator class,
   then array equality is supported, but not ordering comparisons.
</span>
ユーザ定義型の配列の比較も型のデフォルトB-tree演算子クラスで定義された意味に依存します。
デフォルトのB-tree演算子クラスが無く、しかしデフォルトのハッシュ演算子クラスがある場合、配列の順比較ではなく同等比較がサポートされます。
  </p><p>
<span class="original">
   Another SQL feature that requires even more data-type-specific knowledge
   is the &lt;literal&gt;RANGE&lt;/literal&gt; &lt;replaceable&gt;offset&lt;/replaceable&gt;
   &lt;literal&gt;PRECEDING&lt;/literal&gt;/&lt;literal&gt;FOLLOWING&lt;/literal&gt; framing option
   for window functions (see &lt;xref linkend="syntax-window-functions"/&gt;).
   For a query such as
</span>
データ型特有の知識をさらに必要とする他のSQL仕様としては、ウィンドウ関数（<a class="xref" href="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS" title="4.2.8. ウィンドウ関数呼び出し">4.2.8</a>を参照してください）の<code class="literal">RANGE</code> <em class="replaceable"><code>offset</code></em> <code class="literal">PRECEDING</code>/<code class="literal">FOLLOWING</code>フレームオプションがあります。
下記のような問い合わせに対して、
</p><pre class="programlisting">
SELECT sum(x) OVER (ORDER BY x RANGE BETWEEN 5 PRECEDING AND 10 FOLLOWING)
  FROM mytable;
</pre><p>
<span class="original">
   it is not sufficient to know how to order by &lt;literal&gt;x&lt;/literal&gt;;
   the database must also understand how to &lt;quote&gt;subtract 5&lt;/quote&gt; or
   &lt;quote&gt;add 10&lt;/quote&gt; to the current row's value of &lt;literal&gt;x&lt;/literal&gt;
   to identify the bounds of the current window frame.  Comparing the
   resulting bounds to other rows' values of &lt;literal&gt;x&lt;/literal&gt; is
   possible using the comparison operators provided by the B-tree operator
   class that defines the &lt;literal&gt;ORDER BY&lt;/literal&gt; ordering &amp;mdash; but
   addition and subtraction operators are not part of the operator class, so
   which ones should be used?  Hard-wiring that choice would be undesirable,
   because different sort orders (different B-tree operator classes) might
   need different behavior.  Therefore, a B-tree operator class can specify
   an &lt;firstterm&gt;in_range&lt;/firstterm&gt; support function that encapsulates the
   addition and subtraction behaviors that make sense for its sort order.
   It can even provide more than one in_range support function, in case
   there is more than one data type that makes sense to use as the offset
   in &lt;literal&gt;RANGE&lt;/literal&gt; clauses.
   If the B-tree operator class associated with the window's &lt;literal&gt;ORDER
   BY&lt;/literal&gt; clause does not have a matching in_range support function,
   the &lt;literal&gt;RANGE&lt;/literal&gt; &lt;replaceable&gt;offset&lt;/replaceable&gt;
   &lt;literal&gt;PRECEDING&lt;/literal&gt;/&lt;literal&gt;FOLLOWING&lt;/literal&gt;
   option is not supported.
</span>
これはどのように<code class="literal">x</code>で整列するかを知るのに十分ではありません。
データベースは現在のウィンドウフレームの境界を識別するためにどのように現在行の<code class="literal">x</code>の値に<span class="quote">「<span class="quote">5を減算</span>」</span>や<span class="quote">「<span class="quote">10を加算</span>」</span>を行うかを理解する必要もあります。
<code class="literal">ORDER BY</code>整列を定義するB-tree演算子クラスで提供される比較演算子を使って結果として生じる他の行の<code class="literal">x</code>値への範囲を比較することは可能です。
しかし、加算、減算演算子は演算子クラスの一部ではありません。では、どの演算子が使われるべきでしょうか。
異なるソート順序（異なるB-tree演算子クラス）では異なる振る舞いを要するかもしれないため、選択を決め打ちすることは望ましくありません。
そのため、B-tree演算子クラスはそのソート順に意味がある加算と減算の振る舞いをカプセル化する<em class="firstterm">in_range</em>サポート関数を指定することができます。
<code class="literal">RANGE</code>句のオフセットとして使う意味のある複数のデータ型がある場合にむけて、複数のin_rangeサポート関数を提供することもできます。
ウィンドウの<code class="literal">ORDER BY</code>句と関連しているB-tree演算子クラスが、一致するin_rangeサポート関数を持たない場合、<code class="literal">RANGE</code> <em class="replaceable"><code>offset</code></em> <code class="literal">PRECEDING</code>/<code class="literal">FOLLOWING</code>オプションはサポートされません。
  </p><p>
<span class="original">
   Another important point is that an equality operator that
   appears in a hash operator family is a candidate for hash joins,
   hash aggregation, and related optimizations.  The hash operator family
   is essential here since it identifies the hash function(s) to use.
</span>
他の重要な点として、ハッシュ演算子族内に現れる等価性演算子がハッシュ結合、ハッシュ集約、関連する最適化の候補となることがあります。
使用するハッシュ関数を識別するため、ここでのハッシュ演算子族は基本的なものです。
  </p></div><div class="sect2" id="XINDEX-ORDERING-OPS"><div class="titlepage"><div><div><h3 class="title">38.16.7. 順序付け演算子</h3></div></div></div><span class="original">
  &lt;title&gt;Ordering Operators&lt;/title&gt;
</span><p>
<span class="original">
   Some index access methods (currently, only GiST and SP-GiST) support the concept of
   &lt;firstterm&gt;ordering operators&lt;/firstterm&gt;.  What we have been discussing so far
   are &lt;firstterm&gt;search operators&lt;/firstterm&gt;.  A search operator is one for which
   the index can be searched to find all rows satisfying
   &lt;literal&gt;WHERE&lt;/literal&gt;
   &lt;replaceable&gt;indexed_column&lt;/replaceable&gt;
   &lt;replaceable&gt;operator&lt;/replaceable&gt;
   &lt;replaceable&gt;constant&lt;/replaceable&gt;.
   Note that nothing is promised about the order in which the matching rows
   will be returned.  In contrast, an ordering operator does not restrict the
   set of rows that can be returned, but instead determines their order.
   An ordering operator is one for which the index can be scanned to return
   rows in the order represented by
   &lt;literal&gt;ORDER BY&lt;/literal&gt;
   &lt;replaceable&gt;indexed_column&lt;/replaceable&gt;
   &lt;replaceable&gt;operator&lt;/replaceable&gt;
   &lt;replaceable&gt;constant&lt;/replaceable&gt;.
   The reason for defining ordering operators that way is that it supports
   nearest-neighbor searches, if the operator is one that measures distance.
   For example, a query like
</span>
一部のインデックスアクセスメソッド（現時点ではGiSTとSP-GiSTのみ）は<em class="firstterm">順序付け演算子</em>という概念をサポートします。
これまで説明してきたものは<em class="firstterm">検索演算子</em>でした。
検索演算子は、<code class="literal">WHERE</code> <em class="replaceable"><code>indexed_column</code></em> <em class="replaceable"><code>operator</code></em> <em class="replaceable"><code>constant</code></em>を満たすすべての行を見つけるために、インデックスを検索可能にするためのものです。
一致した行がどの順序で返されるかについては保証がないことに注意してください。
反対に、順序付け演算子は返すことができる行集合を限定しませんが、その順序を決定します。
順序付け演算子は、<code class="literal">ORDER BY</code> <em class="replaceable"><code>indexed_column</code></em> <em class="replaceable"><code>operator</code></em> <em class="replaceable"><code>constant</code></em>で表される順序で行を返すために、インデックスをスキャン可能にするためのものです。
このように順序付け演算子を定義する理由は、その演算子が距離を測るものであれば最近傍検索をサポートすることです。
例えば以下のような問い合わせを考えます。
</p><pre class="programlisting">
SELECT * FROM places ORDER BY location &lt;-&gt; point '(101,456)' LIMIT 10;

</pre><p>
<span class="original">
   finds the ten places closest to a given target point.  A GiST index
   on the location column can do this efficiently because
   &lt;literal&gt;&amp;lt;-&amp;gt;&lt;/literal&gt; is an ordering operator.
</span>
これは指定した対象地点に最も近い10地点を見つけ出します。
<code class="literal">&lt;-&gt;</code>は順序付け演算子ですので、location列上のGiSTインデックスは、これを効率的に行うことができます。
  </p><p>
<span class="original">
   While search operators have to return Boolean results, ordering operators
   usually return some other type, such as float or numeric for distances.
   This type is normally not the same as the data type being indexed.
   To avoid hard-wiring assumptions about the behavior of different data
   types, the definition of an ordering operator is required to name
   a B-tree operator family that specifies the sort ordering of the result
   data type.  As was stated in the previous section, B-tree operator families
   define &lt;productname&gt;PostgreSQL&lt;/productname&gt;'s notion of ordering, so
   this is a natural representation.  Since the point &lt;literal&gt;&amp;lt;-&amp;gt;&lt;/literal&gt;
   operator returns &lt;type&gt;float8&lt;/type&gt;, it could be specified in an operator
   class creation command like this:
</span>
検索演算子が論理値結果を返さなければなりませんが、順序付け演算子は普通、距離を表す浮動小数点や数値型など、何らかの他の型を返します。
この型は通常、インデックス対象のデータ型と同じにはなりません。
異なるデータ型の動作についての固定化された前提を防ぐために、順序付け演算子の定義では、結果データ型のソート順序を指定するB-tree演算子族の名前を必要とします。
前節で述べたように、B-tree演算子族は<span class="productname">PostgreSQL</span>の順序付け記法を定義します。
ですのでこれは自然な表現です。
pointに対する<code class="literal">&lt;-&gt;</code>演算子は<code class="type">float8</code>を返しますので、演算子クラスを作成するコマンド内で以下のように指定します。
</p><pre class="programlisting">
OPERATOR 15    &lt;-&gt; (point, point) FOR ORDER BY float_ops

</pre><p>
<span class="original">
   where &lt;literal&gt;float_ops&lt;/literal&gt; is the built-in operator family that includes
   operations on &lt;type&gt;float8&lt;/type&gt;.  This declaration states that the index
   is able to return rows in order of increasing values of the
   &lt;literal&gt;&amp;lt;-&amp;gt;&lt;/literal&gt; operator.
</span>
ここで<code class="literal">float_ops</code>は、<code class="type">float8</code>に対する操作を含んだ組み込みの演算子族です。
この宣言は、インデックスが<code class="literal">&lt;-&gt;</code>演算子の値が増加する方向で行を返すことができることを表しています。
  </p></div><div class="sect2" id="XINDEX-OPCLASS-FEATURES"><div class="titlepage"><div><div><h3 class="title">38.16.8. 演算子クラスの特殊な機能</h3></div></div></div><span class="original">
  &lt;title&gt;Special Features of Operator Classes&lt;/title&gt;
</span><p>
<span class="original">
   There are two special features of operator classes that we have
   not discussed yet, mainly because they are not useful
   with the most commonly used index methods.
</span>
演算子クラスには、まだ説明していない2つの特殊な機能があります。
説明していない主な理由は、最もよく使用するインデックスメソッドでは、これらがあまり有用ではないためです。
  </p><p>
<span class="original">
   Normally, declaring an operator as a member of an operator class
   (or family) means that the index method can retrieve exactly the set of rows
   that satisfy a &lt;literal&gt;WHERE&lt;/literal&gt; condition using the operator.  For example:
</span>
通常、演算子を演算子クラス（または演算子族）のメンバとして宣言すると、インデックスメソッドでその演算子を使用して、<code class="literal">WHERE</code>条件を満たす行の集合を正確に抽出することができます。
以下に例を示します。
</p><pre class="programlisting">
SELECT * FROM table WHERE integer_column &lt; 4;
</pre><p>
<span class="original">
   can be satisfied exactly by a B-tree index on the integer column.
   But there are cases where an index is useful as an inexact guide to
   the matching rows.  For example, if a GiST index stores only bounding boxes
   for geometric objects, then it cannot exactly satisfy a &lt;literal&gt;WHERE&lt;/literal&gt;
   condition that tests overlap between nonrectangular objects such as
   polygons.  Yet we could use the index to find objects whose bounding
   box overlaps the bounding box of the target object, and then do the
   exact overlap test only on the objects found by the index.  If this
   scenario applies, the index is said to be &lt;quote&gt;lossy&lt;/quote&gt; for the
   operator.  Lossy index searches are implemented by having the index
   method return a &lt;firstterm&gt;recheck&lt;/firstterm&gt; flag when a row might or might
   not really satisfy the query condition.  The core system will then
   test the original query condition on the retrieved row to see whether
   it should be returned as a valid match.  This approach works if
   the index is guaranteed to return all the required rows, plus perhaps
   some additional rows, which can be eliminated by performing the original
   operator invocation.  The index methods that support lossy searches
   (currently, GiST, SP-GiST and GIN) allow the support functions of individual
   operator classes to set the recheck flag, and so this is essentially an
   operator-class feature.
</span>
この式は、整数列にB-treeインデックスを使用することにより、正確に満たすことができます。
しかし、一致する行へ厳密ではなくとも導く手段としてインデックスが有用である場合があります。
例えば、GiSTインデックスで、幾何オブジェクトの外接矩形のみを格納したとします。
その結果、多角形のような長方形でないオブジェクトとの重なりをテストする<code class="literal">WHERE</code>条件は正確に満たすことができません。
もっとも、このインデックスを使用して、対象オブジェクトの外接矩形に重なる外接矩形を持つオブジェクトを検索し、さらに、検索されたオブジェクトのみに対して正確に重なるかどうかをテストすることはできます。
この筋書きを適用する場合、インデックスは演算子に対して<span class="quote">「<span class="quote">非可逆</span>」</span>と言われます。
非可逆インデックス検索は、ある行が問い合わせ条件を実際に満足するかしないかの時に<em class="firstterm">recheck</em>フラグを返すインデックスメソッドを持つことで実装されます。
コアシステムは、そこで有効なマッチとして行が返されるか否かを確認するために、抽出された行に対して元の問い合わせ条件を検査します。
この手法はインデックスがすべての必要な行を返すことが保証された上で、元の演算子呼び出しを実行することによって除外することができる、いくつか余分な行を返す可能性がある場合に動作します。
非可逆検索を提供するインデックス方式（現時点ではGiST、SP-GiSTおよびGIN）は個々の演算子クラスのサポート関数がrecheckフラグを設定することを許可します。
このためこれは原則的に演算子クラスの機能です。
  </p><p>
<span class="original">
   Consider again the situation where we are storing in the index only
   the bounding box of a complex object such as a polygon.  In this
   case there's not much value in storing the whole polygon in the index
   entry &amp;mdash; we might as well store just a simpler object of type
   &lt;type&gt;box&lt;/type&gt;.  This situation is expressed by the &lt;literal&gt;STORAGE&lt;/literal&gt;
   option in &lt;command&gt;CREATE OPERATOR CLASS&lt;/command&gt;: we'd write something like:
</span>
再度、多角形のような複雑なオブジェクトの外接矩形のみをインデックスに格納している状況を考えてみてください。
この場合、インデックスエントリに多角形全体を格納するのは、それほど有用なことではありません。
単に、より単純な<code class="type">box</code>型のオブジェクトを格納した方が良いかもしれません。
このような状況は、<code class="command">CREATE OPERATOR CLASS</code>の<code class="literal">STORAGE</code>オプションによって表現することができます。
例えば、以下のように記述します。

</p><pre class="programlisting">
CREATE OPERATOR CLASS polygon_ops
    DEFAULT FOR TYPE polygon USING gist AS
        ...
        STORAGE box;
</pre><p>

<span class="original">
   At present, only the GiST, SP-GiST, GIN and BRIN index methods support a
   &lt;literal&gt;STORAGE&lt;/literal&gt; type that's different from the column data type.
   The GiST &lt;function&gt;compress&lt;/function&gt; and &lt;function&gt;decompress&lt;/function&gt; support
   routines must deal with data-type conversion when &lt;literal&gt;STORAGE&lt;/literal&gt;
   is used.  SP-GiST likewise requires a &lt;function&gt;compress&lt;/function&gt;
   support function to convert to the storage type, when that is different;
   if an SP-GiST opclass also supports retrieving data, the reverse
   conversion must be handled by the &lt;function&gt;consistent&lt;/function&gt; function.
   In GIN, the &lt;literal&gt;STORAGE&lt;/literal&gt; type identifies the type of
   the &lt;quote&gt;key&lt;/quote&gt; values, which normally is different from the type
   of the indexed column &amp;mdash; for example, an operator class for
   integer-array columns might have keys that are just integers.  The
   GIN &lt;function&gt;extractValue&lt;/function&gt; and &lt;function&gt;extractQuery&lt;/function&gt; support
   routines are responsible for extracting keys from indexed values.
   BRIN is similar to GIN: the &lt;literal&gt;STORAGE&lt;/literal&gt; type identifies the
   type of the stored summary values, and operator classes' support
   procedures are responsible for interpreting the summary values
   correctly.
</span>
現時点では、GiST、SP-GiST、GINおよびBRINインデックスメソッドが、列のデータ型と異なる<code class="literal">STORAGE</code>型をサポートしています。
<code class="literal">STORAGE</code>が使用された場合、GiSTの<code class="function">compress</code>および<code class="function">decompress</code>サポートルーチンは、データ型を変換する必要があります。
SP-GiSTも同様に、STORAGE型が異なる場合に変換するための<code class="function">compress</code>サポート関数を必要とします。
SP-GiST演算子クラスがデータの取得もサポートする場合、逆変換は<code class="function">consistent</code>関数で処理する必要があります。
GINでは、<code class="literal">STORAGE</code>型は<span class="quote">「<span class="quote">キー</span>」</span>の値の型を識別します。
通常これはインデックス付けされる列の型とは異なります。
例えば、整数配列の列用の演算子クラスは単なる整数をキーとして持つかもしれません。
GINの<code class="function">extractValue</code>および<code class="function">extractQuery</code>サポートルーチンが、インデックス付けされた値からキーを取り出す責任を負います。
BRINはGINと同様です。<code class="literal">STORAGE</code>型は格納された要約値の型を識別し、演算子クラスのサポートプロシージャは要約値を正しく解釈する責任を負います。
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xoper-optimization.html" title="38.15. 演算子最適化に関する情報">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="extend.html" title="第38章 SQLの拡張">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="extend-extensions.html" title="38.17. 関連するオブジェクトを拡張としてパッケージ化">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">38.15. 演算子最適化に関する情報 </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 15rc1文書">ホーム</a></td><td width="40%" align="right" valign="top"> 38.17. 関連するオブジェクトを拡張としてパッケージ化</td></tr></table></div></body></html>