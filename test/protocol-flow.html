<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>55.2. メッセージの流れ</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="protocol-overview.html" title="55.1. 概要" /><link rel="next" href="sasl-authentication.html" title="55.3. SASL認証" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 15rc1文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="protocol.html" title="第55章 フロントエンド/バックエンドプロトコル">第55章 フロントエンド/バックエンドプロトコル</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?template=bug_report.yml&amp;what-happened=version 15rc1 : protocol-flow.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="protocol-overview.html" title="55.1. 概要">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="protocol.html" title="第55章 フロントエンド/バックエンドプロトコル">上へ</a></td><td width="60%" align="center">55.2. メッセージの流れ</td><td width="20%" align="right"> <a accesskey="n" href="sasl-authentication.html" title="55.3. SASL認証">次へ</a></td></tr></table><hr /></div><div class="sect1" id="PROTOCOL-FLOW"><div class="titlepage"><div><div><h2 class="title" style="clear: both">55.2. メッセージの流れ</h2></div></div></div><span class="original">
  &lt;title&gt;Message Flow&lt;/title&gt;
</span><p>
<span class="original">
   This section describes the message flow and the semantics of each
   message type.  (Details of the exact representation of each message
   appear in &lt;xref linkend="protocol-message-formats"/&gt;.)  There are
   several different sub-protocols depending on the state of the
   connection: start-up, query, function call,
   &lt;command&gt;COPY&lt;/command&gt;, and termination.  There are also special
   provisions for asynchronous operations (including notification
   responses and command cancellation), which can occur at any time
   after the start-up phase.
</span>
本節では、メッセージの流れと各メッセージ種類のセマンティクスを説明します。
（各メッセージの正確な表現の詳細については<a class="xref" href="protocol-message-formats.html" title="55.7. メッセージの書式">55.7</a>で説明します。）
開始、問い合わせ、関数呼び出し、<code class="command">COPY</code>、終了といった接続状態に応じて、複数の異なるサブプロトコルがあります。
また、開始段階の後の任意の時点で発生する可能性がある、非同期操作（通知応答やコマンドのキャンセルを含む）用の特別な準備もあります。
  </p><div class="sect2" id="id-1.10.6.8.3"><div class="titlepage"><div><div><h3 class="title">55.2.1. 開始</h3></div></div></div><span class="original">
   &lt;title&gt;Start-up&lt;/title&gt;
</span><p>
<span class="original">
    To begin a session, a frontend opens a connection to the server and sends
    a startup message.  This message includes the names of the user and of the
    database the user wants to connect to; it also identifies the particular
    protocol version to be used.  (Optionally, the startup message can include
    additional settings for run-time parameters.)
    The server then uses this information and
    the contents of its configuration files (such as
    &lt;filename&gt;pg_hba.conf&lt;/filename&gt;) to determine
    whether the connection is provisionally acceptable, and what additional
    authentication is required (if any).
</span>
セッションを開始するために、フロントエンドはサーバへの接続を開き、開始メッセージを送信します。
このメッセージには、ユーザ名と接続を希望するデータベース名が含まれます。
これはまた、使用する特定のプロトコルバージョンを識別します。
（オプションとして、開始メッセージに、実行時パラメータの追加設定を含めることもできます。）
サーバはその後、この情報と設定ファイル（<code class="filename">pg_hba.conf</code>など）の内容を使用して、接続が暫定的に受け付けられるかどうか、そして（もしあれば）どのような追加認証が必要かを決定します。
   </p><p>
<span class="original">
    The server then sends an appropriate authentication request message,
    to which the frontend must reply with an appropriate authentication
    response message (such as a password).
    For all authentication methods except GSSAPI, SSPI and SASL, there is at
    most one request and one response. In some methods, no response
    at all is needed from the frontend, and so no authentication request
    occurs. For GSSAPI, SSPI and SASL, multiple exchanges of packets may be
    needed to complete the authentication.
</span>
サーバはその後、適切な認証要求メッセージを送信します。
フロントエンドはこれに適切な認証応答メッセージ（パスワードなど）で答えなければなりません。
GSSAPI、SSPI、SASLを除くすべての認証方式では、多くても１つの要求と１つの応答が存在します。
認証方式の中には、フロントエンドからの応答をまったく必要としないものもあり、その場合、認証要求も発生しません。
GSSAPI、SSPI、SASLでは認証を完了するために複数のパケットの交換が必要となるかもしれません。
   </p><p>
<span class="original">
    The authentication cycle ends with the server either rejecting the
    connection attempt (ErrorResponse), or sending AuthenticationOk.
</span>
認証サイクルは、サーバによって接続要求を拒絶する（ErrorResponse）か、あるいはAuthenticationOkを送信することで終わります。
   </p><p>
<span class="original">
    The possible messages from the server in this phase are:
</span>
この段階でサーバから送信される可能性があるメッセージを以下に示します。

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">ErrorResponse</span></dt><dd><p>
<span class="original">
        The connection attempt has been rejected.
        The server then immediately closes the connection.
</span>
接続試行が拒絶されました。
サーバはその後即座に接続を閉ざします。
       </p></dd><dt><span class="term">AuthenticationOk</span></dt><dd><p>
<span class="original">
        The authentication exchange is successfully completed.
</span>
認証情報の交換が正常に完了しました。
       </p></dd><dt><span class="term">AuthenticationKerberosV5</span></dt><dd><p>
<span class="original">
        The frontend must now take part in a Kerberos V5
        authentication dialog (not described here, part of the
        Kerberos specification) with the server.  If this is
        successful, the server responds with an AuthenticationOk,
        otherwise it responds with an ErrorResponse. This is no
        longer supported.
</span>
フロントエンドはここでサーバとのKerberos V5認証ダイアログ（ここでは説明しません。Kerberos仕様の一部）に参加する必要があります。
これが成功すれば、サーバはAuthenticationOk応答を行います。
失敗すれば、ErrorResponse応答を行います。
これはもはやサポートされていません。
       </p></dd><dt><span class="term">AuthenticationCleartextPassword</span></dt><dd><p>
<span class="original">
        The frontend must now send a PasswordMessage containing the
        password in clear-text form.  If
        this is the correct password, the server responds with an
        AuthenticationOk, otherwise it responds with an ErrorResponse.
</span>
フロントエンドはここで平文形式のパスワードを含むPasswordMessageを送信する必要があります。
これが正しいパスワードであればサーバはAuthenticationOk応答を行います。
さもなくば、ErrorResponse応答を行います。
       </p></dd><dt><span class="term">AuthenticationMD5Password</span></dt><dd><p>
<span class="original">
        The frontend must now send a PasswordMessage containing the
        password (with user name) encrypted via MD5, then encrypted
        again using the 4-byte random salt specified in the
        AuthenticationMD5Password message.  If this is the correct
        password, the server responds with an AuthenticationOk,
        otherwise it responds with an ErrorResponse.  The actual
        PasswordMessage can be computed in SQL as &lt;literal&gt;concat('md5',
        md5(concat(md5(concat(password, username)), random-salt)))&lt;/literal&gt;.
        (Keep in mind the &lt;function&gt;md5()&lt;/function&gt; function returns its
        result as a hex string.)
</span>
フロントエンドはここでMD5で暗号化したパスワード（とユーザ名）を再度AuthenticationMD5Passwordメッセージで指定されたランダムな４バイトのソルトを使用して暗号化したものを含むPasswordMessageを送信する必要があります。
これが正しいパスワードであればサーバはAuthenticationOk応答を行います。
さもなくば、ErrorResponse応答を行います。
実際のPasswordMessageを<code class="literal">concat('md5', md5(concat(md5(concat(password, username)), random-salt)))</code>というSQLで計算することができます。
（<code class="function">md5()</code>関数がその結果を１６進数表記で返すことに注意してください。）
       </p></dd><dt><span class="term">AuthenticationSCMCredential</span></dt><dd><p>
<span class="original">
        This response is only possible for local Unix-domain connections
        on platforms that support SCM credential messages.  The frontend
        must issue an SCM credential message and then send a single data
        byte.  (The contents of the data byte are uninteresting; it's
        only used to ensure that the server waits long enough to receive
        the credential message.)  If the credential is acceptable,
        the server responds with an
        AuthenticationOk, otherwise it responds with an ErrorResponse.
        (This message type is only issued by pre-9.1 servers.  It may
        eventually be removed from the protocol specification.)
</span>
この応答はSCM資格証明メッセージをサポートするプラットフォーム上のローカルなUnixドメイン接続でのみあり得ます。
フロントエンドはSCM資格証明メッセージを発行し、その後単一のデータバイトを送信する必要があります。
（データバイトの内容には意味はありません。
これはサーバが資格証明メッセージの受信にどれだけ待機すればよいのかを確実にするためだけに使用されます。）
資格証明が受け付け可能であれば、サーバはAuthenticationOk応答を行います。
さもなくば、ErrorResponse応答を行います。
（この種類のメッセージは9.1より前のサーバでのみ発行されます。
最終的にはプロトコル仕様から削除されるかもしれません。）
       </p></dd><dt><span class="term">AuthenticationGSS</span></dt><dd><p>
<span class="original">
        The frontend must now initiate a GSSAPI negotiation. The frontend
        will send a GSSResponse message with the first part of the GSSAPI
        data stream in response to this. If further messages are needed,
        the server will respond with AuthenticationGSSContinue.
</span>
ここでフロントエンドはGSSAPIの調停を開始しなければなりません。
これに対する応答におけるGSSAPIデータストリームの最初の部分で、フロントエンドはGSSResponseを送信します。
さらにメッセージが必要となる場合、サーバはAuthenticationGSSContinueで応答します。
       </p></dd><dt><span class="term">AuthenticationSSPI</span></dt><dd><p>
<span class="original">
        The frontend must now initiate an SSPI negotiation. The frontend
        will send a GSSResponse with the first part of the SSPI
        data stream in response to this. If further messages are needed,
        the server will respond with AuthenticationGSSContinue.
</span>
ここでフロントエンドはSSPI調停を開始しなければなりません。
これに対する応答におけるSSPIデータストリームの最初の部分で、フロントエンドはGSSResponseを送信します。
さらにメッセージが必要となる場合、サーバはAuthenticationGSSContinueで応答します。
       </p></dd><dt><span class="term">AuthenticationGSSContinue</span></dt><dd><p>
<span class="original">
        This message contains the response data from the previous step
        of GSSAPI or SSPI negotiation (AuthenticationGSS, AuthenticationSSPI
        or a previous AuthenticationGSSContinue). If the GSSAPI
        or SSPI data in this message
        indicates more data is needed to complete the authentication,
        the frontend must send that data as another GSSResponse message. If
        GSSAPI or SSPI authentication is completed by this message, the server
        will next send AuthenticationOk to indicate successful authentication
        or ErrorResponse to indicate failure.
</span>
このメッセージには、GSSAPIまたはSSPI調停の直前の段階（AuthenticationGSS、AuthenticationSSPIまたは前回のAuthenticationGSSContinue）についての応答データが含まれます。
このメッセージ内のGSSAPIまたはSSPIデータが認証を完結させるため、更なる追加データが必要であることを指示している場合、フロントエンドは他のGSSResponseとしてデータを送信しなければなりません。
このメッセージでGSSAPIまたはSSPI認証が完了すれば、次にサーバはAuthenticationOkを送信して認証が成功したことを示すか、あるいはErrorResponseを送信して失敗したことを示します。
       </p></dd><dt><span class="term">AuthenticationSASL</span></dt><dd><p>
<span class="original">
        The frontend must now initiate a SASL negotiation, using one of the
        SASL mechanisms listed in the message. The frontend will send a
        SASLInitialResponse with the name of the selected mechanism, and the
        first part of the SASL data stream in response to this. If further
        messages are needed, the server will respond with
        AuthenticationSASLContinue. See &lt;xref linkend="sasl-authentication"/&gt;
        for details.
</span>
ここでフロントエンドはメッセージ内に列挙されているSASL機構の1つを使ってSASL調停を開始しなければなりません。
これに応答するSASLデータストリームの最初の部分で、フロントエンドはSASLInitialResponseと選択した機構の名前を送信します。
さらにメッセージが必要な場合、サーバはAuthenticationSASLContinueで応答します。
詳細については<a class="xref" href="sasl-authentication.html" title="55.3. SASL認証">55.3</a>を参照してください。
       </p></dd><dt><span class="term">AuthenticationSASLContinue</span></dt><dd><p>
<span class="original">
        This message contains challenge data from the previous step of SASL
        negotiation (AuthenticationSASL, or a previous
        AuthenticationSASLContinue). The frontend must respond with a
        SASLResponse message.
</span>
このメッセージには、SASL調停における直前の段階（AuthenticationSASLまたは以前のAuthenticationSASLContinue）のチャレンジデータが含まれます。
フロントエンドはSASLResponseメッセージで応答しなければなりません。
       </p></dd><dt><span class="term">AuthenticationSASLFinal</span></dt><dd><p>
<span class="original">
        SASL authentication has completed with additional mechanism-specific
        data for the client. The server will next send AuthenticationOk to
        indicate successful authentication, or an ErrorResponse to indicate
        failure. This message is sent only if the SASL mechanism specifies
        additional data to be sent from server to client at completion.
</span>
機構固有のクライアント用の追加データを伴ってSASL認証が完了します。
サーバは次に認証成功を示すAuthenticationOkを送信するか、あるいは失敗を示すErrorResponseを送信します。
このメッセージはSASLの機構が完了時にサーバからクライアントに送信する追加データを指定しているときにのみ送信されます。
       </p></dd><dt><span class="term">NegotiateProtocolVersion</span></dt><dd><p>
<span class="original">
        The server does not support the minor protocol version requested
        by the client, but does support an earlier version of the protocol;
        this message indicates the highest supported minor version.  This
        message will also be sent if the client requested unsupported protocol
        options (i.e., beginning with &lt;literal&gt;_pq_.&lt;/literal&gt;) in the
        startup packet.  This message will be followed by an ErrorResponse or
        a message indicating the success or failure of authentication.
</span>
サーバはクライアントが要求したマイナープロトコルバージョンをサポートしませんが、それ以前のバージョンをサポートします。
このメッセージは、サポートしている最も高いマイナーバージョンを示します。
このメッセージは、クライアントがサポートされないプロトコルオプション（つまり<code class="literal">_pq_.</code>で始まる）をスタートアップパケットの中で指定した場合にも送られます。
このメッセージの後に、ErrorResponseか、認証が成功あるいは失敗したことを示すメッセージが続きます。
       </p></dd></dl></div><p>
   </p><p>
<span class="original">
    If the frontend does not support the authentication method
    requested by the server, then it should immediately close the
    connection.
</span>
サーバが要求した認証方式をフロントエンドがサポートしていない場合、フロントエンドは即座に接続を閉ざします。
   </p><p>
<span class="original">
    After having received AuthenticationOk, the frontend must wait
    for further messages from the server.  In this phase a backend process
    is being started, and the frontend is just an interested bystander.
    It is still possible for the startup attempt
    to fail (ErrorResponse) or the server to decline support for the requested
    minor protocol version (NegotiateProtocolVersion), but in the normal case
    the backend will send some ParameterStatus messages, BackendKeyData, and
    finally ReadyForQuery.
</span>
AuthenticationOkを受け取った後、フロントエンドはさらにサーバからのメッセージを待機する必要があります。
この段階で、バックエンドプロセスが起動し、このフロントエンドは単なる関心を有する第三者となります。
開始試行が失敗（ErrorResponse）するか、サーバが要求されたマイナープロトコルバージョンを拒否する（NegotiateProtocolVersion）可能性がまだありますが、通常、バックエンドは何らかのParameterStatusメッセージ、BackendKeyData、そして最後にReadyForQueryを送信します。
   </p><p>
<span class="original">
    During this phase the backend will attempt to apply any additional
    run-time parameter settings that were given in the startup message.
    If successful, these values become session defaults.  An error causes
    ErrorResponse and exit.
</span>
この段階の期間中、バックエンドは開始メッセージで与えられた任意の実行時パラメータの追加設定を適用しようとします。
成功した場合は、これらの値はセッションのデフォルトになります。
エラーが発生した場合はErrorResponseを行い、終了します。
   </p><p>
<span class="original">
    The possible messages from the backend in this phase are:
</span>
この段階でバックエンドから送信される可能性があるメッセージを以下に示します。

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">BackendKeyData</span></dt><dd><p>
<span class="original">
        This message provides secret-key data that the frontend must
        save if it wants to be able to issue cancel requests later.
        The frontend should not respond to this message, but should
        continue listening for a ReadyForQuery message.
</span>
このメッセージは、フロントエンドがキャンセル要求を後で送信できるようにしたい場合に保存しなければならない、秘密キーデータを用意します。
フロントエンドはこのメッセージに応答してはいけませんが、ReadyForQueryメッセージの監視を続けなくてはなりません。
       </p></dd><dt><span class="term">ParameterStatus</span></dt><dd><p>
<span class="original">
        This message informs the frontend about the current (initial)
         setting of backend parameters, such as &lt;xref
         linkend="guc-client-encoding"/&gt; or &lt;xref linkend="guc-datestyle"/&gt;.
         The frontend can ignore this message, or record the settings
         for its future use; see &lt;xref linkend="protocol-async"/&gt; for
         more details.  The frontend should not respond to this
         message, but should continue listening for a ReadyForQuery
         message.
</span>
このメッセージは、フロントエンドに現在（初期）の<a class="xref" href="runtime-config-client.html#GUC-CLIENT-ENCODING">client_encoding</a>や<a class="xref" href="runtime-config-client.html#GUC-DATESTYLE">DateStyle</a>などのバックエンドパラメータの設定情報を通知します。
フロントエンドはこのメッセージを無視しても、将来の使用に備えてその設定を記録しても構いません。
詳細は<a class="xref" href="protocol-flow.html#PROTOCOL-ASYNC" title="55.2.7. 非同期操作">55.2.7</a>を参照してください。
フロントエンドはこのメッセージに応答してはいけませんが、ReadyForQueryメッセージの監視を続けなくてはなりません。
       </p></dd><dt><span class="term">ReadyForQuery</span></dt><dd><p>
<span class="original">
        Start-up is completed.  The frontend can now issue commands.
</span>
開始処理が完了しました。
フロントエンドはここでコマンドを発行することができます。
       </p></dd><dt><span class="term">ErrorResponse</span></dt><dd><p>
<span class="original">
        Start-up failed.  The connection is closed after sending this
        message.
</span>
開始処理が失敗しました。
接続はこのメッセージの送信後に閉ざされます。
       </p></dd><dt><span class="term">NoticeResponse</span></dt><dd><p>
<span class="original">
        A warning message has been issued.  The frontend should
        display the message but continue listening for ReadyForQuery
        or ErrorResponse.
</span>
警告メッセージが発行されました。
フロントエンドはこのメッセージを表示し、ReadyForQueryもしくはErrorResponseメッセージの監視を続けなければなりません。
       </p></dd></dl></div><p>
   </p><p>
<span class="original">
    The ReadyForQuery message is the same one that the backend will
    issue after each command cycle.  Depending on the coding needs of
    the frontend, it is reasonable to consider ReadyForQuery as
    starting a command cycle, or to consider ReadyForQuery as ending the
    start-up phase and each subsequent command cycle.
</span>
ReadyForQueryメッセージは各コマンドサイクルの後にバックエンドが発行するものと同じものです。
フロントエンドのコーディングにおいて必要であれば、ReadyForQueryをコマンドサイクルの開始とみなしても構いませんし、ReadyForQueryを開始段階とその後の各コマンドサイクルの終端とみなしても構いません。
   </p></div><div class="sect2" id="id-1.10.6.8.4"><div class="titlepage"><div><div><h3 class="title">55.2.2. 簡易問い合わせ</h3></div></div></div><span class="original">
   &lt;title&gt;Simple Query&lt;/title&gt;
</span><p>
<span class="original">
    A simple query cycle is initiated by the frontend sending a Query message
    to the backend.  The message includes an SQL command (or commands)
    expressed as a text string.
    The backend then sends one or more response
    messages depending on the contents of the query command string,
    and finally a ReadyForQuery response message.  ReadyForQuery
    informs the frontend that it can safely send a new command.
    (It is not actually necessary for the frontend to wait for
    ReadyForQuery before issuing another command, but the frontend must
    then take responsibility for figuring out what happens if the earlier
    command fails and already-issued later commands succeed.)
</span>
フロントエンドがQueryメッセージをバックエンドに送信することで、簡易問い合わせサイクルが開始されます。
このメッセージには、テキスト文字列で表現されたSQLコマンド（またはコマンド）が含まれます。
そうすると、バックエンドは、問い合わせコマンド文字列の内容に応じて1つ以上の応答を送信し、最終的にReadyForQueryを応答します。
ReadyForQueryは、新しいコマンドを安全に送信できることをフロントエンドに知らせます。
（実際には、フロントエンドが他のコマンドを発行する前にReadyForQueryを待機することは不要です。
しかし、フロントエンドは、前のコマンドが失敗し、発行済みの後のコマンドが成功した場合に何が起きるかを了解する責任を持たなければなりません。）
   </p><p>
<span class="original">
    The possible response messages from the backend are:
</span>
バックエンドから送信される可能性がある応答メッセージを以下に示します。

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">CommandComplete</span></dt><dd><p>
<span class="original">
        An SQL command completed normally.
</span>
SQLコマンドが正常に終了しました。
       </p></dd><dt><span class="term">CopyInResponse</span></dt><dd><p>
<span class="original">
        The backend is ready to copy data from the frontend to a
        table; see &lt;xref linkend="protocol-copy"/&gt;.
</span>
バックエンドがフロントエンドからのデータをテーブルにコピーする準備ができました。
<a class="xref" href="protocol-flow.html#PROTOCOL-COPY" title="55.2.6. COPY操作">55.2.6</a>を参照してください。
       </p></dd><dt><span class="term">CopyOutResponse</span></dt><dd><p>
<span class="original">
        The backend is ready to copy data from a table to the
        frontend; see &lt;xref linkend="protocol-copy"/&gt;.
</span>
バックエンドがデータをテーブルからフロントエンドにコピーする準備ができました。
<a class="xref" href="protocol-flow.html#PROTOCOL-COPY" title="55.2.6. COPY操作">55.2.6</a>を参照してください。
       </p></dd><dt><span class="term">RowDescription</span></dt><dd><p>
<span class="original">
        Indicates that rows are about to be returned in response to
        a &lt;command&gt;SELECT&lt;/command&gt;, &lt;command&gt;FETCH&lt;/command&gt;, etc. query.
        The contents of this message describe the column layout of the rows.
        This will be followed by a DataRow message for each row being returned
        to the frontend.
</span>
《マッチ度[85.512367]》<code class="command">SELECT</code>や<code class="command">FETCH</code>などの問い合わせの応答の行がまさに返されようとしていることを示します。
このメッセージには、行の列レイアウトに関する説明が含まれます。
このメッセージの後に、フロントエンドに返される各行に対するDataRowメッセージが続きます。
       </p></dd><dt><span class="term">DataRow</span></dt><dd><p>
<span class="original">
        One of the set of rows returned by
        a &lt;command&gt;SELECT&lt;/command&gt;, &lt;command&gt;FETCH&lt;/command&gt;, etc. query.
</span>
《マッチ度[83.168317]》<code class="command">SELECT</code>や<code class="command">FETCH</code>などの問い合わせで返される行の集合の1つです。
       </p></dd><dt><span class="term">EmptyQueryResponse</span></dt><dd><p>
<span class="original">
        An empty query string was recognized.
</span>
空の問い合わせ文字列が検知されました。
       </p></dd><dt><span class="term">ErrorResponse</span></dt><dd><p>
<span class="original">
        An error has occurred.
</span>
エラーが起こりました。
       </p></dd><dt><span class="term">ReadyForQuery</span></dt><dd><p>
<span class="original">
        Processing of the query string is complete.  A separate
        message is sent to indicate this because the query string might
        contain multiple SQL commands.  (CommandComplete marks the
        end of processing one SQL command, not the whole string.)
        ReadyForQuery will always be sent, whether processing
        terminates successfully or with an error.
</span>
問い合わせ文字列の処理が終了しました。
問い合わせ文字列は複数のSQLコマンドが含まれる場合があるため、このことを通知するために分離したメッセージが送出されます。
（CommandCompleteは文字列全体ではなく、1つのSQLコマンドの処理の終了を明らかにします。）
処理が成功またはエラーで終了したかどうかにかかわらずReadyForQueryは常に送出されます。
       </p></dd><dt><span class="term">NoticeResponse</span></dt><dd><p>
<span class="original">
        A warning message has been issued in relation to the query.
        Notices are in addition to other responses, i.e., the backend
        will continue processing the command.
</span>
問い合わせに関して警告メッセージが発行されました。
警告メッセージは他の応答に対する追加のメッセージです。
したがって、バックエンドはそのコマンドの処理を続行します。
       </p></dd></dl></div><p>
   </p><p>
<span class="original">
    The response to a &lt;command&gt;SELECT&lt;/command&gt; query (or other queries that
    return row sets, such as &lt;command&gt;EXPLAIN&lt;/command&gt; or &lt;command&gt;SHOW&lt;/command&gt;)
    normally consists of RowDescription, zero or more
    DataRow messages, and then CommandComplete.
    &lt;command&gt;COPY&lt;/command&gt; to or from the frontend invokes special protocol
    as described in &lt;xref linkend="protocol-copy"/&gt;.
    All other query types normally produce only
    a CommandComplete message.
</span>
<code class="command">SELECT</code>問い合わせ（あるいは、<code class="command">EXPLAIN</code>や<code class="command">SHOW</code>などの行集合を返す他の問い合わせ）に対する応答は、通常、RowDescription、0個以上のDataRowメッセージ、そしてその後のCommandCompleteから構成されます。
フロントエンドへの<code class="command">COPY</code>もしくはフロントエンドからの<code class="command">COPY</code>は<a class="xref" href="protocol-flow.html#PROTOCOL-COPY" title="55.2.6. COPY操作">55.2.6</a>で説明する特別なプロトコルを呼び出します。
他の種類の問い合わせは通常CommandCompleteメッセージのみを生成します。
   </p><p>
<span class="original">
    Since a query string could contain several queries (separated by
    semicolons), there might be several such response sequences before the
    backend finishes processing the query string.  ReadyForQuery is issued
    when the entire string has been processed and the backend is ready to
    accept a new query string.
</span>
問い合わせ文字列には（セミコロンで区切られた）複数の問い合わせが含まれることがありますので、バックエンドが問い合わせ文字列の処理を完了する前に、こうした応答シーケンスが複数発生する可能性があります。
ReadyForQueryは、文字列全体が処理され、バックエンドが新しい問い合わせ文字列を受け付ける準備が整った時点で発行されます。
   </p><p>
<span class="original">
    If a completely empty (no contents other than whitespace) query string
    is received, the response is EmptyQueryResponse followed by ReadyForQuery.
</span>
完全に空の（空白文字以外の文字がない）問い合わせ文字列を受け取った場合、その応答は、EmptyQueryResponse、続いて、ReadyForQueryとなります。
   </p><p>
<span class="original">
    In the event of an error, ErrorResponse is issued followed by
    ReadyForQuery.  All further processing of the query string is aborted by
    ErrorResponse (even if more queries remained in it).  Note that this
    might occur partway through the sequence of messages generated by an
    individual query.
</span>
エラーが発生した場合、ErrorResponse、続いて、ReadyForQueryが発行されます。
その問い合わせ文字列に対する以降の処理は（複数の問い合わせが残っていたとしても）すべて、ErrorResponseによって中断されます。
これは、個々の問い合わせで生成されるメッセージの並びの途中で発生する可能性があることに注意してください。
   </p><p>
<span class="original">
    In simple Query mode, the format of retrieved values is always text,
    except when the given command is a &lt;command&gt;FETCH&lt;/command&gt; from a cursor
    declared with the &lt;literal&gt;BINARY&lt;/literal&gt; option.  In that case, the
    retrieved values are in binary format.  The format codes given in
    the RowDescription message tell which format is being used.
</span>
簡易問い合わせモードでは、読み出される値の書式は常にテキストです。
ただし、与えられたコマンドが<code class="literal">BINARY</code>オプション付きで宣言されたカーソルからの<code class="command">FETCH</code>であった場合は例外です。
この場合は、読み出される値はバイナリ書式になります。
RowDescriptionメッセージ内で与えられる書式コードは、どの書式が使用されているかを通知します。
   </p><p>
<span class="original">
    A frontend must be prepared to accept ErrorResponse and
    NoticeResponse messages whenever it is expecting any other type of
    message.  See also &lt;xref linkend="protocol-async"/&gt; concerning messages
    that the backend might generate due to outside events.
</span>
他の種類のメッセージの受信を待機している時、フロントエンドは常にErrorResponseとNoticeResponseメッセージを受け取る準備ができていなければなりません。
また、外部イベントのためにバックエンドが生成する可能性があるメッセージの扱いについては<a class="xref" href="protocol-flow.html#PROTOCOL-ASYNC" title="55.2.7. 非同期操作">55.2.7</a>を参照してください。
   </p><p>
<span class="original">
    Recommended practice is to code frontends in a state-machine style
    that will accept any message type at any time that it could make sense,
    rather than wiring in assumptions about the exact sequence of messages.
</span>
メッセージの正しい並びを前提としてコーディングするのではなく、任意のメッセージ種類を、そのメッセージが意味を持つ任意の時点で受け付ける状態マシン形式でフロントエンドのコーディングを行うことを推奨します。
   </p><div class="sect3" id="PROTOCOL-FLOW-MULTI-STATEMENT"><div class="titlepage"><div><div><h4 class="title">55.2.2.1. 簡易問い合わせでの複文</h4></div></div></div><span class="original">
    &lt;title&gt;Multiple Statements in a Simple Query&lt;/title&gt;
</span><p>
<span class="original">
     When a simple Query message contains more than one SQL statement
     (separated by semicolons), those statements are executed as a single
     transaction, unless explicit transaction control commands are included
     to force a different behavior.  For example, if the message contains
</span>
簡易Queryメッセージが二つ以上の（セミコロンで区切られた）SQL文を含むとき、振る舞いを変えるように明示的なトランザクション制御コマンドが含まれていない限り、これらの文は単一トランザクションで実行されます。
例えばメッセージが以下を含む場合、
</p><pre class="programlisting">
INSERT INTO mytable VALUES(1);
SELECT 1/0;
INSERT INTO mytable VALUES(2);
</pre><p>
<span class="original">
     then the divide-by-zero failure in the &lt;command&gt;SELECT&lt;/command&gt; will force
     rollback of the first &lt;command&gt;INSERT&lt;/command&gt;.  Furthermore, because
     execution of the message is abandoned at the first error, the second
     &lt;command&gt;INSERT&lt;/command&gt; is never attempted at all.
</span>
<code class="command">SELECT</code>でのゼロ除算エラーは最初の<code class="command">INSERT</code>のロールバックを強制します。
さらに、メッセージの実行が最初のエラー時点で中止されるので、二番目の<code class="command">INSERT</code>は全く試みられません。
    </p><p>
<span class="original">
     If instead the message contains
</span>
代わりにメッセージが以下を含んでいる場合、
</p><pre class="programlisting">
BEGIN;
INSERT INTO mytable VALUES(1);
COMMIT;
INSERT INTO mytable VALUES(2);
SELECT 1/0;
</pre><p>
<span class="original">
     then the first &lt;command&gt;INSERT&lt;/command&gt; is committed by the
     explicit &lt;command&gt;COMMIT&lt;/command&gt; command.  The second &lt;command&gt;INSERT&lt;/command&gt;
     and the &lt;command&gt;SELECT&lt;/command&gt; are still treated as a single transaction,
     so that the divide-by-zero failure will roll back the
     second &lt;command&gt;INSERT&lt;/command&gt;, but not the first one.
</span>
最初の<code class="command">INSERT</code>は明示的な<code class="command">COMMIT</code>コマンドによりコミットされます。
二番目の<code class="command">INSERT</code>と<code class="command">SELECT</code>は、やはり単一トランザクションとして処理されます。
そのためゼロ除算エラーが二番目の<code class="command">INSERT</code>をロールバックしますが、最初の<code class="command">INSERT</code>はロールバックされません。
    </p><p>
<span class="original">
     This behavior is implemented by running the statements in a
     multi-statement Query message in an &lt;firstterm&gt;implicit transaction
     block&lt;/firstterm&gt; unless there is some explicit transaction block for them to
     run in.  The main difference between an implicit transaction block and
     a regular one is that an implicit block is closed automatically at the
     end of the Query message, either by an implicit commit if there was no
     error, or an implicit rollback if there was an error.  This is similar
     to the implicit commit or rollback that happens for a statement
     executed by itself (when not in a transaction block).
</span>
この振る舞いは、<em class="firstterm">暗黙トランザクションブロック</em>で複文Queryメッセージ内の文を実行することで、その中に明示的なトランザクションブロックがある場合を除き、発現します。
暗黙トランザクションブロックと通常のトラザクションブロックとの主な違いは、暗黙ブロックは自動的にQueryメッセージの最後にて、エラーが無いなら暗黙のコミット、エラーがあるなら暗黙のロールバックで、自動的に閉じられることです。
これは（トランザクションブロック内に無いときの）文の単体実行に対して生じる暗黙のコミットあるいはロールバックに似ています。
    </p><p>
<span class="original">
     If the session is already in a transaction block, as a result of
     a &lt;command&gt;BEGIN&lt;/command&gt; in some previous message, then the Query message
     simply continues that transaction block, whether the message contains
     one statement or several.  However, if the Query message contains
     a &lt;command&gt;COMMIT&lt;/command&gt; or &lt;command&gt;ROLLBACK&lt;/command&gt; closing the existing
     transaction block, then any following statements are executed in an
     implicit transaction block.
     Conversely, if a &lt;command&gt;BEGIN&lt;/command&gt; appears in a multi-statement Query
     message, then it starts a regular transaction block that will only be
     terminated by an explicit &lt;command&gt;COMMIT&lt;/command&gt; or &lt;command&gt;ROLLBACK&lt;/command&gt;,
     whether that appears in this Query message or a later one.
     If the &lt;command&gt;BEGIN&lt;/command&gt; follows some statements that were executed as
     an implicit transaction block, those statements are not immediately
     committed; in effect, they are retroactively included into the new
     regular transaction block.
</span>
何らか手前のメッセージでの<code class="command">BEGIN</code>の結果として、セッションが既にトランザクションブロック内である場合、Queryメッセージは、含まれるのが単一文でもいくつかの文でも、単にそのトランザクションを継続します。
しかしながら、Queryメッセージが既存トランザクションブロックを閉じる<code class="command">COMMIT</code>や<code class="command">ROLLBACK</code>を含む場合、続く全ての文は暗黙トランザクションブロックで実行されます。
逆に言えば、複文Queryメッセージで<code class="command">BEGIN</code>が現れたなら、このQueryメッセージ内または後のメッセージのいずれかにあらわれる明示的な<code class="command">COMMIT</code>や<code class="command">ROLLBACK</code>でのみ終了する、通常のトランザクションブロックが開始されます。
<code class="command">BEGIN</code>が暗黙トランザクションブロックとして実行されたいくつかの文に続く場合、これらの文が直ちにコミットされることはありません。
結果として、これらは遡って新たな通常のトランザクションブロックに含められます。
    </p><p>
<span class="original">
     A &lt;command&gt;COMMIT&lt;/command&gt; or &lt;command&gt;ROLLBACK&lt;/command&gt; appearing in an implicit
     transaction block is executed as normal, closing the implicit block;
     however, a warning will be issued since a &lt;command&gt;COMMIT&lt;/command&gt;
     or &lt;command&gt;ROLLBACK&lt;/command&gt; without a previous &lt;command&gt;BEGIN&lt;/command&gt; might
     represent a mistake.  If more statements follow, a new implicit
     transaction block will be started for them.
</span>
暗黙トランザクションブロック内に現れた<code class="command">COMMIT</code>や<code class="command">ROLLBACK</code>は通常通り実行され、暗黙ブロックを閉じますが、手前の<code class="command">BEGIN</code>無しの<code class="command">COMMIT</code>や<code class="command">ROLLBACK</code>は誤りであるかもしれないので警告が発行されます。
さらに文が続く場合、それらに対して新たな暗黙トランザクションブロックが開始されます。
    </p><p>
<span class="original">
     Savepoints are not allowed in an implicit transaction block, since
     they would conflict with the behavior of automatically closing the
     block upon any error.
</span>
エラー時の自動ブロッククローズの振る舞いと競合するので暗黙トランザクションブロックでセーブポイントは使えません。
    </p><p>
<span class="original">
     Remember that, regardless of any transaction control commands that may
     be present, execution of the Query message stops at the first error.
     Thus for example given
</span>
現状のいかなるトランザクション制御コマンドでも、Queryメッセージの実行は最初のエラー時点で打ち切られることに留意してください。
例を示します。
</p><pre class="programlisting">
BEGIN;
SELECT 1/0;
ROLLBACK;
</pre><p>
<span class="original">
     in a single Query message, the session will be left inside a failed
     regular transaction block, since the &lt;command&gt;ROLLBACK&lt;/command&gt; is not
     reached after the divide-by-zero error.  Another &lt;command&gt;ROLLBACK&lt;/command&gt;
     will be needed to restore the session to a usable state.
</span>
上記が単一Queryメッセージにあるとして、ゼロ除算エラーの後に<code class="command">ROLLBACK</code>に達することがないため、このセッションは失敗した通常のトランザクション内のままとなります。
このセッションを通常の状態に回復させるには別の<code class="command">ROLLBACK</code>が必要となります。
    </p><p>
<span class="original">
     Another behavior of note is that initial lexical and syntactic
     analysis is done on the entire query string before any of it is
     executed.  Thus simple errors (such as a misspelled keyword) in later
     statements can prevent execution of any of the statements.  This
     is normally invisible to users since the statements would all roll
     back anyway when done as an implicit transaction block.  However,
     it can be visible when attempting to do multiple transactions within a
     multi-statement Query.  For instance, if a typo turned our previous
     example into
</span>
その他の注意すべき振る舞いは、初期の字句および構文解析が少しも実行されない段階で問い合わせ文字列全体に対して行われることです。
従って、後ろの分にある（スペルミスしたキーワードなどの）単純なエラーは全ての文の実行を妨げることがあります。
暗黙トランザクションブロックとして起きたとき、いずれにせよ全ての文はロールバックされるので、これは通常はユーザに見えません。
しかしながら、複文問い合わせの中で複数のトランザクションを実行しようとするとき、この挙動が明らかになることがあります。
例えば、タイプミスで先の例を以下のようにします。
</p><pre class="programlisting">
BEGIN;
INSERT INTO mytable VALUES(1);
COMMIT;
INSERT INTO mytable VALUES(2);
SELCT 1/0;<span class="original"> this typo is intentional </span>
</pre><p>
<span class="original">
     then none of the statements would get run, resulting in the visible
     difference that the first &lt;command&gt;INSERT&lt;/command&gt; is not committed.
     Errors detected at semantic analysis or later, such as a misspelled
     table or column name, do not have this effect.
</span>
そうすると、含まれる文は一つも実行されず、最初の<code class="command">INSERT</code>がコミットされないという違いが明らかになります。
エラーは、ミススペルしたテーブルやカラム名など、語彙の解析かその後に検出され、コマンドの効力はありません。
    </p></div></div><div class="sect2" id="PROTOCOL-FLOW-EXT-QUERY"><div class="titlepage"><div><div><h3 class="title">55.2.3. 拡張問い合わせ</h3></div></div></div><span class="original">
   &lt;title&gt;Extended Query&lt;/title&gt;
</span><p>
<span class="original">
    The extended query protocol breaks down the above-described simple
    query protocol into multiple steps.  The results of preparatory
    steps can be re-used multiple times for improved efficiency.
    Furthermore, additional features are available, such as the possibility
    of supplying data values as separate parameters instead of having to
    insert them directly into a query string.
</span>
拡張問い合わせプロトコルは、上述の簡易問い合わせプロトコルを複数段階に分解します。
予備段階の結果は複数回再利用できますので、効率が上がります。
さらに、問い合わせ文字列に直接埋め込むのではなく、データ値をパラメータとして分離して提供できる機能など、利用できる追加機能があります。
   </p><p>
<span class="original">
    In the extended protocol, the frontend first sends a Parse message,
    which contains a textual query string, optionally some information
    about data types of parameter placeholders, and the
    name of a destination prepared-statement object (an empty string
    selects the unnamed prepared statement).  The response is
    either ParseComplete or ErrorResponse.  Parameter data types can be
    specified by OID; if not given, the parser attempts to infer the
    data types in the same way as it would do for untyped literal string
    constants.
</span>
拡張プロトコルでは、フロントエンドはまず、テキストの問い合わせ文字列とオプションとしてパラメータプレースホルダのデータ型情報やプリペアド文のオブジェクトの宛先名（空文字列は無名のプリペアド文を選択）を含む、Parseメッセージを送信します。
この応答はParseCompleteまたはErrorResponseです。
パラメータデータ型はそのOIDで指定することができます。
指定がなければ、パーサは型指定のないリテラル文字列定数に対する方法と同じ方法でデータ型を推定します。
   </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
     A parameter data type can be left unspecified by setting it to zero,
     or by making the array of parameter type OIDs shorter than the
     number of parameter symbols (&lt;literal&gt;$&lt;/literal&gt;&lt;replaceable&gt;n&lt;/replaceable&gt;)
     used in the query string.  Another special case is that a parameter's
     type can be specified as &lt;type&gt;void&lt;/type&gt; (that is, the OID of the
     &lt;type&gt;void&lt;/type&gt; pseudo-type).  This is meant to allow parameter symbols
     to be used for function parameters that are actually OUT parameters.
     Ordinarily there is no context in which a &lt;type&gt;void&lt;/type&gt; parameter
     could be used, but if such a parameter symbol appears in a function's
     parameter list, it is effectively ignored.  For example, a function
     call such as &lt;literal&gt;foo($1,$2,$3,$4)&lt;/literal&gt; could match a function with
     two IN and two OUT arguments, if &lt;literal&gt;$3&lt;/literal&gt; and &lt;literal&gt;$4&lt;/literal&gt;
     are specified as having type &lt;type&gt;void&lt;/type&gt;.
</span>
パラメータデータ型をゼロと設定する、または、問い合わせ文字列内で使用されているパラメータ記号（<code class="literal">$</code><em class="replaceable"><code>n</code></em>）の数より短くパラメータ型のOIDの配列を作成することで、指定しないまま残すことができます。
他にも、パラメータの型を<code class="type">void</code>（つまり<code class="type">void</code>仮想型のOID）と指定するという特別な場合があります。
これは、パラメータ記号を、実際のOUTパラメータである関数パラメータとして使用することができることを意味します。
通常では、<code class="type">void</code>パラメータが使用される文脈はありませんが、関数パラメータリストにこうしたパラメータ記号があると、実質的には無視されます。
例えば、<code class="literal">$3</code>と<code class="literal">$4</code>が<code class="type">void</code>型を持つと指定された場合、<code class="literal">foo($1,$2,$3,$4)</code>といった関数呼び出しは、2つのINと2つのOUT引数を持つ関数に一致します。
    </p></div><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
     The query string contained in a Parse message cannot include more
     than one SQL statement; else a syntax error is reported.  This
     restriction does not exist in the simple-query protocol, but it
     does exist in the extended protocol, because allowing prepared
     statements or portals to contain multiple commands would complicate
     the protocol unduly.
</span>
Parseメッセージ内の問い合わせ文字列には、複数のSQL文を含めることはできません。
さもないと、構文エラーが報告されます。
この制限は簡易問い合わせプロトコルにはありませんが、複数のコマンドを持つプリペアド文やポータルを許すと、プロトコルが複雑になり過ぎるため、拡張プロトコルではこの制限があります。
    </p></div><p>
<span class="original">
    If successfully created, a named prepared-statement object lasts till
    the end of the current session, unless explicitly destroyed.  An unnamed
    prepared statement lasts only until the next Parse statement specifying
    the unnamed statement as destination is issued.  (Note that a simple
    Query message also destroys the unnamed statement.)  Named prepared
    statements must be explicitly closed before they can be redefined by
    another Parse message, but this is not required for the unnamed statement.
    Named prepared statements can also be created and accessed at the SQL
    command level, using &lt;command&gt;PREPARE&lt;/command&gt; and &lt;command&gt;EXECUTE&lt;/command&gt;.
</span>
作成に成功すると、名前付きプリペアド文オブジェクトは明示的に破棄されない限り現在のセッションが終わるまで残ります。
無名のプリペアド文オブジェクトは、次に無名のプリペアド文を宛先に指定したParse文が発行されるまでの間のみに残ります。
（単なるQueryメッセージでも無名のプリペアド文オブジェクトは破壊されることに注意してください。）
名前付きプリペアド文は、他のParseメッセージで再定義する前に明示的に閉じなければなりません。
しかし、これは無名のプリペアド文では必要ありません。
名前付きプリペアド文はまた、SQLコマンドレベルで<code class="command">PREPARE</code>と<code class="command">EXECUTE</code>を使用して作成しアクセスすることができます。
   </p><p>
<span class="original">
    Once a prepared statement exists, it can be readied for execution using a
    Bind message.  The Bind message gives the name of the source prepared
    statement (empty string denotes the unnamed prepared statement), the name
    of the destination portal (empty string denotes the unnamed portal), and
    the values to use for any parameter placeholders present in the prepared
    statement.  The
    supplied parameter set must match those needed by the prepared statement.
    (If you declared any &lt;type&gt;void&lt;/type&gt; parameters in the Parse message,
    pass NULL values for them in the Bind message.)
    Bind also specifies the format to use for any data returned
    by the query; the format can be specified overall, or per-column.
    The response is either BindComplete or ErrorResponse.
</span>
プリペアド文が存在すると、Bindメッセージを使用してそれを実行可能状態にすることができます。
Bindメッセージは、元となるプリペアド文（空文字列は無名のプリペアド文を表します）の名前、宛先となるポータル（空文字列は無名ポータルを表します）の名前、およびプリペアド文内のパラメータプレースホルダに使用する値を与えます。
与えられたパラメータ集合はプリペアド文で必要とするものと一致しなければなりません。
（Parseメッセージ内で<code class="type">void</code>パラメータを1つでも宣言した場合、BindメッセージではそれらにはNULLを渡します。）
また、Bindは問い合わせで返されるデータに使用する書式を指定します。
書式は全体に対して指定することも、列単位で指定することも可能です。
応答はBindCompleteもしくはErrorResponseです。
   </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
     The choice between text and binary output is determined by the format
     codes given in Bind, regardless of the SQL command involved.  The
     &lt;literal&gt;BINARY&lt;/literal&gt; attribute in cursor declarations is irrelevant when
     using extended query protocol.
</span>
テキスト出力とバイナリ出力との選択は、含まれるSQLコマンドに関係なく、Bindで与えられた書式コードで決定されます。
拡張問い合わせプロトコルを使用する場合、カーソル宣言の<code class="literal">BINARY</code>属性は役に立ちません。
    </p></div><p>
<span class="original">
    Query planning typically occurs when the Bind message is processed.
    If the prepared statement has no parameters, or is executed repeatedly,
    the server might save the created plan and re-use it during subsequent
    Bind messages for the same prepared statement.  However, it will do so
    only if it finds that a generic plan can be created that is not much
    less efficient than a plan that depends on the specific parameter values
    supplied.  This happens transparently so far as the protocol is concerned.
</span>
典型的に問い合わせ計画はBindメッセージが処理される時に作成されます。
プリペアド文がパラメータを持たない場合、または繰り返し実行される場合、サーバは作成した計画を保管し、その後の同じプリペアド文に対するBindメッセージの際に再利用する可能性があります。
しかし、作成できる汎用的な計画が提供された特定のパラメータ値に依存する計画より効率が大して劣化しないことが分かった場合のみ、このように動作します。
プロトコルに注目している限り、これは透過的に行われます。
   </p><p>
<span class="original">
    If successfully created, a named portal object lasts till the end of the
    current transaction, unless explicitly destroyed.  An unnamed portal is
    destroyed at the end of the transaction, or as soon as the next Bind
    statement specifying the unnamed portal as destination is issued.  (Note
    that a simple Query message also destroys the unnamed portal.)  Named
    portals must be explicitly closed before they can be redefined by another
    Bind message, but this is not required for the unnamed portal.
    Named portals can also be created and accessed at the SQL
    command level, using &lt;command&gt;DECLARE CURSOR&lt;/command&gt; and &lt;command&gt;FETCH&lt;/command&gt;.
</span>
作成に成功すると、名前付きポータルオブジェクトは明示的に破棄されない限り現在のセッションが終わるまで残ります。
無名ポータルは、トランザクションの終わり、もしくは、次に無名ポータルを宛先に指定したBind文が発行されるまでの間のみに残ります。
（単なるQueryメッセージでも無名ポータルは破壊されることに注意してください。）
名前付きポータルは、他のBindメッセージで再定義する前に明示的に閉じなければなりません。
しかし、これは無名ポータルでは必要ありません。
名前付きポータルはまた、SQLコマンドレベルで<code class="command">DECLARE CURSOR</code>と<code class="command">FETCH</code>を使用して作成しアクセスすることができます。
   </p><p>
<span class="original">
    Once a portal exists, it can be executed using an Execute message.
    The Execute message specifies the portal name (empty string denotes the
    unnamed portal) and
    a maximum result-row count (zero meaning &lt;quote&gt;fetch all rows&lt;/quote&gt;).
    The result-row count is only meaningful for portals
    containing commands that return row sets; in other cases the command is
    always executed to completion, and the row count is ignored.
    The possible
    responses to Execute are the same as those described above for queries
    issued via simple query protocol, except that Execute doesn't cause
    ReadyForQuery or RowDescription to be issued.
</span>
ポータルが存在すると、Executeメッセージを使用してそれを実行することができます。
Executeメッセージは、ポータル名（空文字列は無名ポータルを表します）と結果行数の最大値（ゼロは<span class="quote">「<span class="quote">fetch all rows</span>」</span>を意味します）を指定します。
結果行数は、ポータルが行集合を返すコマンドを含む場合のみ意味があります。
その他の場合では、コマンドは常に終わりまで実行され、行数は無視されます。
Executeで起こり得る応答は、ExecuteではReadyForQueryやRowDescriptionが発行されない点を除き、上述の簡易問い合わせプロトコル経由で発行された問い合わせの場合と同じです。
   </p><p>
<span class="original">
    If Execute terminates before completing the execution of a portal
    (due to reaching a nonzero result-row count), it will send a
    PortalSuspended message; the appearance of this message tells the frontend
    that another Execute should be issued against the same portal to
    complete the operation.  The CommandComplete message indicating
    completion of the source SQL command is not sent until
    the portal's execution is completed.  Therefore, an Execute phase is
    always terminated by the appearance of exactly one of these messages:
    CommandComplete, EmptyQueryResponse (if the portal was created from
    an empty query string), ErrorResponse, or PortalSuspended.
</span>
Executeがポータルの実行を完了する前に（非ゼロの結果行数に達したために）終了した場合、PortalSuspendedを送信します。
このメッセージの出現は、フロントエンドに操作を完了させるためには同一のポータルに対して、別のExecuteを発行しなければならないことを通知します。
元となったSQLコマンドが完了したことを示すCommandCompleteメッセージはポータルが完了するまで送信されません。
したがって、Execute段階は常にCommandComplete、EmptyQueryResponse（空の問い合わせ文字列からポータルが作成された場合）、ErrorResponse、またはPortalSuspendedの中の、正確にどれかが出現することによって常に終了します。
   </p><p>
<span class="original">
    At completion of each series of extended-query messages, the frontend
    should issue a Sync message.  This parameterless message causes the
    backend to close the current transaction if it's not inside a
    &lt;command&gt;BEGIN&lt;/command&gt;/&lt;command&gt;COMMIT&lt;/command&gt; transaction block (&lt;quote&gt;close&lt;/quote&gt;
    meaning to commit if no error, or roll back if error).  Then a
    ReadyForQuery response is issued.  The purpose of Sync is to provide
    a resynchronization point for error recovery.  When an error is detected
    while processing any extended-query message, the backend issues
    ErrorResponse, then reads and discards messages until a Sync is reached,
    then issues ReadyForQuery and returns to normal message processing.
    (But note that no skipping occurs if an error is detected
    &lt;emphasis&gt;while&lt;/emphasis&gt; processing Sync &amp;mdash; this ensures that there is one
    and only one ReadyForQuery sent for each Sync.)
</span>
拡張問い合わせメッセージの一連の流れのそれぞれの終了時、フロントエンドはSyncメッセージを発行しなければなりません。
このパラメータのないメッセージにより、もし<code class="command">BEGIN</code>/<code class="command">COMMIT</code>トランザクションブロックの内部でなければ、バックエンドは現在のトランザクションを閉ざします
（<span class="quote">「<span class="quote">閉ざす</span>」</span>とは、エラーがなければコミット、エラーがあればロールバックすることを意味します）。
そして、ReadyForQuery応答が発行されます。
Syncの目的は、エラーからの復旧用の再同期を行う時点を提供することです。
拡張問い合わせメッセージの処理中にエラーが検出されると、バックエンドはErrorResponseを発行し、Syncが届くまでメッセージを読み、それを破棄します。
その後、ReadyForQueryを発行し、通常のメッセージ処理に戻ります。
（しかし、Sync処理<span class="emphasis"><em>中に</em></span>エラーが検出された場合に処理が飛ばされないことに注意してください。
これにより、各Syncに対してReadyForQueryが1つのみであることを保証します。）
   </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
     Sync does not cause a transaction block opened with &lt;command&gt;BEGIN&lt;/command&gt;
     to be closed.  It is possible to detect this situation since the
     ReadyForQuery message includes transaction status information.
</span>
Syncによって、<code class="command">BEGIN</code>で開かれたトランザクションブロックが閉ざされることはありません。
ReadyForQueryメッセージにはトランザクションの状態情報が含まれていますので、この状況を検出することができます。
    </p></div><p>
<span class="original">
    In addition to these fundamental, required operations, there are several
    optional operations that can be used with extended-query protocol.
</span>
これらの基本的な必要操作に加え、拡張問い合わせプロトコルで使用することができる、複数の省略可能な操作があります。
   </p><p>
<span class="original">
    The Describe message (portal variant) specifies the name of an existing
    portal (or an empty string for the unnamed portal).  The response is a
    RowDescription message describing the rows that will be returned by
    executing the portal; or a NoData message if the portal does not contain a
    query that will return rows; or ErrorResponse if there is no such portal.
</span>
Describeメッセージ（ポータルの亜種）は、既存のポータルの名前（もしくは、無名ポータル用の空文字）を指定します。
応答は、実行中のポータルで返される予定の行を記述するRowDescriptionメッセージです。
ポータルが行を返す問い合わせを含まない場合はNoDataメッセージです。
指定したポータルが存在しない場合はErrorResponseです。
   </p><p>
<span class="original">
    The Describe message (statement variant) specifies the name of an existing
    prepared statement (or an empty string for the unnamed prepared
    statement).  The response is a ParameterDescription message describing the
    parameters needed by the statement, followed by a RowDescription message
    describing the rows that will be returned when the statement is eventually
    executed (or a NoData message if the statement will not return rows).
    ErrorResponse is issued if there is no such prepared statement.  Note that
    since Bind has not yet been issued, the formats to be used for returned
    columns are not yet known to the backend; the format code fields in the
    RowDescription message will be zeroes in this case.
</span>
Describeメッセージ（ステートメントの亜種）は、既存のプリペアド文の名前（もしくは無名のプリペアド文用の空文字）を指定します。
応答は、文で必要とされるパラメータを記述するParameterDescriptionメッセージ、続いて、文が実行された場合に返される予定の行を記述するRowDescriptionメッセージ（もしくは文が行を返さない場合のNoDataメッセージ）です。
指定したプリペアド文が存在しない場合はErrorResponseが発行されます。
Bindがまだ発行されていませんので、返される列の書式はまだバックエンドでは不明であることに注意してください。
RowDescriptionメッセージ内の書式コードフィールドはこの場合はゼロになります。
   </p><div class="tip"><h3 class="title">ヒント</h3><p>
<span class="original">
     In most scenarios the frontend should issue one or the other variant
     of Describe before issuing Execute, to ensure that it knows how to
     interpret the results it will get back.
</span>
ほとんどの状況では、フロントエンドはExecuteを発行する前に、返ってくる結果を解釈する方法を確実に判断できるように、Describeもしくはその亜種を実行すべきです。
    </p></div><p>
<span class="original">
    The Close message closes an existing prepared statement or portal
    and releases resources.  It is not an error to issue Close against
    a nonexistent statement or portal name.  The response is normally
    CloseComplete, but could be ErrorResponse if some difficulty is
    encountered while releasing resources.  Note that closing a prepared
    statement implicitly closes any open portals that were constructed
    from that statement.
</span>
Closeメッセージは、既存のプリペアド文、もしくはポータルを閉ざし、リソースを解放します。
存在しない文やポータルに対してCloseを発行してもエラーになりません。
応答は通常CloseCompleteですが、リソースの解放に何らかの問題が発生した場合はErrorResponseになります。
プリペアド文を閉じると、そこから構築され、開いたポータルが暗黙的に閉ざされることに注意してください。
   </p><p>
<span class="original">
    The Flush message does not cause any specific output to be generated,
    but forces the backend to deliver any data pending in its output
    buffers.  A Flush must be sent after any extended-query command except
    Sync, if the frontend wishes to examine the results of that command before
    issuing more commands.  Without Flush, messages returned by the backend
    will be combined into the minimum possible number of packets to minimize
    network overhead.
</span>
Flushメッセージにより特定の出力が生成されることはありません。
しかし、バックエンドに対して、出力バッファ内で待機しているデータを強制的に配送させます。
フロントエンドが他のコマンドを発行する前にコマンドの結果を検証したい場合に、FlushはSync以外の拡張問い合わせコマンドの後に送信される必要があります。
Flushを行わないと、バックエンドで返されるメッセージは、ネットワークオーバーヘッドを最小化する、最小限のパケット数にまとめられます。
   </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
     The simple Query message is approximately equivalent to the series Parse,
     Bind, portal Describe, Execute, Close, Sync, using the unnamed prepared
     statement and portal objects and no parameters.  One difference is that
     it will accept multiple SQL statements in the query string, automatically
     performing the bind/describe/execute sequence for each one in succession.
     Another difference is that it will not return ParseComplete, BindComplete,
     CloseComplete, or NoData messages.
</span>
簡易問い合わせメッセージは、おおよそ、無名のプリペアド文とポータルオブジェクトを使用したパラメータなしのParse、Bind、ポータル用Describe、Execute、Close、Syncの流れと同一です。
違いは、問い合わせ文字列内に複数のSQL文を受け付けられ、bind/describe/executeという流れがそれぞれが成功すれば自動的に行われる点です。
他の違いとして、ParseCompleteやBindComplete、CloseComplete、NoDataメッセージが返されない点があります。
    </p></div></div><div class="sect2" id="PROTOCOL-FLOW-PIPELINING"><div class="titlepage"><div><div><h3 class="title">55.2.4. パイプライン化</h3></div></div></div><span class="original">
   &lt;title&gt;Pipelining&lt;/title&gt;
</span><a id="id-1.10.6.8.6.2" class="indexterm"></a><a id="id-1.10.6.8.6.3" class="indexterm"></a><p>
<span class="original">
    Use of the extended query protocol
    allows &lt;firstterm&gt;pipelining&lt;/firstterm&gt;, which means sending a series
    of queries without waiting for earlier ones to complete.  This reduces
    the number of network round trips needed to complete a given series of
    operations.  However, the user must carefully consider the required
    behavior if one of the steps fails, since later queries will already
    be in flight to the server.
</span>
拡張問い合わせプロトコルの利用により、<em class="firstterm">パイプライン化(pipelining)</em>が可能となります。
これは、先に送った問い合わせの完了を待つことなく一連の問い合わせを送るということです。
これにより、指定された操作を完了するためのネットワークのやり取りの回数が減ります。
しかし、ある段階が失敗した時に必要とされる振る舞いを、ユーザは注意深く検討しなければなりません。
それ以降の問い合わせはすでにサーバに送信中だからです。
   </p><p>
<span class="original">
    One way to deal with that is to make the whole query series be a
    single transaction, that is wrap it in &lt;command&gt;BEGIN&lt;/command&gt; ...
    &lt;command&gt;COMMIT&lt;/command&gt;.  However, this does not help if one wishes
    for some of the commands to commit independently of others.
</span>
これに対処するための一つの方法は、一連の問い合わせ全体を単一のトランザクションにすることです。
すなわち、<code class="command">BEGIN</code> ... <code class="command">COMMIT</code>で囲みます。
しかし、あるコマンドを他のコマンドとは独立してコミットしたい時にはこの方法は役に立ちません。
   </p><p>
<span class="original">
    The extended query protocol provides another way to manage this
    concern, which is to omit sending Sync messages between steps that
    are dependent.  Since, after an error, the backend will skip command
    messages until it finds Sync, this allows later commands in a pipeline
    to be skipped automatically when an earlier one fails, without the
    client having to manage that explicitly with &lt;command&gt;BEGIN&lt;/command&gt;
    and &lt;command&gt;COMMIT&lt;/command&gt;.  Independently-committable segments
    of the pipeline can be separated by Sync messages.
</span>
拡張問い合わせプロトコルは、この問題に対応する別の方法を提供しています。
これは、お互いに依存するステップの間ではSyncメッセージを送るのを省略するというものです。
エラーが起こると、バックエンドはがyncが見つかるまでコマンドメッセージをスキップすることにより、それよりも前のコマンドが失敗した時に、クライアントが明示的に<code class="command">BEGIN</code>と<code class="command">COMMIT</code>で管理することなく、パイプラインの中の後続のコマンドが自動的にスキップされるからです。
パイプラインの中の独立してコミットできる部分は、Syncメッセージで分けておくことができます。
   </p><p>
<span class="original">
    If the client has not issued an explicit &lt;command&gt;BEGIN&lt;/command&gt;,
    then each Sync ordinarily causes an implicit &lt;command&gt;COMMIT&lt;/command&gt;
    if the preceding step(s) succeeded, or an
    implicit &lt;command&gt;ROLLBACK&lt;/command&gt; if they failed.  However, there
    are a few DDL commands (such as &lt;command&gt;CREATE DATABASE&lt;/command&gt;)
    that cannot be executed inside a transaction block.  If one of
    these is executed in a pipeline, it will, upon success, force an
    immediate commit to preserve database consistency.
    A Sync immediately following one of these has no effect except to
    respond with ReadyForQuery.
</span>
クライアントが明示的な<code class="command">BEGIN</code>を発行しないと、先行のステップが成功した場合は各々のSyncは通常暗黙的な<code class="command">COMMIT</code>、失敗した場合には暗黙的な<code class="command">ROLLBACK</code>をもたらします。
しかし、トランザクションブロックの内側で実行できない少数のDDLコマンド（<code class="command">CREATE DATABASE</code>のような）があります。
そうしたコマンドがパイプラインの中で実行されると、成功した場合にはデータベースの一貫性を保つために強制的に直後にコミットが実行されます。
こうしたコマンドの直後のSyncは、ReadyForQueryで応答することを除き、何の効果もありません。
   </p><p>
<span class="original">
    When using this method, completion of the pipeline must be determined
    by counting ReadyForQuery messages and waiting for that to reach the
    number of Syncs sent.  Counting command completion responses is
    unreliable, since some of the commands may not be executed and thus not
    produce a completion message.
</span>
この方法を使うときには、パイプラインの終了は、ReadyForQueryメッセージの数が送信したSyncメッセージの数と一致することで決定しなければなりません。
コマンドのうちいくつかは実行されないかも知れず、その場合は完了メッセージを生成しないので、コマンド完了メッセージを数えるのは信頼性に欠けます。
   </p></div><div class="sect2" id="id-1.10.6.8.7"><div class="titlepage"><div><div><h3 class="title">55.2.5. 関数呼び出し</h3></div></div></div><span class="original">
   &lt;title&gt;Function Call&lt;/title&gt;
</span><p>
<span class="original">
    The Function Call sub-protocol allows the client to request a direct
    call of any function that exists in the database's
    &lt;structname&gt;pg_proc&lt;/structname&gt; system catalog.  The client must have
    execute permission for the function.
</span>
関数呼び出しサブプロトコルにより、クライアントはデータベースの<code class="structname">pg_proc</code>システムカタログに存在する任意の関数を直接呼び出す要求を行うことができます。
クライアントはその関数を実行する権限を持たなければなりません。
   </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
     The Function Call sub-protocol is a legacy feature that is probably best
     avoided in new code.  Similar results can be accomplished by setting up
     a prepared statement that does &lt;literal&gt;SELECT function($1, ...)&lt;/literal&gt;.
     The Function Call cycle can then be replaced with Bind/Execute.
</span>
関数呼び出しサブプロトコルは、おそらく新しく作成するコードでは使用すべきではない古い機能です。
同様の結果は、<code class="literal">SELECT function($1, ...)</code>を行うプリペアド文を設定することで得ることができます。
そして、この関数呼び出しサイクルをBind/Executeで置き換えることができます。
    </p></div><p>
<span class="original">
    A Function Call cycle is initiated by the frontend sending a
    FunctionCall message to the backend.  The backend then sends one
    or more response messages depending on the results of the function
    call, and finally a ReadyForQuery response message.  ReadyForQuery
    informs the frontend that it can safely send a new query or
    function call.
</span>
関数呼び出しサイクルはフロントエンドがFunctionCallメッセージをバックエンドに送ることで起動されます。
バックエンドは1つまたは複数の応答メッセージを関数呼び出しの結果に基づいて送り、最終的にReadyForQueryメッセージを送出します。
ReadyForQueryはフロントエンドに対し新規の問い合わせまたは関数呼び出しを行っても安全確実であることを通知します。
   </p><p>
<span class="original">
    The possible response messages from the backend are:
</span>
バックエンドから送信される可能性がある応答メッセージを以下に示します。

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">ErrorResponse</span></dt><dd><p>
<span class="original">
        An error has occurred.
</span>
エラーが起こりました。
       </p></dd><dt><span class="term">FunctionCallResponse</span></dt><dd><p>
<span class="original">
        The function call was completed and returned the result given
        in the message.
        (Note that the Function Call protocol can only handle a single
        scalar result, not a row type or set of results.)
</span>
関数呼び出しが完了し、メッセージで与えられた結果が返されました。
（関数呼び出しプロトコルは単一のスカラ結果のみを扱うことができます。行型や結果集合を扱うことはできません。）
       </p></dd><dt><span class="term">ReadyForQuery</span></dt><dd><p>
<span class="original">
        Processing of the function call is complete.  ReadyForQuery
        will always be sent, whether processing terminates
        successfully or with an error.
</span>
関数呼び出しの処理が終了しました。
処理が成功またはエラーで終了したかどうかにかかわらずReadyForQueryは常に送出されます。
       </p></dd><dt><span class="term">NoticeResponse</span></dt><dd><p>
<span class="original">
        A warning message has been issued in relation to the function
        call.  Notices are in addition to other responses, i.e., the
        backend will continue processing the command.
</span>
関数呼び出しに関して警告メッセージが出されました。
警告メッセージは他の応答に対する追加のメッセージです。
したがって、バックエンドはそのコマンドの処理を続行します。
       </p></dd></dl></div><p>
   </p></div><div class="sect2" id="PROTOCOL-COPY"><div class="titlepage"><div><div><h3 class="title">55.2.6. COPY操作</h3></div></div></div><span class="original">
   &lt;title&gt;COPY Operations&lt;/title&gt;
</span><p>
<span class="original">
    The &lt;command&gt;COPY&lt;/command&gt; command allows high-speed bulk data transfer
    to or from the server.  Copy-in and copy-out operations each switch
    the connection into a distinct sub-protocol, which lasts until the
    operation is completed.
</span>
<code class="command">COPY</code>コマンドにより、サーバとの間で高速な大量データ転送を行うことができます。
コピーインとコピーアウト操作はそれぞれ接続を別のサブプロトコルに切り替えます。
これは操作が完了するまで残ります。
   </p><p>
<span class="original">
    Copy-in mode (data transfer to the server) is initiated when the
    backend executes a &lt;command&gt;COPY FROM STDIN&lt;/command&gt; SQL statement.  The backend
    sends a CopyInResponse message to the frontend.  The frontend should
    then send zero or more CopyData messages, forming a stream of input
    data.  (The message boundaries are not required to have anything to do
    with row boundaries, although that is often a reasonable choice.)
    The frontend can terminate the copy-in mode by sending either a CopyDone
    message (allowing successful termination) or a CopyFail message (which
    will cause the &lt;command&gt;COPY&lt;/command&gt; SQL statement to fail with an
    error).  The backend then reverts to the command-processing mode it was
    in before the &lt;command&gt;COPY&lt;/command&gt; started, which will be either simple or
    extended query protocol.  It will next send either CommandComplete
    (if successful) or ErrorResponse (if not).
</span>
コピーインモード（サーバへのデータ転送）は、バックエンドが<code class="command">COPY FROM STDIN</code> SQL文を実行した時に起動されます。
バックエンドはフロントエンドにCopyInResponseメッセージを送信します。
フロントエンドはその後、ゼロ個以上のCopyDataメッセージを送信し、入力データのストリームを形成します。
（このメッセージの境界は行の境界に何かしら合わせる必要ありませんが、往々にしてそれが合理的な選択となります。）
フロントエンドは、CopyDoneメッセージ（正常に終了させる）、もしくは、CopyFailメッセージ（<code class="command">COPY</code> SQL文をエラーで失敗させる）を送信することで、コピーインモードを終了させることができます。
そして、バックエンドは、<code class="command">COPY</code>が始まる前の、簡易もしくは拡張問い合わせプロトコルを使用するコマンド処理モードに戻ります。
そして次に、CommandComplete（成功時）またはErrorResponse（失敗時）のどちらかを送信します。
   </p><p>
<span class="original">
    In the event of a backend-detected error during copy-in mode (including
    receipt of a CopyFail message), the backend will issue an ErrorResponse
    message.  If the &lt;command&gt;COPY&lt;/command&gt; command was issued via an extended-query
    message, the backend will now discard frontend messages until a Sync
    message is received, then it will issue ReadyForQuery and return to normal
    processing.  If the &lt;command&gt;COPY&lt;/command&gt; command was issued in a simple
    Query message, the rest of that message is discarded and ReadyForQuery
    is issued.  In either case, any subsequent CopyData, CopyDone, or CopyFail
    messages issued by the frontend will simply be dropped.
</span>
コピーインモードの期間中にバックエンドがエラー（CopyFailメッセージの受信を含む）を検知すると、バックエンドはErrorResponseメッセージを発行します。
拡張問い合わせメッセージ経由で<code class="command">COPY</code>コマンドが発行された場合、バックエンドはSyncメッセージを受け取るまでフロントエンドのメッセージを破棄するようになります。
Syncメッセージを受け取ると、ReadyForQueryを発行し、通常処理に戻ります。
簡易問い合わせメッセージで<code class="command">COPY</code>が発行された場合、メッセージの残りは破棄され、ReadyForQueryメッセージを発行します。
どちらの場合でも、その後にフロントエンドによって発行されたCopyData、CopyDone、CopyFailは単に削除されます。
   </p><p>
<span class="original">
    The backend will ignore Flush and Sync messages received during copy-in
    mode.  Receipt of any other non-copy message type constitutes an error
    that will abort the copy-in state as described above.  (The exception for
    Flush and Sync is for the convenience of client libraries that always
    send Flush or Sync after an Execute message, without checking whether
    the command to be executed is a &lt;command&gt;COPY FROM STDIN&lt;/command&gt;.)
</span>
バックエンドは、コピーインモード期間中、FlushとSyncメッセージを無視します。
その他の種類の非コピーメッセージを受け取ると、エラーになり、上述のようにコピーイン状態を中断します
（クライアントライブラリがExecuteメッセージの後に、実行したコマンドが<code class="command">COPY FROM STDIN</code>かどうかを検査することなく、常にFlushまたはSyncを送信できる、という便利さのためにFlushとSyncは例外です）。
   </p><p>
<span class="original">
    Copy-out mode (data transfer from the server) is initiated when the
    backend executes a &lt;command&gt;COPY TO STDOUT&lt;/command&gt; SQL statement.  The backend
    sends a CopyOutResponse message to the frontend, followed by
    zero or more CopyData messages (always one per row), followed by CopyDone.
    The backend then reverts to the command-processing mode it was
    in before the &lt;command&gt;COPY&lt;/command&gt; started, and sends CommandComplete.
    The frontend cannot abort the transfer (except by closing the connection
    or issuing a Cancel request),
    but it can discard unwanted CopyData and CopyDone messages.
</span>
コピーアウトモード（サーバからのデータ転送）は、バックエンドが<code class="command">COPY TO STDOUT</code> SQL文を実行した時に起動します。
バックエンドはCopyOutResponseメッセージをフロントエンドに送信し、その後、ゼロ個以上のCopyDataメッセージ（常に行ごとに1つ）を、そして、CopyDoneを送信します。
その後、バックエンドは<code class="command">COPY</code>が始まる前のコマンド処理モードに戻り、CommandCompleteを送信します。
フロントエンドは（接続の切断やCancel要求の発行は例外ですが）転送を中断することはできません。
しかし、不要なCopyDataとCopyDoneメッセージを破棄することは可能です。
   </p><p>
<span class="original">
    In the event of a backend-detected error during copy-out mode,
    the backend will issue an ErrorResponse message and revert to normal
    processing.  The frontend should treat receipt of ErrorResponse as
    terminating the copy-out mode.
</span>
コピーアウトモード期間中バックエンドはエラーを検知すると、ErrorResponseメッセージを発行し、通常処理に戻ります。
フロントエンドはErrorResponseの受信をコピーアウトモードの終了として扱うべきです。
   </p><p>
<span class="original">
    It is possible for NoticeResponse and ParameterStatus messages to be
    interspersed between CopyData messages; frontends must handle these cases,
    and should be prepared for other asynchronous message types as well (see
    &lt;xref linkend="protocol-async"/&gt;).  Otherwise, any message type other than
    CopyData or CopyDone may be treated as terminating copy-out mode.
</span>
NoticeResponseおよびParameterStatusメッセージがCopyDataメッセージ間に散在することがあります。
フロントエンドはこのような場合も扱わなければなりません。
また、他の種類の非同期メッセージ（<a class="xref" href="protocol-flow.html#PROTOCOL-ASYNC" title="55.2.7. 非同期操作">55.2.7</a>を参照）も同様に準備すべきです。
さもなくば、CopyDataまたはCopyDone以外の種類のメッセージがコピーアウトモードの終了として扱われてしまう可能性があります。
   </p><p>
<span class="original">
    There is another Copy-related mode called copy-both, which allows
    high-speed bulk data transfer to &lt;emphasis&gt;and&lt;/emphasis&gt; from the server.
    Copy-both mode is initiated when a backend in walsender mode
    executes a &lt;command&gt;START_REPLICATION&lt;/command&gt; statement.  The
    backend sends a CopyBothResponse message to the frontend.  Both
    the backend and the frontend may then send CopyData messages
    until either end sends a CopyDone message. After the client
    sends a CopyDone message, the connection goes from copy-both mode to
    copy-out mode, and the client may not send any more CopyData messages.
    Similarly, when the server sends a CopyDone message, the connection
    goes into copy-in mode, and the server may not send any more CopyData
    messages. After both sides have sent a CopyDone message, the copy mode
    is terminated, and the backend reverts to the command-processing mode.
    In the event of a backend-detected error during copy-both mode,
    the backend will issue an ErrorResponse message, discard frontend messages
    until a Sync message is received, and then issue ReadyForQuery and return
    to normal processing.  The frontend should treat receipt of ErrorResponse
    as terminating the copy in both directions; no CopyDone should be sent
    in this case.  See &lt;xref linkend="protocol-replication"/&gt; for more
    information on the subprotocol transmitted over copy-both mode.
</span>
他にも、サーバへ、<span class="emphasis"><em>および</em></span>サーバからの高速な一括データ転送を行うことができるコピーボースというコピーに関連したモードがあります。
コピーボースモードは、walsenderモードのバックエンドが<code class="command">START_REPLICATION</code>文を実行した時に初期化されます。
バックエンドはCopyBothResponseメッセージをフロントエンドに送信します。
この後バックエンドとフロントエンドの両方が、接続が終了するまでの間にCopyDataメッセージを送信できるようになります。
同様に、サーバがCopyDoneメッセージを送信した場合、接続はコピーインモードとなり、サーバはそれ以上のCopyDataメッセージを送信できません。
両方の側がCopyDoneメッセージを送信した後、コピーモードは終了し、バックエンドはコマンド処理モードに戻ります。
コピーボースモード中にバックエンドが検出したエラーのイベントにおいては、バックエンドはErrorResponseメッセージを発行し、Syncメッセージの受信までフロントエンドのメッセージを破棄し、その後ReadyForQueryを発行して通常の処理に戻ります。
フロントエンドは両方向のコピーを終了するように、ErrorResponse受理の処理をするべきです。
この場合CopyDoneを送信するべきではありません。
コピーボースモードにおけるサブプロトコル転送の詳細は<a class="xref" href="protocol-replication.html" title="55.4. ストリーミングレプリケーションプロトコル">55.4</a>を参照してください。
   </p><p>
<span class="original">
    The CopyInResponse, CopyOutResponse and CopyBothResponse messages
    include fields that inform the frontend of the number of columns
    per row and the format codes being used for each column.  (As of
    the present implementation, all columns in a given &lt;command&gt;COPY&lt;/command&gt;
    operation will use the same format, but the message design does not
    assume this.)
</span>
CopyInResponse、CopyOutResponse、CopyBothResponseメッセージには、フロントエンドに1行当たりの列数と各列で使用する書式コードを通知するためのフィールドが含まれています。
（現在の実装では、<code class="command">COPY</code>操作で与えられるすべての列は同一の書式を使用します。
しかし、メッセージ設計においては、これを前提としていません。）
   </p></div><div class="sect2" id="PROTOCOL-ASYNC"><div class="titlepage"><div><div><h3 class="title">55.2.7. 非同期操作</h3></div></div></div><span class="original">
   &lt;title&gt;Asynchronous Operations&lt;/title&gt;
</span><p>
<span class="original">
    There are several cases in which the backend will send messages that
    are not specifically prompted by the frontend's command stream.
    Frontends must be prepared to deal with these messages at any time,
    even when not engaged in a query.
    At minimum, one should check for these cases before beginning to
    read a query response.
</span>
バックエンドが、フロントエンドのコマンドストリームで特に依頼されていないメッセージを送信する場合が複数あります。
フロントエンドは、問い合わせ作業を行っていない時であっても常に、これらのメッセージを扱う準備をしなければなりません。
少なくとも、問い合わせの応答の読み込みを始める前にこれらを検査すべきです。
   </p><p>
<span class="original">
    It is possible for NoticeResponse messages to be generated due to
    outside activity; for example, if the database administrator commands
    a &lt;quote&gt;fast&lt;/quote&gt; database shutdown, the backend will send a NoticeResponse
    indicating this fact before closing the connection.  Accordingly,
    frontends should always be prepared to accept and display NoticeResponse
    messages, even when the connection is nominally idle.
</span>
外部の活動によって、NoticeResponseメッセージが生成されることがあり得ます。
例えば、データベース管理者が<span class="quote">「<span class="quote">高速</span>」</span>データベース停止コマンドを実行した場合、バックエンドは接続を閉ざす前にこれを通知するためにNoticeResponseを送信します。
したがって、たとえ接続が名目上待機状態であったとしても、フロントエンドは常にNoticeResponseメッセージを受け付け、表示する準備をすべきです。
   </p><p>
<span class="original">
    ParameterStatus messages will be generated whenever the active
    value changes for any of the parameters the backend believes the
    frontend should know about.  Most commonly this occurs in response
    to a &lt;command&gt;SET&lt;/command&gt; SQL command executed by the frontend, and
    this case is effectively synchronous &amp;mdash; but it is also possible
    for parameter status changes to occur because the administrator
    changed a configuration file and then sent the
    &lt;systemitem&gt;SIGHUP&lt;/systemitem&gt; signal to the server.  Also,
    if a &lt;command&gt;SET&lt;/command&gt; command is rolled back, an appropriate
    ParameterStatus message will be generated to report the current
    effective value.
</span>
ParameterStatusメッセージは、任意のパラメータの実際の値が変更され、それをバックエンドがフロントエンドに通知するべきであるとみなした場合は常に生成されます。
ほとんどの場合、これはフロントエンドによる<code class="command">SET</code> SQLコマンド実行に対する応答の中で起こります。
これは実質的には同期していますが、管理者が設定ファイルを変更し、<span class="systemitem">SIGHUP</span>シグナルをサーバに送った場合にも、パラメータ状態の変更が発生することがあります。
また、<code class="command">SET</code>コマンドがロールバックされた場合、現在の有効値を報告するために適切なParameterStatusメッセージが生成されます。
   </p><p>
<span class="original">
    At present there is a hard-wired set of parameters for which
    ParameterStatus will be generated: they are
    &lt;varname&gt;server_version&lt;/varname&gt;,
    &lt;varname&gt;server_encoding&lt;/varname&gt;,
    &lt;varname&gt;client_encoding&lt;/varname&gt;,
    &lt;varname&gt;application_name&lt;/varname&gt;,
    &lt;varname&gt;default_transaction_read_only&lt;/varname&gt;,
    &lt;varname&gt;in_hot_standby&lt;/varname&gt;,
    &lt;varname&gt;is_superuser&lt;/varname&gt;,
    &lt;varname&gt;session_authorization&lt;/varname&gt;,
    &lt;varname&gt;DateStyle&lt;/varname&gt;,
    &lt;varname&gt;IntervalStyle&lt;/varname&gt;,
    &lt;varname&gt;TimeZone&lt;/varname&gt;,
    &lt;varname&gt;integer_datetimes&lt;/varname&gt;, and
    &lt;varname&gt;standard_conforming_strings&lt;/varname&gt;.
    (&lt;varname&gt;server_encoding&lt;/varname&gt;, &lt;varname&gt;TimeZone&lt;/varname&gt;, and
    &lt;varname&gt;integer_datetimes&lt;/varname&gt; were not reported by releases before 8.0;
    &lt;varname&gt;standard_conforming_strings&lt;/varname&gt; was not reported by releases
    before 8.1;
    &lt;varname&gt;IntervalStyle&lt;/varname&gt; was not reported by releases before 8.4;
    &lt;varname&gt;application_name&lt;/varname&gt; was not reported by releases before
    9.0;
    &lt;varname&gt;default_transaction_read_only&lt;/varname&gt; and
    &lt;varname&gt;in_hot_standby&lt;/varname&gt; were not reported by releases before
    14.)
    Note that
    &lt;varname&gt;server_version&lt;/varname&gt;,
    &lt;varname&gt;server_encoding&lt;/varname&gt; and
    &lt;varname&gt;integer_datetimes&lt;/varname&gt;
    are pseudo-parameters that cannot change after startup.
    This set might change in the future, or even become configurable.
    Accordingly, a frontend should simply ignore ParameterStatus for
    parameters that it does not understand or care about.
</span>
現時点では、ParameterStatusを生成するパラメータ群は固定されています。
それらは<code class="varname">server_version</code>、<code class="varname">server_encoding</code>、<code class="varname">client_encoding</code>、<code class="varname">application_name</code>、<code class="varname">default_transaction_read_only</code>、<code class="varname">in_hot_standby</code>、<code class="varname">is_superuser</code>、<code class="varname">session_authorization</code>、<code class="varname">DateStyle</code>、<code class="varname">IntervalStyle</code>、<code class="varname">TimeZone</code>、<code class="varname">integer_datetimes</code>、および<code class="varname">standard_conforming_strings</code>です。
（8.0より前までのリリースでは、<code class="varname">server_encoding</code>、<code class="varname">TimeZone</code>および<code class="varname">integer_datetimes</code>は送信されませんでした。
8.1より前までのリリースでは、<code class="varname">standard_conforming_strings</code>は送信されませんでした。
8.4より前のリリースでは、<code class="varname">IntervalStyle</code>は送信されませんでした。
9.0より前のリリースでは、<code class="varname">application_name</code>は送信されませんでした。
14より前のリリースでは、<code class="varname">default_transaction_read_only</code>と<code class="varname">in_hot_standby</code>は送信されませんでした。）
<code class="varname">server_version</code>、<code class="varname">server_encoding</code>および<code class="varname">integer_datetimes</code>は仮想的なパラメータであり、起動後に変更することができないことに注意してください。
これは今後変更される、あるいは設定変更可能になる可能性があります。
したがって、フロントエンドは未知または注目していないParameterStatusを単に無視すべきです。
   </p><p>
<span class="original">
    If a frontend issues a &lt;command&gt;LISTEN&lt;/command&gt; command, then the
    backend will send a NotificationResponse message (not to be
    confused with NoticeResponse!)  whenever a
    &lt;command&gt;NOTIFY&lt;/command&gt; command is executed for the same
    channel name.
</span>
フロントエンドが<code class="command">LISTEN</code>コマンドを発行した場合、同じチャネル名に対し<code class="command">NOTIFY</code>コマンドが実行された時にバックエンドはNotificationResponseメッセージ（NoticeResponseと間違えないように！）を送出します。
   </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
     At present, NotificationResponse can only be sent outside a
     transaction, and thus it will not occur in the middle of a
     command-response series, though it might occur just before ReadyForQuery.
     It is unwise to design frontend logic that assumes that, however.
     Good practice is to be able to accept NotificationResponse at any
     point in the protocol.
</span>
現在、NotificationResponseをトランザクションの外部でのみ送信することができます。
このため、これはコマンド応答の流れの途中では起こりませんが、ReadyForQueryの直前に発生する可能性があります。
しかし、これを前提にフロントエンドのロジックを設計することは避けてください。
プロトコル内の任意の時点でNotificationResponseを受け付けられるようにすることを勧めます。
    </p></div></div><div class="sect2" id="id-1.10.6.8.10"><div class="titlepage"><div><div><h3 class="title">55.2.8. 処理中のリクエストの取り消し</h3></div></div></div><span class="original">
   &lt;title&gt;Canceling Requests in Progress&lt;/title&gt;
</span><p>
<span class="original">
    During the processing of a query, the frontend might request
    cancellation of the query.  The cancel request is not sent
    directly on the open connection to the backend for reasons of
    implementation efficiency: we don't want to have the backend
    constantly checking for new input from the frontend during query
    processing.  Cancel requests should be relatively infrequent, so
    we make them slightly cumbersome in order to avoid a penalty in
    the normal case.
</span>
問い合わせの処理中に、フロントエンドが問い合わせを取り消す可能性があります。
取り消し要求は、効率を高めるために、接続を開いたバックエンドに対して直接送信されません。
その問い合わせを処理中のバックエンドが、フロントエンドからの新しい入力があるかどうかを定期的に確認することは好ましくありません。
取り消し要求はたいていの場合、頻繁には起こらないので、通常の状態においての負担を避けるため、多少扱いにくくなっています。
   </p><p>
<span class="original">
    To issue a cancel request, the frontend opens a new connection to
    the server and sends a CancelRequest message, rather than the
    StartupMessage message that would ordinarily be sent across a new
    connection.  The server will process this request and then close
    the connection.  For security reasons, no direct reply is made to
    the cancel request message.
</span>
取り消し要求を出す場合、フロントエンドは通常の新規接続の時に送出されるStartupMessageメッセージではなくCancelRequestメッセージをサーバに送り、新規接続を開始します。
サーバはこの要求を処理し、接続を切断します。
セキュリティ上の理由から、取り消し要求メッセージに対し直接の回答はありません。
   </p><p>
<span class="original">
    A CancelRequest message will be ignored unless it contains the
    same key data (PID and secret key) passed to the frontend during
    connection start-up.  If the request matches the PID and secret
    key for a currently executing backend, the processing of the
    current query is aborted.  (In the existing implementation, this is
    done by sending a special signal to the backend process that is
    processing the query.)
</span>
CancelRequestメッセージは、接続開始段階でフロントエンドに送られたものと同一の鍵データ（PIDと秘密鍵）を含んでいない場合は無視されます。
現在バックエンドが実行中の処理に対するPIDと秘密鍵が要求と一致した場合、その現在の問い合わせ処理は中断されます。
（現状では、これは、その問い合わせを処理しているバックエンドプロセスに対し特別なシグナルを送ることで実装されています。）
   </p><p>
<span class="original">
    The cancellation signal might or might not have any effect &amp;mdash; for
    example, if it arrives after the backend has finished processing
    the query, then it will have no effect.  If the cancellation is
    effective, it results in the current command being terminated
    early with an error message.
</span>
この取り消しシグナルは何の効果も生まないことがあります。
例えば、バックエンドが問い合わせの処理を完了した後に届いた場合、効果がありません。
もし取り消し処理が有効であれば、エラーメッセージとともに、現在のコマンドは終了されます。
   </p><p>
<span class="original">
    The upshot of all this is that for reasons of both security and
    efficiency, the frontend has no direct way to tell whether a
    cancel request has succeeded.  It must continue to wait for the
    backend to respond to the query.  Issuing a cancel simply improves
    the odds that the current query will finish soon, and improves the
    odds that it will fail with an error message instead of
    succeeding.
</span>
セキュリティと効率上の理由による上述の実装の結果、フロントエンドは取り消し要求が成功したかどうかを直接判断することはできません。
フロントエンドはバックエンドからの問い合わせの回答を待ち続けなければいけません。
取り消しを要求することは単に現在の問い合わせを早めに終わらせ、成功ではなくエラーメッセージを出して不成功とする可能性を単に高める程度のものです。
   </p><p>
<span class="original">
    Since the cancel request is sent across a new connection to the
    server and not across the regular frontend/backend communication
    link, it is possible for the cancel request to be issued by any
    process, not just the frontend whose query is to be canceled.
    This might provide additional flexibility when building
    multiple-process applications.  It also introduces a security
    risk, in that unauthorized persons might try to cancel queries.
    The security risk is addressed by requiring a dynamically
    generated secret key to be supplied in cancel requests.
</span>
取り消し要求は、通常のフロントエンドとバックエンドの通信接続を通してではなく新規のサーバとの接続に送られるため、取り消される問い合わせを実行したフロントエンドだけでなく、任意のプロセスによっても送信することができます。
このことはマルチプロセスアプリケーションを作るに当たって柔軟性を提供します。
同時に、権限のない者が問い合わせを取り消そうとするといったセキュリティ上のリスクも持ち込みます。
このセキュリティ上のリスクは、取り消し要求内に動的に生成される秘密キーを供給することを必須とすることで回避されます。
   </p></div><div class="sect2" id="id-1.10.6.8.11"><div class="titlepage"><div><div><h3 class="title">55.2.9. 終了</h3></div></div></div><span class="original">
   &lt;title&gt;Termination&lt;/title&gt;
</span><p>
<span class="original">
    The normal, graceful termination procedure is that the frontend
    sends a Terminate message and immediately closes the connection.
    On receipt of this message, the backend closes the connection and
    terminates.
</span>
通常の洗練された終了手順はフロントエンドがTerminateメッセージを出し、すぐに接続を閉じることです。
このメッセージを受け取るとすぐにバックエンドは接続を閉じ終了します。
   </p><p>
<span class="original">
    In rare cases (such as an administrator-commanded database shutdown)
    the backend might disconnect without any frontend request to do so.
    In such cases the backend will attempt to send an error or notice message
    giving the reason for the disconnection before it closes the connection.
</span>
まれに（管理者によるデータベース停止コマンドなど）、バックエンドはフロントエンドからの要求なしに切断することがあります。
こうした場合、バックエンドは、接続を閉ざす前に切断理由を通知するエラーまたは警報メッセージの送信を試みます。
   </p><p>
<span class="original">
    Other termination scenarios arise from various failure cases, such as core
    dump at one end or the other, loss of the communications link, loss of
    message-boundary synchronization, etc.  If either frontend or backend sees
    an unexpected closure of the connection, it should clean
    up and terminate.  The frontend has the option of launching a new backend
    by recontacting the server if it doesn't want to terminate itself.
    Closing the connection is also advisable if an unrecognizable message type
    is received, since this probably indicates loss of message-boundary sync.
</span>
他にも、どちらかの側のコアダンプ、通信リンクの消失、メッセージ境界の同期の消失など各種失敗によって終了する状況があります。
フロントエンドかバックエンドいずれかが予期しない接続の中断を検知した場合、後始末を行い終了しなければいけません。
フロントエンドはもし自身が終了を望まない場合、サーバに再交信し新規のバックエンドを立ち上げる選択権を持っています。
解釈できないメッセージ種類を受け取った時、おそらくメッセージ境界の同期が消失したことを示しますので、接続を閉ざすことを勧めます。
   </p><p>
<span class="original">
    For either normal or abnormal termination, any open transaction is
    rolled back, not committed.  One should note however that if a
    frontend disconnects while a non-&lt;command&gt;SELECT&lt;/command&gt; query
    is being processed, the backend will probably finish the query
    before noticing the disconnection.  If the query is outside any
    transaction block (&lt;command&gt;BEGIN&lt;/command&gt; ... &lt;command&gt;COMMIT&lt;/command&gt;
    sequence) then its results might be committed before the
    disconnection is recognized.
</span>
通常の終了、異常な終了のどちらの場合でも、開いているトランザクションはすべてコミットされずにロールバックされます。
しかし、フロントエンドが<code class="command">SELECT</code>以外の問い合わせを処理中に切断した場合、バックエンドはおそらく切断に気付く前にその問い合わせを完了させてしまうでしょう。
その問い合わせがトランザクションブロック（<code class="command">BEGIN</code> ... <code class="command">COMMIT</code>の並び）外部であった場合、切断に気付く前にその結果はコミットされる可能性があります。
   </p></div><div class="sect2" id="id-1.10.6.8.12"><div class="titlepage"><div><div><h3 class="title">55.2.10. <acronym class="acronym">SSL</acronym>セッション暗号化</h3></div></div></div><span class="original">
   &lt;title&gt;&lt;acronym&gt;SSL&lt;/acronym&gt; Session Encryption&lt;/title&gt;
</span><p>
<span class="original">
    If &lt;productname&gt;PostgreSQL&lt;/productname&gt; was built with
    &lt;acronym&gt;SSL&lt;/acronym&gt; support, frontend/backend communications
    can be encrypted using &lt;acronym&gt;SSL&lt;/acronym&gt;.  This provides
    communication security in environments where attackers might be
    able to capture the session traffic. For more information on
    encrypting &lt;productname&gt;PostgreSQL&lt;/productname&gt; sessions with
    &lt;acronym&gt;SSL&lt;/acronym&gt;, see &lt;xref linkend="ssl-tcp"/&gt;.
</span>
<span class="productname">PostgreSQL</span>が<acronym class="acronym">SSL</acronym>サポート付きで構築された場合、フロントエンドとバックエンド間の通信を<acronym class="acronym">SSL</acronym>で暗号化することができます。
攻撃者がセッショントラフィックをキャプチャできるような環境における通信を安全にすることができます。
<acronym class="acronym">SSL</acronym>を使用した<span class="productname">PostgreSQL</span>セッションの暗号化に関する詳細は<a class="xref" href="ssl-tcp.html" title="19.9. SSLによる安全なTCP/IP接続">19.9</a>を参照してください。
   </p><p>
<span class="original">
    To initiate an &lt;acronym&gt;SSL&lt;/acronym&gt;-encrypted connection, the
    frontend initially sends an SSLRequest message rather than a
    StartupMessage.  The server then responds with a single byte
    containing &lt;literal&gt;S&lt;/literal&gt; or &lt;literal&gt;N&lt;/literal&gt;, indicating that it is
    willing or unwilling to perform &lt;acronym&gt;SSL&lt;/acronym&gt;,
    respectively.  The frontend might close the connection at this point
    if it is dissatisfied with the response.  To continue after
    &lt;literal&gt;S&lt;/literal&gt;, perform an &lt;acronym&gt;SSL&lt;/acronym&gt; startup handshake
    (not described here, part of the &lt;acronym&gt;SSL&lt;/acronym&gt;
    specification) with the server.  If this is successful, continue
    with sending the usual StartupMessage.  In this case the
    StartupMessage and all subsequent data will be
    &lt;acronym&gt;SSL&lt;/acronym&gt;-encrypted.  To continue after
    &lt;literal&gt;N&lt;/literal&gt;, send the usual StartupMessage and proceed without
    encryption.
    (Alternatively, it is permissible to issue a GSSENCRequest message
    after an &lt;literal&gt;N&lt;/literal&gt; response to try to
    use &lt;acronym&gt;GSSAPI&lt;/acronym&gt; encryption instead
    of &lt;acronym&gt;SSL&lt;/acronym&gt;.)
</span>
<acronym class="acronym">SSL</acronym>暗号化接続を開始するには、フロントエンドはまず、StartupMessageではなくSSLRequestを送信します。
その後サーバはそれぞれ<acronym class="acronym">SSL</acronym>の実行を行うか行わないかを示す<code class="literal">S</code>か<code class="literal">N</code>かを持つ1バイトの応答を返します。
フロントエンドはその応答に満足できなければ、この時点で接続を切断することができます。
<code class="literal">S</code>の後に継続するのであれば、サーバと間で<acronym class="acronym">SSL</acronym>起動ハンドシェーク（ここでは<acronym class="acronym">SSL</acronym>の仕様に関しては説明しません）を行います。
これが成功した場合、続いて通常のStartupMessageの送信を行います。
この場合、StartupMessageおよびその後のデータは<acronym class="acronym">SSL</acronym>により暗号化されます。
<code class="literal">N</code>の後に、通常のStartupMessageを送信することで暗号化なしで進みます。
（他に、<acronym class="acronym">SSL</acronym>の代わりに<acronym class="acronym">GSSAPI</acronym>暗号化の利用を試行するために、<code class="literal">N</code>応答の後にGSSENCRequestメッセージを送信することが認められています。）
   </p><p>
<span class="original">
    The frontend should also be prepared to handle an ErrorMessage
    response to SSLRequest from the server.  This would only occur if
    the server predates the addition of &lt;acronym&gt;SSL&lt;/acronym&gt; support
    to &lt;productname&gt;PostgreSQL&lt;/productname&gt;.  (Such servers are now very ancient,
    and likely do not exist in the wild anymore.)
    In this case the connection must
    be closed, but the frontend might choose to open a fresh connection
    and proceed without requesting &lt;acronym&gt;SSL&lt;/acronym&gt;.
</span>
また、フロントエンドはサーバからのSSLRequestに対するErrorMessage応答を取り扱うための用意もすべきです。
これは、<span class="productname">PostgreSQL</span>に<acronym class="acronym">SSL</acronym>サポートが追加される前のサーバの場合のみで発生します。
（現在ではこうしたサーバは非常に古いものといえ、ほとんど存在しません。）
この場合接続を切断しなければなりませんが、フロントエンドは<acronym class="acronym">SSL</acronym>要求なしで新しく接続を開き、処理を進めることもできます。
   </p><p>
<span class="original">
    When &lt;acronym&gt;SSL&lt;/acronym&gt; encryption can be performed, the server
    is expected to send only the single &lt;literal&gt;S&lt;/literal&gt; byte and then
    wait for the frontend to initiate an &lt;acronym&gt;SSL&lt;/acronym&gt; handshake.
    If additional bytes are available to read at this point, it likely
    means that a man-in-the-middle is attempting to perform a
    buffer-stuffing attack
    (&lt;ulink url="https://www.postgresql.org/support/security/CVE-2021-23222/"&gt;CVE-2021-23222&lt;/ulink&gt;).
    Frontends should be coded either to read exactly one byte from the
    socket before turning the socket over to their SSL library, or to
    treat it as a protocol violation if they find they have read additional
    bytes.
</span>
<acronym class="acronym">SSL</acronym>暗号化が実行可能なら、サーバは<code class="literal">S</code>バイトだけを送信し、フロントエンドが<acronym class="acronym">SSL</acronym>ハンドシェイクを開始するのを待つことが期待されます。
この段階でそれ以上のバイトが読み取り可能であるなら、中間者がバッファスタッフィング攻撃(<a class="ulink" href="https://www.postgresql.org/support/security/CVE-2021-23222/" target="_top">CVE-2021-23222</a>)を開始しようとしている可能性が高いです。
フロントエンドは、ソケットをSSLライブラリに渡す前に正確に1バイトだけをソケットから読み出すべきです。
でなければ、追加のバイトが読み取られた場合には、プロトコル違反として扱うべきです。
   </p><p>
<span class="original">
    An initial SSLRequest can also be used in a connection that is being
    opened to send a CancelRequest message.
</span>
最初のSSLRequestはCancelRequestメッセージを送信するために開いた接続で使用することもできます。
   </p><p>
<span class="original">
    While the protocol itself does not provide a way for the server to
    force &lt;acronym&gt;SSL&lt;/acronym&gt; encryption, the administrator can
    configure the server to reject unencrypted sessions as a byproduct
    of authentication checking.
</span>
プロトコル自体には、サーバに<acronym class="acronym">SSL</acronym>暗号化を強制する方法は用意されていませんが、管理者は認証検査の一方法として、暗号化されていないセッションを拒否するようにサーバを設定することができます。
   </p></div><div class="sect2" id="id-1.10.6.8.13"><div class="titlepage"><div><div><h3 class="title">55.2.11. <acronym class="acronym">GSSAPI</acronym>セッション暗号化</h3></div></div></div><span class="original">
   &lt;title&gt;&lt;acronym&gt;GSSAPI&lt;/acronym&gt; Session Encryption&lt;/title&gt;
</span><p>
<span class="original">
    If &lt;productname&gt;PostgreSQL&lt;/productname&gt; was built with
    &lt;acronym&gt;GSSAPI&lt;/acronym&gt; support, frontend/backend communications
    can be encrypted using &lt;acronym&gt;GSSAPI&lt;/acronym&gt;.  This provides
    communication security in environments where attackers might be
    able to capture the session traffic. For more information on
    encrypting &lt;productname&gt;PostgreSQL&lt;/productname&gt; sessions with
    &lt;acronym&gt;GSSAPI&lt;/acronym&gt;, see &lt;xref linkend="gssapi-enc"/&gt;.
</span>
<span class="productname">PostgreSQL</span>が<acronym class="acronym">GSSAPI</acronym>サポートを有効にして構築されていれば、<acronym class="acronym">GSSAPI</acronym>を使ってフロントエンド/バックエンド通信を暗号化できます。
これにより、攻撃者がセッションのやり取りを読み取れるかもしれない環境における通信のセキュリティが提供されます。
<span class="productname">PostgreSQL</span>での通信を<acronym class="acronym">GSSAPI</acronym>で暗号化するための情報に関しては、<a class="xref" href="gssapi-enc.html" title="19.10. GSSAPIによる安全なTCP/IP接続">19.10</a>をご覧ください。
   </p><p>
<span class="original">
    To initiate a &lt;acronym&gt;GSSAPI&lt;/acronym&gt;-encrypted connection, the
    frontend initially sends a GSSENCRequest message rather than a
    StartupMessage.  The server then responds with a single byte
    containing &lt;literal&gt;G&lt;/literal&gt; or &lt;literal&gt;N&lt;/literal&gt;, indicating that it
    is willing or unwilling to perform &lt;acronym&gt;GSSAPI&lt;/acronym&gt; encryption,
    respectively.  The frontend might close the connection at this point
    if it is dissatisfied with the response.  To continue after
    &lt;literal&gt;G&lt;/literal&gt;, using the GSSAPI C bindings as discussed in
    &lt;ulink url="https://tools.ietf.org/html/rfc2744"&gt;RFC 2744&lt;/ulink&gt;
    or equivalent, perform a &lt;acronym&gt;GSSAPI&lt;/acronym&gt; initialization by
    calling &lt;function&gt;gss_init_sec_context()&lt;/function&gt; in a loop and sending
    the result to the server, starting with an empty input and then with each
    result from the server, until it returns no output.  When sending the
    results of &lt;function&gt;gss_init_sec_context()&lt;/function&gt; to the server,
    prepend the length of the message as a four byte integer in network byte
    order.
    To continue after
    &lt;literal&gt;N&lt;/literal&gt;, send the usual StartupMessage and proceed without
    encryption.
    (Alternatively, it is permissible to issue an SSLRequest message
    after an &lt;literal&gt;N&lt;/literal&gt; response to try to
    use &lt;acronym&gt;SSL&lt;/acronym&gt; encryption instead
    of &lt;acronym&gt;GSSAPI&lt;/acronym&gt;.)
</span>
<acronym class="acronym">GSSAPI</acronym>暗号化接続を開始するには、フロントエンドは最初にStartupMessageではなく、GSSENCRequestメッセージを送ります。
次にサーバは、それぞれ<acronym class="acronym">GSSAPI</acronym>暗号化を希望する、しないを意味する<code class="literal">G</code>または<code class="literal">N</code>を含む1バイトを送信します。
このレスポンスに満足できなければ、この時点でフロントエンドは接続を打ち切って構いません。
<code class="literal">G</code>の受信後継続するには、<a class="ulink" href="https://tools.ietf.org/html/rfc2744" target="_top">RFC 2744</a>あるいは同様の文書で議論されているGSSAPI Cバインディングを使い、ループの中で<code class="function">gss_init_sec_context()</code>を呼び出して<acronym class="acronym">GSSAPI</acronym>を初期化し、結果をサーバに送信し、空の入力を受け取ることから始めて、サーバが出力を返さなくなるまでサーバからの出力を受け取ります。
<code class="function">gss_init_sec_context()</code>の結果をサーバに送る際には、ネットワークバイトオーダーで4バイトの整数にメッセージ長を先頭に付与します。
<code class="literal">N</code>の後継続するには、通常のStartupMessageを送信し、暗号化せずに続けてください。
（他に、<acronym class="acronym">GSSAPI</acronym>の代わりに<acronym class="acronym">SSL</acronym>暗号化の使用を試行するために、<code class="literal">N</code>応答の後にSSLRequestメッセージを送信することが認められています。）
   </p><p>
<span class="original">
    The frontend should also be prepared to handle an ErrorMessage
    response to GSSENCRequest from the server.  This would only occur if
    the server predates the addition of &lt;acronym&gt;GSSAPI&lt;/acronym&gt; encryption
    support to &lt;productname&gt;PostgreSQL&lt;/productname&gt;.  In this case the
    connection must be closed, but the frontend might choose to open a fresh
    connection and proceed without requesting &lt;acronym&gt;GSSAPI&lt;/acronym&gt;
    encryption.
</span>
また、フロントエンドはサーバからのGSSENCRequestへのErrorMessage応答に備えるべきです。
これはサーバが<span class="productname">PostgreSQL</span>への<acronym class="acronym">GSSAPI</acronym>暗号化サポートを追加する以前だったときにのみ発生します。
この場合は接続を切断しなければなりませんが、フロントエンドは新しい接続を開いて<acronym class="acronym">GSSAPI</acronym>暗号化を要求せずに進めることを選択するかもしれません。
   </p><p>
<span class="original">
    When &lt;acronym&gt;GSSAPI&lt;/acronym&gt; encryption can be performed, the server
    is expected to send only the single &lt;literal&gt;G&lt;/literal&gt; byte and then
    wait for the frontend to initiate a &lt;acronym&gt;GSSAPI&lt;/acronym&gt; handshake.
    If additional bytes are available to read at this point, it likely
    means that a man-in-the-middle is attempting to perform a
    buffer-stuffing attack
    (&lt;ulink url="https://www.postgresql.org/support/security/CVE-2021-23222/"&gt;CVE-2021-23222&lt;/ulink&gt;).
    Frontends should be coded either to read exactly one byte from the
    socket before turning the socket over to their GSSAPI library, or to
    treat it as a protocol violation if they find they have read additional
    bytes.
</span>
<acronym class="acronym">GSSAPI</acronym>暗号化が実行可能なら、サーバは<code class="literal">G</code>バイトだけを送信し、フロントエンドが<acronym class="acronym">SSL</acronym>ハンドシェイクを開始するのを待つことが期待されます。
この段階でそれ以上のバイトが読み取り可能であるなら、中間者がバッファスタッフィング攻撃(<a class="ulink" href="https://www.postgresql.org/support/security/CVE-2021-23222/" target="_top">CVE-2021-23222</a>)を開始しようとしている可能性が高いです。
フロントエンドは、ソケットをGSSAPIライブラリに渡す前に正確に1バイトだけをソケットから読み出すべきです。
でなければ、追加のバイトが読み取られた場合には、プロトコル違反として扱うべきです。
   </p><p>
<span class="original">
    An initial GSSENCRequest can also be used in a connection that is being
    opened to send a CancelRequest message.
</span>
最初のGSSENCRequestは、CancelRequestメッセージを送信するために開いている接続でも利用できます。
   </p><p>
<span class="original">
    Once &lt;acronym&gt;GSSAPI&lt;/acronym&gt; encryption has been successfully
    established, use &lt;function&gt;gss_wrap()&lt;/function&gt; to
    encrypt the usual StartupMessage and all subsequent data, prepending the
    length of the result from &lt;function&gt;gss_wrap()&lt;/function&gt; as a four byte
    integer in network byte order to the actual encrypted payload.  Note that
    the server will only accept encrypted packets from the client which are less
    than 16kB; &lt;function&gt;gss_wrap_size_limit()&lt;/function&gt; should be used by the
    client to determine the size of the unencrypted message which will fit
    within this limit and larger messages should be broken up into multiple
    &lt;function&gt;gss_wrap()&lt;/function&gt; calls.  Typical segments are 8kB of
    unencrypted data, resulting in encrypted packets of slightly larger than 8kB
    but well within the 16kB maximum.  The server can be expected to not send
    encrypted packets of larger than 16kB to the client.
</span>
<acronym class="acronym">GSSAPI</acronym>暗号化の確立に成功したら、<code class="function">gss_wrap()</code>を使って通常のStartupMessageと後続のすべてのメッセージを暗号化します。
実際に暗号化した送信データの前に、<code class="function">gss_wrap()</code>の結果をネットワークバイトオーダーで4バイトの整数にしたものを付与します。
サーバは16kB未満のクライアントからの暗号化パケットだけを受け付けることに注意してください。
クライアントは<code class="function">gss_wrap_size_limit()</code>を使って暗号化前のメッセージの大きさがこの制限に収まるかどうかを確認し、それより大きなメッセージは複数の<code class="function">gss_wrap()</code>呼び出しに分解すべきです。
典型的なセグメントは暗号化前で8kBのデータで、暗号化後のパケットは8kBより少し大きくなりますが、最大長の16kB以内には問題なく収まります。
サーバは16kBよりも大きな暗号化パケットをクライアントに送らないものと期待することができます。
   </p><p>
<span class="original">
    While the protocol itself does not provide a way for the server to
    force &lt;acronym&gt;GSSAPI&lt;/acronym&gt; encryption, the administrator can
    configure the server to reject unencrypted sessions as a byproduct
    of authentication checking.
</span>
プロトコル自身はサーバに<acronym class="acronym">GSSAPI</acronym>暗号化を強制する方法を提供していませんが、管理者は認証チェックの副次的効果として暗号化されていないセッションをサーバが拒否するように設定できます。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="protocol-overview.html" title="55.1. 概要">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="protocol.html" title="第55章 フロントエンド/バックエンドプロトコル">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="sasl-authentication.html" title="55.3. SASL認証">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">55.1. 概要 </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 15rc1文書">ホーム</a></td><td width="40%" align="right" valign="top"> 55.3. SASL認証</td></tr></table></div></body></html>