<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.15. 配列</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="datatype-json.html" title="8.14. JSONデータ型" /><link rel="next" href="rowtypes.html" title="8.16. 複合型" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="other_version"><a href="https://www.postgresql.jp/document/">バージョンごとのドキュメント一覧</a></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 15.0文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="datatype.html" title="第8章 データ型">第8章 データ型</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?template=bug_report.yml&amp;what-happened=version 15.0 : arrays.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="datatype-json.html" title="8.14. JSONデータ型">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="datatype.html" title="第8章 データ型">上へ</a></td><td width="60%" align="center">8.15. 配列</td><td width="20%" align="right"> <a accesskey="n" href="rowtypes.html" title="8.16. 複合型">次へ</a></td></tr></table><hr /></div><div class="sect1" id="ARRAYS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8.15. 配列</h2></div></div></div><span class="original">
 &lt;title&gt;Arrays&lt;/title&gt;
</span><a id="id-1.5.7.25.2" class="indexterm"></a><a id="id-1.5.7.25.3" class="indexterm"></a><p>
<span class="original">
  &lt;productname&gt;PostgreSQL&lt;/productname&gt; allows columns of a table to be
  defined as variable-length multidimensional arrays. Arrays of any
  built-in or user-defined base type, enum type, composite type, range type,
  or domain can be created.
</span>
<span class="productname">PostgreSQL</span>ではテーブルの列を可変長多次元配列として定義できます。
あらゆる組み込み型あるいはユーザ定義の基本型、列挙型、複合型、範囲型そしてドメインの配列も作成可能です。
 </p><div class="sect2" id="ARRAYS-DECLARATION"><div class="titlepage"><div><div><h3 class="title">8.15.1. 配列型の宣言</h3></div></div></div><span class="original">
  &lt;title&gt;Declaration of Array Types&lt;/title&gt;
</span><a id="id-1.5.7.25.5.2" class="indexterm"></a><a id="id-1.5.7.25.5.3" class="indexterm"></a><p>
<span class="original">
  To illustrate the use of array types, we create this table:
</span>
実際に配列の使い方を説明するために、次のテーブルを作成します。
</p><pre class="programlisting">
CREATE TABLE sal_emp (
    name            text,
    pay_by_quarter  integer[],
    schedule        text[][]
);
</pre><p>
<span class="original">
  As shown, an array data type is named by appending square brackets
  (&lt;literal&gt;[]&lt;/literal&gt;) to the data type name of the array elements.  The
  above command will create a table named
  &lt;structname&gt;sal_emp&lt;/structname&gt; with a column of type
  &lt;type&gt;text&lt;/type&gt; (&lt;structfield&gt;name&lt;/structfield&gt;), a
  one-dimensional array of type &lt;type&gt;integer&lt;/type&gt;
  (&lt;structfield&gt;pay_by_quarter&lt;/structfield&gt;), which represents the
  employee's salary by quarter, and a two-dimensional array of
  &lt;type&gt;text&lt;/type&gt; (&lt;structfield&gt;schedule&lt;/structfield&gt;), which
  represents the employee's weekly schedule.
</span>
見ておわかりのように配列データ型は配列要素のデータ型の名前に大括弧（<code class="literal">[]</code>）を付けて指定します。
このコマンドは<code class="type">text</code>型文字列（<code class="structfield">name</code>）、従業員の四半期の給与を保存する<code class="type">integer</code>型の一次元配列（<code class="structfield">pay_by_quarter</code>）、そして従業員の週間スケジュールを保存する<code class="type">text</code>型の二次元配列（<code class="structfield">schedule</code>）の列を持つ<code class="structname">sal_emp</code>という名前のテーブルを作成します。
 </p><p>
<span class="original">
  The syntax for &lt;command&gt;CREATE TABLE&lt;/command&gt; allows the exact size of
  arrays to be specified, for example:
</span>
<code class="command">CREATE TABLE</code>構文で指定する配列の正確な大きさを指定することができます。

</p><pre class="programlisting">
CREATE TABLE tictactoe (
    squares   integer[3][3]
);
</pre><p>

<span class="original">
  However, the current implementation ignores any supplied array size
  limits, i.e., the behavior is the same as for arrays of unspecified
  length.
</span>
とは言っても現在の実装では指定された配列の大きさの制限を無視します。
つまり、長さの指定がない配列と同じ振舞いをします。
 </p><p>
<span class="original">
  The current implementation does not enforce the declared
  number of dimensions either.  Arrays of a particular element type are
  all considered to be of the same type, regardless of size or number
  of dimensions.  So, declaring the array size or number of dimensions in
  &lt;command&gt;CREATE TABLE&lt;/command&gt; is simply documentation; it does not
  affect run-time behavior.
</span>
現在の実装では次元数の宣言も強制していません。
特定の要素型の配列はすべて大きさあるいは次元数とは無関係に同じ型とみなされます。
ですから<code class="command">CREATE TABLE</code>で配列の大きさや次元数を宣言することは、単なる説明です。
実行時の動作に影響を及ぼしません。
 </p><p>
<span class="original">
  An alternative syntax, which conforms to the SQL standard by using
  the keyword &lt;literal&gt;ARRAY&lt;/literal&gt;, can be used for one-dimensional arrays.
  &lt;structfield&gt;pay_by_quarter&lt;/structfield&gt; could have been defined
  as:
</span>
SQLに準拠し、<code class="literal">ARRAY</code>キーワードを使用したもう1つの構文を一次元配列に使うことができます。
<code class="structfield">pay_by_quarter</code>を次のように定義することもできます。
</p><pre class="programlisting">
    pay_by_quarter  integer ARRAY[4],
</pre><p>
<span class="original">
  Or, if no array size is to be specified:
</span>
または、もし配列の大きさが指定されない場合は次のようになります。
</p><pre class="programlisting">
    pay_by_quarter  integer ARRAY,
</pre><p>
<span class="original">
  As before, however, &lt;productname&gt;PostgreSQL&lt;/productname&gt; does not enforce the
  size restriction in any case.
</span>
しかし、前で触れたように<span class="productname">PostgreSQL</span>はどんな場合でも大きさの制限を強要しません。
 </p></div><div class="sect2" id="ARRAYS-INPUT"><div class="titlepage"><div><div><h3 class="title">8.15.2. 配列の値の入力</h3></div></div></div><span class="original">
  &lt;title&gt;Array Value Input&lt;/title&gt;
</span><a id="id-1.5.7.25.6.2" class="indexterm"></a><a id="id-1.5.7.25.6.3" class="indexterm"></a><p>
<span class="original">
   To write an array value as a literal constant, enclose the element
   values within curly braces and separate them by commas.  (If you
   know C, this is not unlike the C syntax for initializing
   structures.)  You can put double quotes around any element value,
   and must do so if it contains commas or curly braces.  (More
   details appear below.)  Thus, the general format of an array
   constant is the following:
</span>
リテラル定数として配列の値を書き込むには、その要素の値を中括弧で囲み、それぞれの要素の値をカンマで区切ります
（C言語を知っているならば、構造体を初期化するための構文のようなものと考えてください）。
要素の値を二重引用符でくくることもでき、カンマもしくは中括弧がある時は必ずそのように書かなければなりません
（詳細は以下に出てきます）。
したがって配列定数の一般的書式は次のようになります。
</p><pre class="synopsis">
'{ <em class="replaceable"><code>val1</code></em> <em class="replaceable"><code>delim</code></em> <em class="replaceable"><code>val2</code></em> <em class="replaceable"><code>delim</code></em> ... }'
</pre><p>
<span class="original">
   where &lt;replaceable&gt;delim&lt;/replaceable&gt; is the delimiter character
   for the type, as recorded in its &lt;literal&gt;pg_type&lt;/literal&gt; entry.
   Among the standard data types provided in the
   &lt;productname&gt;PostgreSQL&lt;/productname&gt; distribution, all use a comma
   (&lt;literal&gt;,&lt;/literal&gt;), except for type &lt;type&gt;box&lt;/type&gt; which uses a semicolon
   (&lt;literal&gt;;&lt;/literal&gt;). Each &lt;replaceable&gt;val&lt;/replaceable&gt; is
   either a constant of the array element type, or a subarray. An example
   of an array constant is:
</span>
ここで<em class="replaceable"><code>delim</code></em>はその<code class="literal">pg_type</code>項目に記録されている型の区切り文字です。
<span class="productname">PostgreSQL</span>配布物で提供されている標準データ型の内、セミコロン（<code class="literal">;</code>）を使用する<code class="type">box</code>型を除き、すべてはカンマ（<code class="literal">,</code>）を使います。
それぞれの<em class="replaceable"><code>val</code></em>は配列要素の型の定数か副配列です。
配列定数の例を以下に示します。
</p><pre class="programlisting">
'{{1,2,3},{4,5,6},{7,8,9}}'
</pre><p>
<span class="original">
   This constant is a two-dimensional, 3-by-3 array consisting of
   three subarrays of integers.
</span>
この定数は整数の3つの副配列を持っている二次元3×3の配列です。
  </p><p>
<span class="original">
   To set an element of an array constant to NULL, write &lt;literal&gt;NULL&lt;/literal&gt;
   for the element value.  (Any upper- or lower-case variant of
   &lt;literal&gt;NULL&lt;/literal&gt; will do.)  If you want an actual string value
   &lt;quote&gt;NULL&lt;/quote&gt;, you must put double quotes around it.
</span>
配列定数の要素をNULLとするためには、その要素値に<code class="literal">NULL</code>と記載してください。
（<code class="literal">NULL</code>を大文字で書いても小文字で書いても構いません。）
<span class="quote">「<span class="quote">NULL</span>」</span>という文字列値を指定したければ、二重引用符でくくって記載しなければなりません。
  </p><p>
<span class="original">
   (These kinds of array constants are actually only a special case of
   the generic type constants discussed in &lt;xref
   linkend="sql-syntax-constants-generic"/&gt;.  The constant is initially
   treated as a string and passed to the array input conversion
   routine.  An explicit type specification might be necessary.)
</span>
（この種の配列定数は実際<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS-GENERIC" title="4.1.2.7. 他の型の定数">4.1.2.7</a>で説明されている一般型定数の特別の場合に過ぎません。
この定数は元々文字列として扱われていて配列入力ルーチンに渡されます。
明示的な型指定が必要かもしれません。）
  </p><p>
<span class="original">
   Now we can show some &lt;command&gt;INSERT&lt;/command&gt; statements:
</span>
では、<code class="command">INSERT</code>文をいくつか紹介します。

</p><pre class="programlisting">
INSERT INTO sal_emp
    VALUES ('Bill',
    '{10000, 10000, 10000, 10000}',
    '{{"meeting", "lunch"}, {"training", "presentation"}}');

INSERT INTO sal_emp
    VALUES ('Carol',
    '{20000, 25000, 25000, 25000}',
    '{{"breakfast", "consulting"}, {"meeting", "lunch"}}');
</pre><p>
  </p><p>
<span class="original">
  The result of the previous two inserts looks like this:
</span>
上に記載した2つの挿入文の結果は次のようになります。

</p><pre class="programlisting">
SELECT * FROM sal_emp;
 name  |      pay_by_quarter       |                 schedule
-------+---------------------------+-------------------------------------------
 Bill  | {10000,10000,10000,10000} | {{meeting,lunch},{training,presentation}}
 Carol | {20000,25000,25000,25000} | {{breakfast,consulting},{meeting,lunch}}
(2 rows)
</pre><p>
 </p><p>
<span class="original">
  Multidimensional arrays must have matching extents for each
  dimension. A mismatch causes an error, for example:
</span>
多次元配列では、各次元の範囲を合わせなければなりません。
一致しないと以下のようにエラーが発生します。

</p><pre class="programlisting">
INSERT INTO sal_emp
    VALUES ('Bill',
    '{10000, 10000, 10000, 10000}',
    '{{"meeting", "lunch"}, {"meeting"}}');
ERROR:  multidimensional arrays must have array expressions with matching dimensions
</pre><p>
 </p><p>
<span class="original">
  The &lt;literal&gt;ARRAY&lt;/literal&gt; constructor syntax can also be used:
</span>
<code class="literal">ARRAY</code>生成子構文も使えます。
</p><pre class="programlisting">
INSERT INTO sal_emp
    VALUES ('Bill',
    ARRAY[10000, 10000, 10000, 10000],
    ARRAY[['meeting', 'lunch'], ['training', 'presentation']]);

INSERT INTO sal_emp
    VALUES ('Carol',
    ARRAY[20000, 25000, 25000, 25000],
    ARRAY[['breakfast', 'consulting'], ['meeting', 'lunch']]);
</pre><p>
<span class="original">
  Notice that the array elements are ordinary SQL constants or
  expressions; for instance, string literals are single quoted, instead of
  double quoted as they would be in an array literal.  The &lt;literal&gt;ARRAY&lt;/literal&gt;
  constructor syntax is discussed in more detail in
  &lt;xref linkend="sql-syntax-array-constructors"/&gt;.
</span>
配列要素は通常のSQL定数もしくは演算式であることに注意してください。
例えば文字列リテラルは配列リテラルと同様、二重引用符ではなく単一引用符でくくられます。
<code class="literal">ARRAY</code>生成子構文は<a class="xref" href="sql-expressions.html#SQL-SYNTAX-ARRAY-CONSTRUCTORS" title="4.2.12. 配列コンストラクタ">4.2.12</a>により詳しい説明があります。
 </p></div><div class="sect2" id="ARRAYS-ACCESSING"><div class="titlepage"><div><div><h3 class="title">8.15.3. 配列へのアクセス</h3></div></div></div><span class="original">
  &lt;title&gt;Accessing Arrays&lt;/title&gt;
</span><a id="id-1.5.7.25.7.2" class="indexterm"></a><a id="id-1.5.7.25.7.3" class="indexterm"></a><p>
<span class="original">
  Now, we can run some queries on the table.
  First, we show how to access a single element of an array.
  This query retrieves the names of the employees whose pay changed in
  the second quarter:
</span>
ではテーブルに対していくつかの問い合わせを行ってみましょう。
初めに、配列の単一要素にアクセスする方法を示します。
この問い合わせは第2四半期に給与が更新された従業員の名前を抽出します。

</p><pre class="programlisting">
SELECT name FROM sal_emp WHERE pay_by_quarter[1] &lt;&gt; pay_by_quarter[2];

 name
-------
 Carol
(1 row)
</pre><p>

<span class="original">
  The array subscript numbers are written within square brackets.
  By default &lt;productname&gt;PostgreSQL&lt;/productname&gt; uses a
  one-based numbering convention for arrays, that is,
  an array of &lt;replaceable&gt;n&lt;/replaceable&gt; elements starts with &lt;literal&gt;array[1]&lt;/literal&gt; and
  ends with &lt;literal&gt;array[&lt;replaceable&gt;n&lt;/replaceable&gt;]&lt;/literal&gt;.
</span>
配列の添字番号は大括弧で囲んで記述されます。
デフォルトで<span class="productname">PostgreSQL</span>は配列に対し「1始まり」の振り番規定を採用しています。
つまり要素が<em class="replaceable"><code>n</code></em>個ある配列は<code class="literal">array[1]</code>で始まり、<code class="literal">array[<em class="replaceable"><code>n</code></em>]</code>で終わります。
 </p><p>
<span class="original">
  This query retrieves the third quarter pay of all employees:
</span>
次の問い合わせは全ての従業員の第3四半期の給与を抽出します。

</p><pre class="programlisting">
SELECT pay_by_quarter[3] FROM sal_emp;

 pay_by_quarter
----------------
          10000
          25000
(2 rows)
</pre><p>
 </p><p>
<span class="original">
  We can also access arbitrary rectangular slices of an array, or
  subarrays.  An array slice is denoted by writing
  &lt;literal&gt;&lt;replaceable&gt;lower-bound&lt;/replaceable&gt;:&lt;replaceable&gt;upper-bound&lt;/replaceable&gt;&lt;/literal&gt;
  for one or more array dimensions.  For example, this query retrieves the first
  item on Bill's schedule for the first two days of the week:
</span>
また、配列や副配列の任意の縦方向の部分を切り出すこともできます。
一次元以上の配列についてその一部を表現するには、<code class="literal"><em class="replaceable"><code>lower-bound</code></em>:<em class="replaceable"><code>upper-bound</code></em></code>と記述します。
例えばこの問い合わせはBillのその週の初めの2日に最初何が予定されているかを抽出します。

</p><pre class="programlisting">
SELECT schedule[1:2][1:1] FROM sal_emp WHERE name = 'Bill';

        schedule
------------------------
 {{meeting},{training}}
(1 row)
</pre><p>

<span class="original">
  If any dimension is written as a slice, i.e., contains a colon, then all
  dimensions are treated as slices.  Any dimension that has only a single
  number (no colon) is treated as being from 1
  to the number specified.  For example, &lt;literal&gt;[2]&lt;/literal&gt; is treated as
  &lt;literal&gt;[1:2]&lt;/literal&gt;, as in this example:
</span>
任意の次元を部分として、つまりコロンを含めて記述すると、すべての次元が部分として扱われます。
単一の番号のみ（コロンを持たない）を持つ次元はすべて、1から指定番号までと扱われます。
例えば、<code class="literal">[2]</code>は以下の例のように <code class="literal">[1:2]</code>と扱われます。

</p><pre class="programlisting">
SELECT schedule[1:2][2] FROM sal_emp WHERE name = 'Bill';

                 schedule
-------------------------------------------
 {{meeting,lunch},{training,presentation}}
(1 row)
</pre><p>

<span class="original">
  To avoid confusion with the non-slice case, it's best to use slice syntax
  for all dimensions, e.g., &lt;literal&gt;[1:2][1:1]&lt;/literal&gt;, not &lt;literal&gt;[2][1:1]&lt;/literal&gt;.
</span>
切り出しのない場合と混乱を避けるため、すべての次元に対し切り出し構文を使用することが最善です。
例えば、<code class="literal">[2][1:1]</code>ではなく、<code class="literal">[1:2][1:1]</code>のようにします。
 </p><p>
<span class="original">
  It is possible to omit the &lt;replaceable&gt;lower-bound&lt;/replaceable&gt; and/or
  &lt;replaceable&gt;upper-bound&lt;/replaceable&gt; of a slice specifier; the missing
  bound is replaced by the lower or upper limit of the array's subscripts.
  For example:
</span>
切り出し指定子の<em class="replaceable"><code>lower-bound</code></em>、<em class="replaceable"><code>upper-bound</code></em>は省略可能です。省略された上限または下限は、配列の添字の上限または下限で置き換えられます。
例えば、

</p><pre class="programlisting">
SELECT schedule[:2][2:] FROM sal_emp WHERE name = 'Bill';

        schedule
------------------------
 {{lunch},{presentation}}
(1 row)

SELECT schedule[:][1:1] FROM sal_emp WHERE name = 'Bill';

        schedule
------------------------
 {{meeting},{training}}
(1 row)
</pre><p>
 </p><p>
<span class="original">
  An array subscript expression will return null if either the array itself or
  any of the subscript expressions are null.  Also, null is returned if a
  subscript is outside the array bounds (this case does not raise an error).
  For example, if &lt;literal&gt;schedule&lt;/literal&gt;
  currently has the dimensions &lt;literal&gt;[1:3][1:2]&lt;/literal&gt; then referencing
  &lt;literal&gt;schedule[3][3]&lt;/literal&gt; yields NULL.  Similarly, an array reference
  with the wrong number of subscripts yields a null rather than an error.
</span>
配列自体がNULLもしくはその添字式がNULLとなる場合、配列添字式はNULLを返します。
また、配列の範囲を超える添字の場合もNULLが返されます（この場合はエラーになりません）。
例えば、<code class="literal">schedule</code>が現在<code class="literal">[1:3][1:2]</code>次元であれば、<code class="literal">schedule[3][3]</code>の参照はNULLとなります。
同様にして、添字として間違った値を指定して配列を参照した場合もエラーではなく、NULLが返されます。
 </p><p>
<span class="original">
  An array slice expression likewise yields null if the array itself or
  any of the subscript expressions are null.  However, in other
  cases such as selecting an array slice that
  is completely outside the current array bounds, a slice expression
  yields an empty (zero-dimensional) array instead of null.  (This
  does not match non-slice behavior and is done for historical reasons.)
  If the requested slice partially overlaps the array bounds, then it
  is silently reduced to just the overlapping region instead of
  returning null.
</span>
同様に、部分配列式も配列自体がNULLもしくはその添字式がNULLとなる場合にNULLを返します。
しかし、現在の配列範囲を完全に超えた部分配列を選択する場合では、部分配列式はNULLではなく空の（0次元）の配列を返します。
（これは切り出しなしの動作に一致せず、歴史的理由で行われるものです。）
要求された部分配列が配列の範囲に重なる場合、NULLを返さずに、警告なく重複部分だけに減少させます。
 </p><p>
<span class="original">
  The current dimensions of any array value can be retrieved with the
  &lt;function&gt;array_dims&lt;/function&gt; function:
</span>
<code class="function">array_dims</code>関数で任意の配列値の現在の次元を取り出せます。

</p><pre class="programlisting">
SELECT array_dims(schedule) FROM sal_emp WHERE name = 'Carol';

 array_dims
------------
 [1:2][1:2]
(1 row)
</pre><p>

<span class="original">
  &lt;function&gt;array_dims&lt;/function&gt; produces a &lt;type&gt;text&lt;/type&gt; result,
  which is convenient for people to read but perhaps inconvenient
  for programs.  Dimensions can also be retrieved with
  &lt;function&gt;array_upper&lt;/function&gt; and &lt;function&gt;array_lower&lt;/function&gt;,
  which return the upper and lower bound of a
  specified array dimension, respectively:
</span>
<code class="function">array_dims</code>関数は<code class="type">text</code>型で結果を返します。
人間が結果を見るためには便利ですが、プログラムにとって都合がよくありません。
次元は<code class="function">array_upper</code>と<code class="function">array_lower</code>でも抽出することができ、それぞれ特定の配列の次元の上限と下限を返します。

</p><pre class="programlisting">
SELECT array_upper(schedule, 1) FROM sal_emp WHERE name = 'Carol';

 array_upper
-------------
           2
(1 row)
</pre><p>

<span class="original">
 &lt;function&gt;array_length&lt;/function&gt; will return the length of a specified
 array dimension:
</span>
<code class="function">array_length</code>は指定された配列次元の長さを返します。

</p><pre class="programlisting">
SELECT array_length(schedule, 1) FROM sal_emp WHERE name = 'Carol';

 array_length
--------------
            2
(1 row)
</pre><p>

<span class="original">
 &lt;function&gt;cardinality&lt;/function&gt; returns the total number of elements in an
 array across all dimensions.  It is effectively the number of rows a call to
 &lt;function&gt;unnest&lt;/function&gt; would yield:
</span>
<code class="function">cardinality</code>は配列の全次元に渡る要素の総数を返します。
実質的に<code class="function">unnest</code>の呼び出しで生成される行の数です。

</p><pre class="programlisting">
SELECT cardinality(schedule) FROM sal_emp WHERE name = 'Carol';

 cardinality
-------------
           4
(1 row)
</pre><p>
 </p></div><div class="sect2" id="ARRAYS-MODIFYING"><div class="titlepage"><div><div><h3 class="title">8.15.4. 配列の変更</h3></div></div></div><span class="original">
  &lt;title&gt;Modifying Arrays&lt;/title&gt;
</span><a id="id-1.5.7.25.8.2" class="indexterm"></a><a id="id-1.5.7.25.8.3" class="indexterm"></a><p>
<span class="original">
  An array value can be replaced completely:
</span>
配列の値を全て置き換えることができます。

</p><pre class="programlisting">
UPDATE sal_emp SET pay_by_quarter = '{25000,25000,27000,27000}'
    WHERE name = 'Carol';
</pre><p>

<span class="original">
  or using the &lt;literal&gt;ARRAY&lt;/literal&gt; expression syntax:
</span>
もしくは<code class="literal">ARRAY</code>演算構文を用いて次のように書きます。

</p><pre class="programlisting">
UPDATE sal_emp SET pay_by_quarter = ARRAY[25000,25000,27000,27000]
    WHERE name = 'Carol';
</pre><p>

<span class="original">
  An array can also be updated at a single element:
</span>
配列の1つの要素を更新することも可能です。

</p><pre class="programlisting">
UPDATE sal_emp SET pay_by_quarter[4] = 15000
    WHERE name = 'Bill';
</pre><p>

<span class="original">
  or updated in a slice:
</span>
あるいは一部分の更新も可能です。

</p><pre class="programlisting">
UPDATE sal_emp SET pay_by_quarter[1:2] = '{27000,27000}'
    WHERE name = 'Carol';
</pre><p>

<span class="original">
  The slice syntaxes with omitted &lt;replaceable&gt;lower-bound&lt;/replaceable&gt; and/or
  &lt;replaceable&gt;upper-bound&lt;/replaceable&gt; can be used too, but only when
  updating an array value that is not NULL or zero-dimensional (otherwise,
  there is no existing subscript limit to substitute).
</span>
<em class="replaceable"><code>lower-bound</code></em>や<em class="replaceable"><code>upper-bound</code></em>が省略された切り出し構文も使用可能ですが、NULLや0次元でない配列の値を更新する場合に限ります(さもなければ、置き換えるべき添字の上限、下限が存在しません)。
 </p><p>
<span class="original">
  A stored array value can be enlarged by assigning to elements not already
  present.  Any positions between those previously present and the newly
  assigned elements will be filled with nulls.  For example, if array
  &lt;literal&gt;myarray&lt;/literal&gt; currently has 4 elements, it will have six
  elements after an update that assigns to &lt;literal&gt;myarray[6]&lt;/literal&gt;;
  &lt;literal&gt;myarray[5]&lt;/literal&gt; will contain null.
  Currently, enlargement in this fashion is only allowed for one-dimensional
  arrays, not multidimensional arrays.
</span>
保存されている配列の値は、存在しない要素に代入することで拡張することができます。
過去に存在した位置と新しく代入された位置との間はNULLで埋められます。
例えば、現在配列<code class="literal">myarray</code>の要素数が4の場合、<code class="literal">myarray[6]</code>を割り当てる更新の後6要素を持つことなり、<code class="literal">myarray[5]</code>はNULLを含みます。
現在、こうした方法での拡張は、1次元配列でのみ許されます。
多次元配列では行うことができません。
 </p><p>
<span class="original">
  Subscripted assignment allows creation of arrays that do not use one-based
  subscripts.  For example one might assign to &lt;literal&gt;myarray[-2:7]&lt;/literal&gt; to
  create an array with subscript values from -2 to 7.
</span>
添字指定の代入で1始まり以外の添字がある配列を作れます。
例えば添字が-2から7までの値を持つ配列を<code class="literal">array[-2:7]</code>で指定できます。
 </p><p>
<span class="original">
  New array values can also be constructed using the concatenation operator,
  &lt;literal&gt;||&lt;/literal&gt;:
</span>
新規の配列の値は連結演算子<code class="literal">||</code>を用いて作成することもできます。
</p><pre class="programlisting">
SELECT ARRAY[1,2] || ARRAY[3,4];
 ?column?
-----------
 {1,2,3,4}
(1 row)

SELECT ARRAY[5,6] || ARRAY[[1,2],[3,4]];
      ?column?
---------------------
 {{5,6},{1,2},{3,4}}
(1 row)
</pre><p>
 </p><p>
<span class="original">
  The concatenation operator allows a single element to be pushed onto the
  beginning or end of a one-dimensional array. It also accepts two
  &lt;replaceable&gt;N&lt;/replaceable&gt;-dimensional arrays, or an &lt;replaceable&gt;N&lt;/replaceable&gt;-dimensional
  and an &lt;replaceable&gt;N+1&lt;/replaceable&gt;-dimensional array.
</span>
連結演算子を使うと、一次元配列の最初もしくは最後に1つの要素を押し込むことができます。
さらには2つの<em class="replaceable"><code>N</code></em>-次元配列もしくは<em class="replaceable"><code>N</code></em>-次元配列と<em class="replaceable"><code>N+1</code></em>-次元配列にも対応しています。
 </p><p>
<span class="original">
  When a single element is pushed onto either the beginning or end of a
  one-dimensional array, the result is an array with the same lower bound
  subscript as the array operand. For example:
</span>
1つの要素が1次元配列の先頭や末尾に押し込まれた時、結果は配列演算項目と同じ下限添字を持つ配列となります。
以下に例を示します。
</p><pre class="programlisting">
SELECT array_dims(1 || '[0:1]={2,3}'::int[]);
 array_dims
------------
 [0:2]
(1 row)

SELECT array_dims(ARRAY[1,2] || 3);
 array_dims
------------
 [1:3]
(1 row)
</pre><p>
 </p><p>
<span class="original">
  When two arrays with an equal number of dimensions are concatenated, the
  result retains the lower bound subscript of the left-hand operand's outer
  dimension. The result is an array comprising every element of the left-hand
  operand followed by every element of the right-hand operand. For example:
</span>
等しい次元を持った2つの配列が連結された場合、結果は左側演算項目の外側の次元の下限添字を引き継ぎます。
結果は右側被演算子のすべての要素に左側被演算子が続いた配列となります。
例を挙げます。
</p><pre class="programlisting">
SELECT array_dims(ARRAY[1,2] || ARRAY[3,4,5]);
 array_dims
------------
 [1:5]
(1 row)

SELECT array_dims(ARRAY[[1,2],[3,4]] || ARRAY[[5,6],[7,8],[9,0]]);
 array_dims
------------
 [1:5][1:2]
(1 row)
</pre><p>
 </p><p>
<span class="original">
  When an &lt;replaceable&gt;N&lt;/replaceable&gt;-dimensional array is pushed onto the beginning
  or end of an &lt;replaceable&gt;N+1&lt;/replaceable&gt;-dimensional array, the result is
  analogous to the element-array case above. Each &lt;replaceable&gt;N&lt;/replaceable&gt;-dimensional
  sub-array is essentially an element of the &lt;replaceable&gt;N+1&lt;/replaceable&gt;-dimensional
  array's outer dimension. For example:
</span>
<em class="replaceable"><code>N</code></em>-次元配列が<em class="replaceable"><code>N+1</code></em>-次元配列の最初または最後に押し込まれると、結果は上記と似通った要素配列になります。
それぞれの<em class="replaceable"><code>N</code></em>-次元副配列は本質的に<em class="replaceable"><code>N+1</code></em>-次元配列の外側の次元の要素となります。
例を挙げます。
</p><pre class="programlisting">
SELECT array_dims(ARRAY[1,2] || ARRAY[[3,4],[5,6]]);
 array_dims
------------
 [1:3][1:2]
(1 row)
</pre><p>
 </p><p>
<span class="original">
  An array can also be constructed by using the functions
  &lt;function&gt;array_prepend&lt;/function&gt;, &lt;function&gt;array_append&lt;/function&gt;,
  or &lt;function&gt;array_cat&lt;/function&gt;. The first two only support one-dimensional
  arrays, but &lt;function&gt;array_cat&lt;/function&gt; supports multidimensional arrays.
  Some examples:
</span>
配列は<code class="function">array_prepend</code>、<code class="function">array_append</code>、もしくは<code class="function">array_cat</code>を使って構築することもできます。
初めの2つは一次元配列にしか対応していませんが、<code class="function">array_cat</code>は多次元配列でも使えます。
例を挙げます。

</p><pre class="programlisting">
SELECT array_prepend(1, ARRAY[2,3]);
 array_prepend
---------------
 {1,2,3}
(1 row)

SELECT array_append(ARRAY[1,2], 3);
 array_append
--------------
 {1,2,3}
(1 row)

SELECT array_cat(ARRAY[1,2], ARRAY[3,4]);
 array_cat
-----------
 {1,2,3,4}
(1 row)

SELECT array_cat(ARRAY[[1,2],[3,4]], ARRAY[5,6]);
      array_cat
---------------------
 {{1,2},{3,4},{5,6}}
(1 row)

SELECT array_cat(ARRAY[5,6], ARRAY[[1,2],[3,4]]);
      array_cat
---------------------
 {{5,6},{1,2},{3,4}}
</pre><p>
 </p><p>
<span class="original">
  In simple cases, the concatenation operator discussed above is preferred
  over direct use of these functions.  However, because the concatenation
  operator is overloaded to serve all three cases, there are situations where
  use of one of the functions is helpful to avoid ambiguity.  For example
  consider:
</span>
単純な状況では、上で説明した連結演算子はそれぞれの関数を直接実行することよりも望ましいです。
とは言っても、連結演算子は3つの場合すべてに対応するようオーバーロードされていますので、その関数の1つを使うとあいまいさを避けるのに役立つ場合があります。
例えば、以下のような状況を考えてください。

</p><pre class="programlisting">
<span class="original">
SELECT ARRAY[1, 2] || '{3, 4}';  &amp;#45;- the untyped literal is taken as an array
</span>
SELECT ARRAY[1, 2] || '{3, 4}';  -- 型指定のないリテラルは配列と見なされる
 ?column?
-----------
 {1,2,3,4}

<span class="original">
SELECT ARRAY[1, 2] || '7';                 &amp;#45;- so is this one
</span>
SELECT ARRAY[1, 2] || '7';                 -- これも同様
ERROR:  malformed array literal: "7"

<span class="original">
SELECT ARRAY[1, 2] || NULL;                &amp;#45;- so is an undecorated NULL
</span>
SELECT ARRAY[1, 2] || NULL;                -- 修飾されていないNULLも同様
 ?column?
----------
 {1,2}
(1 row)

<span class="original">
SELECT array_append(ARRAY[1, 2], NULL);    &amp;#45;- this might have been meant
</span>
SELECT array_append(ARRAY[1, 2], NULL);    -- これがやりたかった事かも
 array_append
--------------
 {1,2,NULL}
</pre><p>

<span class="original">
  In the examples above, the parser sees an integer array on one side of the
  concatenation operator, and a constant of undetermined type on the other.
  The heuristic it uses to resolve the constant's type is to assume it's of
  the same type as the operator's other input &amp;mdash; in this case,
  integer array.  So the concatenation operator is presumed to
  represent &lt;function&gt;array_cat&lt;/function&gt;, not &lt;function&gt;array_append&lt;/function&gt;.  When
  that's the wrong choice, it could be fixed by casting the constant to the
  array's element type; but explicit use of &lt;function&gt;array_append&lt;/function&gt; might
  be a preferable solution.
</span>
上の例では、パーサは連結演算子の一方の側に整数の配列を見つけ、もう一方の側に型の決まらない定数を見つけます。
パーサが定数の型を解決するのに使う発見的手法は、演算子のもう一方の入力と同じ型(この場合には整数の配列)だと仮定することです。
そのため、連結演算子は<code class="function">array_append</code>ではなく、<code class="function">array_cat</code>と推定されます。
これが誤った選択である場合には、定数を配列の要素の型にキャストすることで直せるかもしれません。ですが、<code class="function">array_append</code>を明示的に使うのが好ましい解決法であるかもしれません。
 </p></div><div class="sect2" id="ARRAYS-SEARCHING"><div class="titlepage"><div><div><h3 class="title">8.15.5. 配列内の検索</h3></div></div></div><span class="original">
  &lt;title&gt;Searching in Arrays&lt;/title&gt;
</span><a id="id-1.5.7.25.9.2" class="indexterm"></a><a id="id-1.5.7.25.9.3" class="indexterm"></a><p>
<span class="original">
  To search for a value in an array, each value must be checked.
  This can be done manually, if you know the size of the array.
  For example:
</span>
配列内のある値を検索するにはそれぞれの値が検証されなければなりません。
もし配列の大きさがわかっているならば手作業でも検索できます。
例を挙げます。

</p><pre class="programlisting">
SELECT * FROM sal_emp WHERE pay_by_quarter[1] = 10000 OR
                            pay_by_quarter[2] = 10000 OR
                            pay_by_quarter[3] = 10000 OR
                            pay_by_quarter[4] = 10000;
</pre><p>

<span class="original">
  However, this quickly becomes tedious for large arrays, and is not
  helpful if the size of the array is unknown. An alternative method is
  described in &lt;xref linkend="functions-comparisons"/&gt;. The above
  query could be replaced by:
</span>
とは言ってもこの方法では大きい配列では大変な作業となりますし、配列の大きさが不明な場合この方法は使えません。
代わりになる方法が<a class="xref" href="functions-comparisons.html" title="9.24. 行と配列の比較">9.24</a>で説明されています。
上の問い合わせは以下のように書くことができます。

</p><pre class="programlisting">
SELECT * FROM sal_emp WHERE 10000 = ANY (pay_by_quarter);
</pre><p>

<span class="original">
  In addition, you can find rows where the array has all values
  equal to 10000 with:
</span>
さらに配列で行の値が全て10000に等しいものを見つけることもできます。

</p><pre class="programlisting">
SELECT * FROM sal_emp WHERE 10000 = ALL (pay_by_quarter);
</pre><p>

 </p><p>
<span class="original">
  Alternatively, the &lt;function&gt;generate_subscripts&lt;/function&gt; function can be used.
  For example:
</span>
代わりとして、<code class="function">generate_subscripts</code>関数を使うことができます。
以下はその例です。

</p><pre class="programlisting">
SELECT * FROM
   (SELECT pay_by_quarter,
           generate_subscripts(pay_by_quarter, 1) AS s
      FROM sal_emp) AS foo
 WHERE pay_by_quarter[s] = 10000;
</pre><p>

<span class="original">
  This function is described in &lt;xref linkend="functions-srf-subscripts"/&gt;.
</span>
この関数は<a class="xref" href="functions-srf.html#FUNCTIONS-SRF-SUBSCRIPTS" title="表9.65 添え字生成関数">表 9.65</a>に記載されています。
 </p><p>
<span class="original">
  You can also search an array using the &lt;literal&gt;&amp;amp;&amp;amp;&lt;/literal&gt; operator,
  which checks whether the left operand overlaps with the right operand.
  For instance:
</span>
<code class="literal">&amp;&amp;</code>演算子を使って配列を検索することもできます。
この演算子は左辺が右辺と重なるかどうかを調べます。
例えば、

</p><pre class="programlisting">
SELECT * FROM sal_emp WHERE pay_by_quarter &amp;&amp; ARRAY[10000];
</pre><p>

<span class="original">
  This and other array operators are further described in
  &lt;xref linkend="functions-array"/&gt;.  It can be accelerated by an appropriate
  index, as described in &lt;xref linkend="indexes-types"/&gt;.
</span>
この演算子やその他の配列の演算子は<a class="xref" href="functions-array.html" title="9.19. 配列関数と演算子">9.19</a>により詳しく書かれています。
<a class="xref" href="indexes-types.html" title="11.2. インデックスの種類">11.2</a>に書いてあるように、適切なインデックスにより高速化されます。
 </p><p>
<span class="original">
  You can also search for specific values in an array using the &lt;function&gt;array_position&lt;/function&gt;
  and &lt;function&gt;array_positions&lt;/function&gt; functions. The former returns the subscript of
  the first occurrence of a value in an array; the latter returns an array with the
  subscripts of all occurrences of the value in the array.  For example:
</span>
関数<code class="function">array_position</code>や<code class="function">array_positions</code>を使って、配列内の特定の値を検索することもできます。
前者は配列内で初めてその値が現れる添字を返し、後者は配列内でその値が現れる添字すべての配列を返します。
例えば、以下の通りです。

</p><pre class="programlisting">
SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon');
 array_position
----------------
              2
(1 row)

SELECT array_positions(ARRAY[1, 4, 3, 1, 3, 4, 2, 1], 1);
 array_positions
-----------------
 {1,4,8}
(1 row)
</pre><p>
 </p><div class="tip"><h3 class="title">ヒント</h3><p>
<span class="original">
   Arrays are not sets; searching for specific array elements
   can be a sign of database misdesign.  Consider
   using a separate table with a row for each item that would be an
   array element.  This will be easier to search, and is likely to
   scale better for a large number of elements.
</span>
配列は集合ではありません。
特定の配列要素に検索をかけることはデータベース設計が誤っている可能性があります。
配列の要素とみなされるそれぞれの項目を行に持つ別のテーブルを使うことを検討してください。
この方が検索がより簡単になり要素数が大きくなっても規模的拡張性があります。
  </p></div></div><div class="sect2" id="ARRAYS-IO"><div class="titlepage"><div><div><h3 class="title">8.15.6. 配列の入出力構文</h3></div></div></div><span class="original">
  &lt;title&gt;Array Input and Output Syntax&lt;/title&gt;
</span><a id="id-1.5.7.25.10.2" class="indexterm"></a><a id="id-1.5.7.25.10.3" class="indexterm"></a><p>
<span class="original">
   The external text representation of an array value consists of items that
   are interpreted according to the I/O conversion rules for the array's
   element type, plus decoration that indicates the array structure.
   The decoration consists of curly braces (&lt;literal&gt;{&lt;/literal&gt; and &lt;literal&gt;}&lt;/literal&gt;)
   around the array value plus delimiter characters between adjacent items.
   The delimiter character is usually a comma (&lt;literal&gt;,&lt;/literal&gt;) but can be
   something else: it is determined by the &lt;literal&gt;typdelim&lt;/literal&gt; setting
   for the array's element type.  Among the standard data types provided
   in the &lt;productname&gt;PostgreSQL&lt;/productname&gt; distribution, all use a comma,
   except for type &lt;type&gt;box&lt;/type&gt;, which uses a semicolon (&lt;literal&gt;;&lt;/literal&gt;).
   In a multidimensional array, each dimension (row, plane,
   cube, etc.) gets its own level of curly braces, and delimiters
   must be written between adjacent curly-braced entities of the same level.
</span>
配列の値の外部表現は配列の要素の型に対するI/O変換ルールに基づいて解釈された項目と配列の構造を示す装飾項目で構成されています。
装飾は配列の値を中括弧（<code class="literal">{</code>と<code class="literal">}</code>）で囲んだものと次の項目との間を区切り文字で区切ったものです。
区切り文字は通常カンマ（<code class="literal">,</code>）ですが他の文字でも構いません。
配列の要素の型<code class="literal">typdelim</code>を設定することで決まります。
<span class="productname">PostgreSQL</span>配布物における標準のデータ型の中でセミコロン（<code class="literal">;</code>）を使う<code class="type">box</code>型を除いて、すべてはカンマを使います。
多次元配列ではそれぞれの次元（行、面、立体など）はそれ自身の階層において中括弧、同じ階層の中括弧でくくられた次の塊との間に区切り文字が書かれていなければなりません。
  </p><p>
<span class="original">
   The array output routine will put double quotes around element values
   if they are empty strings, contain curly braces, delimiter characters,
   double quotes, backslashes, or white space, or match the word
   &lt;literal&gt;NULL&lt;/literal&gt;.  Double quotes and backslashes
   embedded in element values will be backslash-escaped.  For numeric
   data types it is safe to assume that double quotes will never appear, but
   for textual data types one should be prepared to cope with either the presence
   or absence of quotes.
</span>
空の文字列や中括弧や区切り文字、二重引用符、バックスラッシュ、空白、<code class="literal">NULL</code>という単語が含まれていると、配列出力処理は要素の値を二重引用符でくくります。
要素の値に組み込まれている二重引用符とバックスラッシュはバックスラッシュでエスケープされます。
数値データ型に対しては二重引用符が出現しないと想定するのが安全ですが、テキストデータ型の場合引用符がある場合とない場合に対処できるようにしておくべきです。
  </p><p>
<span class="original">
   By default, the lower bound index value of an array's dimensions is
   set to one.  To represent arrays with other lower bounds, the array
   subscript ranges can be specified explicitly before writing the
   array contents.
   This decoration consists of square brackets (&lt;literal&gt;[]&lt;/literal&gt;)
   around each array dimension's lower and upper bounds, with
   a colon (&lt;literal&gt;:&lt;/literal&gt;) delimiter character in between. The
   array dimension decoration is followed by an equal sign (&lt;literal&gt;=&lt;/literal&gt;).
   For example:
</span>
デフォルトでは配列の次元の下限インデックス値は1に設定されています。
他の下限値を持つ配列を表現したければ、配列定数を作成する前に明示的に配列添字範囲を指定することで実現できます。
修飾項目はそれぞれの配列次元の上限と下限をコロン（<code class="literal">:</code>）で区切って前後を大括弧（<code class="literal">[]</code>）でくくった形式になっています。
代入演算子（<code class="literal">=</code>）の後に配列次元修飾項目が続きます。
例を示します。
</p><pre class="programlisting">
SELECT f1[1][-2][3] AS e1, f1[1][-1][5] AS e2
 FROM (SELECT '[1:1][-2:-1][3:5]={{{1,2,3},{4,5,6}}}'::int[] AS f1) AS ss;

 e1 | e2
----+----
  1 |  6
(1 row)
</pre><p>
<span class="original">
   The array output routine will include explicit dimensions in its result
   only when there are one or more lower bounds different from one.
</span>
1とは異なる下限を持つ場合にのみ、配列出力関数はその結果に明示的な次元を含めます。
  </p><p>
<span class="original">
   If the value written for an element is &lt;literal&gt;NULL&lt;/literal&gt; (in any case
   variant), the element is taken to be NULL.  The presence of any quotes
   or backslashes disables this and allows the literal string value
   &lt;quote&gt;NULL&lt;/quote&gt; to be entered.  Also, for backward compatibility with
   pre-8.2 versions of &lt;productname&gt;PostgreSQL&lt;/productname&gt;, the &lt;xref
   linkend="guc-array-nulls"/&gt; configuration parameter can be turned
   &lt;literal&gt;off&lt;/literal&gt; to suppress recognition of &lt;literal&gt;NULL&lt;/literal&gt; as a NULL.
</span>
要素に指定された値が<code class="literal">NULL</code>（またはその亜種）の場合、要素はNULLとして扱われます。
引用符やバックスラッシュがあると、これは無効となり、<span class="quote">「<span class="quote">NULL</span>」</span>という文字列リテラルを入力することができます。
また、8.2以前の<span class="productname">PostgreSQL</span>との後方互換性のため、<a class="xref" href="runtime-config-compatible.html#GUC-ARRAY-NULLS">array_nulls</a>設定パラメータを<code class="literal">off</code>にして、<code class="literal">NULL</code>をNULLとして認識しないようにすることができます。
  </p><p>
<span class="original">
   As shown previously, when writing an array value you can use double
   quotes around any individual array element. You &lt;emphasis&gt;must&lt;/emphasis&gt; do so
   if the element value would otherwise confuse the array-value parser.
   For example, elements containing curly braces, commas (or the data type's
   delimiter character), double quotes, backslashes, or leading or trailing
   whitespace must be double-quoted.  Empty strings and strings matching the
   word &lt;literal&gt;NULL&lt;/literal&gt; must be quoted, too.  To put a double
   quote or backslash in a quoted array element value, precede it
   with a backslash. Alternatively, you can avoid quotes and use
   backslash-escaping to protect all data characters that would otherwise
   be taken as array syntax.
</span>
前に示したように配列に値を書き込む場合は独立した配列要素を二重引用符でくくります。
配列値パーサが配列要素値によって混乱を来さないように<span class="emphasis"><em>必ず</em></span>この形式を守ってください。
例えば、中括弧、カンマ（もしくはデータ型の区切り文字）、二重引用符、バックスラッシュもしくは前後に付いた空白を含む要素は必ず二重引用符でくくらなければなりません。
空文字列や<code class="literal">NULL</code>という単語自体も同様に引用符でくくらなければなりません。
二重引用符もしくはバックスラッシュを引用符付きの配列要素に付け加えたい場合、その直前にバックスラッシュを付けます。
別の方法として、配列構文とみなされかねない全てのデータ文字を保護するために、引用符を使用しないでバックスラッシュでエスケープしても構いません。
  </p><p>
<span class="original">
   You can add whitespace before a left brace or after a right
   brace. You can also add whitespace before or after any individual item
   string. In all of these cases the whitespace will be ignored. However,
   whitespace within double-quoted elements, or surrounded on both sides by
   non-whitespace characters of an element, is not ignored.
</span>
括弧の右側もしくは左側それぞれの前と後に空白を追加することができます。
同様に独立した項目の文字列の前後に空白を付け加えることもできます。
これらすべての場合において空白は無視されます。
とは言っても二重引用符で囲まれた要素の中の空白、もしくは要素の空白文字以外により両側がくくられているものは無視されません。
  </p><div class="tip"><h3 class="title">ヒント</h3><p>
<span class="original">
   The &lt;literal&gt;ARRAY&lt;/literal&gt; constructor syntax (see
   &lt;xref linkend="sql-syntax-array-constructors"/&gt;) is often easier to work
   with than the array-literal syntax when writing array values in SQL
   commands. In &lt;literal&gt;ARRAY&lt;/literal&gt;, individual element values are written the
   same way they would be written when not members of an array.
</span>
SQLコマンドの中で配列値を書く時、配列リテラル構文よりも<code class="literal">ARRAY</code>生成子構文（<a class="xref" href="sql-expressions.html#SQL-SYNTAX-ARRAY-CONSTRUCTORS" title="4.2.12. 配列コンストラクタ">4.2.12</a>を参照）の方が往々にして扱いやすい場合があります。
<code class="literal">ARRAY</code>では、個々の要素値は、配列のメンバーでない場合と同じ方法で記述されます。
  </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="datatype-json.html" title="8.14. JSONデータ型">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="datatype.html" title="第8章 データ型">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="rowtypes.html" title="8.16. 複合型">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">8.14. <acronym class="acronym">JSON</acronym>データ型 </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 15.0文書">ホーム</a></td><td width="40%" align="right" valign="top"> 8.16. 複合型</td></tr></table></div></body></html>