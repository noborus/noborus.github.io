<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.19. オブジェクト識別子データ型</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="domains.html" title="8.18. ドメイン型" /><link rel="next" href="datatype-pg-lsn.html" title="8.20. pg_lsn型" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 16.0文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="datatype.html" title="第8章 データ型">第8章 データ型</a></td><td width="20%" align="right"></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="domains.html" title="8.18. ドメイン型">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="datatype.html" title="第8章 データ型">上へ</a></td><td width="60%" align="center">8.19. オブジェクト識別子データ型</td><td width="20%" align="right"> <a accesskey="n" href="datatype-pg-lsn.html" title="8.20. pg_lsn型">次へ</a></td></tr></table><hr /></div><div class="sect1" id="DATATYPE-OID"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8.19. オブジェクト識別子データ型 <a href="#DATATYPE-OID" class="id_link">#</a></h2></div></div></div><!--
   <title>Object Identifier Types</title>
--><a id="id-1.5.7.29.2" class="indexterm"></a><a id="id-1.5.7.29.3" class="indexterm"></a><a id="id-1.5.7.29.4" class="indexterm"></a><a id="id-1.5.7.29.5" class="indexterm"></a><a id="id-1.5.7.29.6" class="indexterm"></a><a id="id-1.5.7.29.7" class="indexterm"></a><a id="id-1.5.7.29.8" class="indexterm"></a><a id="id-1.5.7.29.9" class="indexterm"></a><a id="id-1.5.7.29.10" class="indexterm"></a><a id="id-1.5.7.29.11" class="indexterm"></a><a id="id-1.5.7.29.12" class="indexterm"></a><a id="id-1.5.7.29.13" class="indexterm"></a><a id="id-1.5.7.29.14" class="indexterm"></a><a id="id-1.5.7.29.15" class="indexterm"></a><a id="id-1.5.7.29.16" class="indexterm"></a><a id="id-1.5.7.29.17" class="indexterm"></a><a id="id-1.5.7.29.18" class="indexterm"></a><a id="id-1.5.7.29.19" class="indexterm"></a><p>
<!--
    Object identifiers (OIDs) are used internally by
    <productname>PostgreSQL</productname> as primary keys for various
    system tables.
    Type <type>oid</type> represents an object identifier.  There are also
    several alias types for <type>oid</type>, each
    named <type>reg<replaceable>something</replaceable></type>.
    <xref linkend="datatype-oid-table"/> shows an
    overview.
-->
オブジェクト識別子（OID）は<span class="productname">PostgreSQL</span>の内部で様々なシステムテーブルの主キーとして使用されます。
<code class="type">oid</code>データ型はオブジェクト識別子を表します。
<code class="type">oid</code>には別名型もいくつかあります。
<code class="type">reg<em class="replaceable"><code>何とか</code></em></code>とそれぞれ名付けられた<code class="type">oid</code>の様々なエイリアスの型は<a class="xref" href="datatype-oid.html#DATATYPE-OID-TABLE" title="表8.26 オブジェクト識別子データ型">表 8.26</a>からその概要を見ることができます。
   </p><p>
<!--
    The <type>oid</type> type is currently implemented as an unsigned
    four-byte integer.  Therefore, it is not large enough to provide
    database-wide uniqueness in large databases, or even in large
    individual tables.
-->
<code class="type">oid</code>データ型は現在、符号なし4バイト整数として実装されています。
このため、大きなデータベース内でデータベース単位での一意性や個別の大きなテーブルで一意性を提供するためには十分な大きさではありません。
   </p><p>
<!--
    The <type>oid</type> type itself has few operations beyond comparison.
    It can be cast to integer, however, and then manipulated using the
    standard integer operators.  (Beware of possible
    signed-versus-unsigned confusion if you do this.)
-->
<code class="type">oid</code>データ型自体は、比較以外の演算はほとんど行いません。
しかし、整数としてキャストすることもでき、その場合標準の整数演算子を使用して操作することができます。
（これを行うと、符号付きと符号なしの間で混乱が起きかねないことに注意してください。）
   </p><p>
<!--
    The OID alias types have no operations of their own except
    for specialized input and output routines.  These routines are able
    to accept and display symbolic names for system objects, rather than
    the raw numeric value that type <type>oid</type> would use.  The alias
    types allow simplified lookup of OID values for objects.  For example,
    to examine the <structname>pg_attribute</structname> rows related to a table
    <literal>mytable</literal>, one could write:
-->
OIDの別名データ型は、専用の入出力ルーチン以外には演算を行いません。
これらのルーチンでは、<code class="type">oid</code>型が使用するような未加工の数値ではなく、システムオブジェクト用のシンボル名を受け入れたり表示したりできます。
別名データ型により、オブジェクトのOID値の検索が簡単になります。
例えば、<code class="literal">mytable</code>テーブルに関連した<code class="structname">pg_attribute</code>行を確認するには、以下のように記述することができます。
</p><pre class="programlisting">
SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;
</pre><p>
<!--
    rather than:
-->
次のように記述する必要はありません。
</p><pre class="programlisting">
SELECT * FROM pg_attribute
  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');
</pre><p>
<!--
    While that doesn't look all that bad by itself, it's still oversimplified.
    A far more complicated sub-select would be needed to
    select the right OID if there are multiple tables named
    <literal>mytable</literal> in different schemas.
    The <type>regclass</type> input converter handles the table lookup according
    to the schema path setting, and so it does the <quote>right thing</quote>
    automatically.  Similarly, casting a table's OID to
    <type>regclass</type> is handy for symbolic display of a numeric OID.
-->
後者もそう悪くないように見えますが、これは過度に単純化されています。
異なるスキーマに<code class="literal">mytable</code>テーブルが複数ある場合には、正しいOIDを選択するために、より複雑なsub-SELECTが必要となります。
<code class="type">regclass</code>入力変換ではスキーマパスの設定に従ってテーブル検索を扱いますので、自動的に<span class="quote">「<span class="quote">正しい検索</span>」</span>を行います。
同様に、テーブルのOIDを<code class="type">regclass</code>にキャストすることは、数値のOIDのシンボル表示に便利です。
   </p><div class="table" id="DATATYPE-OID-TABLE"><p class="title"><strong>表8.26 オブジェクト識別子データ型</strong></p><div class="table-contents"><!--
     <title>Object Identifier Types</title>
--><table class="table" summary="オブジェクト識別子データ型" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>型名</th><th>参照</th><th>説明</th><th>値の例</th></tr></thead><tbody><tr><td><code class="type">oid</code></td><td>すべて</td><td>数値オブジェクト識別子</td><td><code class="literal">564182</code></td></tr><tr><td><code class="type">regclass</code></td><td><code class="structname">pg_class</code></td><td>リレーション名</td><td><code class="literal">pg_type</code></td></tr><tr><td><code class="type">regcollation</code></td><td><code class="structname">pg_collation</code></td><td>照合名</td><td><code class="literal">"POSIX"</code></td></tr><tr><td><code class="type">regconfig</code></td><td><code class="structname">pg_ts_config</code></td><td>テキスト検索設定</td><td><code class="literal">english</code></td></tr><tr><td><code class="type">regdictionary</code></td><td><code class="structname">pg_ts_dict</code></td><td>テキスト検索辞書</td><td><code class="literal">simple</code></td></tr><tr><td><code class="type">regnamespace</code></td><td><code class="structname">pg_namespace</code></td><td>名前空間名</td><td><code class="literal">pg_catalog</code></td></tr><tr><td><code class="type">regoper</code></td><td><code class="structname">pg_operator</code></td><td>演算子名</td><td><code class="literal">+</code></td></tr><tr><td><code class="type">regoperator</code></td><td><code class="structname">pg_operator</code></td><td>引数の型を持つ演算子</td><td><code class="literal">*(integer,​integer)</code>
         or <code class="literal">-(NONE,​integer)</code></td></tr><tr><td><code class="type">regproc</code></td><td><code class="structname">pg_proc</code></td><td>関数名</td><td><code class="literal">sum</code></td></tr><tr><td><code class="type">regprocedure</code></td><td><code class="structname">pg_proc</code></td><td>引数の型を持つ関数</td><td><code class="literal">sum(int4)</code></td></tr><tr><td><code class="type">regrole</code></td><td><code class="structname">pg_authid</code></td><td>ロール名</td><td><code class="literal">smithee</code></td></tr><tr><td><code class="type">regtype</code></td><td><code class="structname">pg_type</code></td><td>データ型の名前</td><td><code class="literal">integer</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
<!--
    All of the OID alias types for objects that are grouped by namespace
    accept schema-qualified names, and will
    display schema-qualified names on output if the object would not
    be found in the current search path without being qualified.
    For example, <literal>myschema.mytable</literal> is acceptable input
    for <type>regclass</type> (if there is such a table).  That value
    might be output as <literal>myschema.mytable</literal>, or
    just <literal>mytable</literal>, depending on the current search path.
    The <type>regproc</type> and <type>regoper</type> alias types will only
    accept input names that are unique (not overloaded), so they are
    of limited use; for most uses <type>regprocedure</type> or
    <type>regoperator</type> are more appropriate.  For <type>regoperator</type>,
    unary operators are identified by writing <literal>NONE</literal> for the unused
    operand.
-->
名前空間でグループ化されたオブジェクトのOID別名型はすべてスキーマ修飾名を受け入れ、出力時にスキーマ修飾名を表示します。
ただし、現在の検索パスでオブジェクトが見つけられなければ、修飾せずに出力します。
例えば、<code class="literal">myschema.mytable</code>は<code class="type">regclass</code>という入力を(そのようなテーブルがあれば)許容します。
この値の出力は現在の検索パス次第で<code class="literal">myschema.mytable</code>もしくは単に<code class="literal">mytable</code>と出力されるでしょう。
<code class="type">regproc</code>と<code class="type">regoper</code>別名型は、一意な（オーバーロードしていない）名前のみを入力として受け入れるため、これらの使用には限度があります。
ほとんどの場合、<code class="type">regprocedure</code>または<code class="type">regoperator</code>を使用するのが適切です。
<code class="type">regoperator</code>の場合、単項演算子は未使用のオペランドを<code class="literal">NONE</code>と記述することによって指定されます。
   </p><p>
<!--
    The input functions for these types allow whitespace between tokens,
    and will fold upper-case letters to lower case, except within double
    quotes; this is done to make the syntax rules similar to the way
    object names are written in SQL.  Conversely, the output functions
    will use double quotes if needed to make the output be a valid SQL
    identifier.  For example, the OID of a function
    named <literal>Foo</literal> (with upper case <literal>F</literal>)
    taking two integer arguments could be entered as
    <literal>' "Foo" ( int, integer ) '::regprocedure</literal>.  The
    output would look like <literal>"Foo"(integer,integer)</literal>.
    Both the function name and the argument type names could be
    schema-qualified, too.
-->
これらの型の入力を許容する関数はトークンの間に空白を入れることを許容し、二重引用符で囲まれたものを除き大文字は小文字に折りたたみます。
これはオブジェクト名がSQLで記述される方法と同じような文法のルールとするための動作です。
逆に出力する関数は有効なSQL識別子となるように必要に応じて二重引用符を使用します。
例えば、<code class="literal">Foo</code>(<code class="literal">F</code>が大文字)という２つの整数型の引数を持つ関数のOIDは<code class="literal">' "Foo" ( int, integer ) '::regprocedure</code>として入力できます。
出力は<code class="literal">"Foo"(integer,integer)</code>のようになります。
関数名も引数の型名も共にスキーマ修飾することもできます。
   </p><p>
<!--
    Many built-in <productname>PostgreSQL</productname> functions accept
    the OID of a table, or another kind of database object, and for
    convenience are declared as taking <type>regclass</type> (or the
    appropriate OID alias type).  This means you do not have to look up
    the object's OID by hand, but can just enter its name as a string
    literal.  For example, the <function>nextval(regclass)</function> function
    takes a sequence relation's OID, so you could call it like this:
-->
<span class="productname">PostgreSQL</span>に組み込まれている多くの関数はテーブルやそれ以外の種類のデータベースオブジェクトのOIDを受け入れ、利便性のために <code class="type">regclass</code>(もしくは適切なOIDのエイリアスである型)を取るものとして定義されています。
これはオブジェクトのOIDをわざわざ手動で調べる必要が無く、単にその名前を文字列として入力すれば良いことを意味します。
例えば、 <code class="function">nextval(regclass)</code>関数はシーケンスリレーションのOIDを引数に取りますが、このように呼び出すことができます。
</p><pre class="programlisting">
<!--
nextval('foo')              <lineannotation>operates on sequence <literal>foo</literal></lineannotation>
nextval('FOO')              <lineannotation>same as above</lineannotation>
nextval('"Foo"')            <lineannotation>operates on sequence <literal>Foo</literal></lineannotation>
nextval('myschema.foo')     <lineannotation>operates on <literal>myschema.foo</literal></lineannotation>
nextval('"myschema".foo')   <lineannotation>same as above</lineannotation>
nextval('foo')              <lineannotation>searches search path for <literal>foo</literal></lineannotation>
-->
nextval('foo')              <em class="lineannotation"><span class="lineannotation">シーケンス<code class="literal">foo</code>への操作</span></em>
nextval('FOO')              <em class="lineannotation"><span class="lineannotation">上と同じ</span></em>
nextval('"Foo"')            <em class="lineannotation"><span class="lineannotation">シーケンス<code class="literal">Foo</code>への操作</span></em>
nextval('myschema.foo')     <em class="lineannotation"><span class="lineannotation"><code class="literal">myschema.foo</code>への操作</span></em>
nextval('"myschema".foo')   <em class="lineannotation"><span class="lineannotation">上と同じ</span></em>
nextval('foo')              <em class="lineannotation"><span class="lineannotation"><code class="literal">foo</code>のサーチパスの検索</span></em>
</pre><p>
   </p><div class="note"><h3 class="title">注記</h3><p>
<!--
     When you write the argument of such a function as an unadorned
     literal string, it becomes a constant of type <type>regclass</type>
     (or the appropriate type).
     Since this is really just an OID, it will track the originally
     identified object despite later renaming, schema reassignment,
     etc.  This <quote>early binding</quote> behavior is usually desirable for
     object references in column defaults and views.  But sometimes you might
     want <quote>late binding</quote> where the object reference is resolved
     at run time.  To get late-binding behavior, force the constant to be
     stored as a <type>text</type> constant instead of <type>regclass</type>:
<programlisting>
nextval('foo'::text)      <lineannotation><literal>foo</literal> is looked up at runtime</lineannotation>
</programlisting>
     The <function>to_regclass()</function> function and its siblings
     can also be used to perform run-time lookups.  See
     <xref linkend="functions-info-catalog-table"/>.
-->
そのような関数の引数を装飾のない文字列として記載した場合、それは<code class="type">regclass</code>型(もしくは適切な型)の定数になります。
これは実際には単にOIDなので、スキーマの再割り当てなどで後からリネームされたとしても最初に識別されたオブジェクトを追跡します。
この<span class="quote">「<span class="quote">早期バインディング(early binding)</span>」</span>の動作は列のデフォルトを参照する列やビューにとっては望ましい動作です。
しかし、オブジェクトの参照を実行時に行う<span class="quote">「<span class="quote">遅延バインディング(late binding)</span>」</span>が望ましいこともあります。
遅延バインディングの動作とするためには、定数は<code class="type">regclass</code>の代わりに<code class="type">text</code>の定数として配置してください。
</p><pre class="programlisting">
nextval('foo'::text)      <em class="lineannotation"><span class="lineannotation"><code class="literal">foo</code>は実行時に参照されます。</span></em>
</pre><p>
<code class="function">to_regclass()</code>関数とその兄弟は実行時に参照させるために使用することもできます。
詳細は<a class="xref" href="functions-info.html#FUNCTIONS-INFO-CATALOG-TABLE" title="表9.72 システムカタログ情報関数">表 9.72</a>を参照ください。
    </p></div><p>
<!--
    Another practical example of use of <type>regclass</type>
    is to look up the OID of a table listed in
    the <literal>information_schema</literal> views, which don't supply
    such OIDs directly.  One might for example wish to call
    the <function>pg_relation_size()</function> function, which requires
    the table OID.  Taking the above rules into account, the correct way
    to do that is
<programlisting>
SELECT table_schema, table_name,
       pg_relation_size((quote_ident(table_schema) || '.' ||
                         quote_ident(table_name))::regclass)
FROM information_schema.tables
WHERE ...
</programlisting>
    The <function>quote_ident()</function> function will take care of
    double-quoting the identifiers where needed.  The seemingly easier
<programlisting>
SELECT pg_relation_size(table_name)
FROM information_schema.tables
WHERE ...
</programlisting>
    is <emphasis>not recommended</emphasis>, because it will fail for
    tables that are outside your search path or have names that require
    quoting.
-->
<code class="type">regclass</code>のもう一つの実用的な使用例はそのようなOIDを直接提供しない<code class="literal">information_schema</code>ビューにリストされたテーブルのOIDを参照することです。
例えば、テーブルのOIDを必要とする<code class="function">pg_relation_size()</code>関数を呼び出したい場合を考えます。
上記のルールを考慮すると、正しい方法は以下のとおりです。
</p><pre class="programlisting">
SELECT table_schema, table_name,
       pg_relation_size((quote_ident(table_schema) || '.' ||
                         quote_ident(table_name))::regclass)
FROM information_schema.tables
WHERE ...
</pre><p>
<code class="function">quote_ident()</code>関数は必要に応じて二重引用符をつけます。
より簡単そうに思われる
</p><pre class="programlisting">
SELECT pg_relation_size(table_name)
FROM information_schema.tables
WHERE ...
</pre><p>
という方法は<span class="emphasis"><em>推奨されません</em></span>。
テーブルがサーチパスの範囲外にあったり、引用符付けを必要とする名前であった場合に失敗するためです。
   </p><p>
<!--
    An additional property of most of the OID alias types is the creation of
    dependencies.  If a
    constant of one of these types appears in a stored expression
    (such as a column default expression or view), it creates a dependency
    on the referenced object.  For example, if a column has a default
    expression <literal>nextval('my_seq'::regclass)</literal>,
    <productname>PostgreSQL</productname>
    understands that the default expression depends on the sequence
    <literal>my_seq</literal>, so the system will not let the sequence
    be dropped without first removing the default expression.  The
    alternative of <literal>nextval('my_seq'::text)</literal> does not
    create a dependency.
    (<type>regrole</type> is an exception to this property. Constants of this
    type are not allowed in stored expressions.)
-->
ほとんどのOID別名型のさらなる属性は依存性の作成です。
これらの型の1つの定数が格納された式内に存在する場合（列のデフォルト式やビューなど）、参照されるオブジェクトへの依存性を生成します。
例えば、列が<code class="literal">nextval('my_seq'::regclass)</code>というデフォルト式を持つ場合、<span class="productname">PostgreSQL</span>はデフォルト式が<code class="literal">my_seq</code>シーケンスに依存することを理解します。
システムは先にこのデフォルト式が削除されない限り、このシーケンスを削除させません。
代わりに<code class="literal">nextval('my_seq'::text)</code>を使用しても依存性は作成されません。
(このプロパティの例外は<code class="type">regrole</code>です。
ストアド式では、この型の定数は使用できません。)
   </p><p>
<!--
    Another identifier type used by the system is <type>xid</type>, or transaction
    (abbreviated <abbrev>xact</abbrev>) identifier.  This is the data type of the system columns
    <structfield>xmin</structfield> and <structfield>xmax</structfield>.  Transaction identifiers are 32-bit quantities.
    In some contexts, a 64-bit variant <type>xid8</type> is used.  Unlike
    <type>xid</type> values, <type>xid8</type> values increase strictly
    monotonically and cannot be reused in the lifetime of a database
    cluster.  See <xref linkend="transaction-id"/> for more details.
-->
《マッチ度[85.144928]》システムが使用するもう1つの識別子の型は<code class="type">xid</code>、すなわちトランザクション（略して<abbr class="abbrev">xact</abbr>）識別子です。
これは<code class="structfield">xmin</code>システム列および<code class="structfield">xmax</code>システム列のデータ型です。
トランザクション識別子は32ビット長です。
文脈によっては64bitに変形した<code class="type">xid8</code>が使われます。
<code class="type">xid</code>の値と違い <code class="type">xid8</code>の値は厳密に単調増加し、データベースクラスタのライフタイムの中で再利用されることはありません。
《機械翻訳》システムで使用されるもう1つの識別子タイプは、<code class="type">xid</code>またはトランザクション<abbr class="abbrev">省略形xact</abbr>識別子です。
これは、システム列<code class="structfield">xmin</code>および<code class="structfield">xmax</code>のデータタイプです。
トランザクション識別子は32ビットの数量です。
状況によっては、64ビットのバリアント<code class="type">xid8</code>が使用されます。
<code class="type">xid</code>値とは異なり、<code class="type">xid8</code>値は厳密に単調に増加し、データベースクラスタの存続期間中に再使用することはできません。
詳細は<a class="xref" href="transaction-id.html" title="74.1. Transactions and Identifiers">74.1</a>を参照してください。
   </p><p>
<!--
    A third identifier type used by the system is <type>cid</type>, or
    command identifier.  This is the data type of the system columns
    <structfield>cmin</structfield> and <structfield>cmax</structfield>. Command identifiers are also 32-bit quantities.
-->
システムが使用する3つ目の識別子は<code class="type">cid</code>、すなわちコマンド識別子です。
これは<code class="structfield">cmin</code>システム列および<code class="structfield">cmax</code>システム列のデータ型です。
コマンド識別子も32ビット長です。
   </p><p>
<!--
    A final identifier type used by the system is <type>tid</type>, or tuple
    identifier (row identifier).  This is the data type of the system column
    <structfield>ctid</structfield>.  A tuple ID is a pair
    (block number, tuple index within block) that identifies the
    physical location of the row within its table.
-->
システムが使用する最後の識別子は<code class="type">tid</code>、すなわちタプル識別子（行識別子）です。
これは<code class="structfield">ctid</code>システム列のデータ型です。
タプルIDはテーブル内の行の物理的位置を識別するための組（ブロック番号、ブロック内のタプルインデックス）です。
   </p><p>
<!--
    (The system columns are further explained in <xref
    linkend="ddl-system-columns"/>.)
-->
（システム列の詳細は<a class="xref" href="ddl-system-columns.html" title="5.5. システム列">5.5</a>で説明します。）
   </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="domains.html" title="8.18. ドメイン型">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="datatype.html" title="第8章 データ型">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="datatype-pg-lsn.html" title="8.20. pg_lsn型">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">8.18. ドメイン型 </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 16.0文書">ホーム</a></td><td width="40%" align="right" valign="top"> 8.20. <code class="type">pg_lsn</code>型</td></tr></table></div></body></html>