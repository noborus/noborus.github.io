<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE TRIGGER</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-createtransform.html" title="CREATE TRANSFORM" /><link rel="next" href="sql-createtype.html" title="CREATE TYPE" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="other_version"><a href="https://www.postgresql.jp/document/">バージョンごとのドキュメント一覧</a></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 15.0文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="sql-commands.html" title="SQLコマンド">SQLコマンド</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?template=bug_report.yml&amp;what-happened=version 15.0 : sql-createtrigger.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createtransform.html" title="CREATE TRANSFORM">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">上へ</a></td><td width="60%" align="center">CREATE TRIGGER</td><td width="20%" align="right"> <a accesskey="n" href="sql-createtype.html" title="CREATE TYPE">次へ</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATETRIGGER"><div class="titlepage"></div><a id="id-1.9.3.93.1" class="indexterm"></a><a id="id-1.9.3.93.2" class="indexterm"></a><a id="id-1.9.3.93.3" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE TRIGGER</span></h2><p>CREATE TRIGGER<span class="original">
  &lt;refpurpose&gt;define a new trigger&lt;/refpurpose&gt;
</span> — 新しいトリガを定義する</p></div><div class="refsynopsisdiv"><h2>概要</h2><pre class="synopsis">
CREATE [ OR REPLACE ] [ CONSTRAINT ] TRIGGER <em class="replaceable"><code>name</code></em> { BEFORE | AFTER | INSTEAD OF } { <em class="replaceable"><code>event</code></em> [ OR ... ] }
    ON <em class="replaceable"><code>table_name</code></em>
    [ FROM <em class="replaceable"><code>referenced_table_name</code></em> ]
    [ NOT DEFERRABLE | [ DEFERRABLE ] [ INITIALLY IMMEDIATE | INITIALLY DEFERRED ] ]
    [ REFERENCING { { OLD | NEW } TABLE [ AS ] <em class="replaceable"><code>transition_relation_name</code></em> } [ ... ] ]
    [ FOR [ EACH ] { ROW | STATEMENT } ]
    [ WHEN ( <em class="replaceable"><code>condition</code></em> ) ]
    EXECUTE { FUNCTION | PROCEDURE } <em class="replaceable"><code>function_name</code></em> ( <em class="replaceable"><code>arguments</code></em> )

<span class="original">
&lt;phrase&gt;where &lt;replaceable class="parameter"&gt;event&lt;/replaceable&gt; can be one of:&lt;/phrase&gt;
</span>
<span class="phrase">
ここで<em class="replaceable"><code>event</code></em>は以下のいずれかを取ることができます。
</span>

    INSERT
    UPDATE [ OF <em class="replaceable"><code>column_name</code></em> [, ... ] ]
    DELETE
    TRUNCATE
</pre></div><div class="refsect1" id="id-1.9.3.93.7"><h2>説明</h2><span class="original">
  &lt;title&gt;Description&lt;/title&gt;
</span><p>
<span class="original">
   &lt;command&gt;CREATE TRIGGER&lt;/command&gt; creates a new trigger.
   &lt;command&gt;CREATE OR REPLACE TRIGGER&lt;/command&gt; will either create a
   new trigger, or replace an existing trigger.  The
   trigger will be associated with the specified table, view, or foreign table
   and will execute the specified
   function &lt;replaceable class="parameter"&gt;function_name&lt;/replaceable&gt; when
   certain operations are performed on that table.
</span>
<code class="command">CREATE TRIGGER</code>は新しいトリガを作成します。
<code class="command">CREATE OR REPLACE TRIGGER</code>は新しいトリガを作成、または、既存のトリガを置き換えます。
作成したトリガは指定したテーブル、ビューまたは外部テーブルと関連付けられ、そのテーブルに特定の操作が行われた時に指定した関数<em class="replaceable"><code>function_name</code></em>を実行します。
  </p><p>
<span class="original">
   To replace the current definition of an existing trigger, use
   &lt;command&gt;CREATE OR REPLACE TRIGGER&lt;/command&gt;, specifying the existing
   trigger's name and parent table.  All other properties are replaced.
</span>
既存トリガの現在の定義を置き換えるには、既存のトリガ名と親テーブルを指定して<code class="command">CREATE OR REPLACE TRIGGER</code>を使用してください。
その他の属性はすべて置き換えられます。
  </p><p>
<span class="original">
   The trigger can be specified to fire before the
   operation is attempted on a row (before constraints are checked and
   the &lt;command&gt;INSERT&lt;/command&gt;, &lt;command&gt;UPDATE&lt;/command&gt;, or
   &lt;command&gt;DELETE&lt;/command&gt; is attempted); or after the operation has
   completed (after constraints are checked and the
   &lt;command&gt;INSERT&lt;/command&gt;, &lt;command&gt;UPDATE&lt;/command&gt;, or
   &lt;command&gt;DELETE&lt;/command&gt; has completed); or instead of the operation
   (in the case of inserts, updates or deletes on a view).
   If the trigger fires before or instead of the event, the trigger can skip
   the operation for the current row, or change the row being inserted (for
   &lt;command&gt;INSERT&lt;/command&gt; and &lt;command&gt;UPDATE&lt;/command&gt; operations
   only). If the trigger fires after the event, all changes, including
   the effects of other triggers, are &lt;quote&gt;visible&lt;/quote&gt;
   to the trigger.
</span>
トリガでは、起動のタイミングとして、行への操作が開始される前（制約条件のチェックと<code class="command">INSERT</code>、<code class="command">UPDATE</code>または<code class="command">DELETE</code>が行われる前）、操作が完了した後（制約条件がチェックされ、<code class="command">INSERT</code>、<code class="command">UPDATE</code>または<code class="command">DELETE</code>が完了した後）、操作の代わり（ビューにおける挿入、更新、削除の場合）のいずれかを指定することができます。
イベントの前または代わりにトリガが起動する場合、そのトリガは対象行に対する操作を省略したり、（<code class="command">INSERT</code>と<code class="command">UPDATE</code>の操作時のみ）挿入する行を変更したりすることができます。
イベントの後にトリガが起動する場合、他のトリガの影響を含む全ての変更が、トリガに対して<span class="quote">「<span class="quote">可視</span>」</span>状態となります。
  </p><p>
<span class="original">
   A trigger that is marked &lt;literal&gt;FOR EACH ROW&lt;/literal&gt; is called
   once for every row that the operation modifies. For example, a
   &lt;command&gt;DELETE&lt;/command&gt; that affects 10 rows will cause any
   &lt;literal&gt;ON DELETE&lt;/literal&gt; triggers on the target relation to be
   called 10 separate times, once for each deleted row. In contrast, a
   trigger that is marked &lt;literal&gt;FOR EACH STATEMENT&lt;/literal&gt; only
   executes once for any given operation, regardless of how many rows
   it modifies (in particular, an operation that modifies zero rows
   will still result in the execution of any applicable &lt;literal&gt;FOR
   EACH STATEMENT&lt;/literal&gt; triggers).
</span>
<code class="literal">FOR EACH ROW</code>付きのトリガは、その操作によって変更される行ごとに1回ずつ呼び出されます。
例えば、10行に影響を与える<code class="command">DELETE</code>操作は、対象リレーション上のすべての<code class="literal">ON DELETE</code>トリガを、削除される各行について1回ずつ、個別に10回呼び出すことになります。
反対に、<code class="literal">FOR EACH STATEMENT</code>付きのトリガは、その操作によって何行変更されたかにかかわらず、任意の操作ごとに1回のみ実行されます
（変更対象が0行となる操作でも、適用できるすべての<code class="literal">FOR EACH STATEMENT</code>トリガが実行されます）。
  </p><p>
<span class="original">
   Triggers that are specified to fire &lt;literal&gt;INSTEAD OF&lt;/literal&gt; the trigger
   event must be marked &lt;literal&gt;FOR EACH ROW&lt;/literal&gt;, and can only be defined
   on views. &lt;literal&gt;BEFORE&lt;/literal&gt; and &lt;literal&gt;AFTER&lt;/literal&gt; triggers on a view
   must be marked as &lt;literal&gt;FOR EACH STATEMENT&lt;/literal&gt;.
</span>
トリガイベントの<code class="literal">INSTEAD OF</code>として発行されるように指定されたトリガは<code class="literal">FOR EACH ROW</code>印を付けなければなりません。
またビュー上にのみ定義することができます。
ビューに対する<code class="literal">BEFORE</code>および<code class="literal">AFTER</code>トリガは<code class="literal">FOR EACH STATEMENT</code>印を付けなければなりません。
  </p><p>
<span class="original">
   In addition, triggers may be defined to fire for
   &lt;command&gt;TRUNCATE&lt;/command&gt;, though only
   &lt;literal&gt;FOR EACH STATEMENT&lt;/literal&gt;.
</span>
さらに、<code class="literal">FOR EACH STATEMENT</code>のみですが、トリガを<code class="command">TRUNCATE</code>に対して発行するように定義することができます。
  </p><p>
<span class="original">
   The following table summarizes which types of triggers may be used on
   tables, views, and foreign tables:
</span>
以下の表にどの種類のトリガがテーブル、ビュー、外部テーブルに対して使用できるかをまとめます。
  </p><div class="informaltable" id="SUPPORTED-TRIGGER-TYPES"><table class="informaltable" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>いつ</th><th>イベント</th><th>行レベル</th><th>文レベル</th></tr></thead><tbody><tr><td rowspan="2" align="center"><code class="literal">BEFORE</code></td><td align="center"><code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code></td><td align="center">テーブル、および外部テーブル</td><td align="center">テーブル、ビューおよび外部テーブル</td></tr><tr><td align="center"><code class="command">TRUNCATE</code></td><td align="center">—</td><td align="center">テーブル</td></tr><tr><td rowspan="2" align="center"><code class="literal">AFTER</code></td><td align="center"><code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code></td><td align="center">テーブルおよび外部テーブル</td><td align="center">テーブル、ビューおよび外部テーブル</td></tr><tr><td align="center"><code class="command">TRUNCATE</code></td><td align="center">—</td><td align="center">テーブル</td></tr><tr><td rowspan="2" align="center"><code class="literal">INSTEAD OF</code></td><td align="center"><code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code></td><td align="center">ビュー</td><td align="center">—</td></tr><tr><td align="center"><code class="command">TRUNCATE</code></td><td align="center">—</td><td align="center">—</td></tr></tbody></table></div><p>
<span class="original">
   Also, a trigger definition can specify a Boolean &lt;literal&gt;WHEN&lt;/literal&gt;
   condition, which will be tested to see whether the trigger should
   be fired.  In row-level triggers the &lt;literal&gt;WHEN&lt;/literal&gt; condition can
   examine the old and/or new values of columns of the row.  Statement-level
   triggers can also have &lt;literal&gt;WHEN&lt;/literal&gt; conditions, although the feature
   is not so useful for them since the condition cannot refer to any values
   in the table.
</span>
またトリガ定義では、論理値の<code class="literal">WHEN</code>条件を指定することができ、これによってトリガを発行すべきかどうかが判定されます。
行レベルのトリガでは、<code class="literal">WHEN</code>条件は行の列の古い値、新しい値、またはその両方で検証することができます。
文レベルのトリガでも<code class="literal">WHEN</code>条件を持たせることができますが、条件としてテーブル内のどの値も参照することができませんので、この機能はあまり有用ではありません
  </p><p>
<span class="original">
   If multiple triggers of the same kind are defined for the same event,
   they will be fired in alphabetical order by name.
</span>
同一イベントに同じ種類の複数のトリガが定義された場合、名前のアルファベット順で実行されます。
  </p><p>
<span class="original">
   When the &lt;literal&gt;CONSTRAINT&lt;/literal&gt; option is specified, this command creates a
   &lt;firstterm&gt;constraint trigger&lt;/firstterm&gt;.&lt;indexterm&gt;&lt;primary&gt;trigger&lt;/primary&gt;
   &lt;secondary&gt;constraint trigger&lt;/secondary&gt;&lt;/indexterm&gt;
   This is the same as a regular trigger
   except that the timing of the trigger firing can be adjusted using
   &lt;link linkend="sql-set-constraints"&gt;&lt;command&gt;SET CONSTRAINTS&lt;/command&gt;&lt;/link&gt;.
   Constraint triggers must be &lt;literal&gt;AFTER ROW&lt;/literal&gt; triggers on plain
   tables (not foreign tables).  They
   can be fired either at the end of the statement causing the triggering
   event, or at the end of the containing transaction; in the latter case they
   are said to be &lt;firstterm&gt;deferred&lt;/firstterm&gt;.  A pending deferred-trigger firing
   can also be forced to happen immediately by using &lt;command&gt;SET
   CONSTRAINTS&lt;/command&gt;.  Constraint triggers are expected to raise an exception
   when the constraints they implement are violated.
</span>
《マッチ度[86.114101]》<code class="literal">CONSTRAINT</code>オプションが指定された場合、このコマンドは<em class="firstterm">制約トリガ</em>を作成します。
これは、<a class="link" href="sql-set-constraints.html" title="SET CONSTRAINTS"><code class="command">SET CONSTRAINTS</code></a>を使用してトリガを発行するタイミングを調整することができるという点を除き、通常のトリガと同じです。
制約トリガは（外部テーブルではない）普通のテーブルの<code class="literal">AFTER ROW</code>トリガでなければなりません。
トリガイベントを引き起こした文の最後、またはそれを含むトランザクションの最後のいずれかで発行することができます。
後者の場合、<em class="firstterm">遅延</em>と呼ばれます。
<code class="command">SET CONSTRAINTS</code>を使用することで、強制的に待機中の遅延トリガの発行を即座に行わせることができます。
制約トリガは、実装する制約に違反した時に例外を発生するものと想定されています。
  </p><p>
<span class="original">
   The &lt;literal&gt;REFERENCING&lt;/literal&gt; option enables collection
   of &lt;firstterm&gt;transition relations&lt;/firstterm&gt;, which are row sets that include all
   of the rows inserted, deleted, or modified by the current SQL statement.
   This feature lets the trigger see a global view of what the statement did,
   not just one row at a time.  This option is only allowed for
   an &lt;literal&gt;AFTER&lt;/literal&gt; trigger that is not a constraint trigger; also, if
   the trigger is an &lt;literal&gt;UPDATE&lt;/literal&gt; trigger, it must not specify
   a &lt;replaceable class="parameter"&gt;column_name&lt;/replaceable&gt; list.
   &lt;literal&gt;OLD TABLE&lt;/literal&gt; may only be specified once, and only for a trigger
   that can fire on &lt;literal&gt;UPDATE&lt;/literal&gt; or &lt;literal&gt;DELETE&lt;/literal&gt;; it creates a
   transition relation containing the &lt;firstterm&gt;before-images&lt;/firstterm&gt; of all rows
   updated or deleted by the statement.
   Similarly, &lt;literal&gt;NEW TABLE&lt;/literal&gt; may only be specified once, and only for
   a trigger that can fire on &lt;literal&gt;UPDATE&lt;/literal&gt; or &lt;literal&gt;INSERT&lt;/literal&gt;;
   it creates a transition relation containing the &lt;firstterm&gt;after-images&lt;/firstterm&gt;
   of all rows updated or inserted by the statement.
</span>
<code class="literal">REFERENCING</code>オプションは<em class="firstterm">遷移リレーション</em>の収集を有効にします。
遷移リレーションとは現在のSQL文によって挿入、削除または修正されたすべての行を含む行集合です。
この機能により、トリガはSQL文によって行われたことを、一度に1行ずつだけではなく、全体のビューとして参照することができます。
このオプションは、制約トリガではない<code class="literal">AFTER</code>トリガについてのみ使うことができます。
また、トリガが<code class="literal">UPDATE</code>トリガの場合、<em class="replaceable"><code>column_name</code></em>のリストを指定してはいけません。
<code class="literal">OLD TABLE</code>は一度だけ指定することができ、<code class="literal">UPDATE</code>または<code class="literal">DELETE</code>のときに実行されるトリガにのみ指定できます。
これは文によって更新または削除されるすべての行の<em class="firstterm">更新前イメージ</em>を含む遷移リレーションを作成します。
同様に、<code class="literal">NEW TABLE</code>は一度だけ指定することができ、<code class="literal">UPDATE</code>または<code class="literal">INSERT</code>のときに実行されるトリガにのみ指定できます。
これは、文によって更新または挿入されるすべての行の<em class="firstterm">更新後イメージ</em>を含む遷移リレーションを作成します。
  </p><p>
<span class="original">
   &lt;command&gt;SELECT&lt;/command&gt; does not modify any rows so you cannot
   create &lt;command&gt;SELECT&lt;/command&gt; triggers.  Rules and views may provide
   workable solutions to problems that seem to need &lt;command&gt;SELECT&lt;/command&gt;
   triggers.
</span>
<code class="command">SELECT</code>はまったく行を変更しないため、<code class="command">SELECT</code>トリガを作成することはできません。
<code class="command">SELECT</code>トリガが必要に見える問題には、ルールやビューが現実的な解決策を提供できるでしょう。
  </p><p>
<span class="original">
   Refer to &lt;xref linkend="triggers"/&gt; for more information about triggers.
</span>
トリガに関するより詳細については、<a class="xref" href="triggers.html" title="第39章 トリガ">第39章</a>を参照してください。
  </p></div><div class="refsect1" id="id-1.9.3.93.8"><h2>パラメータ</h2><span class="original">
  &lt;title&gt;Parameters&lt;/title&gt;
</span><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>name</code></em></span></dt><dd><p>
<span class="original">
      The name to give the new trigger.  This must be distinct from
      the name of any other trigger for the same table.
      The name cannot be schema-qualified &amp;mdash; the trigger inherits the
      schema of its table.  For a constraint trigger, this is also the name to
      use when modifying the trigger's behavior using
      &lt;command&gt;SET CONSTRAINTS&lt;/command&gt;.
</span>
新しいトリガに付与する名前です。
同じテーブルの他のトリガと異なる名前にする必要があります。
名前をスキーマ修飾することはできません。
トリガはそのテーブルのスキーマを引き継ぎます。
制約トリガの場合、この名前が<code class="command">SET CONSTRAINTS</code>を使用してトリガの動作を変更する時に使用されます。
     </p></dd><dt><span class="term"><code class="literal">BEFORE</code><br /></span><span class="term"><code class="literal">AFTER</code><br /></span><span class="term"><code class="literal">INSTEAD OF</code></span></dt><dd><p>
<span class="original">
      Determines whether the function is called before, after, or instead of
      the event.  A constraint trigger can only be specified as
      &lt;literal&gt;AFTER&lt;/literal&gt;.
</span>
関数の呼び出しをイベントの前に行うか後に行うか、それとも代替として行うかを決定します。
制約トリガでは<code class="literal">AFTER</code>としてしか指定することができません。
     </p></dd><dt><span class="term"><em class="replaceable"><code>event</code></em></span></dt><dd><p>
<span class="original">
      One of &lt;literal&gt;INSERT&lt;/literal&gt;, &lt;literal&gt;UPDATE&lt;/literal&gt;,
      &lt;literal&gt;DELETE&lt;/literal&gt;, or &lt;literal&gt;TRUNCATE&lt;/literal&gt;;
      this specifies the event that will fire the trigger. Multiple
      events can be specified using &lt;literal&gt;OR&lt;/literal&gt;, except when
      transition relations are requested.
</span>
<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、<code class="literal">TRUNCATE</code>のいずれかが入ります。
このパラメータは、トリガを起動するイベントを指定します。
遷移リレーションが要求される場合を除き、<code class="literal">OR</code>を使用して、複数のイベントを指定することができます。
     </p><p>
<span class="original">
      For &lt;literal&gt;UPDATE&lt;/literal&gt; events, it is possible to
      specify a list of columns using this syntax:
</span>
<code class="literal">UPDATE</code>イベントでは、以下の構文を使用して列リストを指定することができます。
</p><pre class="synopsis">
UPDATE OF <em class="replaceable"><code>column_name1</code></em> [, <em class="replaceable"><code>column_name2</code></em> ... ]
</pre><p>
<span class="original">
      The trigger will only fire if at least one of the listed columns
      is mentioned as a target of the &lt;command&gt;UPDATE&lt;/command&gt; command
      or if one of the listed columns is a generated column that depends on a
      column that is the target of the &lt;command&gt;UPDATE&lt;/command&gt;.
</span>
このトリガは、<code class="command">UPDATE</code>コマンドの対象として列挙された列のいずれか少なくとも1つの列が指定された場合に、もしくは列挙された列の1つが<code class="command">UPDATE</code>の対象の列に依存する生成列である場合に、発行されます。
     </p><p>
<span class="original">
      &lt;literal&gt;INSTEAD OF UPDATE&lt;/literal&gt; events do not allow a list of columns.
      A column list cannot be specified when requesting transition relations,
      either.
</span>
<code class="literal">INSTEAD OF UPDATE</code>イベントでは列リストを使用できません。
遷移リレーションを要求する場合も列リストを指定することはできません。
     </p></dd><dt><span class="term"><em class="replaceable"><code>table_name</code></em></span></dt><dd><p>
<span class="original">
      The name (optionally schema-qualified) of the table, view, or foreign
      table the trigger is for.
</span>
トリガを作成するテーブル、ビューまたは外部テーブルの名前です（スキーマ修飾名も可）。
     </p></dd><dt><span class="term"><em class="replaceable"><code>referenced_table_name</code></em></span></dt><dd><p>
<span class="original">
      The (possibly schema-qualified) name of another table referenced by the
      constraint.  This option is used for foreign-key constraints and is not
      recommended for general use.  This can only be specified for
      constraint triggers.
</span>
制約で参照される他のテーブルの名前（スキーマ修飾可）です。
このオプションは外部キー制約で使用されるものであり、一般利用を推奨しません。
これは制約トリガでのみ指定することができます。
     </p></dd><dt><span class="term"><code class="literal">DEFERRABLE</code><br /></span><span class="term"><code class="literal">NOT DEFERRABLE</code><br /></span><span class="term"><code class="literal">INITIALLY IMMEDIATE</code><br /></span><span class="term"><code class="literal">INITIALLY DEFERRED</code></span></dt><dd><p>
<span class="original">
      The default timing of the trigger.
      See the &lt;xref linkend="sql-createtable"/&gt; documentation for details of
      these constraint options.  This can only be specified for constraint
      triggers.
</span>
トリガのデフォルトのタイミングです。
これらの制約オプションについては<a class="xref" href="sql-createtable.html" title="CREATE TABLE"><span class="refentrytitle">CREATE TABLE</span></a>文書を参照してください。
これは制約トリガでのみ指定することができます。
     </p></dd><dt><span class="term"><code class="literal">REFERENCING</code></span></dt><dd><p>
<span class="original">
      This keyword immediately precedes the declaration of one or two
      relation names that provide access to the transition relations of the
      triggering statement.
</span>
このキーワードは、トリガの文の遷移リレーションへのアクセスを提供する1つまたは2つのリレーション名の宣言の直前に起きます。
     </p></dd><dt><span class="term"><code class="literal">OLD TABLE</code><br /></span><span class="term"><code class="literal">NEW TABLE</code></span></dt><dd><p>
<span class="original">
      This clause indicates whether the following relation name is for the
      before-image transition relation or the after-image transition
      relation.
</span>
この句は、それに続くリレーション名が更新前イメージの遷移リレーションなのか、更新後イメージの遷移リレーションなのかを示します。
     </p></dd><dt><span class="term"><em class="replaceable"><code>transition_relation_name</code></em></span></dt><dd><p>
<span class="original">
      The (unqualified) name to be used within the trigger for this
      transition relation.
</span>
この遷移リレーションについて、トリガ内で使用される（修飾されていない）名前です。
     </p></dd><dt><span class="term"><code class="literal">FOR EACH ROW</code><br /></span><span class="term"><code class="literal">FOR EACH STATEMENT</code></span></dt><dd><p>
<span class="original">
      This specifies whether the trigger function should be fired
      once for every row affected by the trigger event, or just once
      per SQL statement. If neither is specified, &lt;literal&gt;FOR EACH
      STATEMENT&lt;/literal&gt; is the default.  Constraint triggers can only
      be specified &lt;literal&gt;FOR EACH ROW&lt;/literal&gt;.
</span>
このパラメータは、トリガ関数を、トリガイベントによって影響を受ける行ごとに1回起動するか、SQL文ごとに1回のみ起動するかを指定します。
どちらも指定されない場合は、<code class="literal">FOR EACH STATEMENT</code>がデフォルトです。
制約トリガは<code class="literal">FOR EACH ROW</code>のみ指定することができます。
     </p></dd><dt><span class="term"><em class="replaceable"><code>condition</code></em></span></dt><dd><p>
<span class="original">
      A Boolean expression that determines whether the trigger function
      will actually be executed.  If &lt;literal&gt;WHEN&lt;/literal&gt; is specified, the
      function will only be called if the &lt;replaceable
      class="parameter"&gt;condition&lt;/replaceable&gt; returns &lt;literal&gt;true&lt;/literal&gt;.
      In &lt;literal&gt;FOR EACH ROW&lt;/literal&gt; triggers, the &lt;literal&gt;WHEN&lt;/literal&gt;
      condition can refer to columns of the old and/or new row values
      by writing &lt;literal&gt;OLD.&lt;replaceable
      class="parameter"&gt;column_name&lt;/replaceable&gt;&lt;/literal&gt; or
      &lt;literal&gt;NEW.&lt;replaceable
      class="parameter"&gt;column_name&lt;/replaceable&gt;&lt;/literal&gt; respectively.
      Of course, &lt;literal&gt;INSERT&lt;/literal&gt; triggers cannot refer to &lt;literal&gt;OLD&lt;/literal&gt;
      and &lt;literal&gt;DELETE&lt;/literal&gt; triggers cannot refer to &lt;literal&gt;NEW&lt;/literal&gt;.
</span>
トリガ関数を実際に実行するか否かを決定する論理式です。
<code class="literal">WHEN</code>が指定された場合、<em class="replaceable"><code>condition</code></em>が<code class="literal">true</code>を返す場合のみ関数が呼び出されます。
<code class="literal">FOR EACH ROW</code>トリガでは、<code class="literal">WHEN</code>条件で、それぞれ<code class="literal">OLD.<em class="replaceable"><code>column_name</code></em></code>、<code class="literal">NEW.<em class="replaceable"><code>column_name</code></em></code>と記述することで、古い行の値、新しい行の値、またはその両方の列を参照することができます。
当然ながら<code class="literal">INSERT</code>トリガでは<code class="literal">OLD</code>を参照することはできませんし、<code class="literal">DELETE</code>トリガでは<code class="literal">NEW</code>を参照することはできません。
     </p><span class="original">
     &lt;para&gt;&lt;literal&gt;INSTEAD OF&lt;/literal&gt; triggers do not support &lt;literal&gt;WHEN&lt;/literal&gt;
      conditions.
</span><p><code class="literal">INSTEAD OF</code>トリガは<code class="literal">WHEN</code>条件をサポートしません。
     </p><p>
<span class="original">
      Currently, &lt;literal&gt;WHEN&lt;/literal&gt; expressions cannot contain
      subqueries.
</span>
現時点では<code class="literal">WHEN</code>条件に副問い合わせを含めることはできません。
     </p><p>
<span class="original">
      Note that for constraint triggers, evaluation of the &lt;literal&gt;WHEN&lt;/literal&gt;
      condition is not deferred, but occurs immediately after the row update
      operation is performed. If the condition does not evaluate to true then
      the trigger is not queued for deferred execution.
</span>
制約トリガでは、<code class="literal">WHEN</code>条件の評価は遅延されず、行の更新操作が行われた直後に発生することに注意してください。
この条件が真と評価されなかった場合、トリガは遅延実行用のキューに入りません。
     </p></dd><dt><span class="term"><em class="replaceable"><code>function_name</code></em></span></dt><dd><p>
<span class="original">
      A user-supplied function that is declared as taking no arguments
      and returning type &lt;literal&gt;trigger&lt;/literal&gt;, which is executed when
      the trigger fires.
</span>
ユーザが提供する関数です。この関数は、引数を取らず<code class="literal">trigger</code>型を返すよう定義されます。トリガが起動した時に実行されます。
     </p><p>
<span class="original">
      In the syntax of &lt;literal&gt;CREATE TRIGGER&lt;/literal&gt;, the keywords
      &lt;literal&gt;FUNCTION&lt;/literal&gt; and &lt;literal&gt;PROCEDURE&lt;/literal&gt; are
      equivalent, but the referenced function must in any case be a function,
      not a procedure.  The use of the keyword &lt;literal&gt;PROCEDURE&lt;/literal&gt;
      here is historical and deprecated.
</span>
<code class="literal">CREATE TRIGGER</code>の構文では、キーワード<code class="literal">FUNCTION</code>と<code class="literal">PROCEDURE</code>は等価ですが、参照されている関数はどちらの場合でも関数でなければならず、プロシージャであってはなりません。
ここでキーワード<code class="literal">PROCEDURE</code>を使うことは、歴史的なものであり廃止予定です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>arguments</code></em></span></dt><dd><p>
<span class="original">
      An optional comma-separated list of arguments to be provided to
      the function when the trigger is executed.  The arguments are
      literal string constants.  Simple names and numeric constants
      can be written here, too, but they will all be converted to
      strings.  Please check the description of the implementation
      language of the trigger function to find out how these arguments
      can be accessed within the function; it might be different from
      normal function arguments.
</span>
トリガ実行時に関数に渡される引数をカンマで区切ったリストで、省略可能です。
引数として指定するのは、リテラル文字列定数です。
単純な名前および数値定数を記述できますが、全て文字列に変換されます。
関数内でこれらの引数にアクセスする方法について調べるためには、トリガ関数を実装した言語の説明を参照してください。
通常の関数引数とは異なる場合があります。
     </p></dd></dl></div></div><div class="refsect1" id="SQL-CREATETRIGGER-NOTES"><h2>注釈</h2><span class="original">
  &lt;title&gt;Notes&lt;/title&gt;
</span><p>
<span class="original">
   To create or replace a trigger on a table, the user must have the
   &lt;literal&gt;TRIGGER&lt;/literal&gt; privilege on the table.  The user must
   also have &lt;literal&gt;EXECUTE&lt;/literal&gt; privilege on the trigger function.
</span>
テーブルに対してトリガを作成もしくは変更するには、ユーザがそのテーブルに対し<code class="literal">TRIGGER</code>権限を持っている必要があります。
またユーザはトリガ関数に対し<code class="literal">EXECUTE</code>権限を持たなければなりません。
  </p><p>
<span class="original">
   Use &lt;link linkend="sql-droptrigger"&gt;&lt;command&gt;DROP TRIGGER&lt;/command&gt;&lt;/link&gt; to remove a trigger.
</span>
トリガを削除するためには<a class="link" href="sql-droptrigger.html" title="DROP TRIGGER"><code class="command">DROP TRIGGER</code></a>を使用してください。
  </p><p>
<span class="original">
   Creating a row-level trigger on a partitioned table will cause an
   identical &lt;quote&gt;clone&lt;/quote&gt; trigger to be created on each of its
   existing partitions; and any partitions created or attached later will have
   an identical trigger, too.  If there is a conflictingly-named trigger on a
   child partition already, an error occurs unless &lt;command&gt;CREATE OR REPLACE
   TRIGGER&lt;/command&gt; is used, in which case that trigger is replaced with a
   clone trigger.  When a partition is detached from its parent, its clone
   triggers are removed.
</span>
パーティションテーブルに行レベルのトリガを作ると、存在するパーティションすべてに同一の<span class="quote">「<span class="quote">クローン</span>」</span>トリガがつくられます。そして、後から作られたり追加されるパーティションも同一のトリガを含みます。
子パーティションに名前が衝突するトリガがすでにある場合には、<code class="command">CREATE OR REPLACE
 TRIGGER</code>によってそのトリガをクローントリガで置き換えない限りエラーになります。
パーティションが親から切り離された場合、クローントリガは削除されます。
  </p><p>
<span class="original">
   A column-specific trigger (one defined using the &lt;literal&gt;UPDATE OF
   &lt;replaceable&gt;column_name&lt;/replaceable&gt;&lt;/literal&gt; syntax) will fire when any
   of its columns are listed as targets in the &lt;command&gt;UPDATE&lt;/command&gt;
   command's &lt;literal&gt;SET&lt;/literal&gt; list.  It is possible for a column's value
   to change even when the trigger is not fired, because changes made to the
   row's contents by &lt;literal&gt;BEFORE UPDATE&lt;/literal&gt; triggers are not considered.
   Conversely, a command such as &lt;literal&gt;UPDATE ... SET x = x ...&lt;/literal&gt;
   will fire a trigger on column &lt;literal&gt;x&lt;/literal&gt;, even though the column's
   value did not change.
</span>
列指定のトリガ（<code class="literal">UPDATE OF <em class="replaceable"><code>column_name</code></em></code>構文で定義されたトリガ）は、列挙された列のいずれかが<code class="command">UPDATE</code>コマンドの<code class="literal">SET</code>リスト内に対象として指定された場合に発行されます。
<code class="literal">BEFORE UPDATE</code>トリガにより行の内容になされた変更は考慮されないため、トリガが発行されない場合であっても、列の値が変更されることはあります。
反対に、<code class="literal">UPDATE ... SET x = x ...</code>のようなコマンドは、列の値が変更されませんが、<code class="literal">x</code>列に対するトリガが発行されます。
  </p><p>
<span class="original">
   In a &lt;literal&gt;BEFORE&lt;/literal&gt; trigger, the &lt;literal&gt;WHEN&lt;/literal&gt; condition is
   evaluated just before the function is or would be executed, so using
   &lt;literal&gt;WHEN&lt;/literal&gt; is not materially different from testing the same
   condition at the beginning of the trigger function.  Note in particular
   that the &lt;literal&gt;NEW&lt;/literal&gt; row seen by the condition is the current value,
   as possibly modified by earlier triggers.  Also, a &lt;literal&gt;BEFORE&lt;/literal&gt;
   trigger's &lt;literal&gt;WHEN&lt;/literal&gt; condition is not allowed to examine the
   system columns of the &lt;literal&gt;NEW&lt;/literal&gt; row (such as &lt;literal&gt;ctid&lt;/literal&gt;),
   because those won't have been set yet.
</span>
<code class="literal">BEFORE</code>トリガにおいて<code class="literal">WHEN</code>条件は関数が実行される、またはされそうな直前に評価されます。
このため<code class="literal">WHEN</code>の使用はトリガ関数の先頭で同一の条件を試験することと実質的に違いはありません。
この条件で確認できる<code class="literal">NEW</code>行が現在の値であり、それまでのトリガで変更されている可能性があることに、特に注意して下さい。
また<code class="literal">BEFORE</code>トリガの<code class="literal">WHEN</code>条件では、<code class="literal">NEW</code>行のシステム列(<code class="literal">ctid</code>など)はまだ設定されていないので、検査することができません。
  </p><p>
<span class="original">
   In an &lt;literal&gt;AFTER&lt;/literal&gt; trigger, the &lt;literal&gt;WHEN&lt;/literal&gt; condition is
   evaluated just after the row update occurs, and it determines whether an
   event is queued to fire the trigger at the end of statement.  So when an
   &lt;literal&gt;AFTER&lt;/literal&gt; trigger's &lt;literal&gt;WHEN&lt;/literal&gt; condition does not return
   true, it is not necessary to queue an event nor to re-fetch the row at end
   of statement.  This can result in significant speedups in statements that
   modify many rows, if the trigger only needs to be fired for a few of the
   rows.
</span>
<code class="literal">AFTER</code>トリガにおいて、<code class="literal">WHEN</code>条件は行の更新を行った直後に評価され、文の最後でトリガを発行するためにイベントを保持すべきかどうかを決定します。
このため<code class="literal">AFTER</code>トリガの<code class="literal">WHEN</code>条件は真を返さない場合、イベントを保持する必要もありませんし、文の最後の行を再度取り出す必要もありません。
これにより、トリガをわずかな行のみに対して発行する必要がある場合、多くの行を変更する文を非常に高速にすることができます。
  </p><p>
<span class="original">
   In some cases it is possible for a single SQL command to fire more than
   one kind of trigger.  For instance an &lt;command&gt;INSERT&lt;/command&gt; with
   an &lt;literal&gt;ON CONFLICT DO UPDATE&lt;/literal&gt; clause may cause both insert and
   update operations, so it will fire both kinds of triggers as needed.
   The transition relations supplied to triggers are
   specific to their event type; thus an &lt;command&gt;INSERT&lt;/command&gt; trigger
   will see only the inserted rows, while an &lt;command&gt;UPDATE&lt;/command&gt;
   trigger will see only the updated rows.
</span>
場合によっては1つのSQLコマンドが2種類以上のトリガを発行することがあります。
例えば、<code class="literal">ON CONFLICT DO UPDATE</code>句のある<code class="command">INSERT</code>では、挿入と更新の両方の操作が発生するかもしれないので、必要に応じて両方の種類のトリガを発行します。
トリガに提供される遷移リレーションはトリガのイベント種類毎に個別のものです。
従って、<code class="command">INSERT</code>トリガには挿入された行だけが見え、一方で<code class="command">UPDATE</code>トリガには更新された行だけが見えます。
  </p><p>
<span class="original">
   Row updates or deletions caused by foreign-key enforcement actions, such
   as &lt;literal&gt;ON UPDATE CASCADE&lt;/literal&gt; or &lt;literal&gt;ON DELETE SET NULL&lt;/literal&gt;, are
   treated as part of the SQL command that caused them (note that such
   actions are never deferred).  Relevant triggers on the affected table will
   be fired, so that this provides another way in which an SQL command might
   fire triggers not directly matching its type.  In simple cases, triggers
   that request transition relations will see all changes caused in their
   table by a single original SQL command as a single transition relation.
   However, there are cases in which the presence of an &lt;literal&gt;AFTER ROW&lt;/literal&gt;
   trigger that requests transition relations will cause the foreign-key
   enforcement actions triggered by a single SQL command to be split into
   multiple steps, each with its own transition relation(s).  In such cases,
   any statement-level triggers that are present will be fired once per
   creation of a transition relation set, ensuring that the triggers see
   each affected row in a transition relation once and only once.
</span>
<code class="literal">ON UPDATE CASCADE</code>や<code class="literal">ON DELETE SET NULL</code>など外部キーを強制する動作によって起こる行の更新や削除は、それを起こしたSQLコマンドの一部であるとみなされます（このような動作は決して遅延実行されないことに注意してください）。
影響を受けたテーブルの関連するトリガが発行されるため、これはSQLコマンドの種類と直接には一致しないトリガが発行される別のケースとなります。
単純な場合、遷移リレーションを要求するトリガは、元となる1つのSQLコマンドによって起こされたテーブルへのすべての変更を、一つの遷移リレーションとして見ることになります。
しかし、遷移リレーションを要求する<code class="literal">AFTER ROW</code>トリガの存在により、一つのSQLコマンドによって発生する外部キーを強制する動作が複数のステップに分割され、各ステップがそれぞれの遷移リレーションを持つという場合もあります。
そのような場合、すべての文レベルのトリガは1つの遷移リレーションの集合の作成に対して1度ずつ呼び出され、それによりトリガが遷移リレーション内の変更された行をちょうど一度だけ見ることを確実にしています。
  </p><p>
<span class="original">
   Statement-level triggers on a view are fired only if the action on the
   view is handled by a row-level &lt;literal&gt;INSTEAD OF&lt;/literal&gt; trigger.
   If the action is handled by an &lt;literal&gt;INSTEAD&lt;/literal&gt; rule, then
   whatever statements are emitted by the rule are executed in place of the
   original statement naming the view, so that the triggers that will be
   fired are those on tables named in the replacement statements.
   Similarly, if the view is automatically updatable, then the action is
   handled by automatically rewriting the statement into an action on the
   view's base table, so that the base table's statement-level triggers are
   the ones that are fired.
</span>
ビューに付けられている文レベルのトリガは、ビューに対する操作が行レベルの<code class="literal">INSTEAD OF</code>トリガによって取り扱われた時にのみ発行されます。
ビューに対する操作が<code class="literal">INSTEAD OF</code>ルールによって取り扱われる場合は、ビューを指定した元の文の代わりに、そのルールが出力した文が実行されます。
それにより、発行されるトリガは、置き換えられた文によって指定されたテーブルに付けられたトリガとなります。
同様に、ビューが自動更新可能ならば、操作は、ビューの基底テーブル上の操作に自動的に書き換えられる文によって取り扱われます。
その結果、発行されるのは基底テーブルの文レベルのトリガとなります。
  </p><p>
<span class="original">
   Modifying a partitioned table or a table with inheritance children fires
   statement-level triggers attached to the explicitly named table, but not
   statement-level triggers for its partitions or child tables.  In contrast,
   row-level triggers are fired on the rows in affected partitions or
   child tables, even if they are not explicitly named in the query.
   If a statement-level trigger has been defined with transition relations
   named by a &lt;literal&gt;REFERENCING&lt;/literal&gt; clause, then before and after
   images of rows are visible from all affected partitions or child tables.
   In the case of inheritance children, the row images include only columns
   that are present in the table that the trigger is attached to.
</span>
パーティションテーブルや継承した子テーブルがあるテーブルを変更したとき、明示的に指定されたテーブルに付けられている文レベルのトリガが発行されますが、パーティションや子テーブルに付けられている文レベルのトリガは発行されません。
対照的に、問合せ中で明示的に指定されていなくても、行レベルのトリガはすべての変更されたパーティションや子テーブルに対して発行されます。
<code class="literal">REFERENCING</code>句で指定された遷移リレーションのある文レベルのトリガが定義されている場合、行の変更前イメージおよび変更後イメージは、変更されたすべてのパーティションおよび子テーブルから見ることができます。
継承された子テーブルの場合、行イメージはトリガが付けられたテーブルに存在する列だけしか含みません。
  </p><p>
<span class="original">
   Currently, row-level triggers with transition relations cannot be defined
   on partitions or inheritance child tables.  Also, triggers on partitioned
   tables may not be &lt;literal&gt;INSTEAD OF&lt;/literal&gt;.
</span>
現在のところ、遷移リレーションのある行レベルトリガは、パーティションや継承した子テーブルには定義できません。
また、パーティションテーブルのトリガは<code class="literal">INSTEAD OF</code>とすることはできません。
  </p><p>
<span class="original">
   Currently, the &lt;literal&gt;OR REPLACE&lt;/literal&gt; option is not supported for
   constraint triggers.
</span>
現在のところ、<code class="literal">OR REPLACE</code>オプションは制約トリガに対してはサポートされていません。
  </p><p>
<span class="original">
   Replacing an existing trigger within a transaction that has already
   performed updating actions on the trigger's table is not recommended.
   Trigger firing decisions, or portions of firing decisions, that have
   already been made will not be reconsidered, so the effects could be
   surprising.
</span>
トリガのテーブルに対してすでに更新動作を実行したトランザクション内で、既存のトリガを置き換えることはお勧めしません。
既に決定されたトリガ発行、もしくは発行の判断のうち既に決定された部分は再考されることはありませんので、結果は驚くべきものになるかもしれません。
  </p><p>
<span class="original">
   There are a few built-in trigger functions that can be used to
   solve common problems without having to write your own trigger code;
   see &lt;xref linkend="functions-trigger"/&gt;.
</span>
自身でトリガのコードを書かなくても、よくある問題を解決するために使うことのできる組み込みのトリガ関数が多少あります。<a class="xref" href="functions-trigger.html" title="9.28. トリガ関数">9.28</a>を参照してください。
  </p></div><div class="refsect1" id="SQL-CREATETRIGGER-EXAMPLES"><h2>例</h2><span class="original">
  &lt;title&gt;Examples&lt;/title&gt;
</span><p>
<span class="original">
   Execute the function &lt;function&gt;check_account_update&lt;/function&gt; whenever
   a row of the table &lt;literal&gt;accounts&lt;/literal&gt; is about to be updated:
</span>
テーブル<code class="literal">accounts</code>の行が更新される直前に関数<code class="function">check_account_update</code>を実行します。

</p><pre class="programlisting">
CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    EXECUTE FUNCTION check_account_update();
</pre><p>

<span class="original">
   Modify that trigger definition to only execute the function if
   column &lt;literal&gt;balance&lt;/literal&gt; is specified as a target in
   the &lt;command&gt;UPDATE&lt;/command&gt; command:
</span>
<code class="command">UPDATE</code>コマンドで<code class="literal">balance</code>列が対象として指定されている場合にのみ関数を実行するよう、そのトリガ定義を修正します。

</p><pre class="programlisting">
CREATE OR REPLACE TRIGGER check_update
    BEFORE UPDATE OF balance ON accounts
    FOR EACH ROW
    EXECUTE FUNCTION check_account_update();
</pre><p>

<span class="original">
   This form only executes the function if column &lt;literal&gt;balance&lt;/literal&gt;
   has in fact changed value:
</span>
以下の構文では、列<code class="literal">balance</code>が実際に変更された場合のみ関数が実行されます。

</p><pre class="programlisting">
CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.balance IS DISTINCT FROM NEW.balance)
    EXECUTE FUNCTION check_account_update();
</pre><p>

<span class="original">
   Call a function to log updates of &lt;literal&gt;accounts&lt;/literal&gt;, but only if
   something changed:
</span>
何か変更された場合のみに<code class="literal">accounts</code>の更新のログを取る関数を呼び出します。

</p><pre class="programlisting">
CREATE TRIGGER log_update
    AFTER UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.* IS DISTINCT FROM NEW.*)
    EXECUTE FUNCTION log_account_update();
</pre><p>

<span class="original">
   Execute the function &lt;function&gt;view_insert_row&lt;/function&gt; for each row to insert
   rows into the tables underlying a view:
</span>
ビューの背後にあるテーブルに行を挿入するために、各行に対して関数<code class="function">view_insert_row</code>を実行します。

</p><pre class="programlisting">
CREATE TRIGGER view_insert
    INSTEAD OF INSERT ON my_view
    FOR EACH ROW
    EXECUTE FUNCTION view_insert_row();
</pre><p>

<span class="original">
   Execute the function &lt;function&gt;check_transfer_balances_to_zero&lt;/function&gt; for each
   statement to confirm that the &lt;literal&gt;transfer&lt;/literal&gt; rows offset to a net of
   zero:
</span>
各文に対して関数<code class="function">check_transfer_balances_to_zero</code>を実行して、<code class="literal">transfer</code>の行が相殺してゼロになることを確認します。

</p><pre class="programlisting">
CREATE TRIGGER transfer_insert
    AFTER INSERT ON transfer
    REFERENCING NEW TABLE AS inserted
    FOR EACH STATEMENT
    EXECUTE FUNCTION check_transfer_balances_to_zero();
</pre><p>

<span class="original">
   Execute the function &lt;function&gt;check_matching_pairs&lt;/function&gt; for each row to
   confirm that changes are made to matching pairs at the same time (by the
   same statement):
</span>
各行に対して関数<code class="function">check_matching_pairs</code>を実行して、対応する組み合わせに対して同じ時に（同じ文により）変更されていることを確認します。

</p><pre class="programlisting">
CREATE TRIGGER paired_items_update
    AFTER UPDATE ON paired_items
    REFERENCING NEW TABLE AS newtab OLD TABLE AS oldtab
    FOR EACH ROW
    EXECUTE FUNCTION check_matching_pairs();
</pre><p>
  </p><p>
<span class="original">
   &lt;xref linkend="trigger-example"/&gt; contains a complete example of a trigger
   function written in C.
</span>
<a class="xref" href="trigger-example.html" title="39.4. 完全なトリガの例">39.4</a>には、C言語で作成されたトリガ関数の完全な例があります。
  </p></div><div class="refsect1" id="SQL-CREATETRIGGER-COMPATIBILITY"><h2>互換性</h2><span class="original">
  &lt;title&gt;Compatibility&lt;/title&gt;
</span><span class="original">
   It's not clear whether SQL/MED contemplates triggers on foreign tables.
   Its &lt;drop basic column definition&gt; General Rules do mention the possibility
   of a reference from a trigger column list.  On the other hand, nothing
   overrides the fact that CREATE TRIGGER only targets base tables.  For now,
   do not document the compatibility status of triggers on foreign tables.
  </span><p>
<span class="original">
   The &lt;command&gt;CREATE TRIGGER&lt;/command&gt; statement in
   &lt;productname&gt;PostgreSQL&lt;/productname&gt; implements a subset of the
   &lt;acronym&gt;SQL&lt;/acronym&gt; standard. The following functionalities are currently
   missing:
</span>
<span class="productname">PostgreSQL</span>における<code class="command">CREATE TRIGGER</code>文は標準<acronym class="acronym">SQL</acronym>のサブセットを実装したものです
現在は、<span class="productname">PostgreSQL</span>には、次の機能がありません。

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
      While transition table names for &lt;literal&gt;AFTER&lt;/literal&gt; triggers are
      specified using the &lt;literal&gt;REFERENCING&lt;/literal&gt; clause in the standard way,
      the row variables used in &lt;literal&gt;FOR EACH ROW&lt;/literal&gt; triggers may not be
      specified in a &lt;literal&gt;REFERENCING&lt;/literal&gt; clause.  They are available in a
      manner that is dependent on the language in which the trigger function
      is written, but is fixed for any one language.  Some languages
      effectively behave as though there is a &lt;literal&gt;REFERENCING&lt;/literal&gt; clause
      containing &lt;literal&gt;OLD ROW AS OLD NEW ROW AS NEW&lt;/literal&gt;.
</span>
<code class="literal">AFTER</code>トリガの遷移テーブル名は<code class="literal">REFERENCING</code>句を使って標準SQLの方法で指定できますが、<code class="literal">FOR EACH ROW</code>トリガで使用される行変数は<code class="literal">REFERENCING</code>句で指定することができません。
それはトリガ関数が書かれる言語に依存する方法で利用できますが、各言語によって決まった方法になります。
一部の言語は、<code class="literal">REFERENCING</code>句が<code class="literal">OLD ROW AS OLD NEW ROW AS NEW</code>となっているかのように動作します。
     </p></li><li class="listitem"><p>
<span class="original">
      The standard allows transition tables to be used with
      column-specific &lt;literal&gt;UPDATE&lt;/literal&gt; triggers, but then the set of rows
      that should be visible in the transition tables depends on the
      trigger's column list.  This is not currently implemented by
      &lt;productname&gt;PostgreSQL&lt;/productname&gt;.
</span>
標準SQLでは列を指定した<code class="literal">UPDATE</code>トリガでも遷移テーブルを使うことができますが、その場合遷移テーブルで見ることができる行の集合はトリガの列リストに依存します。
これは現在のところ<span class="productname">PostgreSQL</span>では実装されていません。
     </p></li><li class="listitem"><p>
<span class="original">
      &lt;productname&gt;PostgreSQL&lt;/productname&gt; only allows the execution
      of a user-defined function for the triggered action.  The standard
      allows the execution of a number of other SQL commands, such as
      &lt;command&gt;CREATE TABLE&lt;/command&gt;, as the triggered action.  This
      limitation is not hard to work around by creating a user-defined
      function that executes the desired commands.
</span>
<span class="productname">PostgreSQL</span>では、トリガ動作として、ユーザ定義関数の実行しか認めていません。
標準では、多数の他のSQLコマンドを実行させることができます。
例えば、トリガ動作として<code class="command">CREATE TABLE</code>を実行させることも可能です。
この制限を回避する方法は簡単です。必要なコマンドを実行するユーザ定義関数を作成すればよいのです。
     </p></li></ul></div><p>
  </p><p>
<span class="original">
   SQL specifies that multiple triggers should be fired in
   time-of-creation order.  &lt;productname&gt;PostgreSQL&lt;/productname&gt; uses
   name order, which was judged to be more convenient.
</span>
SQLでは、複数のトリガは、作成時刻順に起動すべきであると規定しています。
<span class="productname">PostgreSQL</span>では名前順です。この方が便利だと考えられるからです。
  </p><p>
<span class="original">
   SQL specifies that &lt;literal&gt;BEFORE DELETE&lt;/literal&gt; triggers on cascaded
   deletes fire &lt;emphasis&gt;after&lt;/emphasis&gt; the cascaded &lt;literal&gt;DELETE&lt;/literal&gt; completes.
   The &lt;productname&gt;PostgreSQL&lt;/productname&gt; behavior is for &lt;literal&gt;BEFORE
   DELETE&lt;/literal&gt; to always fire before the delete action, even a cascading
   one.  This is considered more consistent.  There is also nonstandard
   behavior if &lt;literal&gt;BEFORE&lt;/literal&gt; triggers modify rows or prevent
   updates during an update that is caused by a referential action.  This can
   lead to constraint violations or stored data that does not honor the
   referential constraint.
</span>
SQLでは、数珠繋ぎの削除に対する<code class="literal">BEFORE DELETE</code>は、数珠繋ぎの<code class="literal">DELETE</code>が完了した<span class="emphasis"><em>後に</em></span>発行するものと規定しています。
<span class="productname">PostgreSQL</span>では、<code class="literal">BEFORE DELETE</code>は常に削除操作よりも前に、それも起点となる削除よりも前に行われます。
この方がより一貫性があると考えられいます。
また、参照整合性に関する動作により引き起こされる更新を実行している間に、<code class="literal">BEFORE</code>トリガが行を更新し、更新を妨げるような場合の動作も標準に従わないものがあります。
これは、制約違反となるかもしれませんし、参照整合性制約に合わないデータを格納してしまうかもしれません。
  </p><p>
<span class="original">
   The ability to specify multiple actions for a single trigger using
   &lt;literal&gt;OR&lt;/literal&gt; is a &lt;productname&gt;PostgreSQL&lt;/productname&gt; extension of
   the SQL standard.
</span>
<code class="literal">OR</code>を使用して単一トリガに複数の動作を指定する機能は、標準SQLに対する<span class="productname">PostgreSQL</span>の拡張です。
  </p><p>
<span class="original">
   The ability to fire triggers for &lt;command&gt;TRUNCATE&lt;/command&gt; is a
   &lt;productname&gt;PostgreSQL&lt;/productname&gt; extension of the SQL standard, as is the
   ability to define statement-level triggers on views.
</span>
<code class="command">TRUNCATE</code>でのトリガ発行機能、および、ビューに対する文レベルのトリガの定義機能は標準SQLに対する<span class="productname">PostgreSQL</span>の拡張です。
  </p><p>
<span class="original">
   &lt;command&gt;CREATE CONSTRAINT TRIGGER&lt;/command&gt; is a
   &lt;productname&gt;PostgreSQL&lt;/productname&gt; extension of the &lt;acronym&gt;SQL&lt;/acronym&gt;
   standard.
   So is the &lt;literal&gt;OR REPLACE&lt;/literal&gt; option.
</span>
<code class="command">CREATE CONSTRAINT TRIGGER</code>は標準<acronym class="acronym">SQL</acronym>に対する<span class="productname">PostgreSQL</span>の拡張です。
<code class="literal">OR REPLACE</code>オプションも同じです。
  </p></div><div class="refsect1" id="id-1.9.3.93.12"><h2>関連項目</h2><span class="original">
  &lt;title&gt;See Also&lt;/title&gt;
</span><span class="simplelist"><a class="xref" href="sql-altertrigger.html" title="ALTER TRIGGER"><span class="refentrytitle">ALTER TRIGGER</span></a>, <a class="xref" href="sql-droptrigger.html" title="DROP TRIGGER"><span class="refentrytitle">DROP TRIGGER</span></a>, <a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>, <a class="xref" href="sql-set-constraints.html" title="SET CONSTRAINTS"><span class="refentrytitle">SET CONSTRAINTS</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createtransform.html" title="CREATE TRANSFORM">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createtype.html" title="CREATE TYPE">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE TRANSFORM </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 15.0文書">ホーム</a></td><td width="40%" align="right" valign="top"> CREATE TYPE</td></tr></table></div></body></html>