<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE VIEW</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-createusermapping.html" title="CREATE USER MAPPING" /><link rel="next" href="sql-deallocate.html" title="DEALLOCATE" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 16.0文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="sql-commands.html" title="SQLコマンド">SQLコマンド</a></td><td width="20%" align="right"></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createusermapping.html" title="CREATE USER MAPPING">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">上へ</a></td><td width="60%" align="center">CREATE VIEW</td><td width="20%" align="right"> <a accesskey="n" href="sql-deallocate.html" title="DEALLOCATE">次へ</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATEVIEW"><div class="titlepage"></div><a id="id-1.9.3.97.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE VIEW</span></h2><p>CREATE VIEW<!--
  <refpurpose>define a new view</refpurpose>
--> — 新しいビューを定義する</p></div><div class="refsynopsisdiv"><h2>概要</h2><pre class="synopsis">
CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW <em class="replaceable"><code>name</code></em> [ ( <em class="replaceable"><code>column_name</code></em> [, ...] ) ]
    [ WITH ( <em class="replaceable"><code>view_option_name</code></em> [= <em class="replaceable"><code>view_option_value</code></em>] [, ... ] ) ]
    AS <em class="replaceable"><code>query</code></em>
    [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
</pre></div><div class="refsect1" id="id-1.9.3.97.5"><h2>説明</h2><!--
  <title>Description</title>
--><p>
<!--
   <command>CREATE VIEW</command> defines a view of a query.  The view
   is not physically materialized. Instead, the query is run every time
   the view is referenced in a query.
-->
<code class="command">CREATE VIEW</code>は問い合わせによるビューを定義します。
ビューは物理的な実体として存在するものではありません。
その代わり、問い合わせでビューが参照される度に、指定された問い合わせが実行されます。
  </p><p>
<!--
   <command>CREATE OR REPLACE VIEW</command> is similar, but if a view
   of the same name already exists, it is replaced.  The new query must
   generate the same columns that were generated by the existing view query
   (that is, the same column names in the same order and with the same data
   types), but it may add additional columns to the end of the list.  The
   calculations giving rise to the output columns may be completely different.
-->
<code class="command">CREATE OR REPLACE VIEW</code>も同様の働きをしますが、
このコマンドでは、同じ名前のビューが既に存在している場合、そのビューを置き換えます。
新しい問い合わせは、既存のビュー問い合わせが生成する列と同じ列(つまり、同じ順序の同じデータ型の同じ列名)を生成しなければなりません。
しかし、そのリストの最後に列を追加しても構いません。
出力列を生成する計算をまったく異なるものにしても構いません。
  </p><p>
<!--
   If a schema name is given (for example, <literal>CREATE VIEW
   myschema.myview ...</literal>) then the view is created in the specified
   schema.  Otherwise it is created in the current schema.  Temporary
   views exist in a special schema, so a schema name cannot be given
   when creating a temporary view. The name of the view must be
   distinct from the name of any other relation (table, sequence, index, view,
   materialized view, or foreign table) in the same schema.
-->
スキーマ名が付けられている場合（例えば、<code class="literal">CREATE VIEW myschema.myview ...</code>）、ビューは指定されたスキーマに作成されます。
スキーマ名がなければ、そのビューは現在のスキーマに作成されます。
一時ビューは特別なスキーマに作成されます。
そのため、一時ビューを作成する時にはスキーマ名を付けることはできません。
ビュー名は、同じスキーマ内の他のリレーション(テーブル、シーケンス、インデックス、ビュー、マテリアライズドビュー、外部テーブル)とは異なる名前である必要があります。
  </p></div><div class="refsect1" id="id-1.9.3.97.6"><h2>パラメータ</h2><!--
  <title>Parameters</title>
--><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">TEMPORARY</code>または<code class="literal">TEMP</code></span></dt><dd><p>
<!--
      If specified, the view is created as a temporary view.
      Temporary views are automatically dropped at the end of the
      current session.  Existing
      permanent relations with the same name are not visible to the
      current session while the temporary view exists, unless they are
      referenced with schema-qualified names.
-->
これが指定された場合、ビューは一時ビューとして作成されます。
現在のセッションが終わった時、一時ビューは自動的に削除されます。
一時ビューが存在する間、現在のセッションでは、これと同じ名前の永続リレーションはスキーマ修飾した名前で参照していない限り不可視です。
     </p><p>
<!--
      If any of the tables referenced by the view are temporary,
      the view is created as a temporary view (whether
      <literal>TEMPORARY</literal> is specified or not).
-->
ビューで参照されるテーブルの一部が一時テーブルであった場合、（<code class="literal">TEMPORARY</code>の指定があってもなくても）ビューは一時ビューとして作成されます。
     </p></dd><dt><span class="term"><code class="literal">RECURSIVE</code>
      <a id="id-1.9.3.97.6.2.2.1.2" class="indexterm"></a>
      <a id="id-1.9.3.97.6.2.2.1.3" class="indexterm"></a>
    </span></dt><dd><p>
<!--
      Creates a recursive view.  The syntax
-->
再帰的ビューを作成します。
</p><pre class="synopsis">
CREATE RECURSIVE VIEW [ <em class="replaceable"><code>schema</code></em> . ] <em class="replaceable"><code>view_name</code></em> (<em class="replaceable"><code>column_names</code></em>) AS SELECT <em class="replaceable"><code>...</code></em>;
</pre><p>
<!--
      is equivalent to
-->
という構文は
</p><pre class="synopsis">
CREATE VIEW [ <em class="replaceable"><code>schema</code></em> . ] <em class="replaceable"><code>view_name</code></em> AS WITH RECURSIVE <em class="replaceable"><code>view_name</code></em> (<em class="replaceable"><code>column_names</code></em>) AS (SELECT <em class="replaceable"><code>...</code></em>) SELECT <em class="replaceable"><code>column_names</code></em> FROM <em class="replaceable"><code>view_name</code></em>;
</pre><p>
と同等です。
<!--
      A view column name list must be specified for a recursive view.
-->
再帰的ビューではビューの列名リストを指定する必要があります。
     </p></dd><dt><span class="term"><em class="replaceable"><code>name</code></em></span></dt><dd><p>
<!--
      The name (optionally schema-qualified) of a view to be created.
-->
作成するビューの名前です（スキーマ修飾名も可）。
     </p></dd><dt><span class="term"><em class="replaceable"><code>column_name</code></em></span></dt><dd><p>
<!--
      An optional list of names to be used for columns of the view.
      If not given, the column names are deduced from the query.
-->
ビューの列名として使用する名前のリストで、省略可能です。省略された場合、問い合わせに由来する名前が使用されます。
     </p></dd><dt><span class="term"><code class="literal">WITH ( <em class="replaceable"><code>view_option_name</code></em> [= <em class="replaceable"><code>view_option_value</code></em>] [, ... ] )</code></span></dt><dd><p>
<!--
      This clause specifies optional parameters for a view; the following
      parameters are supported:
-->
この句はビュー用のオプションのパラメータを指定します。
以下のパラメータがサポートされています。

      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">check_option</code> (<code class="type">enum</code>)</span></dt><dd><p>
<!--
          This parameter may be either <literal>local</literal> or
          <literal>cascaded</literal>, and is equivalent to specifying
          <literal>WITH [ CASCADED | LOCAL ] CHECK OPTION</literal> (see below).
-->
このパラメータは<code class="literal">local</code>か<code class="literal">cascaded</code>のいずれかで、<code class="literal">WITH [ CASCADED | LOCAL ] CHECK OPTION</code>を指定するのと同じです(以下を参照)。
         </p></dd><dt><span class="term"><code class="literal">security_barrier</code> (<code class="type">boolean</code>)</span></dt><dd><p>
<!--
          This should be used if the view is intended to provide row-level
          security.  See <xref linkend="rules-privileges"/> for full details.
-->
行単位セキュリティを提供することを意図したビューでは、これを有効にしなければなりません。
詳細については<a class="xref" href="rules-privileges.html" title="41.5. ルールと権限">41.5</a>を参照してください。
         </p></dd><dt><span class="term"><code class="literal">security_invoker</code> (<code class="type">boolean</code>)</span></dt><dd><p>
<!--
          This option causes the underlying base relations to be checked
          against the privileges of the user of the view rather than the view
          owner.  See the notes below for full details.
-->
このオプションを選択すると、基となる基底リレーションが、ビューの所有者ではなくビューのユーザーの権限に対してチェックされます。
詳細については、以下の注釈を参照してください。
         </p></dd></dl></div><p>

<!--
      All of the above options can be changed on existing views using <link
      linkend="sql-alterview"><command>ALTER VIEW</command></link>.
-->
上記のオプションはすべて、<a class="link" href="sql-alterview.html" title="ALTER VIEW"><code class="command">ALTER VIEW</code></a>を使用して既存のビューで変更できます。
     </p></dd><dt><span class="term"><em class="replaceable"><code>query</code></em></span></dt><dd><p>
<!--
      A <link linkend="sql-select"><command>SELECT</command></link> or
      <link linkend="sql-values"><command>VALUES</command></link> command
      which will provide the columns and rows of the view.
-->
ビューの列と行を生成する<a class="link" href="sql-select.html" title="SELECT"><code class="command">SELECT</code></a>または<a class="link" href="sql-values.html" title="VALUES"><code class="command">VALUES</code></a>コマンドです。
     </p></dd><dt><span class="term"><code class="literal">WITH [ CASCADED | LOCAL ] CHECK OPTION</code>
      <a id="id-1.9.3.97.6.2.7.1.2" class="indexterm"></a>
      <a id="id-1.9.3.97.6.2.7.1.3" class="indexterm"></a>
    </span></dt><dd><p>
<!--
      This option controls the behavior of automatically updatable views.  When
      this option is specified, <command>INSERT</command> and <command>UPDATE</command>
      commands on the view will be checked to ensure that new rows satisfy the
      view-defining condition (that is, the new rows are checked to ensure that
      they are visible through the view).  If they are not, the update will be
      rejected.  If the <literal>CHECK OPTION</literal> is not specified,
      <command>INSERT</command> and <command>UPDATE</command> commands on the view are
      allowed to create rows that are not visible through the view.  The
      following check options are supported:
-->
このオプションは、自動的に更新可能なビューの動作を制御します。
このオプションが指定された場合、ビューに対する<code class="command">INSERT</code>および<code class="command">UPDATE</code>コマンドでは、新しい行がビュー定義の条件を満たすことが検査されます(つまり、新しい行がビューで見ることができるかどうか、検査されます)。
条件を満たさない場合、更新は拒絶されます。
<code class="literal">CHECK OPTION</code>が指定されない場合、ビューに対する<code class="command">INSERT</code>および<code class="command">UPDATE</code>コマンドは、ビューで見ることができない行を作ることができます。
以下のcheck optionがサポートされます。

      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">LOCAL</code></span></dt><dd><p>
<!--
          New rows are only checked against the conditions defined directly in
          the view itself.  Any conditions defined on underlying base views are
          not checked (unless they also specify the <literal>CHECK OPTION</literal>).
-->
新しい行は、そのビュー自体に直接定義されている条件に対してのみ検査されます。
ビューが基にするビューについて定義されている条件は、(それらも<code class="literal">CHECK OPTION</code>を指定しているのでなければ)検査されません。
         </p></dd><dt><span class="term"><code class="literal">CASCADED</code></span></dt><dd><p>
<!--
          New rows are checked against the conditions of the view and all
          underlying base views.  If the <literal>CHECK OPTION</literal> is specified,
          and neither <literal>LOCAL</literal> nor <literal>CASCADED</literal> is specified,
          then <literal>CASCADED</literal> is assumed.
-->
新しい行は、そのビュー、およびそれが基にするすべてのビューの条件に対して検査されます。
<code class="literal">CHECK OPTION</code>が指定され、<code class="literal">LOCAL</code>も<code class="literal">CASCADED</code>も指定されていないときは、<code class="literal">CASCADED</code>が指定されたとみなされます。
         </p></dd></dl></div><p>
     </p><p>
<!--
      The <literal>CHECK OPTION</literal> may not be used with <literal>RECURSIVE</literal>
      views.
-->
<code class="literal">CHECK OPTION</code>は<code class="literal">RECURSIVE</code>なビューで使うことはできません。
     </p><p>
<!--
      Note that the <literal>CHECK OPTION</literal> is only supported on views that
      are automatically updatable, and do not have <literal>INSTEAD OF</literal>
      triggers or <literal>INSTEAD</literal> rules.  If an automatically updatable
      view is defined on top of a base view that has <literal>INSTEAD OF</literal>
      triggers, then the <literal>LOCAL CHECK OPTION</literal> may be used to check
      the conditions on the automatically updatable view, but the conditions
      on the base view with <literal>INSTEAD OF</literal> triggers will not be
      checked (a cascaded check option will not cascade down to a
      trigger-updatable view, and any check options defined directly on a
      trigger-updatable view will be ignored).  If the view or any of its base
      relations has an <literal>INSTEAD</literal> rule that causes the
      <command>INSERT</command> or <command>UPDATE</command> command to be rewritten, then
      all check options will be ignored in the rewritten query, including any
      checks from automatically updatable views defined on top of the relation
      with the <literal>INSTEAD</literal> rule.
-->
<code class="literal">CHECK OPTION</code>は、自動更新可能で、かつ<code class="literal">INSTEAD OF</code>トリガーも<code class="literal">INSTEAD</code>ルールもないビューについてのみサポートされていることに注意してください。
自動更新可能ビューが<code class="literal">INSTEAD OF</code>トリガーのあるビューに基づいて定義されている場合、<code class="literal">LOCAL CHECK OPTION</code>を使って自動更新可能ビューの条件を検査することはできますが、<code class="literal">INSTEAD OF</code>トリガーを持つ基のビューの条件は検査されません(cascaded check optionはトリガーで更新されるビューにまでは伝わらず、またトリガーで更新可能なビューに直接定義されたcheck optionは無視されます)。
ビューあるいはその基となるリレーションに<code class="literal">INSTEAD</code>ルールがあり、<code class="command">INSERT</code>あるいは<code class="command">UPDATE</code>の書き換えが生じる場合、その書き換えられたクエリでは(<code class="literal">INSTEAD</code>ルールのあるリレーションに基づく自動更新可能ビューのものも含めて)すべてのcheck optionが無視されます。
     </p></dd></dl></div></div><div class="refsect1" id="id-1.9.3.97.7"><h2>注釈</h2><!--
  <title>Notes</title>
--><p>
<!--
    Use the <link linkend="sql-dropview"><command>DROP VIEW</command></link>
    statement to drop views.
-->
ビューを削除するには、<a class="link" href="sql-dropview.html" title="DROP VIEW"><code class="command">DROP VIEW</code></a>文を使用してください。
   </p><p>
<!--
    Be careful that the names and types of the view's columns will be
    assigned the way you want.  For example:
-->
ビューの列の名前と型は指定通りに割り当てられることに注意してください。
例えば、次のコマンドを見てください。
</p><pre class="programlisting">
CREATE VIEW vista AS SELECT 'Hello World';
</pre><p>
<!--
    is bad form because the column name defaults to <literal>?column?</literal>;
    also, the column data type defaults to <type>text</type>, which might not
    be what you wanted.  Better style for a string literal in a view's
    result is something like:
-->
この例は列の名前がデフォルトの<code class="literal">?column?</code>になるので好ましくありません。
また、列のデータ型もデフォルトの<code class="type">text</code>になりますが、これは求めるものと違うかもしれません。
ビューの結果として文字リテラルを返したい場合は、次のように指定するのがよりよい方法です。
</p><pre class="programlisting">
CREATE VIEW vista AS SELECT text 'Hello World' AS hello;
</pre><p>
   </p><p>
<!--
    By default, access to the underlying base relations referenced in the view
    is determined by the permissions of the view owner.  In some cases, this
    can be used to provide secure but restricted access to the underlying
    tables.  However, not all views are secure against tampering; see <xref
    linkend="rules-privileges"/> for details.
-->
デフォルトでは、ビューで参照される基となる基底リレーションへのアクセス権は、ビューの所有者の権限によって決定されます。
場合によっては、これを使用して基となるテーブルへの安全だが制限されたアクセスを提供できます。
しかしすべてのビューが不正な改変に対して安全というわけではありません。詳細は<a class="xref" href="rules-privileges.html" title="41.5. ルールと権限">41.5</a>を参照してください。
   </p><p>
<!--
    If the view has the <literal>security_invoker</literal> property set to
    <literal>true</literal>, access to the underlying base relations is
    determined by the permissions of the user executing the query, rather than
    the view owner.  Thus, the user of a security invoker view must have the
    relevant permissions on the view and its underlying base relations.
-->
ビューの<code class="literal">security_invoker</code>属性が<code class="literal">true</code>に設定されている場合、基となる基底リレーションへのアクセス権は、ビューの所有者ではなく、問い合わせを実行するユーザーの権限によって決定されます。
したがって、セキュリティ実行者ビューのユーザーは、ビューおよび基となる基底リレーションに対する適切な権限を持っている必要があります。
   </p><p>
<!--
    If any of the underlying base relations is a security invoker view, it
    will be treated as if it had been accessed directly from the original
    query.  Thus, a security invoker view will always check its underlying
    base relations using the permissions of the current user, even if it is
    accessed from a view without the <literal>security_invoker</literal>
    property.
-->
基となる基底リレーションのいずれかがセキュリティ実行者ビューである場合、元の問い合わせから直接アクセスされたものとして処理されます。
したがって、セキュリティ実行者ビューは、<code class="literal">security_invoker</code>属性なしのビューからアクセスされた場合でも、常に現行ユーザーの権限を使用して基となる基底リレーションをチェックします。
   </p><p>
<!--
    If any of the underlying base relations has
    <link linkend="ddl-rowsecurity">row-level security</link> enabled, then
    by default, the row-level security policies of the view owner are applied,
    and access to any additional relations referred to by those policies is
    determined by the permissions of the view owner.  However, if the view has
    <literal>security_invoker</literal> set to <literal>true</literal>, then
    the policies and permissions of the invoking user are used instead, as if
    the base relations had been referenced directly from the query using the
    view.
-->
基となる基底リレーションのいずれかで<a class="link" href="ddl-rowsecurity.html" title="5.8. 行セキュリティポリシー">行レベルセキュリティ</a>が有効になっている場合、デフォルトでは、ビューの所有者の行レベルセキュリティポリシーが適用され、これらのポリシーによって参照される追加のリレーションへのアクセスは、ビュー所有者の権限によって決定されます。
ただし、ビューの<code class="literal">security_invoker</code>が<code class="literal">true</code>に設定されている場合は、基底リレーションがそのビューを使用した問い合わせから直接参照されているかのように、かわりに実行ユーザーのポリシーと権限が使用されます。
   </p><p>
<!--
    Functions called in the view are treated the same as if they had been
    called directly from the query using the view.  Therefore, the user of
    a view must have permissions to call all functions used by the view.
    Functions in the view are executed with the privileges of the user
    executing the query or the function owner, depending on whether the
    functions are defined as <literal>SECURITY INVOKER</literal> or
    <literal>SECURITY DEFINER</literal>.  Thus, for example, calling
    <literal>CURRENT_USER</literal> directly in a view will always return the
    invoking user, not the view owner.  This is not affected by the view's
    <literal>security_invoker</literal> setting, and so a view with
    <literal>security_invoker</literal> set to <literal>false</literal> is
    <emphasis>not</emphasis> equivalent to a
    <literal>SECURITY DEFINER</literal> function and those concepts should not
    be confused.
-->
ビューで呼び出された関数は、ビューを使用する問い合わせから直接呼び出された場合と同様に処理されます。
したがって、ビューのユーザーは、ビューで使用されるすべての関数を呼び出す権限を持っている必要があります。
ビュー内の関数は、関数が<code class="literal">SECURITY INVOKER</code>または<code class="literal">SECURITY DEFINER</code>として定義されているかどうかに応じて、問い合わせを実行するユーザーまたは関数の所有者の権限で実行されます。
したがって、たとえば、ビューで<code class="literal">CURRENT_USER</code>を直接呼び出すと、ビューの所有者ではなく常に実行ユーザーを返します。
これはビューの<code class="literal">security_invoker</code>設定の影響を受けません。
したがって、<code class="literal">security_invoker</code>が<code class="literal">false</code>に設定されているビューは<code class="literal">SECURITY DEFINER</code>関数と同等では<span class="emphasis"><em>なく</em></span>、これらの概念を混同しないでください。
   </p><p>
<!--
    The user creating or replacing a view must have <literal>USAGE</literal>
    privileges on any schemas referred to in the view query, in order to look
    up the referenced objects in those schemas.  Note, however, that this
    lookup only happens when the view is created or replaced.  Therefore, the
    user of the view only requires the <literal>USAGE</literal> privilege on
    the schema containing the view, not on the schemas referred to in the view
    query, even for a security invoker view.
-->
ビューを作成または置換するユーザーは、スキーマ内の参照オブジェクトを検索するために、ビュー問い合わせで参照されるスキーマに対する<code class="literal">USAGE</code>権限を持っている必要があります。
ただし、この参照は、ビューが作成または置換された場合にのみ行なわれることに注意してください。
したがって、ビューのユーザーは、ビューを含むスキーマに対する<code class="literal">USAGE</code>権限のみを必要とし、セキュリティ実行者ビューの場合でも、ビュー問い合わせで参照されるスキーマに対する<code class="literal">USAGE</code>権限を必要としません。
   </p><p>
<!--
    When <command>CREATE OR REPLACE VIEW</command> is used on an existing
    view, only the view's defining SELECT rule, plus any
    <literal>WITH ( ... )</literal> parameters and its
    <literal>CHECK OPTION</literal> are changed.
    Other view properties, including ownership, permissions, and non-SELECT
    rules, remain unchanged.  You must own the view
    to replace it (this includes being a member of the owning role).
-->
<code class="command">CREATE OR REPLACE VIEW</code>が既存のビューに対して使用されると、ビューを定義するSELECTルール、<code class="literal">WITH ( ... )</code>パラメータ、<code class="literal">CHECK OPTION</code>のみが変更されます。
所有者、権限、SELECT以外のルールなど他のビューの属性はそのまま変更されません。
置き換えるためにはビューの所有者（所有ロールのメンバである場合も含む）でなければなりません。
   </p><div class="refsect2" id="SQL-CREATEVIEW-UPDATABLE-VIEWS"><h3>更新可能ビュー</h3><!--
   <title>Updatable Views</title>
--><a id="id-1.9.3.97.7.11.2" class="indexterm"></a><a id="id-1.9.3.97.7.11.3" class="indexterm"></a><p>
<!--
    Simple views are automatically updatable: the system will allow
    <command>INSERT</command>, <command>UPDATE</command> and <command>DELETE</command> statements
    to be used on the view in the same way as on a regular table.  A view is
    automatically updatable if it satisfies all of the following conditions:
-->
簡単なビューは自動更新可能になります。
システムは、ビューに対する<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>文を通常のテーブルの場合と同じ方法で使用できるようにします。
以下の条件のすべてを満たす場合に、ビューは自動更新可能になります。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<!--
       The view must have exactly one entry in its <literal>FROM</literal> list,
       which must be a table or another updatable view.
-->
ビューの<code class="literal">FROM</code>リストには正確に１つだけの項目を持たなければならず、それはテーブルまたは他の更新可能ビューでなければなりません。
      </p></li><li class="listitem"><p>
<!--
       The view definition must not contain <literal>WITH</literal>,
       <literal>DISTINCT</literal>, <literal>GROUP BY</literal>, <literal>HAVING</literal>,
       <literal>LIMIT</literal>, or <literal>OFFSET</literal> clauses at the top level.
-->
ビューの定義の最上位レベルにおいて<code class="literal">WITH</code>、<code class="literal">DISTINCT</code>、<code class="literal">GROUP BY</code>、<code class="literal">HAVING</code>、<code class="literal">LIMIT</code>、<code class="literal">OFFSET</code>を含めてはなりません。
      </p></li><li class="listitem"><p>
<!--
       The view definition must not contain set operations (<literal>UNION</literal>,
       <literal>INTERSECT</literal> or <literal>EXCEPT</literal>) at the top level.
-->
ビューの定義の最上位レベルにおいて集合操作（<code class="literal">UNION</code>、<code class="literal">INTERSECT</code>、<code class="literal">EXCEPT</code>）を含めてはなりません。
      </p></li><li class="listitem"><p>
<!--
       The view's select list must not contain any aggregates, window functions
       or set-returning functions.
-->
ビューの選択リストに、集約関数、ウィンドウ関数、集合を返す関数を含めてはなりません。
      </p></li></ul></div><p>
   </p><p>
<!--
    An automatically updatable view may contain a mix of updatable and
    non-updatable columns.  A column is updatable if it is a simple reference
    to an updatable column of the underlying base relation; otherwise the
    column is read-only, and an error will be raised if an <command>INSERT</command>
    or <command>UPDATE</command> statement attempts to assign a value to it.
-->
自動更新可能ビューでは、更新可能な列と更新不可能な列を混在させることができます。
基になるリレーションの更新可能な列を単純に参照する列は更新可能です。
そうでなければ列は更新不可能で、<code class="command">INSERT</code>あるいは<code class="command">UPDATE</code>文でその列に値を設定しようとしたらエラーが発生します。
   </p><p>
<!--
    If the view is automatically updatable the system will convert any
    <command>INSERT</command>, <command>UPDATE</command> or <command>DELETE</command> statement
    on the view into the corresponding statement on the underlying base
    relation.  <command>INSERT</command> statements that have an <literal>ON
    CONFLICT UPDATE</literal> clause are fully supported.
-->
ビューが自動更新可能であれば、システムはビューに対する<code class="command">INSERT</code>、<code class="command">UPDATE</code>または<code class="command">DELETE</code>文を基となるベースリレーションへの対応する文に変換します。
<code class="literal">ON CONFLICT UPDATE</code>句を持つ<code class="command">INSERT</code>文は完全にサポートされます。
   </p><p>
<!--
    If an automatically updatable view contains a <literal>WHERE</literal>
    condition, the condition restricts which rows of the base relation are
    available to be modified by <command>UPDATE</command> and <command>DELETE</command>
    statements on the view.  However, an <command>UPDATE</command> is allowed to
    change a row so that it no longer satisfies the <literal>WHERE</literal>
    condition, and thus is no longer visible through the view.  Similarly,
    an <command>INSERT</command> command can potentially insert base-relation rows
    that do not satisfy the <literal>WHERE</literal> condition and thus are not
    visible through the view (<literal>ON CONFLICT UPDATE</literal> may
    similarly affect an existing row not visible through the view).
    The <literal>CHECK OPTION</literal> may be used to prevent
    <command>INSERT</command> and <command>UPDATE</command> commands from creating
    such rows that are not visible through the view.
-->
自動更新可能ビューが<code class="literal">WHERE</code>条件を持つ場合、
ベースリレーションのどの行をビューに対する<code class="command">UPDATE</code>、<code class="command">DELETE</code>文により変更可能かをその条件が制限します。
しかし<code class="command">UPDATE</code>による行の変更の結果<code class="literal">WHERE</code>を満たさなくなり、その結果、ビューからは参照することができなくなることがあります。
同様に<code class="command">INSERT</code>コマンドは<code class="literal">WHERE</code>条件を満たさず、そのためビューを通して参照することができない行をベースリレーションに挿入する可能性があります（<code class="literal">ON CONFLICT UPDATE</code>はビューを通して見えない既存の行に同様に影響を及ぼすかもしれません）。
<code class="literal">CHECK OPTION</code>は<code class="command">INSERT</code>や<code class="command">UPDATE</code>がビューで見ることができない行を作るのを防ぐために使うことができます。
   </p><p>
<!--
    If an automatically updatable view is marked with the
    <literal>security_barrier</literal> property then all the view's <literal>WHERE</literal>
    conditions (and any conditions using operators which are marked as <literal>LEAKPROOF</literal>)
    will always be evaluated before any conditions that a user of the view has
    added.   See <xref linkend="rules-privileges"/> for full details.  Note that,
    due to this, rows which are not ultimately returned (because they do not
    pass the user's <literal>WHERE</literal> conditions) may still end up being locked.
    <command>EXPLAIN</command> can be used to see which conditions are
    applied at the relation level (and therefore do not lock rows) and which are
    not.
-->
自動更新可能ビューが<code class="literal">security_barrier</code>属性を持つ場合、ビューのすべての<code class="literal">WHERE</code>条件(および<code class="literal">LEAKPROOF</code>の演算子を使ったすべての条件)が、必ず、ビューのユーザーが追加した条件より前に評価されます。
詳細は<a class="xref" href="rules-privileges.html" title="41.5. ルールと権限">41.5</a>を参照してください。
このため、最終的には(ユーザーの<code class="literal">WHERE</code>条件を満たさないために)戻されない行もロックされてしまう場合があることに注意してください。
<code class="command">EXPLAIN</code>を使って、リレーションのレベルでどの条件が使われ(その結果、行をロックしない)、どの条件が使われないかを調べることができます。
   </p><p>
<!--
    A more complex view that does not satisfy all these conditions is
    read-only by default: the system will not allow an insert, update, or
    delete on the view.  You can get the effect of an updatable view by
    creating <literal>INSTEAD OF</literal> triggers on the view, which must
    convert attempted inserts, etc. on the view into appropriate actions
    on other tables.  For more information see <xref
    linkend="sql-createtrigger"/>.  Another possibility is to create rules
    (see <xref linkend="sql-createrule"/>), but in practice triggers are
    easier to understand and use correctly.
-->
これらの条件をすべて満たさないより複雑なビューはデフォルトで読み取り専用です。
システムはビューに対する挿入、更新、削除を許可しません。
ビューに対する<code class="literal">INSTEAD OF</code>トリガを作成することで、更新可能ビューの効果を得ることができます。
このトリガはビューに対する挿入試行などを他のテーブルに対する適切な操作に変換するものでなければなりません。
詳細については<a class="xref" href="sql-createtrigger.html" title="CREATE TRIGGER"><span class="refentrytitle">CREATE TRIGGER</span></a>を参照してください。
他にもルールを作成する（<a class="xref" href="sql-createrule.html" title="CREATE RULE"><span class="refentrytitle">CREATE RULE</span></a>参照）ことでも実現できますが、実際にはトリガの方が理解しやすく正しく使用するのが容易です。
   </p><p>
<!--
    Note that the user performing the insert, update or delete on the view
    must have the corresponding insert, update or delete privilege on the
    view.  In addition, by default, the view's owner must have the relevant
    privileges on the underlying base relations, whereas the user performing
    the update does not need any permissions on the underlying base relations
    (see <xref linkend="rules-privileges"/>).  However, if the view has
    <literal>security_invoker</literal> set to <literal>true</literal>, the
    user performing the update, rather than the view owner, must have the
    relevant privileges on the underlying base relations.
-->
ビューに対する挿入、更新、削除を行うユーザーは、ビューに対して対応する挿入、更新、削除権限を持たなければならないことに注意してください。
さらに、デフォルトでは、ビューの所有者は基となる基底リレーションに対する適切な権限を持たなければならないのに対して、更新を行なうユーザーは基となる基底リレーションに対する権限をまったく必要としません（<a class="xref" href="rules-privileges.html" title="41.5. ルールと権限">41.5</a>参照）。
しかし、ビューの<code class="literal">security_invoker</code>が<code class="literal">true</code>に設定されていれば、ビューの所有者ではなく更新を行なうユーザーが基となる基底リレーションに対する適切な権限を持たなければなりません。
   </p></div></div><div class="refsect1" id="id-1.9.3.97.8"><h2>例</h2><!--
  <title>Examples</title>
--><p>
<!--
   Create a view consisting of all comedy films:
-->
全てのコメディ映画（Comedy films）からなるビューを作成します。

</p><pre class="programlisting">
CREATE VIEW comedies AS
    SELECT *
    FROM films
    WHERE kind = 'Comedy';
</pre><p>
<!--
   This will create a view containing the columns that are in the
   <literal>film</literal> table at the time of view creation.  Though
   <literal>*</literal> was used to create the view, columns added later to
   the table will not be part of the view.
-->
これはビューを作成した時点で<code class="literal">film</code>テーブル内にある列を持つビューを作成します。
ビューを作成するために<code class="literal">*</code>が使用されていますが、その後にテーブルに追加された列はビューには含まれません。
  </p><p>
<!--
   Create a view with <literal>LOCAL CHECK OPTION</literal>:
-->
<code class="literal">LOCAL CHECK OPTION</code>を使ってビューを作成します。

</p><pre class="programlisting">
CREATE VIEW universal_comedies AS
    SELECT *
    FROM comedies
    WHERE classification = 'U'
    WITH LOCAL CHECK OPTION;
</pre><p>
<!--
   This will create a view based on the <literal>comedies</literal> view, showing
   only films with <literal>kind = 'Comedy'</literal> and
   <literal>classification = 'U'</literal>. Any attempt to <command>INSERT</command> or
   <command>UPDATE</command> a row in the view will be rejected if the new row
   doesn't have <literal>classification = 'U'</literal>, but the film
   <literal>kind</literal> will not be checked.
-->
これは<code class="literal">comedies</code>ビューに基づくビューを作成し、<code class="literal">kind = 'Comedy'</code>かつ<code class="literal">classification = 'U'</code>である映画だけを表示します。
このビューでの行の<code class="command">INSERT</code>や<code class="command">UPDATE</code>は、<code class="literal">classification = 'U'</code>でなければ拒絶されますが、映画の<code class="literal">kind</code>は検査されません。
  </p><p>
<!--
   Create a view with <literal>CASCADED CHECK OPTION</literal>:
-->
<code class="literal">CASCADED CHECK OPTION</code>でビューを作成します。

</p><pre class="programlisting">
CREATE VIEW pg_comedies AS
    SELECT *
    FROM comedies
    WHERE classification = 'PG'
    WITH CASCADED CHECK OPTION;
</pre><p>
<!--
   This will create a view that checks both the <literal>kind</literal> and
   <literal>classification</literal> of new rows.
-->
これは新しい行について<code class="literal">kind</code>と<code class="literal">classification</code>の両方を検査するビューを作成します。
  </p><p>
<!--
   Create a view with a mix of updatable and non-updatable columns:
-->
更新可能な列と更新不可能な列が混在するビューを作成します。

</p><pre class="programlisting">
CREATE VIEW comedies AS
    SELECT f.*,
           country_code_to_name(f.country_code) AS country,
           (SELECT avg(r.rating)
            FROM user_ratings r
            WHERE r.film_id = f.id) AS avg_rating
    FROM films f
    WHERE f.kind = 'Comedy';
</pre><p>
<!--
   This view will support <command>INSERT</command>, <command>UPDATE</command> and
   <command>DELETE</command>.  All the columns from the <literal>films</literal> table will
   be updatable, whereas the computed columns <literal>country</literal> and
   <literal>avg_rating</literal> will be read-only.
-->
このビューは<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>をサポートします。
<code class="literal">films</code>テーブルからのすべての列は更新可能ですが、計算される列<code class="literal">country</code>と<code class="literal">avg_rating</code>は更新できません。
  </p><p>
<!--
   Create a recursive view consisting of the numbers from 1 to 100:
-->
1から100までの数からなる再帰的ビューを作成します。
</p><pre class="programlisting">
CREATE RECURSIVE VIEW public.nums_1_100 (n) AS
    VALUES (1)
UNION ALL
    SELECT n+1 FROM nums_1_100 WHERE n &lt; 100;
</pre><p>
<!--
   Notice that although the recursive view's name is schema-qualified in this
   <command>CREATE</command>, its internal self-reference is not schema-qualified.
   This is because the implicitly-created CTE's name cannot be
   schema-qualified.
-->
上記の<code class="command">CREATE</code>において再帰的ビューの名前はスキーマ修飾されていますが、その内側の自己参照はスキーマ修飾されていないことに注意してください。
これは、暗黙的に作成されるCTEの名前はスキーマ修飾できないからです。
  </p></div><div class="refsect1" id="id-1.9.3.97.9"><h2>互換性</h2><!--
  <title>Compatibility</title>
--><p>
<!--
   <command>CREATE OR REPLACE VIEW</command> is a
   <productname>PostgreSQL</productname> language extension.
   So is the concept of a temporary view.
   The <literal>WITH ( ... )</literal> clause is an extension as well, as are
   security barrier views and security invoker views.
-->
<code class="command">CREATE OR REPLACE VIEW</code>は<span class="productname">PostgreSQL</span>の言語拡張です。
一時ビューという概念も言語拡張です。
<code class="literal">WITH ( ... )</code>句も拡張ですし、セキュリティバリアビューとセキュリティ実行者ビューも同様です。
  </p></div><div class="refsect1" id="id-1.9.3.97.10"><h2>関連項目</h2><!--
  <title>See Also</title>
--><span class="simplelist"><a class="xref" href="sql-alterview.html" title="ALTER VIEW"><span class="refentrytitle">ALTER VIEW</span></a>, <a class="xref" href="sql-dropview.html" title="DROP VIEW"><span class="refentrytitle">DROP VIEW</span></a>, <a class="xref" href="sql-creatematerializedview.html" title="CREATE MATERIALIZED VIEW"><span class="refentrytitle">CREATE MATERIALIZED VIEW</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createusermapping.html" title="CREATE USER MAPPING">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-deallocate.html" title="DEALLOCATE">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE USER MAPPING </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 16.0文書">ホーム</a></td><td width="40%" align="right" valign="top"> DEALLOCATE</td></tr></table></div></body></html>