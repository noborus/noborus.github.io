<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>38.17. 関連するオブジェクトを拡張としてパッケージ化</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="xindex.html" title="38.16. インデックス拡張機能へのインタフェース" /><link rel="next" href="extend-pgxs.html" title="38.18. 拡張構築基盤" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 14.0文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="extend.html" title="第38章 SQLの拡張">第38章 <acronym class="acronym">SQL</acronym>の拡張</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 14.0 &#10;                      extend-extensions.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="xindex.html" title="38.16. インデックス拡張機能へのインタフェース">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="extend.html" title="第38章 SQLの拡張">上へ</a></td><td width="60%" align="center">38.17. 関連するオブジェクトを拡張としてパッケージ化</td><td width="20%" align="right"> <a accesskey="n" href="extend-pgxs.html" title="38.18. 拡張構築基盤">次へ</a></td></tr></table><hr /></div><div class="sect1" id="EXTEND-EXTENSIONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">38.17. 関連するオブジェクトを拡張としてパッケージ化</h2></div></div></div><span class="original">
   &lt;title&gt;Packaging Related Objects into an Extension&lt;/title&gt;
</span><a id="id-1.8.3.20.2" class="indexterm"></a><p>
<span class="original">
    A useful extension to &lt;productname&gt;PostgreSQL&lt;/productname&gt; typically includes
    multiple SQL objects; for example, a new data type will require new
    functions, new operators, and probably new index operator classes.
    It is helpful to collect all these objects into a single package
    to simplify database management.  &lt;productname&gt;PostgreSQL&lt;/productname&gt; calls
    such a package an &lt;firstterm&gt;extension&lt;/firstterm&gt;.  To define an extension,
    you need at least a &lt;firstterm&gt;script file&lt;/firstterm&gt; that contains the
    &lt;acronym&gt;SQL&lt;/acronym&gt; commands to create the extension's objects, and a
    &lt;firstterm&gt;control file&lt;/firstterm&gt; that specifies a few basic properties
    of the extension itself.  If the extension includes C code, there
    will typically also be a shared library file into which the C code
    has been built.  Once you have these files, a simple
    &lt;link linkend="sql-createextension"&gt;&lt;command&gt;CREATE EXTENSION&lt;/command&gt;&lt;/link&gt; command loads the objects into
    your database.
</span>
<span class="productname">PostgreSQL</span>への有用な拡張は通常、複数のSQLオブジェクトを含んでいます。
例えば、新しいデータ型は新しい関数、新しい演算子、おそらく新しいインデックス演算子クラスを必要とします。
これらのオブジェクトをすべて単一のパッケージとしてまとめることは、データベース管理を単純化するために役に立ちます。
<span class="productname">PostgreSQL</span>ではこうしたパッケージを<em class="firstterm">拡張</em>とよびます。
拡張を定義するためには、少なくとも、拡張のオブジェクトを作成するための<acronym class="acronym">SQL</acronym>コマンドを含む<em class="firstterm">スクリプトファイル</em>、拡張自身の数個の基本属性を指定する<em class="firstterm">制御ファイル</em>が必要です。
また拡張がCコードを含む場合、通常Cコードで構築された共有ライブラリが存在します。
これらのファイルがあれば、単純な<a class="link" href="sql-createextension.html" title="CREATE EXTENSION"><code class="command">CREATE EXTENSION</code></a>コマンドがそのオブジェクトをデータベース内に読み込みます。
   </p><p>
<span class="original">
    The main advantage of using an extension, rather than just running the
    &lt;acronym&gt;SQL&lt;/acronym&gt; script to load a bunch of &lt;quote&gt;loose&lt;/quote&gt; objects
    into your database, is that &lt;productname&gt;PostgreSQL&lt;/productname&gt; will then
    understand that the objects of the extension go together.  You can
    drop all the objects with a single &lt;link linkend="sql-dropextension"&gt;&lt;command&gt;DROP EXTENSION&lt;/command&gt;&lt;/link&gt;
    command (no need to maintain a separate &lt;quote&gt;uninstall&lt;/quote&gt; script).
    Even more useful, &lt;application&gt;pg_dump&lt;/application&gt; knows that it should not
    dump the individual member objects of the extension &amp;mdash; it will
    just include a &lt;command&gt;CREATE EXTENSION&lt;/command&gt; command in dumps, instead.
    This vastly simplifies migration to a new version of the extension
    that might contain more or different objects than the old version.
    Note however that you must have the extension's control, script, and
    other files available when loading such a dump into a new database.
</span>
拡張を使用する主な利点は、<acronym class="acronym">SQL</acronym>スクリプトを実行するだけでデータベースに<span class="quote">「<span class="quote">粗な</span>」</span>なオブジェクトの群をロードできることではなく、<span class="productname">PostgreSQL</span>が拡張のオブジェクトをまとまったものと理解できることです。
単一の<a class="link" href="sql-dropextension.html" title="DROP EXTENSION"><code class="command">DROP EXTENSION</code></a>コマンドでオブジェクトすべてを削除することができます（個々の<span class="quote">「<span class="quote">アンインストール</span>」</span>スクリプトを保守する必要はありません）。
もっと有用なことは、<span class="application">pg_dump</span>が拡張の個々のメンバオブジェクトをダンプしてはならないことを把握していることです。
代わりにダンプ内には<code class="command">CREATE EXTENSION</code>コマンドだけが含まれます。
これは、古いバージョンよりも多くのまたは異なるオブジェクトを含む可能性がある、拡張の新しいバージョンへの移行を大きく単純化します。
しかし、こうしたダンプを新しいデータベースにロードする際には、拡張の制御ファイル、スクリプトファイル、その他のファイルが利用できるようにしておく必要があります。
   </p><p>
<span class="original">
    &lt;productname&gt;PostgreSQL&lt;/productname&gt; will not let you drop an individual object
    contained in an extension, except by dropping the whole extension.
    Also, while you can change the definition of an extension member object
    (for example, via &lt;command&gt;CREATE OR REPLACE FUNCTION&lt;/command&gt; for a
    function), bear in mind that the modified definition will not be dumped
    by &lt;application&gt;pg_dump&lt;/application&gt;.  Such a change is usually only sensible if
    you concurrently make the same change in the extension's script file.
    (But there are special provisions for tables containing configuration
    data; see &lt;xref linkend="extend-extensions-config-tables"/&gt;.)
    In production situations, it's generally better to create an extension
    update script to perform changes to extension member objects.
</span>
<span class="productname">PostgreSQL</span>はユーザに、拡張全体を削除させる以外に、拡張内に含まれる個々のオブジェクトを削除させません。
また、拡張のメンバオブジェクトの定義を変更する（例えば関数では<code class="command">CREATE OR REPLACE FUNCTION</code>を介して変更する）ことはできますが、変更した定義は<span class="application">pg_dump</span>によりダンプされないことに留意してください。
こうした変更は通常、同時に拡張のスクリプトファイルにも同じ変更を行った場合のみ認識することができます。
（しかし設定データを持つテーブルに対しては特殊な準備があります。<a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-CONFIG-TABLES" title="38.17.3. 拡張設定テーブル">38.17.3</a>を参照してください。）
本番環境では、拡張メンバオブジェクトへの変更を処理するために拡張更新スクリプトを作成するのが一般により良い方法です。
   </p><p>
<span class="original">
    The extension script may set privileges on objects that are part of the
    extension, using &lt;command&gt;GRANT&lt;/command&gt; and &lt;command&gt;REVOKE&lt;/command&gt;
    statements.  The final set of privileges for each object (if any are set)
    will be stored in the
    &lt;link linkend="catalog-pg-init-privs"&gt;&lt;structname&gt;pg_init_privs&lt;/structname&gt;&lt;/link&gt;
    system catalog.  When &lt;application&gt;pg_dump&lt;/application&gt; is used, the
    &lt;command&gt;CREATE EXTENSION&lt;/command&gt; command will be included in the dump, followed
    by the set of &lt;command&gt;GRANT&lt;/command&gt; and &lt;command&gt;REVOKE&lt;/command&gt;
    statements necessary to set the privileges on the objects to what they were
    at the time the dump was taken.
</span>
拡張スクリプトは、<code class="command">GRANT</code>文と<code class="command">REVOKE</code>文を使って拡張の一部のオブジェクトに権限を設定するかもしれません。
それぞれのオブジェクト（どれかが設定される場合）の最終的な権限のセットは、<a class="link" href="catalog-pg-init-privs.html" title="52.28. pg_init_privs"><code class="structname">pg_init_privs</code></a>システムカタログに格納されます。
<span class="application">pg_dump</span>が使用されると、<code class="command">CREATE EXTENSION</code>コマンドがダンプ内に含まれ、オブジェクトの権限をダンプが取られた時点のものに設定するために必要となる<code class="command">GRANT</code>文と<code class="command">REVOKE</code>文が後に続きます。
   </p><p>
<span class="original">
    &lt;productname&gt;PostgreSQL&lt;/productname&gt; does not currently support extension scripts
    issuing &lt;command&gt;CREATE POLICY&lt;/command&gt; or &lt;command&gt;SECURITY LABEL&lt;/command&gt;
    statements.  These are expected to be set after the extension has been
    created.  All RLS policies and security labels on extension objects will be
    included in dumps created by &lt;application&gt;pg_dump&lt;/application&gt;.
</span>
<span class="productname">PostgreSQL</span>は、現在拡張スクリプトにて<code class="command">CREATE POLICY</code>文や<code class="command">SECURITY LABEL</code>文の発行をサポートしていません。
これらは拡張が作成された後に設定されるべきです。
拡張オブジェクトのすべての行セキュリティポリシーとセキュリティラベルは<span class="application">pg_dump</span>によって作成されたダンプに含まれます。
   </p><p>
<span class="original">
    The extension mechanism also has provisions for packaging modification
    scripts that adjust the definitions of the SQL objects contained in an
    extension.  For example, if version 1.1 of an extension adds one function
    and changes the body of another function compared to 1.0, the extension
    author can provide an &lt;firstterm&gt;update script&lt;/firstterm&gt; that makes just those
    two changes.  The &lt;command&gt;ALTER EXTENSION UPDATE&lt;/command&gt; command can then
    be used to apply these changes and track which version of the extension
    is actually installed in a given database.
</span>
また拡張機構は、拡張に含まれるSQLオブジェクトの定義を調整するパッケージ調整スクリプトを準備しています。
例えば、拡張のバージョン1.1でバージョン1.0と比べて１つの関数を追加し、他の関数本体を変更する場合、拡張の作成者はこれらの２つの変更のみを行う<em class="firstterm">更新スクリプト</em>を提供することができます。
そして<code class="command">ALTER EXTENSION UPDATE</code>コマンドを使用して、これらの変更を適用し、指定されたデータベース内に実際にインストールされた拡張のバージョンが何かを記録します。
   </p><p>
<span class="original">
    The kinds of SQL objects that can be members of an extension are shown in
    the description of &lt;link linkend="sql-alterextension"&gt;&lt;command&gt;ALTER EXTENSION&lt;/command&gt;&lt;/link&gt;.  Notably, objects
    that are database-cluster-wide, such as databases, roles, and tablespaces,
    cannot be extension members since an extension is only known within one
    database.  (Although an extension script is not prohibited from creating
    such objects, if it does so they will not be tracked as part of the
    extension.)  Also notice that while a table can be a member of an
    extension, its subsidiary objects such as indexes are not directly
    considered members of the extension.
    Another important point is that schemas can belong to extensions, but not
    vice versa: an extension as such has an unqualified name and does not
    exist &lt;quote&gt;within&lt;/quote&gt; any schema.  The extension's member objects,
    however, will belong to schemas whenever appropriate for their object
    types.  It may or may not be appropriate for an extension to own the
    schema(s) its member objects are within.
</span>
拡張のメンバとなり得るSQLオブジェクトの種類を<a class="link" href="sql-alterextension.html" title="ALTER EXTENSION"><code class="command">ALTER EXTENSION</code></a>で説明します。
拡張は１つのデータベースの中でのみ認識されますので、データベース、ロール、テーブル空間などデータベースクラスタ全体のオブジェクトは拡張のメンバにすることができないことに注意してください。
（拡張のスクリプトでこうしたオブジェクトを生成することは禁止されていませんが、作成したとしても、拡張の一部として記録されません。）
また、テーブルは拡張のメンバになることができますが、インデックスなどそれに付随するオブジェクトは拡張の直接的なメンバとはみなされません。
もう一つの重要な点は、スキーマは拡張に属すことがありますがその逆はないということです。
拡張は非修飾名でいかなるスキーマ<span class="quote">「<span class="quote">の中に</span>」</span>も存在しません。
しかし、拡張のメンバオブジェクトはオブジェクトの型が適切であればスキーマに属します。
拡張が自身のメンバオブジェクトが属するスキーマを所有することは適切かも知れませんし、そうでないかも知れません。
   </p><p>
<span class="original">
    If an extension's script creates any temporary objects (such as temp
    tables), those objects are treated as extension members for the
    remainder of the current session, but are automatically dropped at
    session end, as any temporary object would be.  This is an exception
    to the rule that extension member objects cannot be dropped without
    dropping the whole extension.
</span>
ある拡張のスクリプトが（一時テーブルのような）一時オブジェクトを作成する場合、現在のセッションで、以降そのオブジェクトは拡張のメンバーとして扱われます。
しかしすべての一時オブジェクト同様、セッションの終わりに削除されます。
これは、拡張全体を削除することなしに、拡張のメンバーオブジェクトは削除できない、という規則の例外です。
   </p><div class="sect2" id="id-1.8.3.20.11"><div class="titlepage"><div><div><h3 class="title">38.17.1. 拡張のファイル</h3></div></div></div><span class="original">
    &lt;title&gt;Extension Files&lt;/title&gt;
</span><a id="id-1.8.3.20.11.2" class="indexterm"></a><p>
<span class="original">
     The &lt;command&gt;CREATE EXTENSION&lt;/command&gt; command relies on a control
     file for each extension, which must be named the same as the extension
     with a suffix of &lt;literal&gt;.control&lt;/literal&gt;, and must be placed in the
     installation's &lt;literal&gt;SHAREDIR/extension&lt;/literal&gt; directory.  There
     must also be at least one &lt;acronym&gt;SQL&lt;/acronym&gt; script file, which follows the
     naming pattern
     &lt;literal&gt;&lt;replaceable&gt;extension&lt;/replaceable&gt;&amp;#045;&amp;#045;&lt;replaceable&gt;old_version&lt;/replaceable&gt;&amp;#045;&amp;#045;&lt;replaceable&gt;target_version&lt;/replaceable&gt;.sql&lt;/literal&gt;
     (for example, &lt;literal&gt;foo&amp;#045;&amp;#045;1.0.sql&lt;/literal&gt; for version &lt;literal&gt;1.0&lt;/literal&gt; of
     extension &lt;literal&gt;foo&lt;/literal&gt;).  By default, the script file(s) are also
     placed in the &lt;literal&gt;SHAREDIR/extension&lt;/literal&gt; directory; but the
     control file can specify a different directory for the script file(s).
</span>
<code class="command">CREATE EXTENSION</code>コマンドは各拡張に関して、拡張と同じ名前に<code class="literal">.control</code>という拡張子を持つファイル名である必要がある、制御ファイルに依存します。
また、このファイルはインストレーションの<code class="literal">SHAREDIR/extension</code>ディレクトリ内に存在しなければなりません。
また少なくとも１つの、<code class="literal"><em class="replaceable"><code>extension</code></em>--<em class="replaceable"><code>old_version</code></em>--<em class="replaceable"><code>target_version</code></em>.sql</code>という命名規約（例えば<code class="literal">foo</code>拡張のバージョン<code class="literal">1.0</code>では<code class="literal">foo--1.0.sql</code>）に従った<acronym class="acronym">SQL</acronym>スクリプトファイルが存在しなければなりません。
デフォルトでは、このスクリプトファイルも<code class="literal">SHAREDIR/extension</code>ディレクトリに格納されますが、制御ファイルでスクリプトファイルを別のディレクトリに指定することができます。
    </p><p>
<span class="original">
     The file format for an extension control file is the same as for the
     &lt;filename&gt;postgresql.conf&lt;/filename&gt; file, namely a list of
     &lt;replaceable&gt;parameter_name&lt;/replaceable&gt; &lt;literal&gt;=&lt;/literal&gt; &lt;replaceable&gt;value&lt;/replaceable&gt;
     assignments, one per line.  Blank lines and comments introduced by
     &lt;literal&gt;#&lt;/literal&gt; are allowed.  Be sure to quote any value that is not
     a single word or number.
</span>
拡張の制御ファイルのファイル書式は<code class="filename">postgresql.conf</code>ファイルと同じです。
すなわち、<em class="replaceable"><code>parameter_name</code></em> <code class="literal">=</code> <em class="replaceable"><code>value</code></em>という代入を１行当たり１つ記述します。
空行および<code class="literal">#</code>から始まるコメントが許されます。
単一の単語または数字ではない値にはすべて引用符で確実にくくってください。
    </p><p>
<span class="original">
     A control file can set the following parameters:
</span>
制御ファイルは以下のパラメータを設定することができます。
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="varname">directory</code> (<code class="type">string</code>)</span></dt><dd><p>
<span class="original">
        The directory containing the extension's &lt;acronym&gt;SQL&lt;/acronym&gt; script
        file(s).  Unless an absolute path is given, the name is relative to
        the installation's &lt;literal&gt;SHAREDIR&lt;/literal&gt; directory.  The
        default behavior is equivalent to specifying
        &lt;literal&gt;directory = 'extension'&lt;/literal&gt;.
</span>
拡張の<acronym class="acronym">SQL</acronym>スクリプトファイルを含むディレクトリです。
絶対パスで指定されていない限り、この名前はインストレーションの<code class="literal">SHAREDIR</code>ディレクトリからの相対パスになります。
デフォルトの動作は<code class="literal">directory = 'extension'</code>と指定した場合と同じです。
       </p></dd><dt><span class="term"><code class="varname">default_version</code> (<code class="type">string</code>)</span></dt><dd><p>
<span class="original">
        The default version of the extension (the one that will be installed
        if no version is specified in &lt;command&gt;CREATE EXTENSION&lt;/command&gt;).  Although
        this can be omitted, that will result in &lt;command&gt;CREATE EXTENSION&lt;/command&gt;
        failing if no &lt;literal&gt;VERSION&lt;/literal&gt; option appears, so you generally
        don't want to do that.
</span>
拡張のデフォルトのバージョン（<code class="command">CREATE EXTENSION</code>でバージョン指定がない場合にインストールされるバージョン）です。
これは省略することができますが、その場合<code class="literal">VERSION</code>オプションがない<code class="command">CREATE EXTENSION</code>は失敗します。
ですので通常省略しようとは思わないでしょう。
       </p></dd><dt><span class="term"><code class="varname">comment</code> (<code class="type">string</code>)</span></dt><dd><p>
<span class="original">
        A comment (any string) about the extension.  The comment is applied
        when initially creating an extension, but not during extension updates
        (since that might override user-added comments).  Alternatively,
        the extension's comment can be set by writing
        a &lt;xref linkend="sql-comment"/&gt; command in the script file.
</span>
拡張に関するコメント（任意の文字列）です。
最初に拡張が作成されるときにコメントは適用されますが、拡張が更新される間はされません（ユーザが追加したコメントを上書いてしまうため）。
この他の方法として、スクリプトファイル内で<a class="xref" href="sql-comment.html" title="COMMENT"><span class="refentrytitle">COMMENT</span></a>コマンドを使用してコメントを設定することができます。
       </p></dd><dt><span class="term"><code class="varname">encoding</code> (<code class="type">string</code>)</span></dt><dd><p>
<span class="original">
        The character set encoding used by the script file(s).  This should
        be specified if the script files contain any non-ASCII characters.
        Otherwise the files will be assumed to be in the database encoding.
</span>
スクリプトファイルで使用される文字セット符号化方式です。
スクリプトファイルに何らかの非ASCII文字が含まれる場合に指定しなければなりません。
指定がなければ、ファイルはデータベース符号化方式であると仮定されます。
       </p></dd><dt><span class="term"><code class="varname">module_pathname</code> (<code class="type">string</code>)</span></dt><dd><p>
<span class="original">
        The value of this parameter will be substituted for each occurrence
        of &lt;literal&gt;MODULE_PATHNAME&lt;/literal&gt; in the script file(s).  If it is not
        set, no substitution is made.  Typically, this is set to
        &lt;literal&gt;$libdir/&lt;replaceable&gt;shared_library_name&lt;/replaceable&gt;&lt;/literal&gt; and
        then &lt;literal&gt;MODULE_PATHNAME&lt;/literal&gt; is used in &lt;command&gt;CREATE
        FUNCTION&lt;/command&gt; commands for C-language functions, so that the script
        files do not need to hard-wire the name of the shared library.
</span>
このパラメータの値でスクリプトファイル内の<code class="literal">MODULE_PATHNAME</code>の出現箇所が置換されます。
設定されていない場合は置換は行われません。
通常これは、スクリプトファイル内で共有ライブラリの名前を直接書き込む必要がなくなるように<code class="literal">$libdir/<em class="replaceable"><code>shared_library_name</code></em></code>に設定され、C言語関数では<code class="command">CREATE FUNCTION</code>コマンド中で<code class="literal">MODULE_PATHNAME</code>を使用します。
       </p></dd><dt><span class="term"><code class="varname">requires</code> (<code class="type">string</code>)</span></dt><dd><p>
<span class="original">
        A list of names of extensions that this extension depends on,
        for example &lt;literal&gt;requires = 'foo, bar'&lt;/literal&gt;.  Those
        extensions must be installed before this one can be installed.
</span>
拡張が依存する拡張の名前のリストです。
例えば<code class="literal">requires = 'foo, bar'</code>です。
対象の拡張がインストールできるようになる前に、これらの拡張がインストールされていなければなりません。
       </p></dd><dt><span class="term"><code class="varname">superuser</code> (<code class="type">boolean</code>)</span></dt><dd><p>
<span class="original">
        If this parameter is &lt;literal&gt;true&lt;/literal&gt; (which is the default),
        only superusers can create the extension or update it to a new
        version (but see also &lt;varname&gt;trusted&lt;/varname&gt;, below).
        If it is set to &lt;literal&gt;false&lt;/literal&gt;, just the privileges
        required to execute the commands in the installation or update script
        are required.
        This should normally be set to &lt;literal&gt;true&lt;/literal&gt; if any of the
        script commands require superuser privileges.  (Such commands would
        fail anyway, but it's more user-friendly to give the error up front.)
</span>
このパラメータが<code class="literal">true</code>（デフォルト）の場合、スーパーユーザのみが拡張を作成または新しいバージョンに更新することができます（ただし、後述する<code class="varname">trusted</code>も参照してください）。
<code class="literal">false</code>に設定されている場合は、インストール中のコマンド実行またはスクリプト更新のために必要な権限のみが必要とされます。
いずれかスクリプトコマンドがスーパーユーザ権限を必要とするなら、通常は<code class="literal">true</code>に設定されるべきです。
（このようなコマンドはいずれにせよ失敗するでしょうけれども、前もってエラーを出す方がよりユーザフレンドリです。）
       </p></dd><dt><span class="term"><code class="varname">trusted</code> (<code class="type">boolean</code>)</span></dt><dd><p>
<span class="original">
        This parameter, if set to &lt;literal&gt;true&lt;/literal&gt; (which is not the
        default), allows some non-superusers to install an extension that
        has &lt;varname&gt;superuser&lt;/varname&gt; set to &lt;literal&gt;true&lt;/literal&gt;.
        Specifically, installation will be permitted for anyone who has
        &lt;literal&gt;CREATE&lt;/literal&gt; privilege on the current database.
        When the user executing &lt;command&gt;CREATE EXTENSION&lt;/command&gt; is not
        a superuser but is allowed to install by virtue of this parameter,
        then the installation or update script is run as the bootstrap
        superuser, not as the calling user.
        This parameter is irrelevant if &lt;varname&gt;superuser&lt;/varname&gt; is
        &lt;literal&gt;false&lt;/literal&gt;.
        Generally, this should not be set true for extensions that could
        allow access to otherwise-superuser-only abilities, such as
        file system access.
        Also, marking an extension trusted requires significant extra effort
        to write the extension's installation and update script(s) securely;
        see &lt;xref linkend="extend-extensions-security"/&gt;.
</span>
このパラメータは、<code class="literal">true</code>（デフォルトではありません）に設定されている場合、一部の非スーパーユーザが<code class="varname">superuser</code>に<code class="literal">true</code>を設定している拡張をインストールできるようにします。
具体的には、現在のデータベースに<code class="literal">CREATE</code>権限を持っているユーザにインストールが許可されるようになります。
<code class="command">CREATE EXTENSION</code>を実行するユーザがスーパーユーザでないけれども本パラメータの効力でインストールできるとき、インストールやスクリプトの更新は実行したユーザではなく、サービス起動のスーパーユーザとして実行されます。
<code class="varname">superuser</code>が<code class="literal">false</code>の場合、本パラメータは無意味です。
一般に、ファイルシステムのアクセスなど、別の方法ではスーパーユーザのみができることにアクセスができる拡張に対して、これをtrueにすべきではありません。
また、拡張をtrustedとして作成するには、拡張のインストールとスクリプト更新を安全に記述するために、かなりの追加の労力が影響が必要です。<a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-SECURITY" title="38.17.6. 拡張のためのセキュリティに関する考慮事項">38.17.6</a>を参照してください。
       </p></dd><dt><span class="term"><code class="varname">relocatable</code> (<code class="type">boolean</code>)</span></dt><dd><p>
<span class="original">
        An extension is &lt;firstterm&gt;relocatable&lt;/firstterm&gt; if it is possible to move
        its contained objects into a different schema after initial creation
        of the extension.  The default is &lt;literal&gt;false&lt;/literal&gt;, i.e., the
        extension is not relocatable.
        See &lt;xref linkend="extend-extensions-relocation"/&gt; for more information.
</span>
拡張を最初に作成した後に拡張により含まれるオブジェクトを別のスキーマに移動することができる場合、拡張は<em class="firstterm">再配置可能</em>です。
デフォルトは<code class="literal">false</code>、つまり、拡張は再配置可能ではありません。
詳しくは<a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-RELOCATION" title="38.17.2. 拡張の再配置性">38.17.2</a>を参照してください。
       </p></dd><dt><span class="term"><code class="varname">schema</code> (<code class="type">string</code>)</span></dt><dd><p>
<span class="original">
        This parameter can only be set for non-relocatable extensions.
        It forces the extension to be loaded into exactly the named schema
        and not any other.
        The &lt;varname&gt;schema&lt;/varname&gt; parameter is consulted only when
        initially creating an extension, not during extension updates.
        See &lt;xref linkend="extend-extensions-relocation"/&gt; for more information.
</span>
このパラメータは再配置可能ではない拡張に対してのみ設定することができます。
拡張が指名したスキーマのみにロードされ、他にはロードされないことを強制します。
<code class="varname">schema</code>パラメータは、拡張を最初に作成するときにのみ参照され、拡張が更新される間はされません。
詳しくは<a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-RELOCATION" title="38.17.2. 拡張の再配置性">38.17.2</a>を参照してください。
       </p></dd></dl></div><p>
<span class="original">
     In addition to the primary control file
     &lt;literal&gt;&lt;replaceable&gt;extension&lt;/replaceable&gt;.control&lt;/literal&gt;,
     an extension can have secondary control files named in the style
     &lt;literal&gt;&lt;replaceable&gt;extension&lt;/replaceable&gt;&amp;#045;-&lt;replaceable&gt;version&lt;/replaceable&gt;.control&lt;/literal&gt;.
     If supplied, these must be located in the script file directory.
     Secondary control files follow the same format as the primary control
     file.  Any parameters set in a secondary control file override the
     primary control file when installing or updating to that version of
     the extension.  However, the parameters &lt;varname&gt;directory&lt;/varname&gt; and
     &lt;varname&gt;default_version&lt;/varname&gt; cannot be set in a secondary control file.
</span>
主制御ファイル<code class="literal"><em class="replaceable"><code>extension</code></em>.control</code>に加え、拡張は<code class="literal"><em class="replaceable"><code>extension</code></em>--<em class="replaceable"><code>version</code></em>.control</code>という形の名前の副制御ファイルを持つことができます。
これらを提供する場合は、スクリプトファイルディレクトリに格納しなければなりません。
副制御ファイルは主制御ファイルと同じ書式に従います。
拡張の対応するバージョンをインストールまたは更新する時、副制御ファイル内で設定されるパラメータはいずれも、主制御ファイルを上書きします。
しかし<code class="varname">directory</code>および<code class="varname">default_version</code>パラメータは副制御ファイルで設定することはできません。
    </p><p>
<span class="original">
     An extension's &lt;acronym&gt;SQL&lt;/acronym&gt; script files can contain any SQL commands,
     except for transaction control commands (&lt;command&gt;BEGIN&lt;/command&gt;,
     &lt;command&gt;COMMIT&lt;/command&gt;, etc) and commands that cannot be executed inside a
     transaction block (such as &lt;command&gt;VACUUM&lt;/command&gt;).  This is because the
     script files are implicitly executed within a transaction block.
</span>
拡張の<acronym class="acronym">SQL</acronym>スクリプトファイルにはトランザクション制御コマンド（<code class="command">BEGIN</code>、<code class="command">COMMIT</code>など）およびトランザクションブロックの内側で実行することができないコマンド（<code class="command">VACUUM</code>など）を除く任意のSQLコマンドを含めることができます。
スクリプトファイルが暗黙的にトランザクションブロック内で実行されるためです。
    </p><p>
<span class="original">
     An extension's &lt;acronym&gt;SQL&lt;/acronym&gt; script files can also contain lines
     beginning with &lt;literal&gt;\echo&lt;/literal&gt;, which will be ignored (treated as
     comments) by the extension mechanism.  This provision is commonly used
     to throw an error if the script file is fed to &lt;application&gt;psql&lt;/application&gt;
     rather than being loaded via &lt;command&gt;CREATE EXTENSION&lt;/command&gt; (see example
     script in &lt;xref linkend="extend-extensions-example"/&gt;).
     Without that, users might accidentally load the
     extension's contents as &lt;quote&gt;loose&lt;/quote&gt; objects rather than as an
     extension, a state of affairs that's a bit tedious to recover from.
</span>
拡張の<acronym class="acronym">SQL</acronym>スクリプトファイルには、<code class="literal">\echo</code>から始まる行を含めることができます。
この行は拡張の機構では無視されます（コメントとして扱われます）。
これは、このスクリプトが<code class="command">CREATE EXTENSION</code>（<a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-EXAMPLE" title="38.17.7. 拡張の例">38.17.7</a>のスクリプト例を参照）ではなく<span class="application">psql</span>に渡された場合にエラーを発生するために一般的に使用するために用意されたものです。
これがないと、ユーザは間違って拡張としてではなく、<span class="quote">「<span class="quote">まとまっていない</span>」</span>オブジェクトとして拡張の内容をロードしてしまい、復旧が多少困難な状態になる可能性があります。
    </p><p>
<span class="original">
     If the extension script contains the
     string &lt;literal&gt;@extowner@&lt;/literal&gt;, that string is replaced with the
     (suitably quoted) name of the user calling &lt;command&gt;CREATE
     EXTENSION&lt;/command&gt; or &lt;command&gt;ALTER EXTENSION&lt;/command&gt;.  Typically
     this feature is used by extensions that are marked trusted to assign
     ownership of selected objects to the calling user rather than the
     bootstrap superuser.  (One should be careful about doing so, however.
     For example, assigning ownership of a C-language function to a
     non-superuser would create a privilege escalation path for that user.)
</span>
拡張のスクリプトに文字列<code class="literal">@extowner@</code>が含まれている場合、この文字列は、<code class="command">CREATE EXTENSION</code>や<code class="command">ALTER EXTENSION</code>を実行した（適切にクォートされた）ユーザ名で置き換えられます。
典型的には、この機能はtrustedと印付けされた拡張が選択されたオブジェクトにサービス起動のスーパーユーザではなく実行したユーザを所有者として割り当てる際に使われます。
（とはいえ、このようにするには注意深くすべきです。例えば、C言語関数の所有者を非スーパーユーザに割り当てると、そのユーザに権限昇格の経路を作ることになるでしょう）
    </p><p>
<span class="original">
     While the script files can contain any characters allowed by the specified
     encoding, control files should contain only plain ASCII, because there
     is no way for &lt;productname&gt;PostgreSQL&lt;/productname&gt; to know what encoding a
     control file is in.  In practice this is only an issue if you want to
     use non-ASCII characters in the extension's comment.  Recommended
     practice in that case is to not use the control file &lt;varname&gt;comment&lt;/varname&gt;
     parameter, but instead use &lt;command&gt;COMMENT ON EXTENSION&lt;/command&gt;
     within a script file to set the comment.
</span>
スクリプトファイルは指定した符号化方式で認められる任意の文字を含めることができますが、<span class="productname">PostgreSQL</span>が制御ファイルの符号化方式が何かを把握する方法がありませんので、制御ファイルにはASCII文字のみを含めなければなりません。
実際には、拡張のコメントに非ASCII文字を含めたい場合にのみ、これが問題になります。
このような場合には、制御ファイルの<code class="varname">comment</code>を使用せず、代わりにコメントを設定するためにスクリプトファイル内で<code class="command">COMMENT ON EXTENSION</code>を使用することを勧めます。
    </p></div><div class="sect2" id="EXTEND-EXTENSIONS-RELOCATION"><div class="titlepage"><div><div><h3 class="title">38.17.2. 拡張の再配置性</h3></div></div></div><span class="original">
    &lt;title&gt;Extension Relocatability&lt;/title&gt;
</span><p>
<span class="original">
     Users often wish to load the objects contained in an extension into a
     different schema than the extension's author had in mind.  There are
     three supported levels of relocatability:
</span>
ユーザは拡張に含まれるオブジェクトを拡張の作成者が考えていたスキーマとは別のスキーマにロードしたいとよく考えます。
再配置性に関して３つのレベルがサポートされます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
       A fully relocatable extension can be moved into another schema
       at any time, even after it's been loaded into a database.
       This is done with the &lt;command&gt;ALTER EXTENSION SET SCHEMA&lt;/command&gt;
       command, which automatically renames all the member objects into
       the new schema.  Normally, this is only possible if the extension
       contains no internal assumptions about what schema any of its
       objects are in.  Also, the extension's objects must all be in one
       schema to begin with (ignoring objects that do not belong to any
       schema, such as procedural languages).  Mark a fully relocatable
       extension by setting &lt;literal&gt;relocatable = true&lt;/literal&gt; in its control
       file.
</span>
完全な再配置可能な拡張は、いつでも、データベースにロードされた後であっても、他のスキーマに移動させることができます。
これは、自動的にすべてのメンバオブジェクトを新しいスキーマに名前を変更する、<code class="command">ALTER EXTENSION SET SCHEMA</code>を用いて行います。
通常これは、拡張がオブジェクトが含まれるスキーマが何かに関して内部的な仮定を持たない場合のみ可能です。
また、拡張のオブジェクト（手続き言語など何らかのスキーマに属さないオブジェクトは無視して）はすべて最初に１つのスキーマ内に存在しなければなりません。
制御ファイル内で<code class="literal">relocatable = true</code>と設定することで、完全な再配置可能と印付けます。
      </p></li><li class="listitem"><p>
<span class="original">
       An extension might be relocatable during installation but not
       afterwards.  This is typically the case if the extension's script
       file needs to reference the target schema explicitly, for example
       in setting &lt;literal&gt;search_path&lt;/literal&gt; properties for SQL functions.
       For such an extension, set &lt;literal&gt;relocatable = false&lt;/literal&gt; in its
       control file, and use &lt;literal&gt;@extschema@&lt;/literal&gt; to refer to the target
       schema in the script file.  All occurrences of this string will be
       replaced by the actual target schema's name before the script is
       executed.  The user can set the target schema using the
       &lt;literal&gt;SCHEMA&lt;/literal&gt; option of &lt;command&gt;CREATE EXTENSION&lt;/command&gt;.
</span>
拡張はインストール処理の間再配置可能ですが、その後再配置することはできません。
通常これは、拡張のスクリプトファイルが、SQL関数用の<code class="literal">search_path</code>属性の設定など、対象のスキーマを明示的に参照する必要がある場合です。
こうした拡張では、制御ファイルで<code class="literal">relocatable = false</code>と設定し、スクリプトファイル内で対象のスキーマを参照するために<code class="literal">@extschema@</code>を設定してください。
この文字列の出現箇所はすべて、スクリプトが実行される前に、実際の対象のスキーマ名に置換されます。
ユーザは<code class="command">CREATE EXTENSION</code>の<code class="literal">SCHEMA</code>オプションを使用して対象のスキーマを設定することができます。
      </p></li><li class="listitem"><p>
<span class="original">
       If the extension does not support relocation at all, set
       &lt;literal&gt;relocatable = false&lt;/literal&gt; in its control file, and also set
       &lt;literal&gt;schema&lt;/literal&gt; to the name of the intended target schema.  This
       will prevent use of the &lt;literal&gt;SCHEMA&lt;/literal&gt; option of &lt;command&gt;CREATE
       EXTENSION&lt;/command&gt;, unless it specifies the same schema named in the control
       file.  This choice is typically necessary if the extension contains
       internal assumptions about schema names that can't be replaced by
       uses of &lt;literal&gt;@extschema@&lt;/literal&gt;.  The &lt;literal&gt;@extschema@&lt;/literal&gt;
       substitution mechanism is available in this case too, although it is
       of limited use since the schema name is determined by the control file.
</span>
拡張が再配置をまったくサポートしない場合、制御ファイルで<code class="literal">relocatable = false</code>を設定し、かつ、<code class="literal">schema</code>を意図している対象スキーマの名前に設定してください。
これは、制御ファイル内で指定されたスキーマと同じ名前が指定されていない限り、<code class="command">CREATE EXTENSION</code>の<code class="literal">SCHEMA</code>オプションの指定を阻止します。
この選択は通常、拡張が<code class="literal">@extschema@</code>を使用して置き換えることができないスキーマ名について内部的な仮定を持つ場合に必要です。
<code class="literal">@extschema@</code>置換機構はこの場合でも使用することができますが、スキーマ名が制御ファイルによって決定されますので、用途は限定されます。
      </p></li></ul></div><p>
<span class="original">
     In all cases, the script file will be executed with
     &lt;xref linkend="guc-search-path"/&gt; initially set to point to the target
     schema; that is, &lt;command&gt;CREATE EXTENSION&lt;/command&gt; does the equivalent of
     this:
</span>
すべての場合において、スクリプトファイルは対象のスキーマを指し示すようにあらかじめ設定した<a class="xref" href="runtime-config-client.html#GUC-SEARCH-PATH">search_path</a>を用いて実行されます。
つまり<code class="command">CREATE EXTENSION</code>は以下と同じことを行います。
</p><pre class="programlisting">
SET LOCAL search_path TO @extschema@, pg_temp;
</pre><p>
<span class="original">
     This allows the objects created by the script file to go into the target
     schema.  The script file can change &lt;varname&gt;search_path&lt;/varname&gt; if it wishes,
     but that is generally undesirable.  &lt;varname&gt;search_path&lt;/varname&gt; is restored
     to its previous setting upon completion of &lt;command&gt;CREATE EXTENSION&lt;/command&gt;.
</span>
これによりスクリプトファイルで作成されるオブジェクトを対象のスキーマ内に格納することができます。
スクリプトファイルは要望に応じて<code class="varname">search_path</code>を変更することができますが、一般的には望まれません。
<code class="command">CREATE EXTENSION</code>の実行後、<code class="varname">search_path</code>は以前の設定に戻されます。
    </p><p>
<span class="original">
     The target schema is determined by the &lt;varname&gt;schema&lt;/varname&gt; parameter in
     the control file if that is given, otherwise by the &lt;literal&gt;SCHEMA&lt;/literal&gt;
     option of &lt;command&gt;CREATE EXTENSION&lt;/command&gt; if that is given, otherwise the
     current default object creation schema (the first one in the caller's
     &lt;varname&gt;search_path&lt;/varname&gt;).  When the control file &lt;varname&gt;schema&lt;/varname&gt;
     parameter is used, the target schema will be created if it doesn't
     already exist, but in the other two cases it must already exist.
</span>
対象のスキーマは制御ファイル内の<code class="varname">schema</code>パラメータがあればこのパラメータにより決定されます。
このパラメータがなければ、<code class="command">CREATE EXTENSION</code>の<code class="literal">SCHEMA</code>があればこの値で決まり、これ以外の場合は現在のデフォルトのオブジェクト生成用スキーマ（呼び出し元の<code class="varname">search_path</code>の最初のもの）になります。
制御ファイルの<code class="varname">schema</code>パラメータが使用される時、対象のスキーマが存在しない場合は作成されますが、これ以外の２つの場合ではすでに存在しなければなりません。
    </p><p>
<span class="original">
     If any prerequisite extensions are listed in &lt;varname&gt;requires&lt;/varname&gt;
     in the control file, their target schemas are added to the initial
     setting of &lt;varname&gt;search_path&lt;/varname&gt;, following the new
     extension's target schema.  This allows their objects to be visible to
     the new extension's script file.
</span>
何らかの事前に必要な拡張が制御ファイル内の<code class="varname">requires</code>に列挙されていた場合、それらのターゲットスキーマは新しい機能拡張のターゲットスキーマに続いて<code class="varname">search_path</code>の初期設定に追加されます。
これにより新しい拡張のスクリプトファイルからそれらのオブジェクトが可視になります。
    </p><p>
<span class="original">
     For security, &lt;literal&gt;pg_temp&lt;/literal&gt; is automatically appended to
     the end of &lt;varname&gt;search_path&lt;/varname&gt; in all cases.
</span>
安全のため、全てのケースにおいて<code class="literal">pg_temp</code>は自動的に<code class="varname">search_path</code>の最後に追記されます。
    </p><p>
<span class="original">
     For security, &lt;literal&gt;pg_temp&lt;/literal&gt; is automatically appended to
     the end of &lt;varname&gt;search_path&lt;/varname&gt; in all cases.
</span>
安全のため、全てのケースにおいて<code class="literal">pg_temp</code>は自動的に<code class="varname">search_path</code>の最後に追記されます。
    </p><p>
<span class="original">
     Although a non-relocatable extension can contain objects spread across
     multiple schemas, it is usually desirable to place all the objects meant
     for external use into a single schema, which is considered the extension's
     target schema.  Such an arrangement works conveniently with the default
     setting of &lt;varname&gt;search_path&lt;/varname&gt; during creation of dependent
     extensions.
</span>
再配置不可能な拡張は複数スキーマにまたがるオブジェクトを含めることができますが、通常、外部使用を意図したオブジェクトはすべて単一スキーマに格納することが望まれます。
この単一スキーマが拡張の対象のスキーマとみなされます。
こうした調整は依存する拡張を作成する間、デフォルトの<code class="varname">search_path</code>設定を都合に合わせて扱います。
    </p></div><div class="sect2" id="EXTEND-EXTENSIONS-CONFIG-TABLES"><div class="titlepage"><div><div><h3 class="title">38.17.3. 拡張設定テーブル</h3></div></div></div><span class="original">
    &lt;title&gt;Extension Configuration Tables&lt;/title&gt;
</span><p>
<span class="original">
     Some extensions include configuration tables, which contain data that
     might be added or changed by the user after installation of the
     extension.  Ordinarily, if a table is part of an extension, neither
     the table's definition nor its content will be dumped by
     &lt;application&gt;pg_dump&lt;/application&gt;.  But that behavior is undesirable for a
     configuration table; any data changes made by the user need to be
     included in dumps, or the extension will behave differently after a dump
     and reload.
</span>
一部の拡張は、拡張をインストールした後でユーザにより追加または変更される可能性があるデータを持つ設定テーブルを含みます。
通常、テーブルが拡張の一部である場合、テーブル定義もその内容も<span class="application">pg_dump</span>によりダンプされません。
しかしこの振舞いは設定テーブルの場合望まれません。
ユーザによってなされたデータ変更はダンプ内に含まれなければなりません。
さもないとダンプしリストアした後で拡張の動作が変わってしまいます。
    </p><a id="id-1.8.3.20.13.3" class="indexterm"></a><p>
<span class="original">
     To solve this problem, an extension's script file can mark a table
     or a sequence it has created as a configuration relation, which will
     cause &lt;application&gt;pg_dump&lt;/application&gt; to include the table's or the sequence's
     contents (not its definition) in dumps.  To do that, call the function
     &lt;function&gt;pg_extension_config_dump(regclass, text)&lt;/function&gt; after creating the
     table or the sequence, for example
</span>
この問題を解消するために、拡張のスクリプトファイルでは設定リレーションとして作成されるテーブル、またはシーケンスに印を付け、<span class="application">pg_dump</span>にテーブルの、またはシーケンスの内容をダンプに含める（定義は含まれません）ようにさせることができます。
このためには、以下の例のようにテーブル、またはシーケンスを作成した後に<code class="function">pg_extension_config_dump(regclass, text)</code>関数を呼び出してください。
</p><pre class="programlisting">
CREATE TABLE my_config (key text, value text);
CREATE SEQUENCE my_config_seq;

SELECT pg_catalog.pg_extension_config_dump('my_config', '');
SELECT pg_catalog.pg_extension_config_dump('my_config_seq', '');
</pre><p>
<span class="original">
     Any number of tables or sequences can be marked this way. Sequences
     associated with &lt;type&gt;serial&lt;/type&gt; or &lt;type&gt;bigserial&lt;/type&gt; columns can
     be marked as well.
</span>
任意数のテーブル、またはシーケンスをこの方法で印付けることができます。
<code class="type">serial</code>列または<code class="type">bigserial</code>列に関連したシーケンスが、同様に印付けることができます。
    </p><p>
<span class="original">
     When the second argument of &lt;function&gt;pg_extension_config_dump&lt;/function&gt; is
     an empty string, the entire contents of the table are dumped by
     &lt;application&gt;pg_dump&lt;/application&gt;.  This is usually only correct if the table
     is initially empty as created by the extension script.  If there is
     a mixture of initial data and user-provided data in the table,
     the second argument of &lt;function&gt;pg_extension_config_dump&lt;/function&gt; provides
     a &lt;literal&gt;WHERE&lt;/literal&gt; condition that selects the data to be dumped.
     For example, you might do
</span>
<code class="function">pg_extension_config_dump</code>の第２引数が空文字列である場合、テーブルのすべての内容が<span class="application">pg_dump</span>によりダンプされます。
これは、拡張のスクリプトによって作成された初期段階においてテーブルが空である場合のみ正しいものです。
テーブルの中で初期データとユーザが提供したデータが混在する場合、<code class="function">pg_extension_config_dump</code>の第２引数においてダンプすべきデータを選択する<code class="literal">WHERE</code>条件を提供します。
以下に例を示します。
</p><pre class="programlisting">
CREATE TABLE my_config (key text, value text, standard_entry boolean);

SELECT pg_catalog.pg_extension_config_dump('my_config', 'WHERE NOT standard_entry');
</pre><p>
<span class="original">
     and then make sure that &lt;structfield&gt;standard_entry&lt;/structfield&gt; is true only
     in the rows created by the extension's script.
</span>
このようにした後、拡張のスクリプトで作成される行のみで<code class="structfield">standard_entry</code>が確実に真になるようにします。
    </p><p>
<span class="original">
     For sequences, the second argument of &lt;function&gt;pg_extension_config_dump&lt;/function&gt;
     has no effect.
</span>
シーケンスにおいて、<code class="function">pg_extension_config_dump</code>の第２引数は何も影響を及ぼしません。
    </p><p>
<span class="original">
     More complicated situations, such as initially-provided rows that might
     be modified by users, can be handled by creating triggers on the
     configuration table to ensure that modified rows are marked correctly.
</span>
初期状態で提供される行がユーザによって変更されるようなもっと複雑な状況では、設定テーブルに対するトリガを作成して、変更された行が正しく印付けられることを確実にするように取り扱うことができます。
    </p><p>
<span class="original">
     You can alter the filter condition associated with a configuration table
     by calling &lt;function&gt;pg_extension_config_dump&lt;/function&gt; again.  (This would
     typically be useful in an extension update script.)  The only way to mark
     a table as no longer a configuration table is to dissociate it from the
     extension with &lt;command&gt;ALTER EXTENSION ... DROP TABLE&lt;/command&gt;.
</span>
<code class="function">pg_extension_config_dump</code>を再度呼び出すことにより、設定テーブルに関連付いたフィルタ条件を変更することができます。
（通常これは拡張の更新スクリプト内で役に立つでしょう。）
設定ファイルからテーブルを取り除くように印付ける方法は、<code class="command">ALTER EXTENSION ... DROP TABLE</code>を用いてテーブルを拡張から分離するしかありません。
    </p><p>
<span class="original">
     Note that foreign key relationships between these tables will dictate the
     order in which the tables are dumped out by pg_dump.  Specifically, pg_dump
     will attempt to dump the referenced-by table before the referencing table.
     As the foreign key relationships are set up at CREATE EXTENSION time (prior
     to data being loaded into the tables) circular dependencies are not
     supported.  When circular dependencies exist, the data will still be dumped
     out but the dump will not be able to be restored directly and user
     intervention will be required.
</span>
このテーブルとの外部キーの関係は、テーブルがpg_dumpによってダンプされる順序に影響します。
特に、pg_dumpは参照しているテーブルの前に参照されているテーブルをダンプしようとします。
外部キーの関係はCREATE EXTENSION時(データがテーブルにロードされる前)に設定されますので、循環依存はサポートされません。
循環依存が存在すれば、データはダンプされますが、そのダンプを直接はリストアできず、ユーザの介入が必要になります。
    </p><p>
<span class="original">
     Sequences associated with &lt;type&gt;serial&lt;/type&gt; or &lt;type&gt;bigserial&lt;/type&gt; columns
     need to be directly marked to dump their state. Marking their parent
     relation is not enough for this purpose.
</span>
<code class="type">serial</code>列または<code class="type">bigserial</code>列に関連したシーケンスは、それらの状態をダンプするために直接印付けする必要があります。
親リレーションを印付けすることは、この目的に十分ではありません。
    </p></div><div class="sect2" id="id-1.8.3.20.14"><div class="titlepage"><div><div><h3 class="title">38.17.4. 拡張の更新</h3></div></div></div><span class="original">
    &lt;title&gt;Extension Updates&lt;/title&gt;
</span><p>
<span class="original">
     One advantage of the extension mechanism is that it provides convenient
     ways to manage updates to the SQL commands that define an extension's
     objects.  This is done by associating a version name or number with
     each released version of the extension's installation script.
     In addition, if you want users to be able to update their databases
     dynamically from one version to the next, you should provide
     &lt;firstterm&gt;update scripts&lt;/firstterm&gt; that make the necessary changes to go from
     one version to the next.  Update scripts have names following the pattern
     &lt;literal&gt;&lt;replaceable&gt;extension&lt;/replaceable&gt;&amp;#045;&amp;#045;&lt;replaceable&gt;old_version&lt;/replaceable&gt;&amp;#045;&amp;#045;&lt;replaceable&gt;target_version&lt;/replaceable&gt;.sql&lt;/literal&gt;
     (for example, &lt;literal&gt;foo&amp;#045;&amp;#045;1.0&amp;#045;&amp;#045;1.1.sql&lt;/literal&gt; contains the commands to modify
     version &lt;literal&gt;1.0&lt;/literal&gt; of extension &lt;literal&gt;foo&lt;/literal&gt; into version
     &lt;literal&gt;1.1&lt;/literal&gt;).
</span>
拡張機構の１つの利点は、拡張のオブジェクトを定義するSQLコマンドの更新を簡便に管理する方法を提供していることです。
これは、拡張のインストール用スクリプトのリリース版それぞれにバージョン名称またはバージョン番号を関連付けることで行われます。
さらに、ユーザにあるバージョンから次のバージョンへ動的にデータベースを更新させることができるようにしたい場合、あるバージョンから次のバージョンまでの間に行われる必要な変更を行う<em class="firstterm">更新スクリプト</em>を提供しなければなりません。
更新スクリプトは<code class="literal"><em class="replaceable"><code>extension</code></em>--<em class="replaceable"><code>old_version</code></em>--<em class="replaceable"><code>target_version</code></em>.sql</code>というパターンに従った名前（例えば、<code class="literal">foo--1.0--1.1.sql</code>は<code class="literal">foo</code>拡張のバージョン<code class="literal">1.0</code>からバージョン<code class="literal">1.1</code>に変更するコマンドを含みます。）を持たなければなりません。
    </p><p>
<span class="original">
     Given that a suitable update script is available, the command
     &lt;command&gt;ALTER EXTENSION UPDATE&lt;/command&gt; will update an installed extension
     to the specified new version.  The update script is run in the same
     environment that &lt;command&gt;CREATE EXTENSION&lt;/command&gt; provides for installation
     scripts: in particular, &lt;varname&gt;search_path&lt;/varname&gt; is set up in the same
     way, and any new objects created by the script are automatically added
     to the extension.  Also, if the script chooses to drop extension member
     objects, they are automatically dissociated from the extension.
</span>
適切な更新スクリプトが利用可能である場合、<code class="command">ALTER EXTENSION UPDATE</code>コマンドはインストール済みの拡張を指定した新しいバージョンへ更新します。
更新スクリプトは、<code class="command">CREATE EXTENSION</code>がインストール用スクリプト向けに提供する環境と同じ環境で実行されます。
具体的には<code class="varname">search_path</code>は同じ方法で設定され、スクリプトにより作成される新しいオブジェクトはすべて自動的に拡張に追加されます。
また、スクリプトが拡張のメンバーオブジェクトを削除する場合には、それらのメンバーオブジェクトは拡張から自動的に分離されます。
    </p><p>
<span class="original">
     If an extension has secondary control files, the control parameters
     that are used for an update script are those associated with the script's
     target (new) version.
</span>
拡張が副制御ファイルを持つ場合、更新スクリプトで使用される制御パラメータは、スクリプトの対象の（新しい）バージョンに関連付けされたものになります。
    </p><p>
<span class="original">
     &lt;command&gt;ALTER EXTENSION&lt;/command&gt; is able to execute sequences of update
     script files to achieve a requested update.  For example, if only
     &lt;literal&gt;foo&amp;#045;-1.0&amp;#045;-1.1.sql&lt;/literal&gt; and &lt;literal&gt;foo&amp;#045;-1.1&amp;#045;-2.0.sql&lt;/literal&gt; are
     available, &lt;command&gt;ALTER EXTENSION&lt;/command&gt; will apply them in sequence if an
     update to version &lt;literal&gt;2.0&lt;/literal&gt; is requested when &lt;literal&gt;1.0&lt;/literal&gt; is
     currently installed.
</span>
<code class="command">ALTER EXTENSION</code>は、要求される更新を実現するために更新スクリプトを連続して実行することができます。
例えば<code class="literal">foo--1.0--1.1.sql</code>と<code class="literal">foo--1.1--2.0.sql</code>のみが利用可能であるとすると、現在<code class="literal">1.0</code>がインストールされている時にバージョン<code class="literal">2.0</code>への更新が要求された場合、<code class="command">ALTER EXTENSION</code>はこれらを順番に適用します。
    </p><p>
<span class="original">
     &lt;productname&gt;PostgreSQL&lt;/productname&gt; doesn't assume anything about the properties
     of version names: for example, it does not know whether &lt;literal&gt;1.1&lt;/literal&gt;
     follows &lt;literal&gt;1.0&lt;/literal&gt;.  It just matches up the available version names
     and follows the path that requires applying the fewest update scripts.
     (A version name can actually be any string that doesn't contain
     &lt;literal&gt;&amp;#045;-&lt;/literal&gt; or leading or trailing &lt;literal&gt;-&lt;/literal&gt;.)
</span>
<span class="productname">PostgreSQL</span>はバージョン名称の特性についてまったく仮定を行いません。
例えば<code class="literal">1.0</code>の次が<code class="literal">1.1</code>であるかどうかを把握しません。
これは利用可能なバージョン名をかみ合わせ、もっとも少ない数の更新スクリプトを適用するために必要な経路を続けるだけです。
（バージョン名には、<code class="literal">--</code>を含まず先頭または最後に<code class="literal">-</code>が付かなければ、任意の文字を取ることができます。）
    </p><p>
<span class="original">
     Sometimes it is useful to provide &lt;quote&gt;downgrade&lt;/quote&gt; scripts, for
     example &lt;literal&gt;foo&amp;#045;-1.1&amp;#045;-1.0.sql&lt;/literal&gt; to allow reverting the changes
     associated with version &lt;literal&gt;1.1&lt;/literal&gt;.  If you do that, be careful
     of the possibility that a downgrade script might unexpectedly
     get applied because it yields a shorter path.  The risky case is where
     there is a &lt;quote&gt;fast path&lt;/quote&gt; update script that jumps ahead several
     versions as well as a downgrade script to the fast path's start point.
     It might take fewer steps to apply the downgrade and then the fast
     path than to move ahead one version at a time.  If the downgrade script
     drops any irreplaceable objects, this will yield undesirable results.
</span>
<span class="quote">「<span class="quote">ダウングレード</span>」</span>スクリプトを提供することが便利な場合があります。
例えば<code class="literal">foo--1.1--1.0.sql</code>は、バージョン<code class="literal">1.1</code>に関連した変更を元に戻すことができます。
この場合、ダウングレードスクリプトがより短いパスを生成するために、予期せず適用されてしまう可能性に注意してください。
複数のバージョンをまたがって更新する<span class="quote">「<span class="quote">近道</span>」</span>更新スクリプトと近道の開始バージョンへのダウングレードスクリプトが存在する場合に危険性があります。
ダウングレードしてから近道となる更新スクリプトを実行する方が、バージョンを１つずつ進めるよりも少ない処理で済んでしまうかもしれません。
ダウングレードスクリプトが取り返しがつかないオブジェクトを何か削除してしまう場合、望まない結果になってしまいます。
    </p><p>
<span class="original">
     To check for unexpected update paths, use this command:
</span>
想定外の更新経路かどうかを検査するためには、以下のコマンドを使用してください。
</p><pre class="programlisting">
SELECT * FROM pg_extension_update_paths('<em class="replaceable"><code>extension_name</code></em>');
</pre><p>
<span class="original">
     This shows each pair of distinct known version names for the specified
     extension, together with the update path sequence that would be taken to
     get from the source version to the target version, or &lt;literal&gt;NULL&lt;/literal&gt; if
     there is no available update path.  The path is shown in textual form
     with &lt;literal&gt;&amp;#045;-&lt;/literal&gt; separators.  You can use
     &lt;literal&gt;regexp_split_to_array(path,'&amp;#045;-')&lt;/literal&gt; if you prefer an array
     format.
</span>
これは指定した拡張の個々の既知のバージョン名の組み合わせをそれぞれ、元のバージョンから対象のバージョンへ進む時に取られる更新経路順、またはもし利用できる更新経路がなければ<code class="literal">NULL</code>を付けて、表示します。
経路は<code class="literal">--</code>を区切り文字として使用したテキスト形式で表示されます。
配列形式の方が良ければ<code class="literal">regexp_split_to_array(path,'--')</code>を使用することができます。
    </p></div><div class="sect2" id="id-1.8.3.20.15"><div class="titlepage"><div><div><h3 class="title">38.17.5. 更新スクリプトを利用した拡張のインストール</h3></div></div></div><span class="original">
    &lt;title&gt;Installing Extensions Using Update Scripts&lt;/title&gt;
</span><p>
<span class="original">
     An extension that has been around for awhile will probably exist in
     several versions, for which the author will need to write update scripts.
     For example, if you have released a &lt;literal&gt;foo&lt;/literal&gt; extension in
     versions &lt;literal&gt;1.0&lt;/literal&gt;, &lt;literal&gt;1.1&lt;/literal&gt;, and &lt;literal&gt;1.2&lt;/literal&gt;, there
     should be update scripts &lt;filename&gt;foo&amp;#045;&amp;#045;1.0&amp;#045;&amp;#045;1.1.sql&lt;/filename&gt;
     and &lt;filename&gt;foo&amp;#045;&amp;#045;1.1&amp;#045;&amp;#045;1.2.sql&lt;/filename&gt;.
     Before &lt;productname&gt;PostgreSQL&lt;/productname&gt; 10, it was necessary to also create
     new script files &lt;filename&gt;foo&amp;#045;&amp;#045;1.1.sql&lt;/filename&gt; and &lt;filename&gt;foo&amp;#045;&amp;#045;1.2.sql&lt;/filename&gt;
     that directly build the newer extension versions, or else the newer
     versions could not be installed directly, only by
     installing &lt;literal&gt;1.0&lt;/literal&gt; and then updating.  That was tedious and
     duplicative, but now it's unnecessary, because &lt;command&gt;CREATE
     EXTENSION&lt;/command&gt; can follow update chains automatically.
     For example, if only the script
     files &lt;filename&gt;foo&amp;#045;&amp;#045;1.0.sql&lt;/filename&gt;, &lt;filename&gt;foo&amp;#045;&amp;#045;1.0&amp;#045;&amp;#045;1.1.sql&lt;/filename&gt;,
     and &lt;filename&gt;foo&amp;#045;&amp;#045;1.1&amp;#045;&amp;#045;1.2.sql&lt;/filename&gt; are available then a request to
     install version &lt;literal&gt;1.2&lt;/literal&gt; is honored by running those three
     scripts in sequence.  The processing is the same as if you'd first
     installed &lt;literal&gt;1.0&lt;/literal&gt; and then updated to &lt;literal&gt;1.2&lt;/literal&gt;.
     (As with &lt;command&gt;ALTER EXTENSION UPDATE&lt;/command&gt;, if multiple pathways are
     available then the shortest is preferred.)  Arranging an extension's
     script files in this style can reduce the amount of maintenance effort
     needed to produce small updates.
</span>
以前から存在している拡張は、おそらく複数のバージョンに渡って存在しているので、拡張の作者は更新スクリプトを開発する必要性が出てきます。
たとえば、拡張<code class="literal">foo</code>がバージョン<code class="literal">1.0</code>、<code class="literal">1.1</code>、<code class="literal">1.2</code>をリリースしていたとすると、更新スクリプト<code class="filename">foo--1.0--1.1.sql</code>と<code class="filename">foo--1.1--1.2.sql</code>が存在しなければなりません。
<span class="productname">PostgreSQL</span> 10より前では、新しい拡張のバージョンを直接作成するスクリプトファイル<code class="filename">foo--1.1.sql</code>と<code class="filename">foo--1.2.sql</code>も新規に作る必要がありました。
これらがないと、新しいバージョンの拡張を直接インストールすることはできず、<code class="literal">1.0</code>をインストールしてから更新するしかありませんでした。
それにはうんざりしますし、また冗長です。
しかし、今では<code class="command">CREATE EXTENSION</code>が自動的に更新連鎖を追跡してくるので、それは不要になりました。
たとえば、<code class="filename">foo--1.0.sql</code>、<code class="filename">foo--1.0--1.1.sql</code>、<code class="filename">foo--1.1--1.2.sql</code>だけしかない場合、バージョン<code class="literal">1.2</code>のインストールのリクエストは、これらのスクリプトを順に実行することによって達成されます。
この手順は、最初に<code class="literal">1.0</code>をインストールして、<code class="literal">1.2</code>にアップデートする場合でも同じです。
（<code class="command">ALTER EXTENSION UPDATE</code>は、複数の手順がある場合には、最短の手順を選びます。）
この方法で拡張のスクリプトを調整することにより、小さな更新を複数作成するための保守の手間を減らすことができます。
    </p><p>
<span class="original">
     If you use secondary (version-specific) control files with an extension
     maintained in this style, keep in mind that each version needs a control
     file even if it has no stand-alone installation script, as that control
     file will determine how the implicit update to that version is performed.
     For example, if &lt;filename&gt;foo&amp;#045;&amp;#045;1.0.control&lt;/filename&gt; specifies &lt;literal&gt;requires
     = 'bar'&lt;/literal&gt; but &lt;literal&gt;foo&lt;/literal&gt;'s other control files do not, the
     extension's dependency on &lt;literal&gt;bar&lt;/literal&gt; will be dropped when updating
     from &lt;literal&gt;1.0&lt;/literal&gt; to another version.
</span>
この方法で保守している拡張に二次的な（バージョン固有の）制御ファイルがある場合は、スタンドアローンのインストールスクリプトがない場合でも、各バージョンで制御ファイルが必要になることに注意してください。
そのバージョンへと更新する暗黙的な方法を、制御ファイルが決定するからです。
たとえば、<code class="filename">foo--1.0.control</code>が<code class="literal">requires = 'bar'</code>を指定しているのに、<code class="literal">foo</code>の他の制御ファイルが指定していないとすると、<code class="literal">1.0</code>から他のバージョンに更新した際に<code class="literal">bar</code>への依存性が削除されてしまうでしょう。
    </p></div><div class="sect2" id="EXTEND-EXTENSIONS-SECURITY"><div class="titlepage"><div><div><h3 class="title">38.17.6. 拡張のためのセキュリティに関する考慮事項</h3></div></div></div><span class="original">
    &lt;title&gt;Security Considerations for Extensions&lt;/title&gt;
</span><p>
<span class="original">
     Widely-distributed extensions should assume little about the database
     they occupy.  Therefore, it's appropriate to write functions provided
     by an extension in a secure style that cannot be compromised by
     search-path-based attacks.
</span>
広く配布される拡張では、インストールされるデータベースについて想定していないはずです。
このため、拡張はサーチパスに基づく攻撃を受けないよう、安全なスタイルで拡張によって提供される関数記述するのが適切です。
    </p><p>
<span class="original">
     An extension that has the &lt;varname&gt;superuser&lt;/varname&gt; property set to
     true must also consider security hazards for the actions taken within
     its installation and update scripts.  It is not terribly difficult for
     a malicious user to create trojan-horse objects that will compromise
     later execution of a carelessly-written extension script, allowing that
     user to acquire superuser privileges.
</span>
<code class="varname">superuser</code>プロパティを真にしている拡張はインストールや更新スクリプトの中で行われるアクションのセキュリティ面での危険も考慮しなければなりません。
悪意あるユーザが不用意に書かれた拡張スクリプトを悪用してトロイの木馬を作成し、スーパーユーザ権限を獲得できるようにすることは、そう難しくありません。
    </p><p>
<span class="original">
     If an extension is marked &lt;varname&gt;trusted&lt;/varname&gt;, then its
     installation schema can be selected by the installing user, who might
     intentionally use an insecure schema in hopes of gaining superuser
     privileges.  Therefore, a trusted extension is extremely exposed from a
     security standpoint, and all its script commands must be carefully
     examined to ensure that no compromise is possible.
</span>
拡張が<code class="varname">trusted</code>と印付けされている場合、そのインストールスキーマはインストールするユーザにより選択できます。そのユーザはスーパーユーザ権限を獲得することを狙って意図的に安全でないスキーマを使用するかもしれません。
したがって、trustedの拡張はセキュリティ観点から極めて危険で、そのスクリプトのコマンドは危険性がないことを確実にするため注意深く検証されなければなりません。
    </p><p>
<span class="original">
     Advice about writing functions securely is provided in
     &lt;xref linkend="extend-extensions-security-funcs"/&gt; below, and advice
     about writing installation scripts securely is provided in
     &lt;xref linkend="extend-extensions-security-scripts"/&gt;.
</span>
関数を安全に書くためのアドバイスは以下のリンクから提供されます。
<a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-SECURITY-FUNCS" title="38.17.6.1. 拡張関数のためのセキュリティに関する考慮事項">38.17.6.1</a>
また、インストールスクリプトを安全に書くためのアドバイスは以下のリンクから提供されます。
<a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-SECURITY-SCRIPTS" title="38.17.6.2. 拡張スクリプトのためのセキュリティに関する考慮事項">38.17.6.2</a>
    </p><div class="sect3" id="EXTEND-EXTENSIONS-SECURITY-FUNCS"><div class="titlepage"><div><div><h4 class="title">38.17.6.1. 拡張関数のためのセキュリティに関する考慮事項</h4></div></div></div><span class="original">
     &lt;title&gt;Security Considerations for Extension Functions&lt;/title&gt;
</span><p>
<span class="original">
      SQL-language and PL-language functions provided by extensions are at
      risk of search-path-based attacks when they are executed, since
      parsing of these functions occurs at execution time not creation time.
</span>
拡張により提供されるSQL言語とPL言語関数は実行されるときにサーチパスに基づく攻撃を受ける危険性があります。
これらの関数は作成時ではなく、実行時に解析されるためです。
     </p><p>
<span class="original">
      The &lt;link linkend="sql-createfunction-security"&gt;&lt;command&gt;CREATE
      FUNCTION&lt;/command&gt;&lt;/link&gt; reference page contains advice about
      writing &lt;literal&gt;SECURITY DEFINER&lt;/literal&gt; functions safely.  It's
      good practice to apply those techniques for any function provided by
      an extension, since the function might be called by a high-privilege
      user.
</span>
<a class="link" href="sql-createfunction.html#SQL-CREATEFUNCTION-SECURITY" title="SECURITY DEFINER関数の安全な作成"><code class="command">CREATE FUNCTION</code></a>のリファレンスページには<code class="literal">SECURITY DEFINER</code>関数を安全に書くためのアドバイスが記載されています。
拡張が提供するあらゆる関数は、強い権限を持つユーザから実行されることがあるので、これらのテクニックを適用することは、良い習慣です。
     </p><span class="original">
(原文もコメント中にあり)
      XXX It's not enough to use qualified names, because one might write a
          qualified name to an object that itself uses unqualified names.  Many
          information_schema functions have that defect, for example.  However,
          that's a defect in the referenced object, and relatively few queries
          will be affected.  Also, we direct applications to secure search_path
          when connecting to an untrusted database; if applications do that,
          they are immune to known attacks even if some extension refers to a
          defective object.  Therefore, guide extension authors as though core
          PostgreSQL contained no such defect.
XXX 名前を(スキーマ)修飾するだけでは十分ではありません。なぜなら修飾されていない名前を使っているオブジェクトに修飾された名前を書くかもしれないためです。
例えば、多くのインフォメーションスキーマの関数にはこの欠陥があります。
しかし、これは参照されるオブジェクトの欠陥なので影響を受ける問い合わせは少ないでしょう。
また、信頼できないデータベースにアクセスする際、アプリケーションは安全なsearch_pathを使うよう、指示しています。
そして、アプリケーションが指示どおりに作成されていれば、拡張が欠陥があるオブジェクトを参照していたとしても、既知の攻撃に影響されません。
そのため、コアのPostgreSQLにはそのような欠陥が含まれないかのように拡張の作成者に案内して下さい。
</span><p>
<span class="original">
      If you cannot set the &lt;varname&gt;search_path&lt;/varname&gt; to contain only
      secure schemas, assume that each unqualified name could resolve to an
      object that a malicious user has defined.  Beware of constructs that
      depend on &lt;varname&gt;search_path&lt;/varname&gt; implicitly; for
      example, &lt;token&gt;IN&lt;/token&gt;
      and &lt;literal&gt;CASE &lt;replaceable&gt;expression&lt;/replaceable&gt; WHEN&lt;/literal&gt;
      always select an operator using the search path.  In their place, use
      &lt;literal&gt;OPERATOR(&lt;replaceable&gt;schema&lt;/replaceable&gt;.=) ANY&lt;/literal&gt;
      and &lt;literal&gt;CASE WHEN &lt;replaceable&gt;expression&lt;/replaceable&gt;&lt;/literal&gt;.
</span>
<code class="varname">search_path</code>に安全なスキーマだけを設定できない場合は、修飾されていない名前は悪意あるユーザが定義したオブジェクトとして名前解決されうることを想定してください。
暗黙的に<code class="varname">search_path</code>に依存する構文に注意してください。
例えば、<code class="token">IN</code>や <code class="literal">CASE <em class="replaceable"><code>式</code></em> WHEN</code>は常にサーチパスを使って演算子を選びます。
これらの場所には、<code class="literal">OPERATOR(<em class="replaceable"><code>スキーマ</code></em>.=) ANY</code>や<code class="literal">CASE WHEN <em class="replaceable"><code>式</code></em></code>を使用してください。
     </p><p>
<span class="original">
      A general-purpose extension usually should not assume that it's been
      installed into a secure schema, which means that even schema-qualified
      references to its own objects are not entirely risk-free.  For
      example, if the extension has defined a
      function &lt;literal&gt;myschema.myfunc(bigint)&lt;/literal&gt; then a call such
      as &lt;literal&gt;myschema.myfunc(42)&lt;/literal&gt; could be captured by a
      hostile function &lt;literal&gt;myschema.myfunc(integer)&lt;/literal&gt;.  Be
      careful that the data types of function and operator parameters exactly
      match the declared argument types, using explicit casts where necessary.
</span>
汎用の拡張は通常、安全なスキーマにインストールされることを想定するべきではありません。これはスキーマ修飾された自身のオブジェクトであっても完全にリスクがないわけではないことを意味しています。
例えば、拡張が <code class="literal">myschema.myfunc(bigint)</code>という関数を定義しているとき、<code class="literal">myschema.myfunc(42)</code>というような呼び出しは、悪意ある関数<code class="literal">myschema.myfunc(integer)</code>に捕捉される可能性があります。
必要に応じて明示的なキャストを使用して関数と演算子のデータ型が引数の型と厳密に一致するように注意してください。
     </p></div><div class="sect3" id="EXTEND-EXTENSIONS-SECURITY-SCRIPTS"><div class="titlepage"><div><div><h4 class="title">38.17.6.2. 拡張スクリプトのためのセキュリティに関する考慮事項</h4></div></div></div><span class="original">
     &lt;title&gt;Security Considerations for Extension Scripts&lt;/title&gt;
</span><p>
<span class="original">
      An extension installation or update script should be written to guard
      against search-path-based attacks occurring when the script executes.
      If an object reference in the script can be made to resolve to some
      other object than the script author intended, then a compromise might
      occur immediately, or later when the mis-defined extension object is
      used.
</span>
拡張のインストールや更新スクリプトはスクリプト実行時にサーチパスに基づく攻撃を防ぐように記述されなければなりません。
スクリプトが参照するオブジェクトがスクリプトの著者が意図したものではないオブジェクトとして解決されうる場合、即座もしくは、誤って定義された拡張オブジェクトが使われたときに攻撃を受ける可能性があります。
     </p><p>
<span class="original">
      DDL commands such as &lt;command&gt;CREATE FUNCTION&lt;/command&gt;
      and &lt;command&gt;CREATE OPERATOR CLASS&lt;/command&gt; are generally secure,
      but beware of any command having a general-purpose expression as a
      component.  For example, &lt;command&gt;CREATE VIEW&lt;/command&gt; needs to be
      vetted, as does a &lt;literal&gt;DEFAULT&lt;/literal&gt; expression
      in &lt;command&gt;CREATE FUNCTION&lt;/command&gt;.
</span>
<code class="command">CREATE FUNCTION</code>や<code class="command">CREATE OPERATOR CLASS</code>などのDDLコマンドは一般的には安全ですが、汎用的な式を構成に持つコマンドには注意が必要です。
例えば、<code class="command">CREATE FUNCTION</code>の<code class="literal">DEFAULT</code>式に行うのと同様に<code class="command">CREATE VIEW</code>には審査が必要です。
     </p><p>
<span class="original">
      Sometimes an extension script might need to execute general-purpose
      SQL, for example to make catalog adjustments that aren't possible via
      DDL.  Be careful to execute such commands with a
      secure &lt;varname&gt;search_path&lt;/varname&gt;; do &lt;emphasis&gt;not&lt;/emphasis&gt;
      trust the path provided by &lt;command&gt;CREATE/ALTER EXTENSION&lt;/command&gt;
      to be secure.  Best practice is to temporarily
      set &lt;varname&gt;search_path&lt;/varname&gt; to &lt;literal&gt;'pg_catalog,
      pg_temp'&lt;/literal&gt; and insert references to the extension's
      installation schema explicitly where needed.  (This practice might
      also be helpful for creating views.)  Examples can be found in
      the &lt;filename&gt;contrib&lt;/filename&gt; modules in
      the &lt;productname&gt;PostgreSQL&lt;/productname&gt; source code distribution.
</span>
拡張スクリプトには汎用SQLを実行する必要があることがあります。
例えば、DDLではできないカタログの調整などです。
そのようなコマンドは安全な<code class="varname">search_path</code>使って実行するように気をつけてください。
<code class="command">CREATE/ALTER EXTENSION</code>で提供されるパスが安全であると<span class="emphasis"><em>信用しないで</em></span>ください。
最も良い方法は一時的に<code class="varname">search_path</code>を<code class="literal">'pg_catalog, pg_temp'</code>にセットし、必要な箇所に明示的に拡張のインストールスキーマの参照を記述する方法です(この方法はビューを作成する場合にも参考になります)。
例は配布される<span class="productname">PostgreSQL</span>ソースコードの<code class="filename">contrib</code>に見つけることができます。
     </p><p>
<span class="original">
      Cross-extension references are extremely difficult to make fully
      secure, partially because of uncertainty about which schema the other
      extension is in.  The hazards are reduced if both extensions are
      installed in the same schema, because then a hostile object cannot be
      placed ahead of the referenced extension in the installation-time
      &lt;varname&gt;search_path&lt;/varname&gt;.  However, no mechanism currently exists
      to require that.  For now, best practice is to not mark an extension
      trusted if it depends on another one, unless that other one is always
      installed in &lt;literal&gt;pg_catalog&lt;/literal&gt;.
</span>
拡張をまたがる参照を完璧に安全にすることは極めて困難です。
理由の一つに、他の拡張がどのスキーマにあるのか定かではないことがあります。
この危険性は両方の拡張を同じスキーマにインストールすることで軽減できます。
悪意あるオブジェクトをインストール時の<code class="varname">search_path</code>内で参照された拡張の前に置くことができないからです。
しかしながら、現時点ではこれを要求するメカニズムはありません。
今のところ、最良の手段は他の拡張に依存する拡張であるなら、依存する拡張が常に<code class="literal">pg_catalog</code>にインストールされるのでない限り、拡張をtrustedと印付けしないことです。
     </p><p>
<span class="original">
      Do &lt;emphasis&gt;not&lt;/emphasis&gt; use &lt;command&gt;CREATE OR REPLACE
      FUNCTION&lt;/command&gt;, except in an update script that must change the
      definition of a function that is known to be an extension member
      already.  (Likewise for other &lt;literal&gt;OR REPLACE&lt;/literal&gt; options.)
      Using &lt;literal&gt;OR REPLACE&lt;/literal&gt; unnecessarily not only has a risk
      of accidentally overwriting someone else's function, but it creates a
      security hazard since the overwritten function would still be owned by
      its original owner, who could modify it.
</span>
拡張のメンバーであることが分かっている関数の定義を変更しなければならない更新スクリプトを除いて、<code class="command">CREATE OR REPLACE FUNCTION</code>は<span class="emphasis"><em>使用しないで</em></span>ください(他の<code class="literal">OR REPLACE</code>でも同様です)。
<code class="literal">OR REPLACE</code> を不必要に使うことは他の誰かの別の関数を誤って上書きしてしまうリスクがあるだけでなく、上書きされた関数は元の所有者のままなので元の所有者が変更できる状態となってしまい、セキュリティの脆弱性になります。
     </p></div></div><div class="sect2" id="EXTEND-EXTENSIONS-EXAMPLE"><div class="titlepage"><div><div><h3 class="title">38.17.7. 拡張の例</h3></div></div></div><span class="original">
    &lt;title&gt;Extension Example&lt;/title&gt;
</span><p>
<span class="original">
     Here is a complete example of an &lt;acronym&gt;SQL&lt;/acronym&gt;-only
     extension, a two-element composite type that can store any type of value
     in its slots, which are named &lt;quote&gt;k&lt;/quote&gt; and &lt;quote&gt;v&lt;/quote&gt;.  Non-text
     values are automatically coerced to text for storage.
</span>
ここでは、<acronym class="acronym">SQL</acronym>のみの拡張の完全な例を示します。
<span class="quote">「<span class="quote">k</span>」</span>と<span class="quote">「<span class="quote">v</span>」</span>という名称の２つの要素からなる複合型であり、そのスロットには任意の型の値を格納することができるものです。
格納の際テキスト以外の値は自動的にテキストに変換されます。
    </p><p>
<span class="original">
     The script file &lt;filename&gt;pair&amp;#045;-1.0.sql&lt;/filename&gt; looks like this:
</span>
<code class="filename">pair--1.0.sql</code>スクリプトファイルは以下のようになります。

</p><pre class="programlisting">
<span class="original">
&amp;#045;- complain if script is sourced in psql, rather than via CREATE EXTENSION
</span>
-- スクリプトが、CREATE EXTENSION経由ではなく、psqlのソースとして使われた場合には文句を言う
\echo Use "CREATE EXTENSION pair" to load this file. \quit

CREATE TYPE pair AS ( k text, v text );

CREATE FUNCTION pair(text, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::@extschema@.pair;';

CREATE OPERATOR ~&gt; (LEFTARG = text, RIGHTARG = text, FUNCTION = pair);

-- "SET search_path" is easy to get right, but qualified names perform better.
CREATE FUNCTION lower(pair)
RETURNS pair LANGUAGE SQL
AS 'SELECT ROW(lower($1.k), lower($1.v))::@extschema@.pair;'
SET search_path = pg_temp;

CREATE FUNCTION pair_concat(pair, pair)
RETURNS pair LANGUAGE SQL
AS 'SELECT ROW($1.k OPERATOR(pg_catalog.||) $2.k,
               $1.v OPERATOR(pg_catalog.||) $2.v)::@extschema@.pair;';

</pre><p>
    </p><p>
<span class="original">
     The control file &lt;filename&gt;pair.control&lt;/filename&gt; looks like this:
</span>
<code class="filename">pair.control</code>制御ファイルは以下のようになります。

</p><pre class="programlisting">
# pair extension
comment = 'A key/value pair data type'
default_version = '1.0'
# cannot be relocatable because of use of @extschema@
relocatable = false
</pre><p>
    </p><p>
<span class="original">
     While you hardly need a makefile to install these two files into the
     correct directory, you could use a &lt;filename&gt;Makefile&lt;/filename&gt; containing this:
</span>
これらの２つのファイルを正しいディレクトリにインストールするためにメークファイルを作成する必要はほとんどありませんが、以下を含む<code class="filename">Makefile</code>を使用することができます。

</p><pre class="programlisting">
EXTENSION = pair
DATA = pair--1.0.sql

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
</pre><p>

<span class="original">
     This makefile relies on &lt;acronym&gt;PGXS&lt;/acronym&gt;, which is described
     in &lt;xref linkend="extend-pgxs"/&gt;.  The command &lt;literal&gt;make install&lt;/literal&gt;
     will install the control and script files into the correct
     directory as reported by &lt;application&gt;pg_config&lt;/application&gt;.
</span>
このメークファイルは<a class="xref" href="extend-pgxs.html" title="38.18. 拡張構築基盤">38.18</a>で説明する<acronym class="acronym">PGXS</acronym>に依存します。
<code class="literal">make install</code>コマンドは制御ファイルとスクリプトファイルを<span class="application">pg_config</span>で報告される正しいディレクトリにインストールします。
    </p><p>
<span class="original">
     Once the files are installed, use the
     &lt;command&gt;CREATE EXTENSION&lt;/command&gt; command to load the objects into
     any particular database.
</span>
ファイルがインストールされた後、<code class="command">CREATE EXTENSION</code>コマンドを使用してオブジェクトを任意の特定のデータベースにロードしてください。
    </p></div></div><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navfooter"><hr></hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xindex.html" title="38.16. インデックス拡張機能へのインタフェース">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="extend.html" title="第38章 SQLの拡張">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="extend-pgxs.html" title="38.18. 拡張構築基盤">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">38.16. インデックス拡張機能へのインタフェース </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 14.0文書">ホーム</a></td><td width="40%" align="right" valign="top"> 38.18. 拡張構築基盤</td></tr></table></div></body></html>