<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.14. JSONデータ型</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="datatype-xml.html" title="8.13. XML型" /><link rel="next" href="arrays.html" title="8.15. 配列" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 15.0文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="datatype.html" title="第8章 データ型">第8章 データ型</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?template=bug_report.yml&amp;what-happened=version 15.0 : datatype-json.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="datatype-xml.html" title="8.13. XML型">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="datatype.html" title="第8章 データ型">上へ</a></td><td width="60%" align="center">8.14. <acronym class="acronym">JSON</acronym>データ型</td><td width="20%" align="right"> <a accesskey="n" href="arrays.html" title="8.15. 配列">次へ</a></td></tr></table><div class="other_version"><a href="https://www.postgresql.jp/document/">他のバージョンの文書</a></div><hr /></div><div class="sect1" id="DATATYPE-JSON"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8.14. <acronym class="acronym">JSON</acronym>データ型</h2></div></div></div><span class="original">
 &lt;title&gt;&lt;acronym&gt;JSON&lt;/acronym&gt; Types&lt;/title&gt;
</span><a id="id-1.5.7.24.2" class="indexterm"></a><a id="id-1.5.7.24.3" class="indexterm"></a><p>
<span class="original">
  JSON data types are for storing JSON (JavaScript Object Notation)
  data, as specified in &lt;ulink url="https://tools.ietf.org/html/rfc7159"&gt;RFC
  7159&lt;/ulink&gt;. Such data can also be stored as &lt;type&gt;text&lt;/type&gt;, but
  the JSON data types have the advantage of enforcing that each
  stored value is valid according to the JSON rules.  There are also
  assorted JSON-specific functions and operators available for data stored
  in these data types; see &lt;xref linkend="functions-json"/&gt;.
</span>
JSONデータ型はJSON(JavaScript Object Notation)データを格納するためのものです。JSONの仕様は<a class="ulink" href="https://tools.ietf.org/html/rfc7159" target="_top">RFC 7159</a>に定義されています。
このようなデータは、<code class="type">text</code>型として格納することもできますが、JSONデータ型は、それぞれ格納された値がJSONルールに従って有効に施行されるという利点があります。
これらのデータ型に格納されたデータのために利用可能な各種JSON固有の関数と演算子もあります。
<a class="xref" href="functions-json.html" title="9.16. JSON関数と演算子">9.16</a>を参照してください。
 </p><p>
<span class="original">
  &lt;productname&gt;PostgreSQL&lt;/productname&gt; offers two types for storing JSON
  data: &lt;type&gt;json&lt;/type&gt; and &lt;type&gt;jsonb&lt;/type&gt;. To implement efficient query
  mechanisms for these data types, &lt;productname&gt;PostgreSQL&lt;/productname&gt;
  also provides the &lt;type&gt;jsonpath&lt;/type&gt; data type described in
  &lt;xref linkend="datatype-jsonpath"/&gt;.
</span>
<span class="productname">PostgreSQL</span>には、JSONデータを格納するための2つの型、<code class="type">json</code>と<code class="type">jsonb</code>があります。
これらのデータ型に対して効率的な問い合わせメカニズムを実装するために、<span class="productname">PostgreSQL</span>は<a class="xref" href="datatype-json.html#DATATYPE-JSONPATH" title="8.14.7. jsonpath型">8.14.7</a>で説明されている<code class="type">jsonpath</code>データ型も提供します。
 </p><p>
<span class="original">
  The &lt;type&gt;json&lt;/type&gt; and &lt;type&gt;jsonb&lt;/type&gt; data types
  accept &lt;emphasis&gt;almost&lt;/emphasis&gt; identical sets of values as
  input.  The major practical difference is one of efficiency.  The
  &lt;type&gt;json&lt;/type&gt; data type stores an exact copy of the input text,
  which processing functions must reparse on each execution; while
  &lt;type&gt;jsonb&lt;/type&gt; data is stored in a decomposed binary format that
  makes it slightly slower to input due to added conversion
  overhead, but significantly faster to process, since no reparsing
  is needed.  &lt;type&gt;jsonb&lt;/type&gt; also supports indexing, which can be a
  significant advantage.
</span>
<code class="type">json</code>型と<code class="type">jsonb</code>型というデータ型は、<span class="emphasis"><em>ほとんど</em></span> 同一の入力値セットを受け入れます。
現実的に主要な違いは効率です。
<code class="type">json</code>データ型は入力テキストの正確なコピーで格納し、処理関数を実行するたびに再解析する必要があります。
<code class="type">jsonb</code>データ型では、分解されたバイナリ形式で格納されます。
格納するときには変換のオーバーヘッドのため少し遅くなりますが、処理するときには、全く再解析が必要とされないので大幅に高速化されます。
また <code class="type">jsonb</code>型の重要な利点はインデックスをサポートしていることです。
 </p><p>
<span class="original">
  Because the &lt;type&gt;json&lt;/type&gt; type stores an exact copy of the input text, it
  will preserve semantically-insignificant white space between tokens, as
  well as the order of keys within JSON objects. Also, if a JSON object
  within the value contains the same key more than once, all the key/value
  pairs are kept.  (The processing functions consider the last value as the
  operative one.)  By contrast, &lt;type&gt;jsonb&lt;/type&gt; does not preserve white
  space, does not preserve the order of object keys, and does not keep
  duplicate object keys.  If duplicate keys are specified in the input,
  only the last value is kept.
</span>
<code class="type">json</code>型は入力値のコピーを格納しているので、意味的に重要でないトークン間の空白だけでなく、JSONオブジェクト内のキーの順序も維持します。
また、JSONオブジェクト内に同じキーと値が複数含まれていてもすべてのキー／値のペアが保持されます。(この処理関数は最後の値１つを処理させるようにすれば済みます。)
これとは対照的に、<code class="type">jsonb</code>は空白を保持しません。オブジェクトキーの順序を保持せず、重複したオブジェクトキーを保持しません。重複キーを入力で指定された場合は、最後の値が保持されます。
 </p><p>
<span class="original">
  In general, most applications should prefer to store JSON data as
  &lt;type&gt;jsonb&lt;/type&gt;, unless there are quite specialized needs, such as
  legacy assumptions about ordering of object keys.
</span>
一般的に、ほとんどのアプリケーションではJSONデータ型として<code class="type">jsonb</code>型のほうが望ましいでしょう。ただし、オブジェクトキーを従来のような順序であることを仮定する非常に特殊なニーズが存在するような場合は除きます。
 </p><p>
<span class="original">
  &lt;acronym&gt;RFC&lt;/acronym&gt; 7159 specifies that JSON strings should be encoded in UTF8.
  It is therefore not possible for the JSON
  types to conform rigidly to the JSON specification unless the database
  encoding is UTF8. Attempts to directly include characters that
  cannot be represented in the database encoding will fail; conversely,
  characters that can be represented in the database encoding but not
  in UTF8 will be allowed.
</span>
<acronym class="acronym">RFC</acronym> 7159は、JSON文字列はUTF8でエンコードすべきと指定しています。
従ってデータベースエンコーディングがUTF8でない限り、厳密にはJSON型がJSON仕様に準拠することはできません。
データベースのエンコーディングで表現できない文字を直接含めようとすると失敗します。逆に、UTF8で許可されずにデータベースのエンコーディングで許可される文字が許されてしまいます。
 </p><p>
<span class="original">
  &lt;acronym&gt;RFC&lt;/acronym&gt; 7159 permits JSON strings to contain Unicode escape sequences
  denoted by &lt;literal&gt;\u&lt;replaceable&gt;XXXX&lt;/replaceable&gt;&lt;/literal&gt;.  In the input
  function for the &lt;type&gt;json&lt;/type&gt; type, Unicode escapes are allowed
  regardless of the database encoding, and are checked only for syntactic
  correctness (that is, that four hex digits follow &lt;literal&gt;\u&lt;/literal&gt;).
  However, the input function for &lt;type&gt;jsonb&lt;/type&gt; is stricter: it disallows
  Unicode escapes for characters that cannot be represented in the database
  encoding.  The &lt;type&gt;jsonb&lt;/type&gt; type also
  rejects &lt;literal&gt;\u0000&lt;/literal&gt; (because that cannot be represented in
  &lt;productname&gt;PostgreSQL&lt;/productname&gt;'s &lt;type&gt;text&lt;/type&gt; type), and it insists
  that any use of Unicode surrogate pairs to designate characters outside
  the Unicode Basic Multilingual Plane be correct.  Valid Unicode escapes
  are converted to the equivalent single character for storage;
  this includes folding surrogate pairs into a single character.
</span>
<acronym class="acronym">RFC</acronym> 7159 では、JSON文字列はUnicodeエスケープシーケンス <code class="literal">\u<em class="replaceable"><code>XXXX</code></em></code> を許可するように記述されています。
<code class="type">json</code>型の入力関数は、データベースエンコーディング方式に関係なくUnicodeエスケープが許可されています。それは、構文上の正しさ(つまり<code class="literal">\u</code>に続けて16進数が4桁)だけをチェックしています。
しかし、<code class="type">jsonb</code>の入力関数はより厳しくなります。
データベースエンコーディング方式で表現できない文字のUnicodeエスケープを禁止します。
<code class="type">jsonb</code>型は<code class="literal">\u0000</code>も許可しません。(なぜなら<span class="productname">PostgreSQL</span>の<code class="type">text</code>型で表現できないためです。)
また、Unicode基本多言語面以外の文字はUnicodeのサロゲートペアに直すことが要求されています。
有効なUnicodeエスケープは、同等の単一の文字に変換されて格納されます。これはサロゲートペアを単一の文字に変換する処理も含まれています。
 </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
   Many of the JSON processing functions described
   in &lt;xref linkend="functions-json"/&gt; will convert Unicode escapes to
   regular characters, and will therefore throw the same types of errors
   just described even if their input is of type &lt;type&gt;json&lt;/type&gt;
   not &lt;type&gt;jsonb&lt;/type&gt;. The fact that the &lt;type&gt;json&lt;/type&gt; input function does
   not make these checks may be considered a historical artifact, although
   it does allow for simple storage (without processing) of JSON Unicode
   escapes in a database encoding that does not support the represented
   characters.
</span>
<a class="xref" href="functions-json.html" title="9.16. JSON関数と演算子">9.16</a>で説明されているJSONの処理関数の多くは、Unicodeエスケープを通常の文字に変換します。
そして、それらの入力は<code class="type">jsonb</code>でない<code class="type">json</code>の場合でも記載された同じ種類のエラーになります。
<code class="type">json</code>入力関数がこれらのチェックをしないことは歴史的経緯によるものと言えるかもしれませんが、そのために、表現された文字をサポートしないデータベースエンコーディングで、JSON Unicodeエスケープされた文字を単に格納(処理を必要としない場合)できてしまいます。
  </p></div><p>
<span class="original">
  When converting textual JSON input into &lt;type&gt;jsonb&lt;/type&gt;, the primitive
  types described by &lt;acronym&gt;RFC&lt;/acronym&gt; 7159 are effectively mapped onto
  native &lt;productname&gt;PostgreSQL&lt;/productname&gt; types, as shown
  in &lt;xref linkend="json-type-mapping-table"/&gt;.
  Therefore, there are some minor additional constraints on what
  constitutes valid &lt;type&gt;jsonb&lt;/type&gt; data that do not apply to
  the &lt;type&gt;json&lt;/type&gt; type, nor to JSON in the abstract, corresponding
  to limits on what can be represented by the underlying data type.
  Notably, &lt;type&gt;jsonb&lt;/type&gt; will reject numbers that are outside the
  range of the &lt;productname&gt;PostgreSQL&lt;/productname&gt; &lt;type&gt;numeric&lt;/type&gt; data
  type, while &lt;type&gt;json&lt;/type&gt; will not.  Such implementation-defined
  restrictions are permitted by &lt;acronym&gt;RFC&lt;/acronym&gt; 7159.  However, in
  practice such problems are far more likely to occur in other
  implementations, as it is common to represent JSON's &lt;type&gt;number&lt;/type&gt;
  primitive type as IEEE 754 double precision floating point
  (which &lt;acronym&gt;RFC&lt;/acronym&gt; 7159 explicitly anticipates and allows for).
  When using JSON as an interchange format with such systems, the danger
  of losing numeric precision compared to data originally stored
  by &lt;productname&gt;PostgreSQL&lt;/productname&gt; should be considered.
</span>
原文のJSONが<code class="type">jsonb</code>型に変換されるときには、<acronym class="acronym">RFC</acronym> 7159に記載されているプリミティブ型は<a class="xref" href="datatype-json.html#JSON-TYPE-MAPPING-TABLE" title="表8.23 JSONプリミティブ型とPostgreSQL型の対応表">表 8.23</a>に記されているように<span class="productname">PostgreSQL</span>のネイティブな型に変換されます。
そのため、<code class="type">jsonb</code>データ型には、<code class="type">json</code>型になく、また理論上JSONにはないマイナーな制約があります。それは基礎となるデータ型に付随する制限によって表されます。
特に<code class="type">jsonb</code>型は、<span class="productname">PostgreSQL</span>の<code class="type">numeric</code>型の範囲外の数を拒否しますが、<code class="type">json</code>は拒否しません。
このような処理系で定義される制限は<acronym class="acronym">RFC</acronym> 7159で許可されています。
しかし、それは IEEE 754 倍精度浮動小数点がJSONの<code class="type">number</code>プリミティブ型を表すのが一般的であるように、実際には他の実装でこのような問題が発生することの方がはるかに可能性が高いです(<acronym class="acronym">RFC</acronym> 7159が明示的に予測して、許可しています)。
このようなシステムと<span class="productname">PostgreSQL</span>で交換フォーマットとしてJSONを使用する場合は、数値精度を失う危険性があることを把握しておく必要があります。
 </p><p>
<span class="original">
  Conversely, as noted in the table there are some minor restrictions on
  the input format of JSON primitive types that do not apply to
  the corresponding &lt;productname&gt;PostgreSQL&lt;/productname&gt; types.
</span>
逆に、表に示すようにJSONプリミティブ型の入力フォーマットには、対応する<span class="productname">PostgreSQL</span>型と適合しない、いくつかのマイナーな制限があります。
 </p><div class="table" id="JSON-TYPE-MAPPING-TABLE"><p class="title"><strong>表8.23 JSONプリミティブ型と<span class="productname">PostgreSQL</span>型の対応表</strong></p><div class="table-contents"><span class="original">
     &lt;title&gt;JSON Primitive Types and Corresponding &lt;productname&gt;PostgreSQL&lt;/productname&gt; Types&lt;/title&gt;
</span><table class="table" summary="JSONプリミティブ型とPostgreSQL型の対応表" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>JSON プリミティブ型</th><th><span class="productname">PostgreSQL</span>型</th><th>注釈</th></tr></thead><tbody><tr><td><code class="type">string</code></td><td><code class="type">text</code></td><td><code class="literal">\u0000</code>は許可されません。
またそのデータベースエンコーディング方式で利用できない文字を表現するユニコードエスケープも許可されません。</td></tr><tr><td><code class="type">number</code></td><td><code class="type">numeric</code></td><td><code class="literal">NaN</code> と <code class="literal">infinity</code> 値は許可されません</td></tr><tr><td><code class="type">boolean</code></td><td><code class="type">boolean</code></td><td>小文字の<code class="literal">true</code> と <code class="literal">false</code> という綴りのみ許可されます</td></tr><tr><td><code class="type">null</code></td><td>(none)</td><td>SQLの<code class="literal">NULL</code>とは概念が異なります</td></tr></tbody></table></div></div><br class="table-break" /><div class="sect2" id="JSON-KEYS-ELEMENTS"><div class="titlepage"><div><div><h3 class="title">8.14.1. JSONの入出力構文</h3></div></div></div><span class="original">
  &lt;title&gt;JSON Input and Output Syntax&lt;/title&gt;
</span><p>
<span class="original">
   The input/output syntax for the JSON data types is as specified in
   &lt;acronym&gt;RFC&lt;/acronym&gt; 7159.
</span>
JSON型の入出力構文の仕様は<acronym class="acronym">RFC</acronym> 7159 に規定されています。
  </p><p>
<span class="original">
   The following are all valid &lt;type&gt;json&lt;/type&gt; (or &lt;type&gt;jsonb&lt;/type&gt;) expressions:
</span>
以下は、すべて有効な<code class="type">json</code>型(または <code class="type">jsonb</code>型)の式です。
</p><pre class="programlisting">
<span class="original">
&amp;#45;- Simple scalar/primitive value
&amp;#45;- Primitive values can be numbers, quoted strings, true, false, or null
</span>
-- シンプルなスカラ/プリミティブ値
-- プリミティブ値は、数値、引用符で括られた文字列、true、 false、またはnullです。
SELECT '5'::json;

<span class="original">
&amp;#45;- Array of zero or more elements (elements need not be of same type)
</span>
-- 0個以上の要素の配列（要素は同じ型である必要はありません)。
SELECT '[1, 2, "foo", null]'::json;

<span class="original">
&amp;#45;- Object containing pairs of keys and values
&amp;#45;- Note that object keys must always be quoted strings
</span>
-- キーと値のペアを含むオブジェクト
-- オブジェクトキーは常に引用符で括られた文字列でなければならないことに注意してください。
SELECT '{"bar": "baz", "balance": 7.77, "active": false}'::json;

<span class="original">
&amp;#45;- Arrays and objects can be nested arbitrarily
</span>
-- 配列とオブジェクトは任意に入れ子にすることができます。
SELECT '{"foo": [true, "bar"], "tags": {"a": 1, "b": null}}'::json;
</pre><p>
  </p><p>
<span class="original">
   As previously stated, when a JSON value is input and then printed without
   any additional processing, &lt;type&gt;json&lt;/type&gt; outputs the same text that was
   input, while &lt;type&gt;jsonb&lt;/type&gt; does not preserve semantically-insignificant
   details such as whitespace.  For example, note the differences here:
</span>
先に述べたようにJSONの値が入力されたときに、その後、追加の処理を行わずに表示する場合、<code class="type">json</code>は入力と同じテキストが出力されます、<code class="type">jsonb</code>では、空白のような意味を持たない情報を保持しません。
例を示します。ここでは相違点に注意してください。
</p><pre class="programlisting">
SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::json;
                      json
-------------------------------------------------
 {"bar": "baz", "balance": 7.77, "active":false}
(1 row)

SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::jsonb;
                      jsonb
--------------------------------------------------
 {"bar": "baz", "active": false, "balance": 7.77}
(1 row)
</pre><p>
<span class="original">
   One semantically-insignificant detail worth noting is that
   in &lt;type&gt;jsonb&lt;/type&gt;, numbers will be printed according to the behavior of the
   underlying &lt;type&gt;numeric&lt;/type&gt; type.  In practice this means that numbers
   entered with &lt;literal&gt;E&lt;/literal&gt; notation will be printed without it, for
   example:
</span>
もう一つ注目に値するのは、<code class="type">jsonb</code>では、数値は<code class="type">numeric</code>型の動作に応じて表示され、意味を持たない情報を保持しません。実際には数字は<code class="literal">E</code>表記なしで表示されることを意味します。
例を示します。
</p><pre class="programlisting">
SELECT '{"reading": 1.230e-5}'::json, '{"reading": 1.230e-5}'::jsonb;
         json          |          jsonb
-----------------------+-------------------------
 {"reading": 1.230e-5} | {"reading": 0.00001230}
(1 row)
</pre><p>
<span class="original">
   However, &lt;type&gt;jsonb&lt;/type&gt; will preserve trailing fractional zeroes, as seen
   in this example, even though those are semantically insignificant for
   purposes such as equality checks.
</span>
しかし、この例に見られるように<code class="type">jsonb</code>は小数の末尾のゼロを保持します。それにも関わらず、等しいかチェックする場合等では、意味的に重要ではありません。
  </p><p>
<span class="original">
    For the list of built-in functions and operators available for
    constructing and processing JSON values, see &lt;xref linkend="functions-json"/&gt;.
</span>
JSONの値の作成と処理に使用可能な組み込み関数と演算子のリストについては、<a class="xref" href="functions-json.html" title="9.16. JSON関数と演算子">9.16</a>を参照してください。
  </p></div><div class="sect2" id="JSON-DOC-DESIGN"><div class="titlepage"><div><div><h3 class="title">8.14.2. JSONドキュメントの設計</h3></div></div></div><span class="original">
  &lt;title&gt;Designing JSON Documents&lt;/title&gt;
</span><p>
<span class="original">
   Representing data as JSON can be considerably more flexible than
   the traditional relational data model, which is compelling in
   environments where requirements are fluid.  It is quite possible
   for both approaches to co-exist and complement each other within
   the same application.  However, even for applications where maximal
   flexibility is desired, it is still recommended that JSON documents
   have a somewhat fixed structure.  The structure is typically
   unenforced (though enforcing some business rules declaratively is
   possible), but having a predictable structure makes it easier to write
   queries that usefully summarize a set of &lt;quote&gt;documents&lt;/quote&gt; (datums)
   in a table.
</span>
JSONデータは従来のリレーショナルデータモデルよりもかなり柔軟に表現することができます。そのため、要件が変わりやすい環境では説得力があります。
そして、それは同じアプリケーション内で、両方のアプローチが共存し相互に補完することが可能です。
しかし、最大の柔軟性が要求されるアプリケーションのためでもJSONドキュメントには、まだいくらかの固定構造を持つことを推奨します。
構造は（いくつかのビジネスルールを強制することは宣言的に可能であるが）、一般的に強制されないですが、テーブル内の<span class="quote">「<span class="quote">ドキュメント</span>」</span>（データ）セットをまとめて予測可能な構造にすることで、簡単に問い合わせを記述することができます。
  </p><p>
<span class="original">
   JSON data is subject to the same concurrency-control
   considerations as any other data type when stored in a table.
   Although storing large documents is practicable, keep in mind that
   any update acquires a row-level lock on the whole row.
   Consider limiting JSON documents to a
   manageable size in order to decrease lock contention among updating
   transactions.  Ideally, JSON documents should each
   represent an atomic datum that business rules dictate cannot
   reasonably be further subdivided into smaller datums that
   could be modified independently.
</span>
JSONデータはテーブルに格納するとき、他のデータ型と同一の同時実行制御の対象となります。大きな文章を保存することは実行可能ですが、すべての更新が行レベルロックを取得することに留意してください。
更新トランザクション間のロックの競合を減少させるために、管理可能なサイズにJSONドキュメントを制限することを検討してください。
理想的には、JSONドキュメントはビジネス・ルール上、独立して変更することができない単位までデータを分割すべきです。
  </p></div><div class="sect2" id="JSON-CONTAINMENT"><div class="titlepage"><div><div><h3 class="title">8.14.3. <code class="type">jsonb</code>型用包含演算子と存在演算子</h3></div></div></div><span class="original">
  &lt;title&gt;&lt;type&gt;jsonb&lt;/type&gt; Containment and Existence&lt;/title&gt;
</span><a id="id-1.5.7.24.17.2" class="indexterm"></a><a id="id-1.5.7.24.17.3" class="indexterm"></a><a id="id-1.5.7.24.17.4" class="indexterm"></a><a id="id-1.5.7.24.17.5" class="indexterm"></a><p>
<span class="original">
    Testing &lt;firstterm&gt;containment&lt;/firstterm&gt; is an important capability of
    &lt;type&gt;jsonb&lt;/type&gt;.  There is no parallel set of facilities for the
    &lt;type&gt;json&lt;/type&gt; type.  Containment tests whether
    one &lt;type&gt;jsonb&lt;/type&gt; document has contained within it another one.
    These examples return true except as noted:
</span>
<em class="firstterm">包含演算子</em>による検査は<code class="type">jsonb</code>型の重要な機能です。
<code class="type">json</code>型には同等の機能セットはありません。
<code class="type">jsonb</code>ドキュメントが、その中に指定するドキュメントを含むかどうかを検査します。
これらの例は、特に記載がないかぎりtrueを返します。
  </p><pre class="programlisting">
<span class="original">
&amp;#45;- Simple scalar/primitive values contain only the identical value:
</span>
-- 単純なスカラ/プリミティブ値は、同一の値が含まれています。
SELECT '"foo"'::jsonb @&gt; '"foo"'::jsonb;

<span class="original">
&amp;#45;- The array on the right side is contained within the one on the left:
</span>
-- 左辺の配列に右辺の配列が含まれています。
SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 3]'::jsonb;

<span class="original">
&amp;#45;- Order of array elements is not significant, so this is also true:
</span>
-- 配列要素の順序は重要ではありませんので、これもまた真になります。
SELECT '[1, 2, 3]'::jsonb @&gt; '[3, 1]'::jsonb;

<span class="original">
&amp;#45;- Duplicate array elements don't matter either:
</span>
-- 配列要素に重複が含まれているかは問題ではありません。
SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 2, 2]'::jsonb;

<span class="original">
&amp;#45;- The object with a single pair on the right side is contained
&amp;#45;- within the object on the left side:
</span>
-- 右辺の単一ペアを持つオブジェクトが左辺のオブジェクト内に含まれています。
SELECT '{"product": "PostgreSQL", "version": 9.4, "jsonb": true}'::jsonb @&gt; '{"version": 9.4}'::jsonb;

<span class="original">
&amp;#45;- The array on the right side is &lt;emphasis&gt;not&lt;/emphasis&gt; considered contained within the
&amp;#45;- array on the left, even though a similar array is nested within it:
</span>
-- 右辺の配列は左辺の配列に含まれま<span class="emphasis"><strong>せん</strong></span>、
-- 類似の配列が、その中のネストに含まれているにも関わらず。
<span class="original">
SELECT '[1, 2, [1, 3]]'::jsonb @&amp;gt; '[1, 3]'::jsonb;  &amp;#45;- yields false
</span>
SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[1, 3]'::jsonb;  -- falseになる

<span class="original">
&amp;#45;- But with a layer of nesting, it is contained:
</span>
-- しかし、ネストで層を合わせれば含まれるようになります。
SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[[1, 3]]'::jsonb;

<span class="original">
&amp;#45;- Similarly, containment is not reported here:
</span>
-- 同様に、これも含まれません。
<span class="original">
SELECT '{"foo": {"bar": "baz"}}'::jsonb @&amp;gt; '{"bar": "baz"}'::jsonb;  &amp;#45;- yields false
</span>
SELECT '{"foo": {"bar": "baz"}}'::jsonb @&gt; '{"bar": "baz"}'::jsonb;  -- falseになる

<span class="original">
&amp;#45;- A top-level key and an empty object is contained:
</span>
-- トップレベルのキーと空のオブジェクトが含まれる。
SELECT '{"foo": {"bar": "baz"}}'::jsonb @&gt; '{"foo": {}}'::jsonb;
</pre><p>
<span class="original">
   The general principle is that the contained object must match the
   containing object as to structure and data contents, possibly after
   discarding some non-matching array elements or object key/value pairs
   from the containing object.
   But remember that the order of array elements is not significant when
   doing a containment match, and duplicate array elements are effectively
   considered only once.
</span>
一般原則では、オブジェクトにオブジェクトが含まれているかを判断するには、いくつかの条件に一致しない配列要素とキー／値のペアを含むオブジェクトを捨てた後に構造とデータを一致させる必要があります。
しかし、条件に一致するには配列要素の順序は重要ではなく、重複要素は一回のみ有効に評価されることを覚えておく必要があります。
  </p><p>
<span class="original">
   As a special exception to the general principle that the structures
   must match, an array may contain a primitive value:
</span>
構造が一致しなければならないという一般原則の特別な例外として、配列はプリミティブな値を含めることができます。
  </p><pre class="programlisting">
<span class="original">
&amp;#45;- This array contains the primitive string value:
</span>
-- この配列はプリミティブな文字列を含みます。
SELECT '["foo", "bar"]'::jsonb @&gt; '"bar"'::jsonb;

<span class="original">
&amp;#45;- This exception is not reciprocal &amp;#45;- non-containment is reported here:
</span>
-- この例外は相互的ではありません。 -- これは含まれません。
<span class="original">
SELECT '"bar"'::jsonb @&amp;gt; '["bar"]'::jsonb;  &amp;#45;- yields false
</span>
SELECT '"bar"'::jsonb @&gt; '["bar"]'::jsonb;  -- falseになる
</pre><p>
<span class="original">
    &lt;type&gt;jsonb&lt;/type&gt; also has an &lt;firstterm&gt;existence&lt;/firstterm&gt; operator, which is
    a variation on the theme of containment: it tests whether a string
    (given as a &lt;type&gt;text&lt;/type&gt; value) appears as an object key or array
    element at the top level of the &lt;type&gt;jsonb&lt;/type&gt; value.
    These examples return true except as noted:
</span>
<code class="type">jsonb</code>型は、また<em class="firstterm">存在</em>演算子を持ちます。包含の変種です。それは文字列(与えられた<code class="type">text</code>値)が、<code class="type">jsonb</code>値のオブジェクトキーまたは配列のトップレベルに存在するかどうかを検査します。
これらの例は、特に記載がないかぎりtrueを返します。
  </p><pre class="programlisting">
<span class="original">
&amp;#45;- String exists as array element:
</span>
-- 文字列が配列要素に存在する。
SELECT '["foo", "bar", "baz"]'::jsonb ? 'bar';

<span class="original">
&amp;#45;- String exists as object key:
</span>
-- 文字列がオブジェクトキーに存在する。
SELECT '{"foo": "bar"}'::jsonb ? 'foo';

<span class="original">
&amp;#45;- Object values are not considered:
</span>
-- オブジェクト値は考慮されません。
<span class="original">
SELECT '{"foo": "bar"}'::jsonb ? 'bar';  &amp;#45;- yields false
</span>
SELECT '{"foo": "bar"}'::jsonb ? 'bar';  -- falseになる

<span class="original">
&amp;#45;- As with containment, existence must match at the top level:
</span>
-- オブジェクトはトップレベルから一致するように存在する必要があります。
<span class="original">
SELECT '{"foo": {"bar": "baz"}}'::jsonb ? 'bar'; &amp;#45;- yields false
</span>
SELECT '{"foo": {"bar": "baz"}}'::jsonb ? 'bar'; -- falseになる

<span class="original">
&amp;#45;- A string is considered to exist if it matches a primitive JSON string:
</span>
-- 文字列はJSONプリミティブ文字列と一致させることができます。
SELECT '"foo"'::jsonb ? 'foo';
</pre><p>
<span class="original">
    JSON objects are better suited than arrays for testing containment or
    existence when there are many keys or elements involved, because
    unlike arrays they are internally optimized for searching, and do not
    need to be searched linearly.
</span>
JSONオブジェクトは、関係するキーや要素が多く存在する場合、含むかどうかまたは存在するかどうかのテストに適しています。なぜなら配列とは異なり、リニア検索をする必要がなく、内部的に検索に最適化されています。
  </p><div class="tip"><h3 class="title">ヒント</h3><p>
<span class="original">
    Because JSON containment is nested, an appropriate query can skip
    explicit selection of sub-objects.  As an example, suppose that we have
    a &lt;structfield&gt;doc&lt;/structfield&gt; column containing objects at the top level, with
    most objects containing &lt;literal&gt;tags&lt;/literal&gt; fields that contain arrays of
    sub-objects.  This query finds entries in which sub-objects containing
    both &lt;literal&gt;"term":"paris"&lt;/literal&gt; and &lt;literal&gt;"term":"food"&lt;/literal&gt; appear,
    while ignoring any such keys outside the &lt;literal&gt;tags&lt;/literal&gt; array:
</span>
JSONでは包含がネストされるので、適切な問い合わせではサブオブジェクトの明示的な選択を省略することが出来ます。
例を挙げます。
<code class="structfield">doc</code>列にトップレベルのオブジェクトがあります。
このオブジェクトには、<code class="literal">tags</code>フィールドが含まれ、このフィールドにサブオブジェクトの配列が多く含まれているとします。
以下の問い合わせは、サブオブジェクトが<code class="literal">"term":"paris"</code>と<code class="literal">"term":"food"</code>の両方を含むエントリを探します。
そのとき<code class="literal">tags</code>配列の外側にある、それらのキーは無視されます。
</p><pre class="programlisting">
SELECT doc-&gt;'site_name' FROM websites
  WHERE doc @&gt; '{"tags":[{"term":"paris"}, {"term":"food"}]}';
</pre><p>
<span class="original">
    One could accomplish the same thing with, say,
</span>
同じことを達成することは出来ます。例えば、
</p><pre class="programlisting">
SELECT doc-&gt;'site_name' FROM websites
  WHERE doc-&gt;'tags' @&gt; '[{"term":"paris"}, {"term":"food"}]';
</pre><p>
<span class="original">
    but that approach is less flexible, and often less efficient as well.
</span>
しかし、そのアプローチは柔軟性に欠け、効率も落ちます。
   </p><p>
<span class="original">
    On the other hand, the JSON existence operator is not nested: it will
    only look for the specified key or array element at top level of the
    JSON value.
</span>
一方、JSONの存在演算子は、ネストしていません。
JSONの値の最上位に指定されたキーまたは配列要素のみを探します。
   </p></div><p>
<span class="original">
    The various containment and existence operators, along with all other
    JSON operators and functions are documented
    in &lt;xref linkend="functions-json"/&gt;.
</span>
JSONの様々な包含演算子や存在演算子、他のすべてのJSON演算子と関数は <a class="xref" href="functions-json.html" title="9.16. JSON関数と演算子">9.16</a>に記載されています。
  </p></div><div class="sect2" id="JSON-INDEXING"><div class="titlepage"><div><div><h3 class="title">8.14.4. <code class="type">jsonb</code> インデックス</h3></div></div></div><span class="original">
  &lt;title&gt;&lt;type&gt;jsonb&lt;/type&gt; Indexing&lt;/title&gt;
</span><a id="id-1.5.7.24.18.2" class="indexterm"></a><a id="id-1.5.7.24.18.3" class="indexterm"></a><p>
<span class="original">
    GIN indexes can be used to efficiently search for
    keys or key/value pairs occurring within a large number of
    &lt;type&gt;jsonb&lt;/type&gt; documents (datums).
    Two GIN &lt;quote&gt;operator classes&lt;/quote&gt; are provided, offering different
    performance and flexibility trade-offs.
</span>
GINインデックスは、多数の<code class="type">jsonb</code>ドキュメント(データ)のキーやキー／値ペアを効率的に検索するときに用いることができます。
異なるパフォーマンスと柔軟性のトレードオフを持つ、2つのGIN <span class="quote">「<span class="quote">演算子クラス</span>」</span> が提供されています。
  </p><p>
<span class="original">
    The default GIN operator class for &lt;type&gt;jsonb&lt;/type&gt; supports queries with
    the key-exists operators &lt;literal&gt;?&lt;/literal&gt;, &lt;literal&gt;?|&lt;/literal&gt;
    and &lt;literal&gt;?&amp;amp;&lt;/literal&gt;, the containment operator
    &lt;literal&gt;@&amp;gt;&lt;/literal&gt;, and the &lt;type&gt;jsonpath&lt;/type&gt; match
    operators &lt;literal&gt;@?&lt;/literal&gt; and &lt;literal&gt;@@&lt;/literal&gt;.
    (For details of the semantics that these operators
    implement, see &lt;xref linkend="functions-jsonb-op-table"/&gt;.)
    An example of creating an index with this operator class is:
</span>
<code class="type">jsonb</code>型の問い合わせでサポートしているデフォルトのGIN演算子クラスは、キーが存在するかの演算子として<code class="literal">?</code>、<code class="literal">?|</code>、<code class="literal">?&amp;</code>があり、包含演算子として<code class="literal">@&gt;</code>があり、<code class="type">jsonpath</code>マッチング演算子として<code class="literal">@?</code>、<code class="literal">@@</code>があります。
（これらの演算子の意味の詳細は、<a class="xref" href="functions-json.html#FUNCTIONS-JSONB-OP-TABLE" title="表9.46 追加jsonb演算子">表 9.46</a>を参照してください。）
この演算子クラスのインデックスを作成する例。
</p><pre class="programlisting">
CREATE INDEX idxgin ON api USING GIN (jdoc);
</pre><p>
<span class="original">
    The non-default GIN operator class &lt;literal&gt;jsonb_path_ops&lt;/literal&gt;
    does not support the key-exists operators, but it does support
    &lt;literal&gt;@&amp;gt;&lt;/literal&gt;, &lt;literal&gt;@?&lt;/literal&gt; and &lt;literal&gt;@@&lt;/literal&gt;.
    An example of creating an index with this operator class is:
</span>
デフォルトでないGIN演算子クラス<code class="literal">jsonb_path_ops</code>は、キーが存在するかの演算子をサポートしませんが、<code class="literal">@&gt;</code>、<code class="literal">@?</code>、<code class="literal">@@</code>をサポートします。
この演算子クラスのインデックスを作成する例。
</p><pre class="programlisting">
CREATE INDEX idxginp ON api USING GIN (jdoc jsonb_path_ops);
</pre><p>
  </p><p>
<span class="original">
    Consider the example of a table that stores JSON documents
    retrieved from a third-party web service, with a documented schema
    definition.  A typical document is:
</span>
サードパーティのWebサービスから、ドキュメント化されたスキーマ定義を持つJSONドキュメントを取得し、格納するテーブルの例を考えてみましょう。
典型的なドキュメントは、次のとおりです。
</p><pre class="programlisting">
{
    "guid": "9c36adc1-7fb5-4d5b-83b4-90356a46061a",
    "name": "Angela Barton",
    "is_active": true,
    "company": "Magnafone",
    "address": "178 Howard Place, Gulf, Washington, 702",
    "registered": "2009-11-07T08:53:22 +08:00",
    "latitude": 19.793713,
    "longitude": 86.513373,
    "tags": [
        "enim",
        "aliquip",
        "qui"
    ]
}
</pre><p>
<span class="original">
    We store these documents in a table named &lt;structname&gt;api&lt;/structname&gt;,
    in a &lt;type&gt;jsonb&lt;/type&gt; column named &lt;structfield&gt;jdoc&lt;/structfield&gt;.
    If a GIN index is created on this column,
    queries like the following can make use of the index:
</span>
テーブル名 <code class="structname">api</code>に<code class="type">jsonb</code>型で<code class="structfield">jdoc</code>をカラム名として格納します。
このカラムにGINインデックスを作成した場合、以下のような問い合わせがインデックスを利用することができます。
</p><pre class="programlisting">
<span class="original">
&amp;#45;- Find documents in which the key "company" has value "Magnafone"
</span>
-- "company"キー が "Magnafone"値であるものを見つける
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"company": "Magnafone"}';
</pre><p>
<span class="original">
    However, the index could not be used for queries like the
    following, because though the operator &lt;literal&gt;?&lt;/literal&gt; is indexable,
    it is not applied directly to the indexed column &lt;structfield&gt;jdoc&lt;/structfield&gt;:
</span>
しかし 次のような問い合わせはインデックスを使用しません。なぜなら、<code class="literal">?</code>演算子はインデックス可能ですが、<code class="structfield">jdoc</code>カラムのインデックスが直接適用されていないためです。
</p><pre class="programlisting">
<span class="original">
&amp;#45;- Find documents in which the key "tags" contains key or array element "qui"
</span>
-- キー "tags" の配列要素に "qui"が含まれているか見つける
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc -&gt; 'tags' ? 'qui';
</pre><p>
<span class="original">
    Still, with appropriate use of expression indexes, the above
    query can use an index.  If querying for particular items within
    the &lt;literal&gt;"tags"&lt;/literal&gt; key is common, defining an index like this
    may be worthwhile:
</span>
それでも、上記の問い合わせは、式インデックスを適切に使用することでインデックスを使用することができます。一般的な <code class="literal">"tags"</code>キーから特定の項目を照会する場合、このようなインデックスを定義すると良いかもしれません。
</p><pre class="programlisting">
CREATE INDEX idxgintags ON api USING GIN ((jdoc -&gt; 'tags'));
</pre><p>
<span class="original">
    Now, the &lt;literal&gt;WHERE&lt;/literal&gt; clause &lt;literal&gt;jdoc -&amp;gt; 'tags' ? 'qui'&lt;/literal&gt;
    will be recognized as an application of the indexable
    operator &lt;literal&gt;?&lt;/literal&gt; to the indexed
    expression &lt;literal&gt;jdoc -&amp;gt; 'tags'&lt;/literal&gt;.
    (More information on expression indexes can be found in &lt;xref
    linkend="indexes-expressional"/&gt;.)
</span>
さて、 <code class="literal">WHERE</code>句の <code class="literal">jdoc -&gt; 'tags' ? 'qui'</code>は、インデックス式<code class="literal">jdoc-&gt;'tags'</code>では、<code class="literal">?</code>演算子はインデックス可能として認識されます。
（式インデックスに関する詳細情報は<a class="xref" href="indexes-expressional.html" title="11.7. 式に対するインデックス">11.7</a>を参照してください。）
  </p><p>
<span class="original">
    Another approach to querying is to exploit containment, for example:
</span>
別のアプローチとして包含を利用する問い合わせがあります。例を示します。
</p><pre class="programlisting">
<span class="original">
&amp;#45;- Find documents in which the key "tags" contains array element "qui"
</span>
-- キー "tags"に 要素"qui"が含まれるかどうか見つける
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"tags": ["qui"]}';
</pre><p>
<span class="original">
    A simple GIN index on the &lt;structfield&gt;jdoc&lt;/structfield&gt; column can support this
    query.  But note that such an index will store copies of every key and
    value in the &lt;structfield&gt;jdoc&lt;/structfield&gt; column, whereas the expression index
    of the previous example stores only data found under
    the &lt;literal&gt;tags&lt;/literal&gt; key.  While the simple-index approach is far more
    flexible (since it supports queries about any key), targeted expression
    indexes are likely to be smaller and faster to search than a simple
    index.
</span>
<code class="structfield">jdoc</code>カラムのシンプルなGINインデックスは、この問い合わせをサポートすることができます。
しかし、前の例では、<code class="literal">tags</code>キーの下にあるデータのみをインデックスに格納していたのに対して、そのようなインデックスは、<code class="structfield">jdoc</code>のすべてのキーと値のコピーを保存しますので、注意が必要です。
シンプルなインデックスアプローチは（それが全てのキーについての問い合わせをサポートしているため）はるかに柔軟ですが、ターゲット式インデックスは単純なインデックスより小さく、検索のときに高速である可能性が高くなります。
  </p><p>
<span class="original">
    GIN indexes also support the &lt;literal&gt;@?&lt;/literal&gt;
    and &lt;literal&gt;@@&lt;/literal&gt; operators, which
    perform &lt;type&gt;jsonpath&lt;/type&gt; matching.  Examples are
</span>
GINインデックスは<code class="type">jsonpath</code>のマッチングを実行する<code class="literal">@?</code>演算子と<code class="literal">@@</code>演算子もサポートします。
例は以下の通りです。
</p><pre class="programlisting">
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @? '$.tags[*] ? (@ == "qui")';
</pre><p>
</p><pre class="programlisting">
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @@ '$.tags[*] == "qui"';
</pre><p>
<span class="original">
    For these operators, a GIN index extracts clauses of the form
    &lt;literal&gt;&lt;replaceable&gt;accessors_chain&lt;/replaceable&gt;
    = &lt;replaceable&gt;constant&lt;/replaceable&gt;&lt;/literal&gt; out of
    the &lt;type&gt;jsonpath&lt;/type&gt; pattern, and does the index search based on
    the keys and values mentioned in these clauses.  The accessors chain
    may include &lt;literal&gt;.&lt;replaceable&gt;key&lt;/replaceable&gt;&lt;/literal&gt;,
    &lt;literal&gt;[*]&lt;/literal&gt;,
    and &lt;literal&gt;[&lt;replaceable&gt;index&lt;/replaceable&gt;]&lt;/literal&gt; accessors.
    The &lt;literal&gt;jsonb_ops&lt;/literal&gt; operator class also
    supports &lt;literal&gt;.*&lt;/literal&gt; and &lt;literal&gt;.**&lt;/literal&gt; accessors,
    but the &lt;literal&gt;jsonb_path_ops&lt;/literal&gt; operator class does not.
</span>
これらの演算子に対して、GINインデックスは、<code class="type">jsonpath</code>パターンから<code class="literal"><em class="replaceable"><code>accessors_chain</code></em> = <em class="replaceable"><code>constant</code></em></code>の形式の句を抽出し、句内で使われているキーと値に基づいてインデックスサーチをします。
アクセサチェーン(accessors chain)は<code class="literal">.<em class="replaceable"><code>key</code></em></code>、<code class="literal">[*]</code>、<code class="literal">[<em class="replaceable"><code>index</code></em>]</code>アクセサを含みます。
<code class="literal">jsonb_ops</code>演算子クラスは<code class="literal">.*</code>と<code class="literal">.**</code>アクセサもサポートしますが、<code class="literal">jsonb_path_ops</code>演算子クラスはサポートしません。
  </p><p>
<span class="original">
    Although the &lt;literal&gt;jsonb_path_ops&lt;/literal&gt; operator class supports
    only queries with the &lt;literal&gt;@&amp;gt;&lt;/literal&gt;, &lt;literal&gt;@?&lt;/literal&gt;
    and &lt;literal&gt;@@&lt;/literal&gt; operators, it has notable
    performance advantages over the default operator
    class &lt;literal&gt;jsonb_ops&lt;/literal&gt;.  A &lt;literal&gt;jsonb_path_ops&lt;/literal&gt;
    index is usually much smaller than a &lt;literal&gt;jsonb_ops&lt;/literal&gt;
    index over the same data, and the specificity of searches is better,
    particularly when queries contain keys that appear frequently in the
    data.  Therefore search operations typically perform better
    than with the default operator class.
</span>
<code class="literal">jsonb_path_ops</code>演算子クラスは、<code class="literal">@&gt;</code>、<code class="literal">@?</code>、<code class="literal">@@</code>演算子をサポートしているだけですが、デフォルト演算子クラスの<code class="literal">jsonb_ops</code>よりも顕著なパフォーマンス上の利点があります。
<code class="literal">jsonb_path_ops</code>インデックスは、通常同じデータの<code class="literal">jsonb_ops</code>インデックスよりもはるかに小さく、データの中で頻繁に現れるキーを含む場合のような特別な検索には、より良くなります。
そのため、デフォルトの演算子クラスよりも検索性能が良くなります。
  </p><p>
<span class="original">
    The technical difference between a &lt;literal&gt;jsonb_ops&lt;/literal&gt;
    and a &lt;literal&gt;jsonb_path_ops&lt;/literal&gt; GIN index is that the former
    creates independent index items for each key and value in the data,
    while the latter creates index items only for each value in the
    data.
</span>
<code class="literal">jsonb_ops</code>と<code class="literal">jsonb_path_ops</code>のGINインデックスの技術的差異は、前者はデータのキーと値のための独立したインデックスを作成しますが、後者は、データの値に対してのみインデックスを作成します。
    <a href="#ftn.id-1.5.7.24.18.10.3" class="footnote"><sup class="footnote" id="id-1.5.7.24.18.10.3">[7]</sup></a>
<span class="original">
    Basically, each &lt;literal&gt;jsonb_path_ops&lt;/literal&gt; index item is
    a hash of the value and the key(s) leading to it; for example to index
    &lt;literal&gt;{"foo": {"bar": "baz"}}&lt;/literal&gt;, a single index item would
    be created incorporating all three of &lt;literal&gt;foo&lt;/literal&gt;, &lt;literal&gt;bar&lt;/literal&gt;,
    and &lt;literal&gt;baz&lt;/literal&gt; into the hash value.  Thus a containment query
    looking for this structure would result in an extremely specific index
    search; but there is no way at all to find out whether &lt;literal&gt;foo&lt;/literal&gt;
    appears as a key.  On the other hand, a &lt;literal&gt;jsonb_ops&lt;/literal&gt;
    index would create three index items representing &lt;literal&gt;foo&lt;/literal&gt;,
    &lt;literal&gt;bar&lt;/literal&gt;, and &lt;literal&gt;baz&lt;/literal&gt; separately; then to do the
    containment query, it would look for rows containing all three of
    these items.  While GIN indexes can perform such an AND search fairly
    efficiently, it will still be less specific and slower than the
    equivalent &lt;literal&gt;jsonb_path_ops&lt;/literal&gt; search, especially if
    there are a very large number of rows containing any single one of the
    three index items.
</span>
基本的に、<code class="literal">jsonb_path_ops</code>インデックス項目は、値とキーのハッシュです。例えば、<code class="literal">{"foo": {"bar": "baz"}}</code>のインデックスはハッシュ値に<code class="literal">foo</code>、<code class="literal">bar</code>、 <code class="literal">baz</code>すべてを組み込んで作成されます。
したがって、包含問い合わせのためのインデックス検索は、非常に特定の構造を返すようになっています。
しかし<code class="literal">foo</code>がキーとして表示されるかどうかを調べるには全く方法はありません。
一方、<code class="literal">jsonb_ops</code>インデックスは個別には<code class="literal">foo</code>、<code class="literal">bar</code>、<code class="literal">baz</code>を表す3つのインデックス項目を作成します。
その後、包含問い合わせをおこなうには、これらの項目の3つすべてを含む行を探します。
GINインデックスは、かなり効率的に検索することができますが、特に3つの索引項目のいずれかで、非常に多数の行が単一の場合に、同等の<code class="literal">jsonb_path_ops</code>検索よりも遅くなります。
  </p><p>
<span class="original">
    A disadvantage of the &lt;literal&gt;jsonb_path_ops&lt;/literal&gt; approach is
    that it produces no index entries for JSON structures not containing
    any values, such as &lt;literal&gt;{"a": {}}&lt;/literal&gt;.  If a search for
    documents containing such a structure is requested, it will require a
    full-index scan, which is quite slow.  &lt;literal&gt;jsonb_path_ops&lt;/literal&gt; is
    therefore ill-suited for applications that often perform such searches.
</span>
<code class="literal">jsonb_path_ops</code>アプローチの欠点は、<code class="literal">{"a": {}}</code>のような、任意の値を含まないJSON構造のためのインデックスエントリを生成しません。
このような構造を含むドキュメントの検索が要求された場合、それは、フルインデックススキャンを必要とします。それは非常に遅くなります。そのため、
<code class="literal">jsonb_path_ops</code>は、多くの場合、そのような検索を実行するのには不適当です。
  </p><p>
<span class="original">
    &lt;type&gt;jsonb&lt;/type&gt; also supports &lt;literal&gt;btree&lt;/literal&gt; and &lt;literal&gt;hash&lt;/literal&gt;
    indexes.  These are usually useful only if it's important to check
    equality of complete JSON documents.
    The &lt;literal&gt;btree&lt;/literal&gt; ordering for &lt;type&gt;jsonb&lt;/type&gt; datums is seldom
    of great interest, but for completeness it is:
</span>
<code class="type">jsonb</code>型は、<code class="literal">btree</code> と <code class="literal">hash</code> インデックスもサポートします。
これらは通常、JSONドキュメントの完全性をチェックすることが重要な場合のみ有用です。
<code class="type">jsonb</code>のための<code class="literal">btree</code>順序には、興味深いことはほとんどありませんが、しかし、完全さのために次に示します。
</p><pre class="synopsis">
<em class="replaceable"><code>Object</code></em> &gt; <em class="replaceable"><code>Array</code></em> &gt; <em class="replaceable"><code>Boolean</code></em> &gt; <em class="replaceable"><code>Number</code></em> &gt; <em class="replaceable"><code>String</code></em> &gt; <em class="replaceable"><code>Null</code></em>

<em class="replaceable"><code>Object with n pairs</code></em> &gt; <em class="replaceable"><code>object with n - 1 pairs</code></em>

<em class="replaceable"><code>Array with n elements</code></em> &gt; <em class="replaceable"><code>array with n - 1 elements</code></em>
</pre><p>
<span class="original">
      Objects with equal numbers of pairs are compared in the order:
</span>
ペアの同じ番号を持つオブジェクトは、順に比較されます。
</p><pre class="synopsis">
<em class="replaceable"><code>key-1</code></em>, <em class="replaceable"><code>value-1</code></em>, <em class="replaceable"><code>key-2</code></em> ...
</pre><p>
<span class="original">
      Note that object keys are compared in their storage order;
      in particular, since shorter keys are stored before longer keys, this
      can lead to results that might be unintuitive, such as:
</span>
そのオブジェクトのキーは、その格納順に比較されることに注意してください。
短いキーは長いキーの前に格納されているため、特にこれは、次のような直感的でない結果に結果につながるかもしれません。
</p><pre class="programlisting">
{ "aa": 1, "c": 1} &gt; {"b": 1, "d": 1}
</pre><p>
<span class="original">
      Similarly, arrays with equal numbers of elements are compared in the
      order:
</span>
同様に、配列と同じ番号を持つ要素を比較する順番。
</p><pre class="synopsis">
<em class="replaceable"><code>element-1</code></em>, <em class="replaceable"><code>element-2</code></em> ...
</pre><p>
<span class="original">
      Primitive JSON values are compared using the same
      comparison rules as for the underlying
      &lt;productname&gt;PostgreSQL&lt;/productname&gt; data type.  Strings are
      compared using the default database collation.
</span>
JSONプリミティブ値は基本的に<span class="productname">PostgreSQL</span>データ型と同じルールで比較されます。文字列は、デフォルトのデータベース照合を使用して比較されます
  </p></div><div class="sect2" id="JSONB-SUBSCRIPTING"><div class="titlepage"><div><div><h3 class="title">8.14.5. <code class="type">jsonb</code>の添字</h3></div></div></div><span class="original">
  &lt;title&gt;&lt;type&gt;jsonb&lt;/type&gt; Subscripting&lt;/title&gt;
</span><p>
<span class="original">
   The &lt;type&gt;jsonb&lt;/type&gt; data type supports array-style subscripting expressions
   to extract and modify elements. Nested values can be indicated by chaining
   subscripting expressions, following the same rules as the &lt;literal&gt;path&lt;/literal&gt;
   argument in the &lt;literal&gt;jsonb_set&lt;/literal&gt; function. If a &lt;type&gt;jsonb&lt;/type&gt;
   value is an array, numeric subscripts start at zero, and negative integers count
   backwards from the last element of the array. Slice expressions are not supported.
   The result of a subscripting expression is always of the jsonb data type.
</span>
<code class="type">jsonb</code>データ型は要素を取り出したり修正したりするために配列形式の添字表現をサポートします。
入れ子になった値は、<code class="literal">jsonb_set</code>関数での<code class="literal">path</code>引数と同じ規則に従って、添字表現をつなげることで指定できます。
<code class="type">jsonb</code>値が配列であれば、数字の添字はゼロから始まり、負の整数は配列の最後の要素から逆に数えます。
スライス表現はサポートされていません。
添字表現の結果は、必ずjsonbデータ型です。
  </p><p>
<span class="original">
   &lt;command&gt;UPDATE&lt;/command&gt; statements may use subscripting in the
   &lt;literal&gt;SET&lt;/literal&gt; clause to modify &lt;type&gt;jsonb&lt;/type&gt; values. Subscript
   paths must be traversable for all affected values insofar as they exist. For
   instance, the path &lt;literal&gt;val['a']['b']['c']&lt;/literal&gt; can be traversed all
   the way to &lt;literal&gt;c&lt;/literal&gt; if every &lt;literal&gt;val&lt;/literal&gt;,
   &lt;literal&gt;val['a']&lt;/literal&gt;, and &lt;literal&gt;val['a']['b']&lt;/literal&gt; is an
   object. If any &lt;literal&gt;val['a']&lt;/literal&gt; or &lt;literal&gt;val['a']['b']&lt;/literal&gt;
   is not defined, it will be created as an empty object and filled as
   necessary. However, if any &lt;literal&gt;val&lt;/literal&gt; itself or one of the
   intermediary values is defined as a non-object such as a string, number, or
   &lt;literal&gt;jsonb&lt;/literal&gt; &lt;literal&gt;null&lt;/literal&gt;, traversal cannot proceed so
   an error is raised and the transaction aborted.
</span>
<code class="command">UPDATE</code>文では、<code class="type">jsonb</code>値を修正する<code class="literal">SET</code>句内で添字が使えます。
添字のパスは、存在する範囲では影響する値すべてが到達可能でなければなりません。
例えば、パス<code class="literal">val['a']['b']['c']</code>は、<code class="literal">val</code>、<code class="literal">val['a']</code>、<code class="literal">val['a']['b']</code>それぞれがオブジェクトであれば、<code class="literal">c</code>までたどることができます。
<code class="literal">val['a']</code>または<code class="literal">val['a']['b']</code>が定義されていなければ、空のオブジェクトとして作られ必要に応じて埋められます。
しかしながら、<code class="literal">val</code>自身または途中の値の1つでも、文字列、数値、<code class="literal">jsonb</code> <code class="literal">null</code>のような非オブジェクトとして定義されていれば、到達できないためエラーが発生し、トランザクションはアボートされます。
  </p><p>
<span class="original">
   An example of subscripting syntax:
</span>
添字構文の例です。

</p><pre class="programlisting">

<span class="original">
&amp;#45;- Extract object value by key
</span>
-- キーでオブジェクトの値を取り出す
SELECT ('{"a": 1}'::jsonb)['a'];

<span class="original">
&amp;#45;- Extract nested object value by key path
</span>
-- キーのパスで入れ子のオブジェクトの値を取り出す
SELECT ('{"a": {"b": {"c": 1}}}'::jsonb)['a']['b']['c'];

<span class="original">
&amp;#45;- Extract array element by index
</span>
-- インデックスで配列要素を取り出す
SELECT ('[1, "2", null]'::jsonb)[1];

<span class="original">
&amp;#45;- Update object value by key. Note the quotes around '1': the assigned
&amp;#45;- value must be of the jsonb type as well
</span>
-- キーでオブジェクトの値を更新する。'1'の周りの一重引用符に注意。
-- 代入する値もjsonb型でなければならない
UPDATE table_name SET jsonb_field['key'] = '1';

<span class="original">
&amp;#45;- This will raise an error if any record's jsonb_field['a']['b'] is something
&amp;#45;- other than an object. For example, the value {"a": 1} has a numeric value
&amp;#45;- of the key 'a'.
</span>
-- これはjsonb_field['a']['b']のいずれかのデータがオブジェクト以外のものであればエラーになる。
-- 例えば、値{"a": 1}はキー'a'の数値を持つ。
UPDATE table_name SET jsonb_field['a']['b']['c'] = '1';

<span class="original">
&amp;#45;- Filter records using a WHERE clause with subscripting. Since the result of
&amp;#45;- subscripting is jsonb, the value we compare it against must also be jsonb.
&amp;#45;- The double quotes make "value" also a valid jsonb string.
</span>
-- WHERE句で添字を使ってデータにフィルタを掛ける。
-- 添字による結果はjsonbなので、それと比較する値もjsonbでなければならない。
-- 二重引用符により"value"も有効なjsonb文字列になる。
SELECT * FROM table_name WHERE jsonb_field['key'] = '"value"';
</pre><p>

<span class="original">
   &lt;type&gt;jsonb&lt;/type&gt; assignment via subscripting handles a few edge cases
   differently from &lt;literal&gt;jsonb_set&lt;/literal&gt;. When a source &lt;type&gt;jsonb&lt;/type&gt;
   value is &lt;literal&gt;NULL&lt;/literal&gt;, assignment via subscripting will proceed
   as if it was an empty JSON value of the type (object or array) implied by the
   subscript key:
</span>
添字による<code class="type">jsonb</code>の代入は、まれに<code class="literal">jsonb_set</code>とは異なる場合があります。
元の<code class="type">jsonb</code>値が<code class="literal">NULL</code>の場合、添字による代入は、添字のキーで暗示されるその型の空のJSON値(オブジェクトまたは配列)であるかのように処理されます。

</p><pre class="programlisting">
<span class="original">
&amp;#45;- Where jsonb_field was NULL, it is now {"a": 1}
</span>
-- jsonb_fieldがNULLの場合、{"a": 1}になる
UPDATE table_name SET jsonb_field['a'] = '1';

<span class="original">
&amp;#45;- Where jsonb_field was NULL, it is now [1]
</span>
-- jsonb_fieldがNULLの場合、[1]になる
UPDATE table_name SET jsonb_field[0] = '1';
</pre><p>

<span class="original">
   If an index is specified for an array containing too few elements,
   &lt;literal&gt;NULL&lt;/literal&gt; elements will be appended until the index is reachable
   and the value can be set.
</span>
要素が足りない配列に対してインデックスを指定した場合、インデックスが到達可能になって値が設定できるようになるまで<code class="literal">NULL</code>要素が追加されます。

</p><pre class="programlisting">
<span class="original">
&amp;#45;- Where jsonb_field was [], it is now [null, null, 2];
&amp;#45;- where jsonb_field was [0], it is now [0, null, 2]
</span>
-- jsonb_fieldが[]なら、[null, null, 2]になり、
-- jsonb_fieldが[0]なら、[0, null, 2]になる
UPDATE table_name SET jsonb_field[2] = '2';
</pre><p>

<span class="original">
   A &lt;type&gt;jsonb&lt;/type&gt; value will accept assignments to nonexistent subscript
   paths as long as the last existing element to be traversed is an object or
   array, as implied by the corresponding subscript (the element indicated by
   the last subscript in the path is not traversed and may be anything). Nested
   array and object structures will be created, and in the former case
   &lt;literal&gt;null&lt;/literal&gt;-padded, as specified by the subscript path until the
   assigned value can be placed.
</span>
対応する添字が暗示するように、到達できる最後の存在する要素がオブジェクトか配列である限り、<code class="type">jsonb</code>値は存在しない添字のパスへの代入を受け付けます。
(パスの最後の添字で指定される要素には到達しませんし、何でも構いません。)
入れ子の配列やオブジェクト構造が作られ、前者の場合には、添字のパスにより指定されたように値が代入できるようになるまで<code class="literal">null</code>で埋められます。

</p><pre class="programlisting">
<span class="original">
&amp;#45;- Where jsonb_field was {}, it is now {"a": [{"b": 1}]}
</span>
-- jsonb_fieldが{}であれば、{"a": [{"b": 1}]}になる
UPDATE table_name SET jsonb_field['a'][0]['b'] = '1';

<span class="original">
&amp;#45;- Where jsonb_field was [], it is now [null, {"a": 1}]
</span>
-- jsonb_fieldが[]であれば、[null, {"a": 1}]になる
UPDATE table_name SET jsonb_field[1]['a'] = '1';
</pre><p>

  </p></div><div class="sect2" id="id-1.5.7.24.20"><div class="titlepage"><div><div><h3 class="title">8.14.6. 変換</h3></div></div></div><span class="original">
  &lt;title&gt;Transforms&lt;/title&gt;
</span><p>
<span class="original">
   Additional extensions are available that implement transforms for the
   &lt;type&gt;jsonb&lt;/type&gt; type for different procedural languages.
</span>
異なるプロシージャ言語で<code class="type">jsonb</code>型の変換を実装した追加の拡張が入手可能です。
  </p><p>
<span class="original">
   The extensions for PL/Perl are called &lt;literal&gt;jsonb_plperl&lt;/literal&gt; and
   &lt;literal&gt;jsonb_plperlu&lt;/literal&gt;.  If you use them, &lt;type&gt;jsonb&lt;/type&gt;
   values are mapped to Perl arrays, hashes, and scalars, as appropriate.
</span>
PL/Perl向けの拡張は、<code class="literal">jsonb_plperl</code>と<code class="literal">jsonb_plperlu</code>と呼ばれます。
この拡張を使うと<code class="type">jsonb</code>の値は適したPerlの配列、ハッシュ、スカラにマップされます。
  </p><p>
<span class="original">
   The extension for PL/Python is called &lt;literal&gt;jsonb_plpython3u&lt;/literal&gt;.
   If you use it, &lt;type&gt;jsonb&lt;/type&gt; values are mapped to Python
   dictionaries, lists, and scalars, as appropriate.
</span>
《マッチ度[58.064516]》PL/Perl向けの拡張は、<code class="literal">jsonb_plperl</code>と<code class="literal">jsonb_plperlu</code>と呼ばれます。
この拡張を使うと<code class="type">jsonb</code>の値は適したPerlの配列、ハッシュ、スカラにマップされます。
  </p><p>
<span class="original">
   Of these extensions, &lt;literal&gt;jsonb_plperl&lt;/literal&gt; is
   considered &lt;quote&gt;trusted&lt;/quote&gt;, that is, it can be installed by
   non-superusers who have &lt;literal&gt;CREATE&lt;/literal&gt; privilege on the
   current database.  The rest require superuser privilege to install.
</span>
上記の拡張のうち、<code class="literal">jsonb_plperl</code>は<span class="quote">「<span class="quote">trusted</span>」</span>と見なされます。つまり、現在のデータベースに対して<code class="literal">CREATE</code>権限を持つ非スーパーユーザがインストールできます。
残りはインストールするのにスーパーユーザ権限が必要です。
  </p></div><div class="sect2" id="DATATYPE-JSONPATH"><div class="titlepage"><div><div><h3 class="title">8.14.7. jsonpath型</h3></div></div></div><span class="original">
  &lt;title&gt;jsonpath Type&lt;/title&gt;
</span><a id="id-1.5.7.24.21.2" class="indexterm"></a><p>
<span class="original">
   The &lt;type&gt;jsonpath&lt;/type&gt; type implements support for the SQL/JSON path language
   in &lt;productname&gt;PostgreSQL&lt;/productname&gt; to efficiently query JSON data.
   It provides a binary representation of the parsed SQL/JSON path
   expression that specifies the items to be retrieved by the path
   engine from the JSON data for further processing with the
   SQL/JSON query functions.
</span>
<code class="type">jsonpath</code>型は、<span class="productname">PostgreSQL</span>でJSONデータの効率的な問い合わせをするために、SQL/JSONパス言語のサポートを実装しています。
構文解析されたSQL/JSONパス式のバイナリ表現を提供し、SQL/JSON問い合わせ関数でさらに処理するために、パスエンジンがJSONデータから取得する項目を指定します。
  </p><p>
<span class="original">
   The semantics of SQL/JSON path predicates and operators generally follow SQL.
   At the same time, to provide a natural way of working with JSON data,
   SQL/JSON path syntax uses some JavaScript conventions:
</span>
SQL/JSONパス述部および演算子のセマンティクスは、SQLに準拠しています。
同時に、JSONデータを処理する自然な方法を提供するために、SQL/JSONのパス構文ではいくつかのJavaScript規則を使用します。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
     Dot (&lt;literal&gt;.&lt;/literal&gt;) is used for member access.
</span>
ドット(<code class="literal">.</code>)は、メンバアクセスに使用されます。
    </p></li><li class="listitem"><p>
<span class="original">
     Square brackets (&lt;literal&gt;[]&lt;/literal&gt;) are used for array access.
</span>
大括弧(<code class="literal">[]</code>)は配列アクセスに使用されます。
    </p></li><li class="listitem"><p>
<span class="original">
     SQL/JSON arrays are 0-relative, unlike regular SQL arrays that start from 1.
</span>
1から始まる通常のSQL配列とは異なり、SQL/JSON配列は0スタートです。
    </p></li></ul></div><p>
<span class="original">
   An SQL/JSON path expression is typically written in an SQL query as an
   SQL character string literal, so it must be enclosed in single quotes,
   and any single quotes desired within the value must be doubled
   (see &lt;xref linkend="sql-syntax-strings"/&gt;).
   Some forms of path expressions require string literals within them.
   These embedded string literals follow JavaScript/ECMAScript conventions:
   they must be surrounded by double quotes, and backslash escapes may be
   used within them to represent otherwise-hard-to-type characters.
   In particular, the way to write a double quote within an embedded string
   literal is &lt;literal&gt;\"&lt;/literal&gt;, and to write a backslash itself, you
   must write &lt;literal&gt;\\&lt;/literal&gt;.  Other special backslash sequences
   include those recognized in JSON strings:
   &lt;literal&gt;\b&lt;/literal&gt;,
   &lt;literal&gt;\f&lt;/literal&gt;,
   &lt;literal&gt;\n&lt;/literal&gt;,
   &lt;literal&gt;\r&lt;/literal&gt;,
   &lt;literal&gt;\t&lt;/literal&gt;,
   &lt;literal&gt;\v&lt;/literal&gt;
   for various ASCII control characters, and
   &lt;literal&gt;\u&lt;replaceable&gt;NNNN&lt;/replaceable&gt;&lt;/literal&gt; for a Unicode
   character identified by its 4-hex-digit code point.  The backslash
   syntax also includes two cases not allowed by JSON:
   &lt;literal&gt;\x&lt;replaceable&gt;NN&lt;/replaceable&gt;&lt;/literal&gt; for a character code
   written with only two hex digits, and
   &lt;literal&gt;\u{&lt;replaceable&gt;N...&lt;/replaceable&gt;}&lt;/literal&gt; for a character
   code written with 1 to 6 hex digits.
</span>
SQL/JSONパス式は通常、SQL問い合わせでSQL文字列リテラルとして記述されるため、一重引用符で囲む必要があり、値内で必要な一重引用符は二重にする必要があります
(<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS" title="4.1.2.1. 文字列定数">4.1.2.1</a>を参照)。
一部の形式のパス式では、文字列リテラルを含める必要があります。
これらの埋め込み文字列リテラルは二重引用符で囲む必要があり、バックスラッシュエスケープを使用してハード・タイプ文字を表すことができます。
特に、埋め込み文字列リテラル内で二重引用符を記述する方法は<code class="literal">\"</code>であり、バックスラッシュを記述する必要がある場合は<code class="literal">\\</code>と書く必要があります。
その他の特別なバックスラッシュ構文には、以下のJSON文字列で認識されるものが含まれます。
さまざまなASCII制御用文字の<code class="literal">\b</code>、<code class="literal">\f</code>、<code class="literal">\n</code>、<code class="literal">\r</code>、<code class="literal">\t</code>、<code class="literal">\v</code>、および4つの16進数のコードポイントで識別されるUnicode文字用の<code class="literal">\u<em class="replaceable"><code>NNNN</code></em></code>です。
バックスラッシュ構文には、JSONでは許されない2つのケースも含まれています。
<code class="literal">\x<em class="replaceable"><code>NN</code></em></code>は2桁の16進数だけで記述された文字コードの場合で、<code class="literal">\u{<em class="replaceable"><code>N...</code></em>}</code>は、1～6桁の16進数で記述された文字コードの場合です。
  </p><p>
<span class="original">
   A path expression consists of a sequence of path elements,
   which can be any of the following:
</span>
パスの式は、次のようなパス要素のシーケンスで構成されます。
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
      Path literals of JSON primitive types:
      Unicode text, numeric, true, false, or null.
</span>
JSONプリミティブ型のパスリテラル。
ユニコードテキスト、数値、true、false、又はnullです。
     </p></li><li class="listitem"><p>
<span class="original">
      Path variables listed in &lt;xref linkend="type-jsonpath-variables"/&gt;.
</span>
パス変数<a class="xref" href="datatype-json.html#TYPE-JSONPATH-VARIABLES" title="表8.24 jsonpath変数">表 8.24</a>。
     </p></li><li class="listitem"><p>
<span class="original">
      Accessor operators listed in &lt;xref linkend="type-jsonpath-accessors"/&gt;.
</span>
アクセサ演算子<a class="xref" href="datatype-json.html#TYPE-JSONPATH-ACCESSORS" title="表8.25 jsonpath Accessors">表 8.25</a>。
     </p></li><li class="listitem"><p>
<span class="original">
      &lt;type&gt;jsonpath&lt;/type&gt; operators and methods listed
      in &lt;xref linkend="functions-sqljson-path-operators"/&gt;.
</span>
<code class="type">jsonpath</code>演算子とメソッド<a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-PATH-OPERATORS" title="9.16.2.2. SQL/JSONパス演算子とメソッド">9.16.2.2</a>。
     </p></li><li class="listitem"><p>
<span class="original">
      Parentheses, which can be used to provide filter expressions
      or define the order of path evaluation.
</span>
括弧。フィルタ式を提供したり、パス評価の順序を定義するために使用できます。
     </p></li></ul></div><p>
  </p><p>
<span class="original">
   For details on using &lt;type&gt;jsonpath&lt;/type&gt; expressions with SQL/JSON
   query functions, see &lt;xref linkend="functions-sqljson-path"/&gt;.
</span>
<code class="type">jsonpath</code>式を使用したSQL/JSON問い合わせ関数の詳細は、<a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-PATH" title="9.16.2. SQL/JSONパス言語">9.16.2</a>を参照してください。
  </p><div class="table" id="TYPE-JSONPATH-VARIABLES"><p class="title"><strong>表8.24 <code class="type">jsonpath</code>変数</strong></p><div class="table-contents"><span class="original">
   &lt;title&gt;&lt;type&gt;jsonpath&lt;/type&gt; Variables&lt;/title&gt;
</span><table class="table" summary="jsonpath変数" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th>変数</th><th>説明</th></tr></thead><tbody><tr><td><code class="literal">$</code></td><td>
問い合わせ対象(<em class="firstterm">context item</em>)のJSON値を表す変数。
      </td></tr><tr><td><code class="literal">$varname</code></td><td>
<span class="original">
        A named variable. Its value can be set by the parameter
        &lt;parameter&gt;vars&lt;/parameter&gt; of several JSON processing functions;
        see &lt;xref linkend="functions-json-processing-table"/&gt; for details.
</span>
名前付き変数。
その値はいくつかのJSON処理関数のパラメーター<em class="parameter"><code>vars</code></em>で設定できます。
詳細は<a class="xref" href="functions-json.html#FUNCTIONS-JSON-PROCESSING-TABLE" title="表9.48 JSON処理関数">表 9.48</a>を参照してください。
        <span class="original"> TODO: describe PASSING clause once implemented !</span>
      </td></tr><tr><td><code class="literal">@</code></td><td>フィルター式のパス評価の結果を表す変数。
      </td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="TYPE-JSONPATH-ACCESSORS"><p class="title"><strong>表8.25 <code class="type">jsonpath</code> Accessors</strong></p><div class="table-contents"><table class="table" summary="jsonpath Accessors" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th>アクセサ演算子</th><th>説明</th></tr></thead><tbody><tr><td>
       <p>
        <code class="literal">.<em class="replaceable"><code>key</code></em></code>
       </p>
       <p>
        <code class="literal">."$<em class="replaceable"><code>varname</code></em>"</code>
       </p>
      </td><td>
       <p>
<span class="original">
        Member accessor that returns an object member with
        the specified key. If the key name matches some named variable
        starting with &lt;literal&gt;$&lt;/literal&gt; or does not meet the
        JavaScript rules for an identifier, it must be enclosed in
        double quotes to make it a string literal.
</span>
指定されたキーを持つオブジェクトメンバを返すメンバアクセサ。
キー名が<code class="literal">$</code>で始まる名前付き変数に一致する場合、または識別子のJavaScriptルールを満たさない場合は、文字列リテラルとするため二重引用符で囲む必要があります。
       </p>
      </td></tr><tr><td>
       <p>
        <code class="literal">.*</code>
       </p>
      </td><td>
       <p>
<span class="original">
        Wildcard member accessor that returns the values of all
        members located at the top level of the current object.
</span>
現在のオブジェクトの最上位レベルになるすべてのメンバの値を返すワイルドカードメンバアクセサ。
       </p>
      </td></tr><tr><td>
       <p>
        <code class="literal">.**</code>
       </p>
      </td><td>
       <p>
<span class="original">
        Recursive wildcard member accessor that processes all levels
        of the JSON hierarchy of the current object and returns all
        the member values, regardless of their nesting level. This
        is a &lt;productname&gt;PostgreSQL&lt;/productname&gt; extension of
        the SQL/JSON standard.
</span>
現在のオブジェクトのJSON階層のすべてのレベルを処理し、ネストされたレベルに関わらず全てのメンバ値を返す再帰的なワイルドカードメンバアクセサ。
これはSQL/JSON標準の<span class="productname">PostgreSQL</span>の拡張です。
       </p>
      </td></tr><tr><td>
       <p>
        <code class="literal">.**{<em class="replaceable"><code>level</code></em>}</code>
       </p>
       <p>
        <code class="literal">.**{<em class="replaceable"><code>start_level</code></em> to
        <em class="replaceable"><code>end_level</code></em>}</code>
       </p>
      </td><td>
       <p>
<span class="original">
        Like &lt;literal&gt;.**&lt;/literal&gt;, but selects only the specified
        levels of the JSON hierarchy. Nesting levels are specified as integers.
        Level zero corresponds to the current object. To access the lowest
        nesting level, you can use the &lt;literal&gt;last&lt;/literal&gt; keyword.
        This is a &lt;productname&gt;PostgreSQL&lt;/productname&gt; extension of
        the SQL/JSON standard.
</span>
<code class="literal">.**</code>と似ていますが、JSON階層の指定したレベルだけを選びます。
ネストレベルは整数で指定します。
レベル0は現在のオブジェクトに対応します。
最下位のネストレベルにアクセスするのに、<code class="literal">last</code>キーワードが使用できます。
これはSQL/JSON標準の<span class="productname">PostgreSQL</span>の拡張です。
       </p>
      </td></tr><tr><td>
       <p>
        <code class="literal">[<em class="replaceable"><code>subscript</code></em>, ...]</code>
       </p>
      </td><td>
       <p>
<span class="original">
        Array element accessor.
        &lt;literal&gt;&lt;replaceable&gt;subscript&lt;/replaceable&gt;&lt;/literal&gt; can be
        given in two forms: &lt;literal&gt;&lt;replaceable&gt;index&lt;/replaceable&gt;&lt;/literal&gt;
        or &lt;literal&gt;&lt;replaceable&gt;start_index&lt;/replaceable&gt; to &lt;replaceable&gt;end_index&lt;/replaceable&gt;&lt;/literal&gt;.
        The first form returns a single array element by its index. The second
        form returns an array slice by the range of indexes, including the
        elements that correspond to the provided
        &lt;replaceable&gt;start_index&lt;/replaceable&gt; and &lt;replaceable&gt;end_index&lt;/replaceable&gt;.
</span>
配列要素アクセサ。
<code class="literal"><em class="replaceable"><code>subscript</code></em></code>は、<code class="literal"><em class="replaceable"><code>index</code></em></code>または<code class="literal"><em class="replaceable"><code>start_index</code></em>から<em class="replaceable"><code>end_index</code></em></code>までの2つの形式で指定できます。
最初の形式は、インデックスによって単一の配列要素を返します。
２番目の形式は、指定された<em class="replaceable"><code>start_index</code></em>と<em class="replaceable"><code>end_index</code></em>に対応する要素を含む、インデックスの範囲による配列スライスを返します。
       </p>
       <p>
<span class="original">
        The specified &lt;replaceable&gt;index&lt;/replaceable&gt; can be an integer, as
        well as an expression returning a single numeric value, which is
        automatically cast to integer. Index zero corresponds to the first
        array element. You can also use the &lt;literal&gt;last&lt;/literal&gt; keyword
        to denote the last array element, which is useful for handling arrays
        of unknown length.
</span>
指定された<em class="replaceable"><code>index</code></em>には、整数だけでなく、自動的に整数にキャストされる単一の数値を返す式を指定できます。
インデックス0は最初の配列要素に対応します。
また、<code class="literal">last</code>キーワードを使用して最後の配列要素を指定することもできます。
これは、長さが不明な配列の処理に役立ちます。
       </p>
      </td></tr><tr><td>
       <p>
        <code class="literal">[*]</code>
       </p>
      </td><td>
       <p>
<span class="original">
        Wildcard array element accessor that returns all array elements.
</span>
全ての配列の要素を返すワイルドカード配列要素アクセサ。
       </p>
      </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.5.7.24.18.10.3" class="footnote"><p><a href="#id-1.5.7.24.18.10.3" class="para"><sup class="para">[7] </sup></a>
<span class="original">
      For this purpose, the term &lt;quote&gt;value&lt;/quote&gt; includes array elements,
      though JSON terminology sometimes considers array elements distinct
      from values within objects.
</span>
この目的のために、<span class="quote">「<span class="quote">値</span>」</span> という用語は配列の要素を含みますが、JSONの専門用語では、オブジェクト内の値と配列の要素が時々違うことがあります。
     </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="datatype-xml.html" title="8.13. XML型">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="datatype.html" title="第8章 データ型">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="arrays.html" title="8.15. 配列">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">8.13. <acronym class="acronym">XML</acronym>型 </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 15.0文書">ホーム</a></td><td width="40%" align="right" valign="top"> 8.15. 配列</td></tr></table></div></body></html>